func mustwaitpinready ( t * testing . t , cli * clientv3 . client ) { ctx , cancel : = context . withtimeout ( context . background ( ) , 10 * time . second ) , err : = cli . get ( ctx , " " ) cancel ( ) if err ! = nil { t . fatal ( err ) } } 
func newgatewaycommand ( ) * cobra . command { lpc : = & cobra . command { use : " " , short : " " , } lpc . addcommand ( newgatewaystartcommand ( ) ) return lpc } 
func newlimitedbufferreader ( r io . reader , n int ) io . reader { return & limitedbufferreader { r : r , n : n , } } 
func withabortcontext ( ctx context . context ) stmoption { return func ( so * stmoptions ) { so . ctx = ctx } } 
func withprefetch ( keys ... string ) stmoption { return func ( so * stmoptions ) { so . prefetch = append ( so . prefetch , keys ... ) } } 
func newstm ( c * v3 . client , apply func ( stm ) error , so ... stmoption ) ( * v3 . txnresponse , error ) { opts : = & stmoptions { ctx : c . ctx ( ) } for , f : = range so { f ( opts ) } if len ( opts . prefetch ) ! = 0 { f : = apply apply = func ( s stm ) error { s . get ( opts . prefetch ... ) return f ( s ) } } return runstm ( mkstm ( c , opts ) , apply ) } 
func ( rs readset ) first ( ) int64 { ret : = int64 ( math . maxint64 - 1 ) for , resp : = range rs { if rev : = resp . header . revision ; rev < ret { ret = rev } } return ret } 
func ( rs readset ) cmps ( ) [ ] v3 . cmp { cmps : = make ( [ ] v3 . cmp , 0 , len ( rs ) ) for k , rk : = range rs { cmps = append ( cmps , iskeycurrent ( k , rk ) ) } return cmps } 
func ( ws writeset ) cmps ( rev int64 ) [ ] v3 . cmp { cmps : = make ( [ ] v3 . cmp , 0 , len ( ws ) ) for key : = range ws { cmps = append ( cmps , v3 . compare ( v3 . modrevision ( key ) , " " , rev ) ) } return cmps } 
func ( ws writeset ) puts ( ) [ ] v3 . op { puts : = make ( [ ] v3 . op , 0 , len ( ws ) ) for , v : = range ws { puts = append ( puts , v . op ) } return puts } 
func newstmrepeatable ( ctx context . context , c * v3 . client , apply func ( stm ) error ) ( * v3 . txnresponse , error ) { return newstm ( c , apply , withabortcontext ( ctx ) , withisolation ( repeatablereads ) ) } 
func newstmserializable ( ctx context . context , c * v3 . client , apply func ( stm ) error ) ( * v3 . txnresponse , error ) { return newstm ( c , apply , withabortcontext ( ctx ) , withisolation ( serializable ) ) } 
func newstmreadcommitted ( ctx context . context , c * v3 . client , apply func ( stm ) error ) ( * v3 . txnresponse , error ) { return newstm ( c , apply , withabortcontext ( ctx ) , withisolation ( readcommitted ) ) } 
func newcertpool ( cafiles [ ] string ) ( * x509 . certpool , error ) { certpool : = x509 . newcertpool ( ) for , cafile : = range cafiles { pembyte , err : = ioutil . readfile ( cafile ) if err ! = nil { return nil , err } for { var block * pem . block block , pembyte = pem . decode ( pembyte ) if block == nil { break } cert , err : = x509 . parsecertificate ( block . bytes ) if err ! = nil { return nil , err } certpool . addcert ( cert ) } } return certpool , nil } 
func newcert ( certfile , keyfile string , parsefunc func ( [ ] byte , [ ] byte ) ( tls . certificate , error ) ) ( * tls . certificate , error ) { cert , err : = ioutil . readfile ( certfile ) if err ! = nil { return nil , err } key , err : = ioutil . readfile ( keyfile ) if err ! = nil { return nil , err } if parsefunc == nil { parsefunc = tls . x509keypair } tlscert , err : = parsefunc ( cert , key ) if err ! = nil { return nil , err } return & tlscert , nil } 
func newgrpcloggerv2 ( lcfg zap . config ) ( grpclog . loggerv2 , error ) { lg , err : = lcfg . build ( zap . addcallerskip ( 1 ) ) if err ! = nil { return nil , err } return & zapgrpclogger { lg : lg , sugar : lg . sugar ( ) } , nil } 
func newgrpcloggerv2fromzapcore ( cr zapcore . core , syncer zapcore . writesyncer ) grpclog . loggerv2 { lg : = zap . new ( cr , zap . addcaller ( ) , zap . addcallerskip ( 1 ) , zap . erroroutput ( syncer ) ) return & zapgrpclogger { lg : lg , sugar : lg . sugar ( ) } } 
func ( p * peer ) pause ( ) { p . mu . lock ( ) defer p . mu . unlock ( ) p . paused = true p . msgappreader . pause ( ) p . msgappv2reader . pause ( ) } 
func ( p * peer ) resume ( ) { p . mu . lock ( ) defer p . mu . unlock ( ) p . paused = false p . msgappreader . resume ( ) p . msgappv2reader . resume ( ) } 
func ( p * peer ) pick ( m raftpb . message ) ( writec chan < - raftpb . message , picked string ) { var ok bool if ismsgsnap ( m ) { return p . pipeline . msgc , pipelinemsg } else if writec , ok = p . msgappv2writer . writec ( ) ; ok && ismsgapp ( m ) { return writec , streamappv2 } else if writec , ok = p . writer . writec ( ) ; ok { return writec , streammsg } return p . pipeline . msgc , pipelinemsg } 
func ( s * snapshotsender ) post ( req * http . request ) ( err error ) { ctx , cancel : = context . withcancel ( context . background ( ) ) req = req . withcontext ( ctx ) defer cancel ( ) type responseanderror struct { resp * http . response body [ ] byte err error } result : = make ( chan responseanderror , 1 ) go func ( ) { resp , err : = s . tr . pipelinert . roundtrip ( req ) if err ! = nil { result < - responseanderror { resp , nil , err } return } time . afterfunc ( snapresponsereadtimeout , func ( ) { httputil . gracefulclose ( resp ) } ) body , err : = ioutil . readall ( resp . body ) result < - responseanderror { resp , body , err } } ( ) select { case < - s . stopc : return errstopped case r : = < - result : if r . err ! = nil { return r . err } return checkpostresponse ( r . resp , r . body , req , s . to ) } } 
func newtxnresp ( rt * pb . txnrequest , txnpath [ ] bool ) ( txnresp * pb . txnresponse , txncount int ) { reqs : = rt . success if ! txnpath [ 0 ] { reqs = rt . failure } resps : = make ( [ ] * pb . responseop , len ( reqs ) ) txnresp = & pb . txnresponse { responses : resps , succeeded : txnpath [ 0 ] , header : & pb . responseheader { } , } for i , req : = range reqs { switch tv : = req . request . ( type ) { case * pb . requestop requestrange : resps [ i ] = & pb . responseop { response : & pb . responseop responserange { } } case * pb . requestop requestput : resps [ i ] = & pb . responseop { response : & pb . responseop responseput { } } case * pb . requestop requestdeleterange : resps [ i ] = & pb . responseop { response : & pb . responseop responsedeleterange { } } case * pb . requestop requesttxn : resp , txns : = newtxnresp ( tv . requesttxn , txnpath [ 1 : ] ) resps [ i ] = & pb . responseop { response : & pb . responseop responsetxn { responsetxn : resp } } txnpath = txnpath [ 1 + txns : ] txncount += txns + 1 default : } } return txnresp , txncount } 
func applycompare ( rv mvcc . readview , c * pb . compare ) bool { rr , err : = rv . range ( c . key , mkgterange ( c . rangeend ) , mvcc . rangeoptions { } ) if err ! = nil { return false } if len ( rr . kvs ) == 0 { if c . target == pb . compare value { return false } return comparekv ( c , mvccpb . keyvalue { } ) } for , kv : = range rr . kvs { if ! comparekv ( c , kv ) { return false } } return true } 
func opcompact ( rev int64 , opts ... compactoption ) compactop { ret : = compactop { revision : rev } ret . applycompactopts ( opts ) return ret } 
func newpriorityqueue ( client * v3 . client , key string ) * priorityqueue { return & priorityqueue { client , context . todo ( ) , key + " " } } 
func ( q * priorityqueue ) enqueue ( val string , pr uint16 ) error { prefix : = fmt . sprintf ( " " , q . key , pr ) , err : = newsequentialkv ( q . client , prefix , val ) return err } 
func newleaderstats ( id string ) * leaderstats { return & leaderstats { leaderstats : leaderstats { leader : id , followers : make ( map [ string ] * followerstats ) , } , } } 
func ( fs * followerstats ) succ ( d time . duration ) { fs . lock ( ) defer fs . unlock ( ) total : = float64 ( fs . counts . success ) * fs . latency . average totalsquare : = float64 ( fs . counts . success ) * fs . latency . averagesquare fs . counts . success ++ fs . latency . current = float64 ( d ) / ( 1000000 . 0 ) if fs . latency . current > fs . latency . maximum { fs . latency . maximum = fs . latency . current } if fs . latency . current < fs . latency . minimum { fs . latency . minimum = fs . latency . current } fs . latency . average = ( total + fs . latency . current ) / float64 ( fs . counts . success ) fs . latency . averagesquare = ( totalsquare + fs . latency . current * fs . latency . current ) / float64 ( fs . counts . success ) fs . latency . standarddeviation = math . sqrt ( fs . latency . averagesquare - fs . latency . average * fs . latency . average ) } 
func ( fs * followerstats ) fail ( ) { fs . lock ( ) defer fs . unlock ( ) fs . counts . fail ++ } 
func ( wbs * watchbroadcasts ) delete ( w * watcher ) int { wbs . mu . lock ( ) defer wbs . mu . unlock ( ) wb , ok : = wbs . watchers [ w ] if ! ok { panic ( " " ) } delete ( wbs . watchers , w ) wb . delete ( w ) if wb . empty ( ) { delete ( wbs . bcasts , wb ) wb . stop ( ) } return len ( wbs . bcasts ) } 
func startstreamwriter ( lg * zap . logger , local , id types . id , status * peerstatus , fs * stats . followerstats , r raft ) * streamwriter { w : = & streamwriter { lg : lg , localid : local , peerid : id , status : status , fs : fs , r : r , msgc : make ( chan raftpb . message , streambufsize ) , connc : make ( chan * outgoingconn ) , stopc : make ( chan struct { } ) , done : make ( chan struct { } ) , } go w . run ( ) return w } 
func checkstreamsupport ( v * semver . version , t streamtype ) bool { nv : = & semver . version { major : v . major , minor : v . minor } for , s : = range supportedstream [ nv . string ( ) ] { if s == t { return true } } return false } 
func ( pr * progress ) maybeupdate ( n uint64 ) bool { var updated bool if pr . match < n { pr . match = n updated = true pr . resume ( ) } if pr . next < n + 1 { pr . next = n + 1 } return updated } 
func ( pr * progress ) maybedecrto ( rejected , last uint64 ) bool { if pr . state == progressstatereplicate { if rejected <= pr . match { return false } pr . next = pr . match + 1 return true } if pr . next - 1 ! = rejected { return false } if pr . next = min ( rejected , last + 1 ) ; pr . next < 1 { pr . next = 1 } pr . resume ( ) return true } 
func ( pr * progress ) ispaused ( ) bool { switch pr . state { case progressstateprobe : return pr . paused case progressstatereplicate : return pr . ins . full ( ) case progressstatesnapshot : return true default : panic ( " " ) } } 
func ( pr * progress ) needsnapshotabort ( ) bool { return pr . state == progressstatesnapshot && pr . match >= pr . pendingsnapshot } 
func ( in * inflights ) add ( inflight uint64 ) { if in . full ( ) { panic ( " " ) } next : = in . start + in . count size : = in . size if next >= size { next - = size } if next >= len ( in . buffer ) { in . growbuf ( ) } in . buffer [ next ] = inflight in . count ++ } 
func ( in * inflights ) growbuf ( ) { newsize : = len ( in . buffer ) * 2 if newsize == 0 { newsize = 1 } else if newsize > in . size { newsize = in . size } newbuffer : = make ( [ ] uint64 , newsize ) copy ( newbuffer , in . buffer ) in . buffer = newbuffer } 
func ( in * inflights ) freeto ( to uint64 ) { if in . count == 0 | | to < in . buffer [ in . start ] { return } idx : = in . start var i int for i = 0 ; i < in . count ; i ++ { if to < in . buffer [ idx ] { break } size : = in . size if idx ++ ; idx >= size { idx - = size } } in . count - = i in . start = idx if in . count == 0 { in . start = 0 } } 
func ( s * snapshotter ) savedbfrom ( r io . reader , id uint64 ) ( int64 , error ) { start : = time . now ( ) f , err : = ioutil . tempfile ( s . dir , " " ) if err ! = nil { return 0 , err } var n int64 n , err = io . copy ( f , r ) if err == nil { fsyncstart : = time . now ( ) err = fileutil . fsync ( f ) snapdbfsyncsec . observe ( time . since ( fsyncstart ) . seconds ( ) ) } f . close ( ) if err ! = nil { os . remove ( f . name ( ) ) return n , err } fn : = s . dbfilepath ( id ) if fileutil . exist ( fn ) { os . remove ( f . name ( ) ) return n , nil } err = os . rename ( f . name ( ) , fn ) if err ! = nil { os . remove ( f . name ( ) ) return n , err } if s . lg ! = nil { s . lg . info ( " " , zap . string ( " " , fn ) , zap . int64 ( " " , n ) , zap . string ( " " , humanize . bytes ( uint64 ( n ) ) ) , ) } else { plog . infof ( " " , n ) } snapdbsavesec . observe ( time . since ( start ) . seconds ( ) ) return n , nil } 
func ( s * snapshotter ) dbfilepath ( id uint64 ) ( string , error ) { if , err : = fileutil . readdir ( s . dir ) ; err ! = nil { return " " , err } fn : = s . dbfilepath ( id ) if fileutil . exist ( fn ) { return fn , nil } if s . lg ! = nil { s . lg . warn ( " " , zap . uint64 ( " " , id ) , zap . string ( " " , fn ) , zap . error ( errnodbsnapshot ) , ) } return " " , errnodbsnapshot } 
func ( us * uniquestringsvalue ) set ( s string ) error { us . values = make ( map [ string ] struct { } ) for , v : = range strings . split ( s , " " ) { us . values [ v ] = struct { } { } } return nil } 
func newuniquestringsvalue ( s string ) ( us * uniquestringsvalue ) { us = & uniquestringsvalue { values : make ( map [ string ] struct { } ) } if s == " " { return us } if err : = us . set ( s ) ; err ! = nil { plog . panicf ( " " , err ) } return us } 
func uniquestringsfromflag ( fs * flag . flagset , flagname string ) [ ] string { return ( * fs . lookup ( flagname ) . value . ( * uniquestringsvalue ) ) . stringslice ( ) } 
func uniquestringsmapfromflag ( fs * flag . flagset , flagname string ) map [ string ] struct { } { return ( * fs . lookup ( flagname ) . value . ( * uniquestringsvalue ) ) . values } 
func percentiles ( nums [ ] float64 ) ( pcs [ ] float64 , data [ ] float64 ) { return pctls , percentiles ( nums ) } 
func ( c * serverconfig ) verifybootstrap ( ) error { if err : = c . haslocalmember ( ) ; err ! = nil { return err } if err : = c . advertisematchescluster ( ) ; err ! = nil { return err } if checkduplicateurl ( c . initialpeerurlsmap ) { return fmt . errorf ( " " , c . initialpeerurlsmap ) } if c . initialpeerurlsmap . string ( ) == " " && c . discoveryurl == " " { return fmt . errorf ( " " ) } return nil } 
func ( c * serverconfig ) verifyjoinexisting ( ) error { if err : = c . haslocalmember ( ) ; err ! = nil { return err } if checkduplicateurl ( c . initialpeerurlsmap ) { return fmt . errorf ( " " , c . initialpeerurlsmap ) } if c . discoveryurl ! = " " { return fmt . errorf ( " " ) } return nil } 
func ( c * serverconfig ) haslocalmember ( ) error { if urls : = c . initialpeerurlsmap [ c . name ] ; urls == nil { return fmt . errorf ( " " , c . name ) } return nil } 
func ( c * serverconfig ) reqtimeout ( ) time . duration { return 5 * time . second + 2 * time . duration ( c . electionticks * int ( c . tickms ) ) * time . millisecond } 
func getstatus ( r * raft ) status { s : = getstatuswithoutprogress ( r ) if s . raftstate == stateleader { s . progress = getprogresscopy ( r ) } return s } 
func ( s status ) marshaljson ( ) ( [ ] byte , error ) { j : = fmt . sprintf ( ' { " id " : " % x " , " term " : %d , " vote " : " % x " , " commit " : %d , " lead " : " % x " , " raftstate " : % q , " applied " : %d , " progress " : { ' , s . id , s . term , s . vote , s . commit , s . lead , s . raftstate , s . applied ) if len ( s . progress ) == 0 { j += " " } else { for k , v : = range s . progress { subj : = fmt . sprintf ( ' " % x " : { " match " : %d , " next " : %d , " state " : % q } , ' , k , v . match , v . next , v . state ) j += subj } j = j [ : len ( j ) - 1 ] + " " } j += fmt . sprintf ( ' " leadtransferee " : " % x " } ' , s . leadtransferee ) return [ ] byte ( j ) , nil } 
func getdefaulthost ( ) ( string , error ) { rmsgs , rerr : = getdefaultroutes ( ) if rerr ! = nil { return " " , rerr } if rmsg , ok : = rmsgs [ syscall . af inet ] ; ok { if host , err : = choosehost ( syscall . af inet , rmsg ) ; host ! = " " | | err ! = nil { return host , err } delete ( rmsgs , syscall . af inet ) } var families [ ] int for family : = range rmsgs { families = append ( families , int ( family ) ) } sort . ints ( families ) for , f : = range families { family : = uint8 ( f ) if host , err : = choosehost ( family , rmsgs [ family ] ) ; host ! = " " | | err ! = nil { return host , err } } return " " , errnodefaulthost } 
func getifaceaddr ( idx uint32 , family uint8 ) ( * syscall . netlinkmessage , error ) { dat , err : = syscall . netlinkrib ( syscall . rtm getaddr , int ( family ) ) if err ! = nil { return nil , err } msgs , msgerr : = syscall . parsenetlinkmessage ( dat ) if msgerr ! = nil { return nil , msgerr } ifaddrmsg : = syscall . ifaddrmsg { } for , m : = range msgs { if m . header . type ! = syscall . rtm newaddr { continue } buf : = bytes . newbuffer ( m . data [ : syscall . sizeofifaddrmsg ] ) if rerr : = binary . read ( buf , cpuutil . byteorder ( ) , & ifaddrmsg ) ; rerr ! = nil { continue } if ifaddrmsg . index == idx { return & m , nil } } return nil , fmt . errorf ( " " , idx ) } 
func getifacelink ( idx uint32 ) ( * syscall . netlinkmessage , error ) { dat , err : = syscall . netlinkrib ( syscall . rtm getlink , syscall . af unspec ) if err ! = nil { return nil , err } msgs , msgerr : = syscall . parsenetlinkmessage ( dat ) if msgerr ! = nil { return nil , msgerr } ifinfomsg : = syscall . ifinfomsg { } for , m : = range msgs { if m . header . type ! = syscall . rtm newlink { continue } buf : = bytes . newbuffer ( m . data [ : syscall . sizeofifinfomsg ] ) if rerr : = binary . read ( buf , cpuutil . byteorder ( ) , & ifinfomsg ) ; rerr ! = nil { continue } if ifinfomsg . index == int32 ( idx ) { return & m , nil } } return nil , fmt . errorf ( " " , idx ) } 
func getdefaultinterfaces ( ) ( map [ string ] uint8 , error ) { interfaces : = make ( map [ string ] uint8 ) rmsgs , rerr : = getdefaultroutes ( ) if rerr ! = nil { return interfaces , rerr } for family , rmsg : = range rmsgs { , oif , err : = parseprefsrc ( rmsg ) if err ! = nil { return interfaces , err } ifmsg , ierr : = getifacelink ( oif ) if ierr ! = nil { return interfaces , ierr } attrs , aerr : = syscall . parsenetlinkrouteattr ( ifmsg ) if aerr ! = nil { return interfaces , aerr } for , attr : = range attrs { if attr . attr . type == syscall . ifla ifname { interfaces [ string ( attr . value [ : len ( attr . value ) - 1 ] ) ] += family } } } if len ( interfaces ) > 0 { return interfaces , nil } return interfaces , errnodefaultinterface } 
func parseprefsrc ( m * syscall . netlinkmessage ) ( host string , oif uint32 , err error ) { var attrs [ ] syscall . netlinkrouteattr attrs , err = syscall . parsenetlinkrouteattr ( m ) if err ! = nil { return " " , 0 , err } for , attr : = range attrs { if attr . attr . type == syscall . rta prefsrc { host = net . ip ( attr . value ) . string ( ) } if attr . attr . type == syscall . rta oif { oif = cpuutil . byteorder ( ) . uint32 ( attr . value ) } if host ! = " " && oif ! = uint32 ( 0 ) { break } } if oif == 0 { err = errnodefaultroute } return host , oif , err } 
func lscommandfunc ( c * cli . context , ki client . keysapi ) { key : = " " if len ( c . args ( ) ) ! = 0 { key = c . args ( ) [ 0 ] } sort : = c . bool ( " " ) recursive : = c . bool ( " " ) quorum : = c . bool ( " " ) ctx , cancel : = contextwithtotaltimeout ( c ) resp , err : = ki . get ( ctx , key , & client . getoptions { sort : sort , recursive : recursive , quorum : quorum } ) cancel ( ) if err ! = nil { handleerror ( c , exitservererror , err ) } printls ( c , resp ) } 
func printls ( c * cli . context , resp * client . response ) { if c . globalstring ( " " ) == " " { if ! resp . node . dir { fmt . println ( resp . node . key ) } for , node : = range resp . node . nodes { rprint ( c , node ) } } else { printresponsekey ( resp , c . globalstring ( " " ) ) } } 
func rprint ( c * cli . context , n * client . node ) { if n . dir && c . bool ( " " ) { fmt . println ( fmt . sprintf ( " " , n . key ) ) } else { fmt . println ( n . key ) } for , node : = range n . nodes { rprint ( c , node ) } } 
func newleaserenewercommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : runleaserenewerfunc , } cmd . flags ( ) . int64var ( & leasettl , " " , 5 , " " ) return cmd } 
func ( s * snapshotter ) snapnames ( ) ( [ ] string , error ) { dir , err : = os . open ( s . dir ) if err ! = nil { return nil , err } defer dir . close ( ) names , err : = dir . readdirnames ( - 1 ) if err ! = nil { return nil , err } snaps : = checksuffix ( s . lg , names ) if len ( snaps ) == 0 { return nil , errnosnapshot } sort . sort ( sort . reverse ( sort . stringslice ( snaps ) ) ) return snaps , nil } 
func gethostname ( req * http . request ) string { if req == nil { return " " } h , , err : = net . splithostport ( req . host ) if err ! = nil { return req . host } return h } 
func ( q * queue ) dequeue ( ) ( string , error ) { resp , err : = q . client . get ( q . ctx , q . keyprefix , v3 . withfirstrev ( ) ... ) if err ! = nil { return " " , err } kv , err : = claimfirstkey ( q . client , resp . kvs ) if err ! = nil { return " " , err } else if kv ! = nil { return string ( kv . value ) , nil } else if resp . more { return q . dequeue ( ) } ev , err : = waitprefixevents ( q . client , q . keyprefix , resp . header . revision , [ ] mvccpb . event eventtype { mvccpb . put } ) if err ! = nil { return " " , err } ok , err : = deleterevkey ( q . client , string ( ev . kv . key ) , ev . kv . modrevision ) if err ! = nil { return " " , err } else if ! ok { return q . dequeue ( ) } return string ( ev . kv . value ) , err } 
func getciphersuite ( s string ) ( uint16 , bool ) { v , ok : = ciphersuites [ s ] return v , ok } 
func ( p * pipeline ) post ( data [ ] byte ) ( err error ) { u : = p . picker . pick ( ) req : = createpostrequest ( u , raftprefix , bytes . newbuffer ( data ) , " " , p . tr . urls , p . tr . id , p . tr . clusterid ) done : = make ( chan struct { } , 1 ) ctx , cancel : = context . withcancel ( context . background ( ) ) req = req . withcontext ( ctx ) go func ( ) { select { case < - done : case < - p . stopc : waitschedule ( ) cancel ( ) } } ( ) resp , err : = p . tr . pipelinert . roundtrip ( req ) done < - struct { } { } if err ! = nil { p . picker . unreachable ( u ) return err } defer resp . body . close ( ) b , err : = ioutil . readall ( resp . body ) if err ! = nil { p . picker . unreachable ( u ) return err } err = checkpostresponse ( resp , b , req , p . peerid ) if err ! = nil { p . picker . unreachable ( u ) if err == errmemberremoved { reportcriticalerror ( err , p . errorc ) } return err } return nil } 
func ( * requestop ) xxx oneoffuncs ( ) ( func ( msg proto . message , b * proto . buffer ) error , func ( msg proto . message , tag , wire int , b * proto . buffer ) ( bool , error ) , func ( msg proto . message ) ( n int ) , [ ] interface { } ) { return requestop oneofmarshaler , requestop oneofunmarshaler , requestop oneofsizer , [ ] interface { } { ( * requestop requestrange ) ( nil ) , ( * requestop requestput ) ( nil ) , ( * requestop requestdeleterange ) ( nil ) , ( * requestop requesttxn ) ( nil ) , } } 
func ( * responseop ) xxx oneoffuncs ( ) ( func ( msg proto . message , b * proto . buffer ) error , func ( msg proto . message , tag , wire int , b * proto . buffer ) ( bool , error ) , func ( msg proto . message ) ( n int ) , [ ] interface { } ) { return responseop oneofmarshaler , responseop oneofunmarshaler , responseop oneofsizer , [ ] interface { } { ( * responseop responserange ) ( nil ) , ( * responseop responseput ) ( nil ) , ( * responseop responsedeleterange ) ( nil ) , ( * responseop responsetxn ) ( nil ) , } } 
func ( * compare ) xxx oneoffuncs ( ) ( func ( msg proto . message , b * proto . buffer ) error , func ( msg proto . message , tag , wire int , b * proto . buffer ) ( bool , error ) , func ( msg proto . message ) ( n int ) , [ ] interface { } ) { return compare oneofmarshaler , compare oneofunmarshaler , compare oneofsizer , [ ] interface { } { ( * compare version ) ( nil ) , ( * compare createrevision ) ( nil ) , ( * compare modrevision ) ( nil ) , ( * compare value ) ( nil ) , ( * compare lease ) ( nil ) , } } 
func ( * watchrequest ) xxx oneoffuncs ( ) ( func ( msg proto . message , b * proto . buffer ) error , func ( msg proto . message , tag , wire int , b * proto . buffer ) ( bool , error ) , func ( msg proto . message ) ( n int ) , [ ] interface { } ) { return watchrequest oneofmarshaler , watchrequest oneofunmarshaler , watchrequest oneofsizer , [ ] interface { } { ( * watchrequest createrequest ) ( nil ) , ( * watchrequest cancelrequest ) ( nil ) , ( * watchrequest progressrequest ) ( nil ) , } } 
func ( r * raft ) send ( m pb . message ) { m . from = r . id if m . type == pb . msgvote | | m . type == pb . msgvoteresp | | m . type == pb . msgprevote | | m . type == pb . msgprevoteresp { if m . term == 0 { panic ( fmt . sprintf ( " " , m . type ) ) } } else { if m . term ! = 0 { panic ( fmt . sprintf ( " " , m . type , m . term ) ) } if m . type ! = pb . msgprop && m . type ! = pb . msgreadindex { m . term = r . term } } r . msgs = append ( r . msgs , m ) } 
func ( r * raft ) sendheartbeat ( to uint64 , ctx [ ] byte ) { commit : = min ( r . getprogress ( to ) . match , r . raftlog . committed ) m : = pb . message { to : to , type : pb . msgheartbeat , commit : commit , context : ctx , } r . send ( m ) } 
func ( r * raft ) bcastappend ( ) { r . foreachprogress ( func ( id uint64 , * progress ) { if id == r . id { return } r . sendappend ( id ) } ) } 
func ( r * raft ) bcastheartbeat ( ) { lastctx : = r . readonly . lastpendingrequestctx ( ) if len ( lastctx ) == 0 { r . bcastheartbeatwithctx ( nil ) } else { r . bcastheartbeatwithctx ( [ ] byte ( lastctx ) ) } } 
func ( r * raft ) maybecommit ( ) bool { if cap ( r . matchbuf ) < len ( r . prs ) { r . matchbuf = make ( uint64slice , len ( r . prs ) ) } r . matchbuf = r . matchbuf [ : len ( r . prs ) ] idx : = 0 for , p : = range r . prs { r . matchbuf [ idx ] = p . match idx ++ } sort . sort ( & r . matchbuf ) mci : = r . matchbuf [ len ( r . matchbuf ) - r . quorum ( ) ] return r . raftlog . maybecommit ( mci , r . term ) } 
func ( r * raft ) tickelection ( ) { r . electionelapsed ++ if r . promotable ( ) && r . pastelectiontimeout ( ) { r . electionelapsed = 0 r . step ( pb . message { from : r . id , type : pb . msghup } ) } } 
func ( r * raft ) tickheartbeat ( ) { r . heartbeatelapsed ++ r . electionelapsed ++ if r . electionelapsed >= r . electiontimeout { r . electionelapsed = 0 if r . checkquorum { r . step ( pb . message { from : r . id , type : pb . msgcheckquorum } ) } if r . state == stateleader && r . leadtransferee ! = none { r . abortleadertransfer ( ) } } if r . state ! = stateleader { return } if r . heartbeatelapsed >= r . heartbeattimeout { r . heartbeatelapsed = 0 r . step ( pb . message { from : r . id , type : pb . msgbeat } ) } } 
func stepcandidate ( r * raft , m pb . message ) error { var myvoteresptype pb . messagetype if r . state == stateprecandidate { myvoteresptype = pb . msgprevoteresp } else { myvoteresptype = pb . msgvoteresp } switch m . type { case pb . msgprop : r . logger . infof ( " " , r . id , r . term ) return errproposaldropped case pb . msgapp : r . becomefollower ( m . term , m . from ) r . handleappendentries ( m ) case pb . msgheartbeat : r . becomefollower ( m . term , m . from ) r . handleheartbeat ( m ) case pb . msgsnap : r . becomefollower ( m . term , m . from ) r . handlesnapshot ( m ) case myvoteresptype : gr : = r . poll ( m . from , m . type , ! m . reject ) r . logger . infof ( " " , r . id , r . quorum ( ) , gr , m . type , len ( r . votes ) - gr ) switch r . quorum ( ) { case gr : if r . state == stateprecandidate { r . campaign ( campaignelection ) } else { r . becomeleader ( ) r . bcastappend ( ) } case len ( r . votes ) - gr : r . becomefollower ( r . term , none ) } case pb . msgtimeoutnow : r . logger . debugf ( " " , r . id , r . term , r . state , m . from ) } return nil } 
func ( r * raft ) restore ( s pb . snapshot ) bool { if s . metadata . index <= r . raftlog . committed { return false } if r . raftlog . matchterm ( s . metadata . index , s . metadata . term ) { r . logger . infof ( " " , r . id , r . raftlog . committed , r . raftlog . lastindex ( ) , r . raftlog . lastterm ( ) , s . metadata . index , s . metadata . term ) r . raftlog . committo ( s . metadata . index ) return false } if ! r . islearner { for , id : = range s . metadata . confstate . learners { if id == r . id { r . logger . errorf ( " " , r . id , s . metadata . index , s . metadata . term ) return false } } } r . logger . infof ( " " , r . id , r . raftlog . committed , r . raftlog . lastindex ( ) , r . raftlog . lastterm ( ) , s . metadata . index , s . metadata . term ) r . raftlog . restore ( s ) r . prs = make ( map [ uint64 ] * progress ) r . learnerprs = make ( map [ uint64 ] * progress ) r . restorenode ( s . metadata . confstate . nodes , false ) r . restorenode ( s . metadata . confstate . learners , true ) return true } 
func ( r * raft ) promotable ( ) bool { , ok : = r . prs [ r . id ] return ok } 
func ( r * raft ) checkquorumactive ( ) bool { var act int r . foreachprogress ( func ( id uint64 , pr * progress ) { if id == r . id { act ++ return } if pr . recentactive && ! pr . islearner { act ++ } pr . recentactive = false } ) return act >= r . quorum ( ) } 
func ( r * raft ) increaseuncommittedsize ( ents [ ] pb . entry ) bool { var s uint64 for , e : = range ents { s += uint64 ( payloadsize ( e ) ) } if r . uncommittedsize > 0 && r . uncommittedsize + s > r . maxuncommittedsize { return false } r . uncommittedsize += s return true } 
func ( r * raft ) reduceuncommittedsize ( ents [ ] pb . entry ) { if r . uncommittedsize == 0 { return } var s uint64 for , e : = range ents { s += uint64 ( payloadsize ( e ) ) } if s > r . uncommittedsize { r . uncommittedsize = 0 } else { r . uncommittedsize - = s } } 
func newperiodic ( lg * zap . logger , clock clockwork . clock , h time . duration , rg revgetter , c compactable ) * periodic { pc : = & periodic { lg : lg , clock : clock , period : h , rg : rg , c : c , revs : make ( [ ] int64 , 0 ) , } pc . ctx , pc . cancel = context . withcancel ( context . background ( ) ) return pc } 
func ( pc * periodic ) getcompactinterval ( ) time . duration { itv : = pc . period if itv > time . hour { itv = time . hour } return itv } 
func ( pc * periodic ) pause ( ) { pc . mu . lock ( ) pc . paused = true pc . mu . unlock ( ) } 
func ( pc * periodic ) resume ( ) { pc . mu . lock ( ) pc . paused = false pc . mu . unlock ( ) } 
func ( m * mutex ) lock ( ctx context . context ) error { s : = m . s client : = m . s . client ( ) m . mykey = fmt . sprintf ( " " , m . pfx , s . lease ( ) ) cmp : = v3 . compare ( v3 . createrevision ( m . mykey ) , " " , 0 ) put : = v3 . opput ( m . mykey , " " , v3 . withlease ( s . lease ( ) ) ) get : = v3 . opget ( m . mykey ) getowner : = v3 . opget ( m . pfx , v3 . withfirstcreate ( ) ... ) resp , err : = client . txn ( ctx ) . if ( cmp ) . then ( put , getowner ) . else ( get , getowner ) . commit ( ) if err ! = nil { return err } m . myrev = resp . header . revision if ! resp . succeeded { m . myrev = resp . responses [ 0 ] . getresponserange ( ) . kvs [ 0 ] . createrevision } ownerkey : = resp . responses [ 1 ] . getresponserange ( ) . kvs if len ( ownerkey ) == 0 | | ownerkey [ 0 ] . createrevision == m . myrev { m . hdr = resp . header return nil } hdr , werr : = waitdeletes ( ctx , client , m . pfx , m . myrev - 1 ) if werr ! = nil { m . unlock ( client . ctx ( ) ) } else { m . hdr = hdr } return werr } 
func newlocker ( s * session , pfx string ) sync . locker { return & lockermutex { newmutex ( s , pfx ) } } 
func newfifoscheduler ( ) scheduler { f : = & fifo { resume : make ( chan struct { } , 1 ) , donec : make ( chan struct { } , 1 ) , } f . finishcond = sync . newcond ( & f . mu ) f . ctx , f . cancel = context . withcancel ( context . background ( ) ) go f . run ( ) return f } 
func ( f * fifo ) schedule ( j job ) { f . mu . lock ( ) defer f . mu . unlock ( ) if f . cancel == nil { panic ( " " ) } if len ( f . pendings ) == 0 { select { case f . resume < - struct { } { } : default : } } f . pendings = append ( f . pendings , j ) } 
func ( f * fifo ) stop ( ) { f . mu . lock ( ) f . cancel ( ) f . cancel = nil f . mu . unlock ( ) < - f . donec } 
func newserver ( lg * zap . logger , network string , address string , ) * server { return & server { lg : lg , network : network , address : address , last : rpcpb . operation not started , advertiseclientporttoproxy : make ( map [ int ] proxy . server ) , advertisepeerporttoproxy : make ( map [ int ] proxy . server ) , } } 
func ( srv * server ) startserve ( ) error { var err error srv . ln , err = net . listen ( srv . network , srv . address ) if err ! = nil { return err } var opts [ ] grpc . serveroption opts = append ( opts , grpc . maxrecvmsgsize ( int ( maxrequestbytes + grpcoverheadbytes ) ) ) opts = append ( opts , grpc . maxsendmsgsize ( maxsendbytes ) ) opts = append ( opts , grpc . maxconcurrentstreams ( maxstreams ) ) srv . grpcserver = grpc . newserver ( opts ... ) rpcpb . registertransportserver ( srv . grpcserver , srv ) srv . lg . info ( " " , zap . string ( " " , srv . address ) , zap . string ( " " , srv . ln . addr ( ) . string ( ) ) , ) err = srv . grpcserver . serve ( srv . ln ) if err ! = nil && strings . contains ( err . error ( ) , " " ) { srv . lg . info ( " " , zap . string ( " " , srv . address ) , zap . error ( err ) , ) } else { srv . lg . warn ( " " , zap . string ( " " , srv . address ) , zap . error ( err ) , ) } return err } 
func ( srv * server ) stop ( ) { srv . lg . info ( " " , zap . string ( " " , srv . address ) ) srv . grpcserver . stop ( ) srv . lg . info ( " " , zap . string ( " " , srv . address ) ) } 
func ( srv * server ) transport ( stream rpcpb . transport transportserver ) ( err error ) { errc : = make ( chan error ) go func ( ) { for { var req * rpcpb . request req , err = stream . recv ( ) if err ! = nil { errc < - err return } if req . member ! = nil { srv . member = req . member } if req . tester ! = nil { srv . tester = req . tester } var resp * rpcpb . response resp , err = srv . handletesterrequest ( req ) if err ! = nil { errc < - err return } if err = stream . send ( resp ) ; err ! = nil { errc < - err return } } } ( ) select { case err = < - errc : case < - stream . context ( ) . done ( ) : err = stream . context ( ) . err ( ) } return err } 
func registerinterrupthandler ( h interrupthandler ) { interruptregistermu . lock ( ) defer interruptregistermu . unlock ( ) interrupthandlers = append ( interrupthandlers , h ) } 
func handleinterrupts ( lg * zap . logger ) { notifier : = make ( chan os . signal , 1 ) signal . notify ( notifier , syscall . sigint , syscall . sigterm ) go func ( ) { sig : = < - notifier interruptregistermu . lock ( ) ihs : = make ( [ ] interrupthandler , len ( interrupthandlers ) ) copy ( ihs , interrupthandlers ) interruptregistermu . unlock ( ) interruptexitmu . lock ( ) if lg ! = nil { lg . info ( " " , zap . string ( " " , sig . string ( ) ) ) } else { plog . noticef ( " " , sig ) } for , h : = range ihs { h ( ) } signal . stop ( notifier ) pid : = syscall . getpid ( ) if pid == 1 { os . exit ( 0 ) } setdflsignal ( sig . ( syscall . signal ) ) syscall . kill ( pid , sig . ( syscall . signal ) ) } ( ) } 
func ( op op ) txn ( ) ( [ ] cmp , [ ] op , [ ] op ) { return op . cmps , op . thenops , op . elseops } 
func opget ( key string , opts ... opoption ) op { if iswithprefix ( opts ) && iswithfromkey ( opts ) { panic ( " " ) } ret : = op { t : trange , key : [ ] byte ( key ) } ret . applyopts ( opts ) return ret } 
func opdelete ( key string , opts ... opoption ) op { if iswithprefix ( opts ) && iswithfromkey ( opts ) { panic ( " " ) } ret : = op { t : tdeleterange , key : [ ] byte ( key ) } ret . applyopts ( opts ) switch { case ret . leaseid ! = 0 : panic ( " " ) case ret . limit ! = 0 : panic ( " " ) case ret . rev ! = 0 : panic ( " " ) case ret . sort ! = nil : panic ( " " ) case ret . serializable : panic ( " " ) case ret . countonly : panic ( " " ) case ret . minmodrev ! = 0 , ret . maxmodrev ! = 0 : panic ( " " ) case ret . mincreaterev ! = 0 , ret . maxcreaterev ! = 0 : panic ( " " ) case ret . filterdelete , ret . filterput : panic ( " " ) case ret . creatednotify : panic ( " " ) } return ret } 
func opput ( key , val string , opts ... opoption ) op { ret : = op { t : tput , key : [ ] byte ( key ) , val : [ ] byte ( val ) } ret . applyopts ( opts ) switch { case ret . end ! = nil : panic ( " " ) case ret . limit ! = 0 : panic ( " " ) case ret . rev ! = 0 : panic ( " " ) case ret . sort ! = nil : panic ( " " ) case ret . serializable : panic ( " " ) case ret . countonly : panic ( " " ) case ret . minmodrev ! = 0 , ret . maxmodrev ! = 0 : panic ( " " ) case ret . mincreaterev ! = 0 , ret . maxcreaterev ! = 0 : panic ( " " ) case ret . filterdelete , ret . filterput : panic ( " " ) case ret . creatednotify : panic ( " " ) } return ret } 
func optxn ( cmps [ ] cmp , thenops [ ] op , elseops [ ] op ) op { return op { t : ttxn , cmps : cmps , thenops : thenops , elseops : elseops } } 
func withsort ( target sorttarget , order sortorder ) opoption { return func ( op * op ) { if target == sortbykey && order == sortascend { order = sortnone } op . sort = & sortoption { target , order } } } 
func withprefix ( ) opoption { return func ( op * op ) { if len ( op . key ) == 0 { op . key , op . end = [ ] byte { 0 } , [ ] byte { 0 } return } op . end = getprefix ( op . key ) } } 
func withrange ( endkey string ) opoption { return func ( op * op ) { op . end = [ ] byte ( endkey ) } } 
func withfromkey ( ) opoption { return func ( op * op ) { if len ( op . key ) == 0 { op . key = [ ] byte { 0 } } op . end = [ ] byte ( " \ x00 " ) } } 
func withtop ( target sorttarget , order sortorder ) [ ] opoption { return [ ] opoption { withprefix ( ) , withsort ( target , order ) , withlimit ( 1 ) } } 
func exist ( dir string ) bool { names , err : = fileutil . readdir ( dir , fileutil . withext ( " " ) ) if err ! = nil { return false } return len ( names ) ! = 0 } 
func searchindex ( lg * zap . logger , names [ ] string , index uint64 ) ( int , bool ) { for i : = len ( names ) - 1 ; i >= 0 ; i -- { name : = names [ i ] , curindex , err : = parsewalname ( name ) if err ! = nil { if lg ! = nil { lg . panic ( " " , zap . string ( " " , name ) , zap . error ( err ) ) } else { plog . panicf ( " " , err ) } } if index >= curindex { return i , true } } return - 1 , false } 
func isvalidseq ( lg * zap . logger , names [ ] string ) bool { var lastseq uint64 for , name : = range names { curseq , , err : = parsewalname ( name ) if err ! = nil { if lg ! = nil { lg . panic ( " " , zap . string ( " " , name ) , zap . error ( err ) ) } else { plog . panicf ( " " , err ) } } if lastseq ! = 0 && lastseq ! = curseq - 1 { return false } lastseq = curseq } return true } 
func newlistener ( addr , scheme string , tlsinfo * tlsinfo ) ( l net . listener , err error ) { if l , err = newlistener ( addr , scheme ) ; err ! = nil { return nil , err } return wraptls ( scheme , tlsinfo , l ) } 
func ( info tlsinfo ) cafiles ( ) [ ] string { cs : = make ( [ ] string , 0 ) if info . trustedcafile ! = " " { cs = append ( cs , info . trustedcafile ) } return cs } 
func ( info tlsinfo ) serverconfig ( ) ( * tls . config , error ) { cfg , err : = info . baseconfig ( ) if err ! = nil { return nil , err } cfg . clientauth = tls . noclientcert if info . trustedcafile ! = " " | | info . clientcertauth { cfg . clientauth = tls . requireandverifyclientcert } cs : = info . cafiles ( ) if len ( cs ) > 0 { cp , err : = tlsutil . newcertpool ( cs ) if err ! = nil { return nil , err } cfg . clientcas = cp } cfg . nextprotos = [ ] string { " " } return cfg , nil } 
func ( info tlsinfo ) clientconfig ( ) ( * tls . config , error ) { var cfg * tls . config var err error if ! info . empty ( ) { cfg , err = info . baseconfig ( ) if err ! = nil { return nil , err } } else { cfg = & tls . config { servername : info . servername } } cfg . insecureskipverify = info . insecureskipverify cs : = info . cafiles ( ) if len ( cs ) > 0 { cfg . rootcas , err = tlsutil . newcertpool ( cs ) if err ! = nil { return nil , err } } if info . selfcert { cfg . insecureskipverify = true } if info . emptycn { hasnonemptycn : = false cn : = " " tlsutil . newcert ( info . certfile , info . keyfile , func ( certpemblock [ ] byte , keypemblock [ ] byte ) ( tls . certificate , error ) { var block * pem . block block , = pem . decode ( certpemblock ) cert , err : = x509 . parsecertificate ( block . bytes ) if err ! = nil { return tls . certificate { } , err } if len ( cert . subject . commonname ) ! = 0 { hasnonemptycn = true cn = cert . subject . commonname } return tls . x509keypair ( certpemblock , keypemblock ) } ) if hasnonemptycn { return nil , fmt . errorf ( " " , cn ) } } return cfg , nil } 
func ( l * tlskeepalivelistener ) accept ( ) ( c net . conn , err error ) { c , err = l . listener . accept ( ) if err ! = nil { return } kac : = c . ( keepaliveconn ) kac . setkeepalive ( true ) kac . setkeepaliveperiod ( 30 * time . second ) c = tls . server ( c , l . config ) return c , nil } 
func newtlskeepalivelistener ( inner net . listener , config * tls . config ) net . listener { l : = & tlskeepalivelistener { } l . listener = inner l . config = config return l } 
func ( s * etcdserver ) applyv2request ( r * requestv2 ) response { defer warnofexpensiverequest ( s . getlogger ( ) , time . now ( ) , r , nil , nil ) switch r . method { case " " : return s . applyv2 . post ( r ) case " " : return s . applyv2 . put ( r ) case " " : return s . applyv2 . delete ( r ) case " " : return s . applyv2 . qget ( r ) case " " : return s . applyv2 . sync ( r ) default : return response { err : errunknownmethod } } } 
func newrolecommand ( ) * cobra . command { ac : = & cobra . command { use : " " , short : " " , } ac . addcommand ( newroleaddcommand ( ) ) ac . addcommand ( newroledeletecommand ( ) ) ac . addcommand ( newrolegetcommand ( ) ) ac . addcommand ( newrolelistcommand ( ) ) ac . addcommand ( newrolegrantpermissioncommand ( ) ) ac . addcommand ( newrolerevokepermissioncommand ( ) ) return ac } 
func roleaddcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } resp , err : = mustclientfromcmd ( cmd ) . auth . roleadd ( context . todo ( ) , args [ 0 ] ) if err ! = nil { exitwitherror ( exiterror , err ) } display . roleadd ( args [ 0 ] , * resp ) } 
func rolegetcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } name : = args [ 0 ] resp , err : = mustclientfromcmd ( cmd ) . auth . roleget ( context . todo ( ) , name ) if err ! = nil { exitwitherror ( exiterror , err ) } display . roleget ( name , * resp ) } 
func rolegrantpermissioncommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) < 3 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } perm , err : = clientv3 . strtopermissiontype ( args [ 1 ] ) if err ! = nil { exitwitherror ( exitbadargs , err ) } key , rangeend : = permrange ( args [ 2 : ] ) resp , err : = mustclientfromcmd ( cmd ) . auth . rolegrantpermission ( context . todo ( ) , args [ 0 ] , key , rangeend , perm ) if err ! = nil { exitwitherror ( exiterror , err ) } display . rolegrantpermission ( args [ 0 ] , * resp ) } 
func rolerevokepermissioncommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) < 2 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } key , rangeend : = permrange ( args [ 1 : ] ) resp , err : = mustclientfromcmd ( cmd ) . auth . rolerevokepermission ( context . todo ( ) , args [ 0 ] , key , rangeend ) if err ! = nil { exitwitherror ( exiterror , err ) } display . rolerevokepermission ( args [ 0 ] , args [ 1 ] , rangeend , * resp ) } 
func newcluster ( t testing . tb , size int ) * cluster { return newcluster ( t , & clusterconfig { size : size } ) } 
func newclusterbyconfig ( t testing . tb , cfg * clusterconfig ) * cluster { return newcluster ( t , cfg ) } 
func ( c * cluster ) waitleader ( t testing . tb , membs [ ] * member ) int { possiblelead : = make ( map [ uint64 ] bool ) var lead uint64 for , m : = range membs { possiblelead [ uint64 ( m . s . id ( ) ) ] = true } cc : = mustnewhttpclient ( t , getmembersurls ( membs ) , nil ) kapi : = client . newkeysapi ( cc ) for { ctx , cancel : = context . withtimeout ( context . background ( ) , 10 * tickduration + time . second ) , err : = kapi . get ( ctx , " " , & client . getoptions { quorum : true } ) cancel ( ) if err == nil | | strings . contains ( err . error ( ) , " " ) { break } } for lead == 0 | | ! possiblelead [ lead ] { lead = 0 for , m : = range membs { select { case < - m . s . stopnotify ( ) : continue default : } if lead ! = 0 && lead ! = m . s . lead ( ) { lead = 0 time . sleep ( 10 * tickduration ) break } lead = m . s . lead ( ) } } for i , m : = range membs { if uint64 ( m . s . id ( ) ) == lead { return i } } return - 1 } 
func ( c * cluster ) waitnoleader ( membs [ ] * member ) { noleader : = false for ! noleader { noleader = true for , m : = range membs { select { case < - m . s . stopnotify ( ) : continue default : } if m . s . lead ( ) ! = 0 { noleader = false time . sleep ( 10 * tickduration ) break } } } } 
func ismembersequal ( membs [ ] client . member , wmembs [ ] client . member ) bool { sort . sort ( sortablememberslicebypeerurls ( membs ) ) sort . sort ( sortablememberslicebypeerurls ( wmembs ) ) for i : = range membs { membs [ i ] . id = " " } return reflect . deepequal ( membs , wmembs ) } 
func ( m * member ) listengrpc ( ) error { m . grpcaddr = " " + m . name if m . useip { m . grpcaddr = " " + m . name } l , err : = transport . newunixlistener ( m . grpcaddr ) if err ! = nil { return fmt . errorf ( " " , m . grpcaddr , err ) } m . grpcbridge , err = newbridge ( m . grpcaddr ) if err ! = nil { l . close ( ) return err } m . grpcaddr = schemefromtlsinfo ( m . clienttlsinfo ) + " " + m . grpcbridge . inaddr m . grpclistener = l return nil } 
func newclientv3 ( m * member ) ( * clientv3 . client , error ) { if m . grpcaddr == " " { return nil , fmt . errorf ( " " ) } cfg : = clientv3 . config { endpoints : [ ] string { m . grpcaddr } , dialtimeout : 5 * time . second , dialoptions : [ ] grpc . dialoption { grpc . withblock ( ) } , maxcallsendmsgsize : m . clientmaxcallsendmsgsize , maxcallrecvmsgsize : m . clientmaxcallrecvmsgsize , } if m . clienttlsinfo ! = nil { tls , err : = m . clienttlsinfo . clientconfig ( ) if err ! = nil { return nil , err } cfg . tls = tls } if m . dialoptions ! = nil { cfg . dialoptions = append ( cfg . dialoptions , m . dialoptions ... ) } return newclientv3 ( cfg ) } 
func ( m * member ) clone ( t testing . tb ) * member { mm : = & member { } mm . serverconfig = m . serverconfig var err error clienturlstrs : = m . clienturls . stringslice ( ) mm . clienturls , err = types . newurls ( clienturlstrs ) if err ! = nil { panic ( err ) } peerurlstrs : = m . peerurls . stringslice ( ) mm . peerurls , err = types . newurls ( peerurlstrs ) if err ! = nil { panic ( err ) } clusterstr : = m . initialpeerurlsmap . string ( ) mm . initialpeerurlsmap , err = types . newurlsmap ( clusterstr ) if err ! = nil { panic ( err ) } mm . initialclustertoken = m . initialclustertoken mm . electionticks = m . electionticks mm . peertlsinfo = m . peertlsinfo mm . clienttlsinfo = m . clienttlsinfo return mm } 
func ( m * member ) close ( ) { if m . grpcbridge ! = nil { m . grpcbridge . close ( ) m . grpcbridge = nil } if m . serverclient ! = nil { m . serverclient . close ( ) m . serverclient = nil } if m . grpcserver ! = nil { m . grpcserver . stop ( ) m . grpcserver . gracefulstop ( ) m . grpcserver = nil m . grpcserverpeer . stop ( ) m . grpcserverpeer . gracefulstop ( ) m . grpcserverpeer = nil } m . s . hardstop ( ) for , f : = range m . serverclosers { f ( ) } } 
func ( m * member ) stop ( t testing . tb ) { lg . info ( " " , zap . string ( " " , m . name ) , zap . strings ( " " , m . peerurls . stringslice ( ) ) , zap . strings ( " " , m . clienturls . stringslice ( ) ) , zap . string ( " " , m . grpcaddr ) , ) m . close ( ) m . serverclosers = nil lg . info ( " " , zap . string ( " " , m . name ) , zap . strings ( " " , m . peerurls . stringslice ( ) ) , zap . strings ( " " , m . clienturls . stringslice ( ) ) , zap . string ( " " , m . grpcaddr ) , ) } 
func checkleadertransition ( m * member , oldlead uint64 ) uint64 { interval : = time . duration ( m . s . cfg . tickms ) * time . millisecond for m . s . lead ( ) == 0 | | ( m . s . lead ( ) == oldlead ) { time . sleep ( interval ) } return m . s . lead ( ) } 
func ( m * member ) restart ( t testing . tb ) error { lg . info ( " " , zap . string ( " " , m . name ) , zap . strings ( " " , m . peerurls . stringslice ( ) ) , zap . strings ( " " , m . clienturls . stringslice ( ) ) , zap . string ( " " , m . grpcaddr ) , ) newpeerlisteners : = make ( [ ] net . listener , 0 ) for , ln : = range m . peerlisteners { newpeerlisteners = append ( newpeerlisteners , newlistenerwithaddr ( t , ln . addr ( ) . string ( ) ) ) } m . peerlisteners = newpeerlisteners newclientlisteners : = make ( [ ] net . listener , 0 ) for , ln : = range m . clientlisteners { newclientlisteners = append ( newclientlisteners , newlistenerwithaddr ( t , ln . addr ( ) . string ( ) ) ) } m . clientlisteners = newclientlisteners if m . grpclistener ! = nil { if err : = m . listengrpc ( ) ; err ! = nil { t . fatal ( err ) } } err : = m . launch ( ) lg . info ( " " , zap . string ( " " , m . name ) , zap . strings ( " " , m . peerurls . stringslice ( ) ) , zap . strings ( " " , m . clienturls . stringslice ( ) ) , zap . string ( " " , m . grpcaddr ) , zap . error ( err ) , ) return err } 
func ( m * member ) terminate ( t testing . tb ) { lg . info ( " " , zap . string ( " " , m . name ) , zap . strings ( " " , m . peerurls . stringslice ( ) ) , zap . strings ( " " , m . clienturls . stringslice ( ) ) , zap . string ( " " , m . grpcaddr ) , ) m . close ( ) if ! m . keepdatadirterminate { if err : = os . removeall ( m . serverconfig . datadir ) ; err ! = nil { t . fatal ( err ) } } lg . info ( " " , zap . string ( " " , m . name ) , zap . strings ( " " , m . peerurls . stringslice ( ) ) , zap . strings ( " " , m . clienturls . stringslice ( ) ) , zap . string ( " " , m . grpcaddr ) , ) } 
func ( m * member ) metric ( metricname string ) ( string , error ) { cfgtls : = transport . tlsinfo { } tr , err : = transport . newtimeouttransport ( cfgtls , time . second , time . second , time . second ) if err ! = nil { return " " , err } cli : = & http . client { transport : tr } resp , err : = cli . get ( m . clienturls [ 0 ] . string ( ) + " " ) if err ! = nil { return " " , err } defer resp . body . close ( ) b , rerr : = ioutil . readall ( resp . body ) if rerr ! = nil { return " " , rerr } lines : = strings . split ( string ( b ) , " \n " ) for , l : = range lines { if strings . hasprefix ( l , metricname ) { return strings . split ( l , " " ) [ 1 ] , nil } } return " " , nil } 
func ( m * member ) injectpartition ( t testing . tb , others ... * member ) { for , other : = range others { m . s . cutpeer ( other . s . id ( ) ) other . s . cutpeer ( m . s . id ( ) ) } } 
func ( m * member ) recoverpartition ( t testing . tb , others ... * member ) { for , other : = range others { m . s . mendpeer ( other . s . id ( ) ) other . s . mendpeer ( m . s . id ( ) ) } } 
func newclusterv3 ( t testing . tb , cfg * clusterconfig ) * clusterv3 { cfg . usegrpc = true if os . getenv ( " " ) ! = " " { clientv3 . setlogger ( grpclog . newloggerv2withverbosity ( os . stderr , os . stderr , os . stderr , 4 ) ) } clus : = & clusterv3 { cluster : newclusterbyconfig ( t , cfg ) , } clus . launch ( t ) if ! cfg . skipcreatingclient { for , m : = range clus . members { client , err : = newclientv3 ( m ) if err ! = nil { t . fatalf ( " " , err ) } clus . clients = append ( clus . clients , client ) } } return clus } 
func ( opts * jwtoptions ) parsewithdefaults ( optmap map [ string ] string ) error { if opts . ttl == 0 && optmap [ optttl ] == " " { opts . ttl = defaultttl } return opts . parse ( optmap ) } 
func ( opts * jwtoptions ) parse ( optmap map [ string ] string ) error { var err error if ttl : = optmap [ optttl ] ; ttl ! = " " { opts . ttl , err = time . parseduration ( ttl ) if err ! = nil { return err } } if file : = optmap [ optpublickey ] ; file ! = " " { opts . publickey , err = ioutil . readfile ( file ) if err ! = nil { return err } } if file : = optmap [ optprivatekey ] ; file ! = " " { opts . privatekey , err = ioutil . readfile ( file ) if err ! = nil { return err } } method : = optmap [ optsignmethod ] opts . signmethod = jwt . getsigningmethod ( method ) if opts . signmethod == nil { return errinvalidauthmethod } return nil } 
func ( opts * jwtoptions ) key ( ) ( interface { } , error ) { switch opts . signmethod . ( type ) { case * jwt . signingmethodrsa , * jwt . signingmethodrsapss : return opts . rsakey ( ) case * jwt . signingmethodecdsa : return opts . eckey ( ) case * jwt . signingmethodhmac : return opts . hmackey ( ) default : return nil , fmt . errorf ( " " , opts . signmethod ) } } 
func ( h * header ) fill ( rh * pb . responseheader ) { if rh == nil { plog . panic ( " " ) } rh . clusterid = uint64 ( h . clusterid ) rh . memberid = uint64 ( h . memberid ) rh . raftterm = h . sg . term ( ) if rh . revision == 0 { rh . revision = h . rev ( ) } } 
func ( wb * watchbroadcast ) add ( w * watcher ) bool { wb . mu . lock ( ) defer wb . mu . unlock ( ) if wb . nextrev > w . nextrev | | ( wb . nextrev == 0 && w . nextrev ! = 0 ) { return false } if wb . responses == 0 { wb . receivers [ w ] = struct { } { } return true } ok : = w . post ( & pb . watchresponse { header : & pb . responseheader { revision : w . nextrev , } , watchid : w . id , created : true , } ) if ! ok { return false } wb . receivers [ w ] = struct { } { } watcherscoalescing . inc ( ) return true } 
func ( ws * watchstream ) watch ( id watchid , key , end [ ] byte , startrev int64 , fcs ... filterfunc ) ( watchid , error ) { if len ( end ) ! = 0 && bytes . compare ( key , end ) ! = - 1 { return - 1 , erremptywatcherrange } ws . mu . lock ( ) defer ws . mu . unlock ( ) if ws . closed { return - 1 , erremptywatcherrange } if id == autowatchid { for ws . watchers [ ws . nextid ] ! = nil { ws . nextid ++ } id = ws . nextid ws . nextid ++ } else if , ok : = ws . watchers [ id ] ; ok { return - 1 , errwatcherduplicateid } w , c : = ws . watchable . watch ( key , end , startrev , id , ws . ch , fcs ... ) ws . cancels [ id ] = c ws . watchers [ id ] = w return id , nil } 
func newfileencoder ( f * os . file , prevcrc uint32 ) ( * encoder , error ) { offset , err : = f . seek ( 0 , io . seekcurrent ) if err ! = nil { return nil , err } return newencoder ( f , prevcrc , int ( offset ) ) , nil } 
func ( ss * stringsvalue ) set ( s string ) error { * ss = strings . split ( s , " " ) return nil } 
func newstringsvalue ( s string ) ( ss * stringsvalue ) { if s == " " { return & stringsvalue { } } ss = new ( stringsvalue ) if err : = ss . set ( s ) ; err ! = nil { plog . panicf ( " " , err ) } return ss } 
func stringsfromflag ( fs * flag . flagset , flagname string ) [ ] string { return [ ] string ( * fs . lookup ( flagname ) . value . ( * stringsvalue ) ) } 
func cluster ( v string ) string { vs : = strings . split ( v , " " ) if len ( vs ) <= 2 { return v } return fmt . sprintf ( " " , vs [ 0 ] , vs [ 1 ] ) } 
func newpagewriter ( w io . writer , pagebytes , pageoffset int ) * pagewriter { return & pagewriter { w : w , pageoffset : pageoffset , pagebytes : pagebytes , buf : make ( [ ] byte , defaultbufferbytes + pagebytes ) , bufwatermarkbytes : defaultbufferbytes , } } 
func newwatchhub ( capacity int ) * watcherhub { return & watcherhub { watchers : make ( map [ string ] * list . list ) , eventhistory : neweventhistory ( capacity ) , } } 
func ( wh * watcherhub ) watch ( key string , recursive , stream bool , index , storeindex uint64 ) ( watcher , * v2error . error ) { reportwatchrequest ( ) event , err : = wh . eventhistory . scan ( key , recursive , index ) if err ! = nil { err . index = storeindex return nil , err } w : = & watcher { eventchan : make ( chan * event , 100 ) , recursive : recursive , stream : stream , sinceindex : index , startindex : storeindex , hub : wh , } wh . mutex . lock ( ) defer wh . mutex . unlock ( ) if event ! = nil { ne : = event . clone ( ) ne . etcdindex = storeindex w . eventchan < - ne return w , nil } l , ok : = wh . watchers [ key ] var elem * list . element if ok { elem = l . pushback ( w ) } else { l = list . new ( ) elem = l . pushback ( w ) wh . watchers [ key ] = l } w . remove = func ( ) { if w . removed { return } w . removed = true l . remove ( elem ) atomic . addint64 ( & wh . count , - 1 ) reportwatcherremoved ( ) if l . len ( ) == 0 { delete ( wh . watchers , key ) } } atomic . addint64 ( & wh . count , 1 ) reportwatcheradded ( ) return w , nil } 
func ( wh * watcherhub ) notify ( e * event ) { e = wh . eventhistory . addevent ( e ) segments : = strings . split ( e . node . key , " " ) currpath : = " " for , segment : = range segments { currpath = path . join ( currpath , segment ) wh . notifywatchers ( e , currpath , false ) } } 
func ( wh * watcherhub ) clone ( ) * watcherhub { clonedhistory : = wh . eventhistory . clone ( ) return & watcherhub { eventhistory : clonedhistory , } } 
func ishidden ( watchpath , keypath string ) bool { if len ( watchpath ) > len ( keypath ) { return false } afterpath : = path . clean ( " " + keypath [ len ( watchpath ) : ] ) return strings . contains ( afterpath , " " ) } 
func newtimeoutlistener ( addr string , scheme string , tlsinfo * tlsinfo , rdtimeoutd , wtimeoutd time . duration ) ( net . listener , error ) { ln , err : = newlistener ( addr , scheme ) if err ! = nil { return nil , err } ln = & rwtimeoutlistener { listener : ln , rdtimeoutd : rdtimeoutd , wtimeoutd : wtimeoutd , } if ln , err = wraptls ( scheme , tlsinfo , ln ) ; err ! = nil { return nil , err } return ln , nil } 
func ( srv * server ) createetcdlogfile ( ) error { var err error srv . etcdlogfile , err = os . create ( srv . member . etcd . logoutputs [ 0 ] ) if err ! = nil { return err } srv . lg . info ( " " , zap . string ( " " , srv . member . etcd . logoutputs [ 0 ] ) ) return nil } 
func ( srv * server ) runetcd ( ) error { errc : = make ( chan error ) go func ( ) { time . sleep ( 5 * time . second ) errc < - srv . startproxy ( ) } ( ) if srv . etcdcmd ! = nil { srv . lg . info ( " " , zap . string ( " " , srv . etcdcmd . path ) , ) err : = srv . etcdcmd . start ( ) perr : = < - errc srv . lg . info ( " " , zap . string ( " " , srv . etcdcmd . path ) , zap . errors ( " " , [ ] error { err , perr } ) , ) if err ! = nil { return err } return perr } select { case < - srv . etcdserver . server . readynotify ( ) : srv . lg . info ( " " ) case < - time . after ( time . minute ) : srv . etcdserver . close ( ) return fmt . errorf ( " " , < - srv . etcdserver . err ( ) ) } return < - errc } 
func ( srv * server ) stopetcd ( sig os . signal ) error { srv . stopproxy ( ) if srv . etcdcmd ! = nil { srv . lg . info ( " " , zap . string ( " " , srv . etcdcmd . path ) , zap . string ( " " , sig . string ( ) ) , ) err : = srv . etcdcmd . process . signal ( sig ) if err ! = nil { return err } errc : = make ( chan error ) go func ( ) { , ew : = srv . etcdcmd . process . wait ( ) errc < - ew close ( errc ) } ( ) select { case < - time . after ( 5 * time . second ) : srv . etcdcmd . process . kill ( ) case e : = < - errc : return e } err = < - errc srv . lg . info ( " " , zap . string ( " " , srv . etcdcmd . path ) , zap . string ( " " , sig . string ( ) ) , zap . error ( err ) , ) return err } srv . lg . info ( " " ) srv . etcdserver . server . hardstop ( ) srv . etcdserver . close ( ) srv . lg . info ( " " ) return nil } 
func ( srv * server ) handle sigquit etcd and remove data and stop agent ( ) ( * rpcpb . response , error ) { err : = srv . stopetcd ( syscall . sigquit ) if err ! = nil { return nil , err } if srv . etcdserver ! = nil { srv . etcdserver . getlogger ( ) . sync ( ) } else { srv . etcdlogfile . sync ( ) srv . etcdlogfile . close ( ) } err = os . removeall ( srv . member . basedir ) if err ! = nil { return nil , err } srv . lg . info ( " " , zap . string ( " " , srv . member . basedir ) ) srv . stop ( ) return & rpcpb . response { success : true , status : " " , } , nil } 
func limitlistener ( l net . listener , n int ) net . listener { return & limitlistener { l , make ( chan struct { } , n ) } } 
func allowmethod ( w http . responsewriter , m string , ms ... string ) bool { for , meth : = range ms { if m == meth { return true } } w . header ( ) . set ( " " , strings . join ( ms , " " ) ) http . error ( w , " " , http . statusmethodnotallowed ) return false } 
func newwatchserver ( s * etcdserver . etcdserver ) pb . watchserver { return & watchserver { lg : s . cfg . logger , clusterid : int64 ( s . cluster ( ) . id ( ) ) , memberid : int64 ( s . id ( ) ) , maxrequestbytes : int ( s . cfg . maxrequestbytes + grpcoverheadbytes ) , sg : s , watchable : s . watchable ( ) , ag : s , } } 
func getprogressreportinterval ( ) time . duration { progressreportintervalmu . rlock ( ) interval : = progressreportinterval progressreportintervalmu . runlock ( ) jitter : = time . duration ( rand . int63n ( int64 ( interval ) / 10 ) ) return interval + jitter } 
func setprogressreportinterval ( newtimeout time . duration ) { progressreportintervalmu . lock ( ) progressreportinterval = newtimeout progressreportintervalmu . unlock ( ) } 
func filtersfromrequest ( creq * pb . watchcreaterequest ) [ ] mvcc . filterfunc { filters : = make ( [ ] mvcc . filterfunc , 0 , len ( creq . filters ) ) for , ft : = range creq . filters { switch ft { case pb . watchcreaterequest noput : filters = append ( filters , filternoput ) case pb . watchcreaterequest nodelete : filters = append ( filters , filternodelete ) default : } } return filters } 
func newpipelinehandler ( t * transport , r raft , cid types . id ) http . handler { return & pipelinehandler { lg : t . logger , localid : t . id , tr : t , r : r , cid : cid , } } 
func keyexists ( key string ) clientv3 . cmp { return clientv3 . compare ( clientv3 . version ( key ) , " " , 0 ) } 
func keymissing ( key string ) clientv3 . cmp { return clientv3 . compare ( clientv3 . version ( key ) , " " , 0 ) } 
func validatesecureendpoints ( tlsinfo tlsinfo , eps [ ] string ) ( [ ] string , error ) { t , err : = newtransport ( tlsinfo , 5 * time . second ) if err ! = nil { return nil , err } var errs [ ] string var endpoints [ ] string for , ep : = range eps { if ! strings . hasprefix ( ep , " " ) { errs = append ( errs , fmt . sprintf ( " " , ep ) ) continue } conn , cerr : = t . dial ( " " , ep [ len ( " " ) : ] ) if cerr ! = nil { errs = append ( errs , fmt . sprintf ( " " , ep , cerr ) ) continue } conn . close ( ) endpoints = append ( endpoints , ep ) } if len ( errs ) ! = 0 { err = fmt . errorf ( " " , strings . join ( errs , " " ) ) } return endpoints , err } 
func putnewkv ( kv v3 . kv , key , val string , leaseid v3 . leaseid ) ( int64 , error ) { cmp : = v3 . compare ( v3 . version ( key ) , " " , 0 ) req : = v3 . opput ( key , val , v3 . withlease ( leaseid ) ) txnresp , err : = kv . txn ( context . todo ( ) ) . if ( cmp ) . then ( req ) . commit ( ) if err ! = nil { return 0 , err } if ! txnresp . succeeded { return 0 , errkeyexists } return txnresp . header . revision , nil } 
func newsequentialkv ( kv v3 . kv , prefix , val string ) ( * remotekv , error ) { resp , err : = kv . get ( context . todo ( ) , prefix , v3 . withlastkey ( ) ... ) if err ! = nil { return nil , err } newseqnum : = 0 if len ( resp . kvs ) ! = 0 { fields : = strings . split ( string ( resp . kvs [ 0 ] . key ) , " " ) , serr : = fmt . sscanf ( fields [ len ( fields ) - 1 ] , " " , & newseqnum ) if serr ! = nil { return nil , serr } newseqnum ++ } newkey : = fmt . sprintf ( " " , prefix , newseqnum ) basekey : = " " + prefix cmp : = v3 . compare ( v3 . modrevision ( basekey ) , " " , resp . header . revision + 1 ) reqprefix : = v3 . opput ( basekey , " " ) reqnewkey : = v3 . opput ( newkey , val ) txn : = kv . txn ( context . todo ( ) ) txnresp , err : = txn . if ( cmp ) . then ( reqprefix , reqnewkey ) . commit ( ) if err ! = nil { return nil , err } if ! txnresp . succeeded { return newsequentialkv ( kv , prefix , val ) } return & remotekv { kv , newkey , txnresp . header . revision , val } , nil } 
func newephemeralkv ( s * concurrency . session , key , val string ) ( * ephemeralkv , error ) { k , err : = newkv ( s . client ( ) , key , val , s . lease ( ) ) if err ! = nil { return nil , err } return & ephemeralkv { * k } , nil } 
func newuniqueephemeralkey ( s * concurrency . session , prefix string ) ( * ephemeralkv , error ) { return newuniqueephemeralkv ( s , prefix , " " ) } 
func newuniqueephemeralkv ( s * concurrency . session , prefix , val string ) ( ek * ephemeralkv , err error ) { for { newkey : = fmt . sprintf ( " " , prefix , time . now ( ) . unixnano ( ) ) ek , err = newephemeralkv ( s , newkey , val ) if err == nil | | err ! = errkeyexists { break } } return ek , err } 
func newupdatedircommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , flags : [ ] cli . flag { cli . intflag { name : " " , value : 0 , usage : " " } , } , action : func ( c * cli . context ) error { updatedircommandfunc ( c , mustnewkeyapi ( c ) ) return nil } , } } 
func updatedircommandfunc ( c * cli . context , ki client . keysapi ) { if len ( c . args ( ) ) == 0 { handleerror ( c , exitbadargs , errors . new ( " " ) ) } key : = c . args ( ) [ 0 ] ttl : = c . int ( " " ) ctx , cancel : = contextwithtotaltimeout ( c ) resp , err : = ki . set ( ctx , key , " " , & client . setoptions { ttl : time . duration ( ttl ) * time . second , dir : true , prevexist : client . prevexist } ) cancel ( ) if err ! = nil { handleerror ( c , exitservererror , err ) } if c . globalstring ( " " ) ! = " " { printresponsekey ( resp , c . globalstring ( " " ) ) } } 
func newwatchcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : runwatcherfunc , } cmd . flags ( ) . durationvar ( & runningtime , " " , 60 , " " ) cmd . flags ( ) . stringvar ( & watchprefix , " " , " " , " " ) cmd . flags ( ) . intvar ( & noofprefixes , " " , 10 , " " ) cmd . flags ( ) . intvar ( & watchperprefix , " " , 10 , " " ) cmd . flags ( ) . intvar ( & totalkeys , " " , 1000 , " " ) return cmd } 
func newv3 ( lg * zap . logger ) manager { if lg == nil { lg = zap . newexample ( ) } return & v3manager { lg : lg } } 
func newauthstore ( lg * zap . logger , be backend . backend , tp tokenprovider , bcryptcost int ) * authstore { if bcryptcost < bcrypt . mincost | | bcryptcost > bcrypt . maxcost { if lg ! = nil { lg . warn ( " " , zap . int ( " " , bcrypt . mincost ) , zap . int ( " " , bcrypt . maxcost ) , zap . int ( " " , bcrypt . defaultcost ) , zap . int ( " " , bcryptcost ) ) } else { plog . warningf ( " " , bcrypt . defaultcost , bcryptcost ) } bcryptcost = bcrypt . defaultcost } tx : = be . batchtx ( ) tx . lock ( ) tx . unsafecreatebucket ( authbucketname ) tx . unsafecreatebucket ( authusersbucketname ) tx . unsafecreatebucket ( authrolesbucketname ) enabled : = false , vs : = tx . unsaferange ( authbucketname , enableflagkey , nil , 0 ) if len ( vs ) == 1 { if bytes . equal ( vs [ 0 ] , authenabled ) { enabled = true } } as : = & authstore { revision : getrevision ( tx ) , lg : lg , be : be , enabled : enabled , rangepermcache : make ( map [ string ] * unifiedrangepermissions ) , tokenprovider : tp , bcryptcost : bcryptcost , } if enabled { as . tokenprovider . enable ( ) } if as . revision ( ) == 0 { as . commitrevision ( tx ) } tx . unlock ( ) be . forcecommit ( ) return as } 
func newtokenprovider ( lg * zap . logger , tokenopts string , indexwaiter func ( uint64 ) < - chan struct { } ) ( tokenprovider , error ) { tokentype , typespecificopts , err : = decomposeopts ( lg , tokenopts ) if err ! = nil { return nil , errinvalidauthopts } switch tokentype { case tokentypesimple : if lg ! = nil { lg . warn ( " " ) } else { plog . warningf ( " " ) } return newtokenprovidersimple ( lg , indexwaiter ) , nil case tokentypejwt : return newtokenproviderjwt ( lg , typespecificopts ) case " " : return newtokenprovidernop ( ) default : if lg ! = nil { lg . warn ( " " , zap . string ( " " , tokentype ) , zap . error ( errinvalidauthopts ) , ) } else { plog . errorf ( " " , tokentype ) } return nil , errinvalidauthopts } } 
func ( t * transport ) cutpeer ( id types . id ) { t . mu . rlock ( ) p , pok : = t . peers [ id ] g , gok : = t . remotes [ id ] t . mu . runlock ( ) if pok { p . ( pausable ) . pause ( ) } if gok { g . pause ( ) } } 
func ( t * transport ) mendpeer ( id types . id ) { t . mu . rlock ( ) p , pok : = t . peers [ id ] g , gok : = t . remotes [ id ] t . mu . runlock ( ) if pok { p . ( pausable ) . resume ( ) } if gok { g . resume ( ) } } 
func ( t * transport ) removepeer ( id types . id ) { if peer , ok : = t . peers [ id ] ; ok { peer . stop ( ) } else { if t . logger ! = nil { t . logger . panic ( " " , zap . string ( " " , id . string ( ) ) ) } else { plog . panicf ( " " , id ) } } delete ( t . peers , id ) delete ( t . leaderstats . followers , id . string ( ) ) t . pipelineprober . remove ( id . string ( ) ) t . streamprober . remove ( id . string ( ) ) if t . logger ! = nil { t . logger . info ( " " , zap . string ( " " , t . id . string ( ) ) , zap . string ( " " , id . string ( ) ) , ) } else { plog . infof ( " " , id ) } } 
func ( t * transport ) activepeers ( ) ( cnt int ) { t . mu . rlock ( ) defer t . mu . runlock ( ) for , p : = range t . peers { if ! p . activesince ( ) . iszero ( ) { cnt ++ } } return cnt } 
func resolvetcpaddrdefault ( ctx context . context , addr string ) ( * net . tcpaddr , error ) { host , port , serr : = net . splithostport ( addr ) if serr ! = nil { return nil , serr } portnum , perr : = net . defaultresolver . lookupport ( ctx , " " , port ) if perr ! = nil { return nil , perr } var ips [ ] net . ipaddr if ip : = net . parseip ( host ) ; ip ! = nil { ips = [ ] net . ipaddr { { ip : ip } } } else { ipss , err : = net . defaultresolver . lookupipaddr ( ctx , host ) if err ! = nil { return nil , err } ips = ipss } ip : = ips [ 0 ] return & net . tcpaddr { ip : ip . ip , port : portnum , zone : ip . zone } , nil } 
func resolvetcpaddrs ( ctx context . context , lg * zap . logger , urls [ ] [ ] url . url ) ( [ ] [ ] url . url , error ) { newurls : = make ( [ ] [ ] url . url , 0 ) for , us : = range urls { nus : = make ( [ ] url . url , len ( us ) ) for i , u : = range us { nu , err : = url . parse ( u . string ( ) ) if err ! = nil { return nil , fmt . errorf ( " " , u . string ( ) , err ) } nus [ i ] = * nu } for i , u : = range nus { h , err : = resolveurl ( ctx , lg , u ) if err ! = nil { return nil , fmt . errorf ( " " , u . string ( ) , err ) } if h ! = " " { nus [ i ] . host = h } } newurls = append ( newurls , nus ) } return newurls , nil } 
func urlsequal ( ctx context . context , lg * zap . logger , a [ ] url . url , b [ ] url . url ) ( bool , error ) { if len ( a ) ! = len ( b ) { return false , fmt . errorf ( " " , urlstostrings ( a ) , urlstostrings ( b ) ) } urls , err : = resolvetcpaddrs ( ctx , lg , [ ] [ ] url . url { a , b } ) if err ! = nil { return false , err } preva , prevb : = a , b a , b = urls [ 0 ] , urls [ 1 ] sort . sort ( types . urls ( a ) ) sort . sort ( types . urls ( b ) ) for i : = range a { if ! reflect . deepequal ( a [ i ] , b [ i ] ) { return false , fmt . errorf ( " " , a [ i ] . string ( ) , preva [ i ] . string ( ) , b [ i ] . string ( ) , prevb [ i ] . string ( ) , ) } } return true , nil } 
func urlstringsequal ( ctx context . context , lg * zap . logger , a [ ] string , b [ ] string ) ( bool , error ) { if len ( a ) ! = len ( b ) { return false , fmt . errorf ( " " , a , b ) } urlsa : = make ( [ ] url . url , 0 ) for , str : = range a { u , err : = url . parse ( str ) if err ! = nil { return false , fmt . errorf ( " " , str ) } urlsa = append ( urlsa , * u ) } urlsb : = make ( [ ] url . url , 0 ) for , str : = range b { u , err : = url . parse ( str ) if err ! = nil { return false , fmt . errorf ( " " , str ) } urlsb = append ( urlsb , * u ) } if lg == nil { lg , = zap . newproduction ( ) if lg == nil { lg = zap . newexample ( ) } } return urlsequal ( ctx , lg , urlsa , urlsb ) } 
func newleasecommand ( ) * cobra . command { lc : = & cobra . command { use : " " , short : " " , } lc . addcommand ( newleasegrantcommand ( ) ) lc . addcommand ( newleaserevokecommand ( ) ) lc . addcommand ( newleasetimetolivecommand ( ) ) lc . addcommand ( newleaselistcommand ( ) ) lc . addcommand ( newleasekeepalivecommand ( ) ) return lc } 
func newleasegrantcommand ( ) * cobra . command { lc : = & cobra . command { use : " " , short : " " , run : leasegrantcommandfunc , } return lc } 
func leasegrantcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } ttl , err : = strconv . parseint ( args [ 0 ] , 10 , 64 ) if err ! = nil { exitwitherror ( exitbadargs , fmt . errorf ( " " , err ) ) } ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . grant ( ctx , ttl ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , fmt . errorf ( " " , err ) ) } display . grant ( * resp ) } 
func newleaserevokecommand ( ) * cobra . command { lc : = & cobra . command { use : " " , short : " " , run : leaserevokecommandfunc , } return lc } 
func leaserevokecommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } id : = leasefromargs ( args [ 0 ] ) ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . revoke ( ctx , id ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , fmt . errorf ( " " , err ) ) } display . revoke ( id , * resp ) } 
func newleasetimetolivecommand ( ) * cobra . command { lc : = & cobra . command { use : " " , short : " " , run : leasetimetolivecommandfunc , } lc . flags ( ) . boolvar ( & timetolivekeys , " " , false , " " ) return lc } 
func leasetimetolivecommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } var opts [ ] v3 . leaseoption if timetolivekeys { opts = append ( opts , v3 . withattachedkeys ( ) ) } resp , rerr : = mustclientfromcmd ( cmd ) . timetolive ( context . todo ( ) , leasefromargs ( args [ 0 ] ) , opts ... ) if rerr ! = nil { exitwitherror ( exitbadconnection , rerr ) } display . timetolive ( * resp , timetolivekeys ) } 
func newleaselistcommand ( ) * cobra . command { lc : = & cobra . command { use : " " , short : " " , run : leaselistcommandfunc , } return lc } 
func leaselistcommandfunc ( cmd * cobra . command , args [ ] string ) { resp , rerr : = mustclientfromcmd ( cmd ) . leases ( context . todo ( ) ) if rerr ! = nil { exitwitherror ( exitbadconnection , rerr ) } display . leases ( * resp ) } 
func newleasekeepalivecommand ( ) * cobra . command { lc : = & cobra . command { use : " " , short : " " , run : leasekeepalivecommandfunc , } lc . flags ( ) . boolvar ( & leasekeepaliveonce , " " , false , " " ) return lc } 
func leasekeepalivecommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } id : = leasefromargs ( args [ 0 ] ) if leasekeepaliveonce { respc , kerr : = mustclientfromcmd ( cmd ) . keepaliveonce ( context . todo ( ) , id ) if kerr ! = nil { exitwitherror ( exitbadconnection , kerr ) } display . keepalive ( * respc ) return } respc , kerr : = mustclientfromcmd ( cmd ) . keepalive ( context . todo ( ) , id ) if kerr ! = nil { exitwitherror ( exitbadconnection , kerr ) } for resp : = range respc { display . keepalive ( * resp ) } if , ok : = ( display ) . ( * simpleprinter ) ; ok { fmt . printf ( " \n " , id ) } } 
func newalarmcommand ( ) * cobra . command { ac : = & cobra . command { use : " " , short : " " , } ac . addcommand ( newalarmdisarmcommand ( ) ) ac . addcommand ( newalarmlistcommand ( ) ) return ac } 
func alarmdisarmcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 0 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . alarmdisarm ( ctx , & v3 . alarmmember { } ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . alarm ( * resp ) } 
func alarmlistcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 0 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . alarmlist ( ctx ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . alarm ( * resp ) } 
func ( e * etcd ) flags ( ) ( fs [ ] string ) { tp : = reflect . typeof ( * e ) vo : = reflect . valueof ( * e ) for , name : = range etcdfields { field , ok : = tp . fieldbyname ( name ) if ! ok { panic ( fmt . errorf ( " " , name ) ) } fv : = reflect . indirect ( vo ) . fieldbyname ( name ) var sv string switch fv . type ( ) . kind ( ) { case reflect . string : sv = fv . string ( ) case reflect . slice : n : = fv . len ( ) sl : = make ( [ ] string , n ) for i : = 0 ; i < n ; i ++ { sl [ i ] = fv . index ( i ) . string ( ) } sv = strings . join ( sl , " " ) case reflect . int64 : sv = fmt . sprintf ( " " , fv . int ( ) ) case reflect . bool : sv = fmt . sprintf ( " " , fv . bool ( ) ) default : panic ( fmt . errorf ( " " , name , fv . type ( ) . kind ( ) ) ) } fname : = field . tag . get ( " " ) if fname == " " { fname = " " + fname } if sv ! = " " { fs = append ( fs , fmt . sprintf ( " " , fname , sv ) ) } } return fs } 
func newclusterproxy ( c * clientv3 . client , advaddr string , prefix string ) ( pb . clusterserver , < - chan struct { } ) { cp : = & clusterproxy { clus : c . cluster , ctx : c . ctx ( ) , gr : & naming . grpcresolver { client : c } , advaddr : advaddr , prefix : prefix , umap : make ( map [ string ] gnaming . update ) , } donec : = make ( chan struct { } ) if advaddr ! = " " && prefix ! = " " { go func ( ) { defer close ( donec ) cp . resolve ( prefix ) } ( ) return cp , donec } close ( donec ) return cp , donec } 
func ( cp * clusterproxy ) memberlist ( ctx context . context , r * pb . memberlistrequest ) ( * pb . memberlistresponse , error ) { if cp . advaddr ! = " " { if cp . prefix ! = " " { mbs , err : = cp . membersfromupdates ( ) if err ! = nil { return nil , err } if len ( mbs ) > 0 { return & pb . memberlistresponse { members : mbs } , nil } } hostname , : = os . hostname ( ) return & pb . memberlistresponse { members : [ ] * pb . member { { name : hostname , clienturls : [ ] string { cp . advaddr } } } } , nil } mresp , err : = cp . clus . memberlist ( ctx ) if err ! = nil { return nil , err } resp : = ( pb . memberlistresponse ) ( * mresp ) return & resp , err } 
func newwatcherbatch ( wg * watchergroup , evs [ ] mvccpb . event ) watcherbatch { if len ( wg . watchers ) == 0 { return nil } wb : = make ( watcherbatch ) for , ev : = range evs { for w : = range wg . watchersetbykey ( string ( ev . kv . key ) ) { if ev . kv . modrevision >= w . minrev { wb . add ( w , ev ) } } } return wb } 
func ( wg * watchergroup ) add ( wa * watcher ) { wg . watchers . add ( wa ) if wa . end == nil { wg . keywatchers . add ( wa ) return } ivl : = adt . newstringaffineinterval ( string ( wa . key ) , string ( wa . end ) ) if iv : = wg . ranges . find ( ivl ) ; iv ! = nil { iv . val . ( watcherset ) . add ( wa ) return } ws : = make ( watcherset ) ws . add ( wa ) wg . ranges . insert ( ivl , ws ) } 
func ( wg * watchergroup ) contains ( key string ) bool { , ok : = wg . keywatchers [ key ] return ok | | wg . ranges . intersects ( adt . newstringaffinepoint ( key ) ) } 
func ( wg * watchergroup ) delete ( wa * watcher ) bool { if , ok : = wg . watchers [ wa ] ; ! ok { return false } wg . watchers . delete ( wa ) if wa . end == nil { wg . keywatchers . delete ( wa ) return true } ivl : = adt . newstringaffineinterval ( string ( wa . key ) , string ( wa . end ) ) iv : = wg . ranges . find ( ivl ) if iv == nil { return false } ws : = iv . val . ( watcherset ) delete ( ws , wa ) if len ( ws ) == 0 { if ok : = wg . ranges . delete ( ivl ) ; ! ok { panic ( " " ) } } return true } 
func ( wg * watchergroup ) choose ( maxwatchers int , currev , compactrev int64 ) ( * watchergroup , int64 ) { if len ( wg . watchers ) < maxwatchers { return wg , wg . chooseall ( currev , compactrev ) } ret : = newwatchergroup ( ) for w : = range wg . watchers { if maxwatchers <= 0 { break } maxwatchers -- ret . add ( w ) } return & ret , ret . chooseall ( currev , compactrev ) } 
func ( wg * watchergroup ) watchersetbykey ( key string ) watcherset { wkeys : = wg . keywatchers [ key ] wranges : = wg . ranges . stab ( adt . newstringaffinepoint ( key ) ) switch { case len ( wranges ) == 0 : return wkeys case len ( wranges ) == 0 && len ( wkeys ) == 0 : return nil case len ( wranges ) == 1 && len ( wkeys ) == 0 : return wranges [ 0 ] . val . ( watcherset ) } ret : = make ( watcherset ) ret . union ( wg . keywatchers [ key ] ) for , item : = range wranges { ret . union ( item . val . ( watcherset ) ) } return ret } 
func ( ivl * interval ) compare ( c comparable ) int { ivl2 : = c . ( * interval ) ivbcmpbegin : = ivl . begin . compare ( ivl2 . begin ) ivbcmpend : = ivl . begin . compare ( ivl2 . end ) ivecmpbegin : = ivl . end . compare ( ivl2 . begin ) if ivbcmpbegin < 0 && ivecmpbegin <= 0 { return - 1 } if ivbcmpend >= 0 { return 1 } return 0 } 
func ( x * intervalnode ) successor ( ) * intervalnode { if x . right ! = nil { return x . right . min ( ) } y : = x . parent for y ! = nil && x == y . right { x = y y = y . parent } return y } 
func ( x * intervalnode ) updatemax ( ) { for x ! = nil { oldmax : = x . max max : = x . iv . ivl . end if x . left ! = nil && x . left . max . compare ( max ) > 0 { max = x . left . max } if x . right ! = nil && x . right . max . compare ( max ) > 0 { max = x . right . max } if oldmax . compare ( max ) == 0 { break } x . max = max x = x . parent } } 
func ( x * intervalnode ) visit ( iv * interval , nv nodevisitor ) bool { if x == nil { return true } v : = iv . compare ( & x . iv . ivl ) switch { case v < 0 : if ! x . left . visit ( iv , nv ) { return false } case v > 0 : maxiv : = interval { x . iv . ivl . begin , x . max } if maxiv . compare ( iv ) == 0 { if ! x . left . visit ( iv , nv ) | | ! x . right . visit ( iv , nv ) { return false } } default : if ! x . left . visit ( iv , nv ) | | ! nv ( x ) | | ! x . right . visit ( iv , nv ) { return false } } return true } 
func ( ivt * intervaltree ) delete ( ivl interval ) bool { z : = ivt . find ( ivl ) if z == nil { return false } y : = z if z . left ! = nil && z . right ! = nil { y = z . successor ( ) } x : = y . left if x == nil { x = y . right } if x ! = nil { x . parent = y . parent } if y . parent == nil { ivt . root = x } else { if y == y . parent . left { y . parent . left = x } else { y . parent . right = x } y . parent . updatemax ( ) } if y ! = z { z . iv = y . iv z . updatemax ( ) } if y . color ( ) == black && x ! = nil { ivt . deletefixup ( x ) } ivt . count -- return true } 
func ( ivt * intervaltree ) insert ( ivl interval , val interface { } ) { var y * intervalnode z : = & intervalnode { iv : intervalvalue { ivl , val } , max : ivl . end , c : red } x : = ivt . root for x ! = nil { y = x if z . iv . ivl . begin . compare ( x . iv . ivl . begin ) < 0 { x = x . left } else { x = x . right } } z . parent = y if y == nil { ivt . root = z } else { if z . iv . ivl . begin . compare ( y . iv . ivl . begin ) < 0 { y . left = z } else { y . right = z } y . updatemax ( ) } z . c = red ivt . insertfixup ( z ) ivt . count ++ } 
func ( ivt * intervaltree ) rotateleft ( x * intervalnode ) { y : = x . right x . right = y . left if y . left ! = nil { y . left . parent = x } x . updatemax ( ) ivt . replaceparent ( x , y ) y . left = x y . updatemax ( ) } 
func ( ivt * intervaltree ) replaceparent ( x * intervalnode , y * intervalnode ) { y . parent = x . parent if x . parent == nil { ivt . root = y } else { if x == x . parent . left { x . parent . left = y } else { x . parent . right = y } x . parent . updatemax ( ) } x . parent = y } 
func ( ivt * intervaltree ) maxheight ( ) int { return int ( ( 2 * math . log2 ( float64 ( ivt . len ( ) + 1 ) ) ) + 0 . 5 ) } 
func ( ivt * intervaltree ) visit ( ivl interval , ivv intervalvisitor ) { ivt . root . visit ( & ivl , func ( n * intervalnode ) bool { return ivv ( & n . iv ) } ) } 
func ( ivt * intervaltree ) find ( ivl interval ) ( ret * intervalnode ) { f : = func ( n * intervalnode ) bool { if n . iv . ivl ! = ivl { return true } ret = n return false } ivt . root . visit ( & ivl , f ) return ret } 
func ( ivt * intervaltree ) find ( ivl interval ) ( ret * intervalvalue ) { n : = ivt . find ( ivl ) if n == nil { return nil } return & n . iv } 
func ( ivt * intervaltree ) intersects ( iv interval ) bool { x : = ivt . root for x ! = nil && iv . compare ( & x . iv . ivl ) ! = 0 { if x . left ! = nil && x . left . max . compare ( iv . begin ) > 0 { x = x . left } else { x = x . right } } return x ! = nil } 
func ( ivt * intervaltree ) contains ( ivl interval ) bool { var maxend , minbegin comparable iscontiguous : = true ivt . visit ( ivl , func ( n * intervalvalue ) bool { if minbegin == nil { minbegin = n . ivl . begin maxend = n . ivl . end return true } if maxend . compare ( n . ivl . begin ) < 0 { iscontiguous = false return false } if n . ivl . end . compare ( maxend ) > 0 { maxend = n . ivl . end } return true } ) return iscontiguous && minbegin ! = nil && maxend . compare ( ivl . end ) >= 0 && minbegin . compare ( ivl . begin ) <= 0 } 
func ( ivt * intervaltree ) stab ( iv interval ) ( ivs [ ] * intervalvalue ) { if ivt . count == 0 { return nil } f : = func ( n * intervalvalue ) bool { ivs = append ( ivs , n ) ; return true } ivt . visit ( iv , f ) return ivs } 
func ( ivt * intervaltree ) union ( inivt intervaltree , ivl interval ) { f : = func ( n * intervalvalue ) bool { ivt . insert ( n . ivl , n . val ) return true } inivt . visit ( ivl , f ) } 
func newexactreadcloser ( rc io . readcloser , totalbytes int64 ) io . readcloser { return & exactreadcloser { rc : rc , totalbytes : totalbytes } } 
func newelection ( s * session , pfx string ) * election { return & election { session : s , keyprefix : pfx + " " } } 
func resumeelection ( s * session , pfx string , leaderkey string , leaderrev int64 ) * election { return & election { keyprefix : pfx , session : s , leaderkey : leaderkey , leaderrev : leaderrev , leadersession : s , } } 
func ( e * election ) campaign ( ctx context . context , val string ) error { s : = e . session client : = e . session . client ( ) k : = fmt . sprintf ( " " , e . keyprefix , s . lease ( ) ) txn : = client . txn ( ctx ) . if ( v3 . compare ( v3 . createrevision ( k ) , " " , 0 ) ) txn = txn . then ( v3 . opput ( k , val , v3 . withlease ( s . lease ( ) ) ) ) txn = txn . else ( v3 . opget ( k ) ) resp , err : = txn . commit ( ) if err ! = nil { return err } e . leaderkey , e . leaderrev , e . leadersession = k , resp . header . revision , s if ! resp . succeeded { kv : = resp . responses [ 0 ] . getresponserange ( ) . kvs [ 0 ] e . leaderrev = kv . createrevision if string ( kv . value ) ! = val { if err = e . proclaim ( ctx , val ) ; err ! = nil { e . resign ( ctx ) return err } } } , err = waitdeletes ( ctx , client , e . keyprefix , e . leaderrev - 1 ) if err ! = nil { select { case < - ctx . done ( ) : e . resign ( client . ctx ( ) ) default : e . leadersession = nil } return err } e . hdr = resp . header return nil } 
func ( e * election ) proclaim ( ctx context . context , val string ) error { if e . leadersession == nil { return errelectionnotleader } client : = e . session . client ( ) cmp : = v3 . compare ( v3 . createrevision ( e . leaderkey ) , " " , e . leaderrev ) txn : = client . txn ( ctx ) . if ( cmp ) txn = txn . then ( v3 . opput ( e . leaderkey , val , v3 . withlease ( e . leadersession . lease ( ) ) ) ) tresp , terr : = txn . commit ( ) if terr ! = nil { return terr } if ! tresp . succeeded { e . leaderkey = " " return errelectionnotleader } e . hdr = tresp . header return nil } 
func ( e * election ) resign ( ctx context . context ) ( err error ) { if e . leadersession == nil { return nil } client : = e . session . client ( ) cmp : = v3 . compare ( v3 . createrevision ( e . leaderkey ) , " " , e . leaderrev ) resp , err : = client . txn ( ctx ) . if ( cmp ) . then ( v3 . opdelete ( e . leaderkey ) ) . commit ( ) if err == nil { e . hdr = resp . header } e . leaderkey = " " e . leadersession = nil return err } 
func ( e * election ) leader ( ctx context . context ) ( * v3 . getresponse , error ) { client : = e . session . client ( ) resp , err : = client . get ( ctx , e . keyprefix , v3 . withfirstcreate ( ) ... ) if err ! = nil { return nil , err } else if len ( resp . kvs ) == 0 { return nil , errelectionnoleader } return resp , nil } 
func ( e * election ) observe ( ctx context . context ) < - chan v3 . getresponse { retc : = make ( chan v3 . getresponse ) go e . observe ( ctx , retc ) return retc } 
func ( qa * quotaalarmer ) check ( ctx context . context , r interface { } ) error { if qa . q . available ( r ) { return nil } req : = & pb . alarmrequest { memberid : uint64 ( qa . id ) , action : pb . alarmrequest activate , alarm : pb . alarmtype nospace , } qa . a . alarm ( ctx , req ) return rpctypes . errgrpcnospace } 
func newexecwatchcommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , flags : [ ] cli . flag { cli . intflag { name : " " , value : 0 , usage : " " } , cli . boolflag { name : " " , usage : " " } , } , action : func ( c * cli . context ) error { execwatchcommandfunc ( c , mustnewkeyapi ( c ) ) return nil } , } } 
func newlistener ( u url . url , tlsinfo * transport . tlsinfo ) ( net . listener , error ) { return transport . newtimeoutlistener ( u . host , u . scheme , tlsinfo , connreadtimeout , connwritetimeout ) } 
func comparemajorminorversion ( a , b * semver . version ) int { na : = & semver . version { major : a . major , minor : a . minor } nb : = & semver . version { major : b . major , minor : b . minor } switch { case na . lessthan ( * nb ) : return - 1 case nb . lessthan ( * na ) : return 1 default : return 0 } } 
func serverversion ( h http . header ) * semver . version { verstr : = h . get ( " " ) if verstr == " " { verstr = " " } return semver . must ( semver . newversion ( verstr ) ) } 
func checkversioncompatibility ( name string , server , mincluster * semver . version ) ( localserver * semver . version , localmincluster * semver . version , err error ) { localserver = semver . must ( semver . newversion ( version . version ) ) localmincluster = semver . must ( semver . newversion ( version . minclusterversion ) ) if comparemajorminorversion ( server , localmincluster ) == - 1 { return localserver , localmincluster , fmt . errorf ( " " , name , server , localserver ) } if comparemajorminorversion ( mincluster , localserver ) == 1 { return localserver , localmincluster , fmt . errorf ( " " , name , server , localserver ) } return localserver , localmincluster , nil } 
func setpeerurlsheader ( req * http . request , urls types . urls ) { if urls == nil { return } peerurls : = make ( [ ] string , urls . len ( ) ) for i : = range urls { peerurls [ i ] = urls [ i ] . string ( ) } req . header . set ( " " , strings . join ( peerurls , " " ) ) } 
func newkeysapiwithprefix ( c client , p string ) keysapi { return & httpkeysapi { client : c , prefix : p , } } 
func ( n * node ) ttlduration ( ) time . duration { return time . duration ( n . ttl ) * time . second } 
func v2keysurl ( ep url . url , prefix , key string ) * url . url { if prefix ! = " " && prefix [ 0 ] ! = ' / ' { prefix = " " + prefix } if key ! = " " && key [ 0 ] ! = ' / ' { key = " " + key } ep . path = pathutil . canonicalurlpath ( ep . path + prefix + key ) return & ep } 
func setflagsfromenv ( prefix string , fs * flag . flagset ) error { var err error alreadyset : = make ( map [ string ] bool ) fs . visit ( func ( f * flag . flag ) { alreadyset [ flagtoenv ( prefix , f . name ) ] = true } ) usedenvkey : = make ( map [ string ] bool ) fs . visitall ( func ( f * flag . flag ) { if serr : = setflagfromenv ( fs , prefix , f . name , usedenvkey , alreadyset , true ) ; serr ! = nil { err = serr } } ) verifyenv ( prefix , usedenvkey , alreadyset ) return err } 
func setpflagsfromenv ( prefix string , fs * pflag . flagset ) error { var err error alreadyset : = make ( map [ string ] bool ) usedenvkey : = make ( map [ string ] bool ) fs . visitall ( func ( f * pflag . flag ) { if f . changed { alreadyset [ flagtoenv ( prefix , f . name ) ] = true } if serr : = setflagfromenv ( fs , prefix , f . name , usedenvkey , alreadyset , false ) ; serr ! = nil { err = serr } } ) verifyenv ( prefix , usedenvkey , alreadyset ) return err } 
func flagtoenv ( prefix , name string ) string { return prefix + " " + strings . toupper ( strings . replace ( name , " " , " " , - 1 ) ) } 
func excerpt ( str string , pre , suf int ) string { if pre + suf > len ( str ) { return fmt . sprintf ( " " , str ) } return fmt . sprintf ( " " , str [ : pre ] , str [ len ( str ) - suf : ] ) } 
func passconfchange ( entry raftpb . entry ) ( bool , string ) { return entry . type == raftpb . entryconfchange , " " } 
func printinternalraftrequest ( entry raftpb . entry ) { var rr etcdserverpb . internalraftrequest if err : = rr . unmarshal ( entry . data ) ; err == nil { fmt . printf ( " \ t \ t \ t " , entry . term , entry . index , rr . string ( ) ) } } 
func evaluateentrytypeflag ( entrytype string ) [ ] entryfilter { var entrytypelist [ ] string if entrytype ! = " " { entrytypelist = strings . split ( entrytype , " " ) } validrequest : = map [ string ] [ ] entryfilter { " " : { passconfchange } , " " : { passinternalraftrequest , passrequest , passunknownnormal } , " " : { passrequest } , " " : { passinternalraftrequest } , " " : { passirrrange } , " " : { passirrput } , " " : { passirrdeleterange } , " " : { passirrtxn } , " " : { passirrcompaction } , " " : { passirrleasegrant } , " " : { passirrleaserevoke } , " " : { passirrleasecheckpoint } , } filters : = make ( [ ] entryfilter , 0 ) if len ( entrytypelist ) == 0 { filters = append ( filters , passinternalraftrequest ) filters = append ( filters , passrequest ) filters = append ( filters , passunknownnormal ) filters = append ( filters , passconfchange ) } for , et : = range entrytypelist { if f , ok : = validrequest [ et ] ; ok { filters = append ( filters , f ... ) } else { log . printf ( , et ) } } return filters } 
func newlog ( storage storage , logger logger ) * raftlog { return newlogwithsize ( storage , logger , nolimit ) } 
func newlogwithsize ( storage storage , logger logger , maxnextentssize uint64 ) * raftlog { if storage == nil { log . panic ( " " ) } log : = & raftlog { storage : storage , logger : logger , maxnextentssize : maxnextentssize , } firstindex , err : = storage . firstindex ( ) if err ! = nil { panic ( err ) } lastindex , err : = storage . lastindex ( ) if err ! = nil { panic ( err ) } log . unstable . offset = lastindex + 1 log . unstable . logger = logger log . committed = firstindex - 1 log . applied = firstindex - 1 return log } 
func ( l * raftlog ) maybeappend ( index , logterm , committed uint64 , ents ... pb . entry ) ( lastnewi uint64 , ok bool ) { if l . matchterm ( index , logterm ) { lastnewi = index + uint64 ( len ( ents ) ) ci : = l . findconflict ( ents ) switch { case ci == 0 : case ci <= l . committed : l . logger . panicf ( " " , ci , l . committed ) default : offset : = index + 1 l . append ( ents [ ci - offset : ] ... ) } l . committo ( min ( committed , lastnewi ) ) return lastnewi , true } return 0 , false } 
func ( l * raftlog ) findconflict ( ents [ ] pb . entry ) uint64 { for , ne : = range ents { if ! l . matchterm ( ne . index , ne . term ) { if ne . index <= l . lastindex ( ) { l . logger . infof ( " " , ne . index , l . zerotermonerrcompacted ( l . term ( ne . index ) ) , ne . term ) } return ne . index } } return 0 } 
func ( l * raftlog ) nextents ( ) ( ents [ ] pb . entry ) { off : = max ( l . applied + 1 , l . firstindex ( ) ) if l . committed + 1 > off { ents , err : = l . slice ( off , l . committed + 1 , l . maxnextentssize ) if err ! = nil { l . logger . panicf ( " " , err ) } return ents } return nil } 
func ( l * raftlog ) hasnextents ( ) bool { off : = max ( l . applied + 1 , l . firstindex ( ) ) return l . committed + 1 > off } 
func ( l * raftlog ) allentries ( ) [ ] pb . entry { ents , err : = l . entries ( l . firstindex ( ) , nolimit ) if err == nil { return ents } if err == errcompacted { return l . allentries ( ) } panic ( err ) } 
func ( l * raftlog ) isuptodate ( lasti , term uint64 ) bool { return term > l . lastterm ( ) | | ( term == l . lastterm ( ) && lasti >= l . lastindex ( ) ) } 
func ( l * raftlog ) slice ( lo , hi , maxsize uint64 ) ( [ ] pb . entry , error ) { err : = l . mustcheckoutofbounds ( lo , hi ) if err ! = nil { return nil , err } if lo == hi { return nil , nil } var ents [ ] pb . entry if lo < l . unstable . offset { storedents , err : = l . storage . entries ( lo , min ( hi , l . unstable . offset ) , maxsize ) if err == errcompacted { return nil , err } else if err == errunavailable { l . logger . panicf ( " " , lo , min ( hi , l . unstable . offset ) ) } else if err ! = nil { panic ( err ) } if uint64 ( len ( storedents ) ) < min ( hi , l . unstable . offset ) - lo { return storedents , nil } ents = storedents } if hi > l . unstable . offset { unstable : = l . unstable . slice ( max ( lo , l . unstable . offset ) , hi ) if len ( ents ) > 0 { combined : = make ( [ ] pb . entry , len ( ents ) + len ( unstable ) ) n : = copy ( combined , ents ) copy ( combined [ n : ] , unstable ) ents = combined } else { ents = unstable } } return limitsize ( ents , maxsize ) , nil } 
func newsession ( client * v3 . client , opts ... sessionoption ) ( * session , error ) { ops : = & sessionoptions { ttl : defaultsessionttl , ctx : client . ctx ( ) } for , opt : = range opts { opt ( ops ) } id : = ops . leaseid if id == v3 . nolease { resp , err : = client . grant ( ops . ctx , int64 ( ops . ttl ) ) if err ! = nil { return nil , err } id = v3 . leaseid ( resp . id ) } ctx , cancel : = context . withcancel ( ops . ctx ) keepalive , err : = client . keepalive ( ctx , id ) if err ! = nil | | keepalive == nil { cancel ( ) return nil , err } donec : = make ( chan struct { } ) s : = & session { client : client , opts : ops , id : id , cancel : cancel , donec : donec } go func ( ) { defer close ( donec ) for range keepalive { } } ( ) return s , nil } 
func ( s * session ) close ( ) error { s . orphan ( ) ctx , cancel : = context . withtimeout ( s . opts . ctx , time . duration ( s . opts . ttl ) * time . second ) , err : = s . client . revoke ( ctx , s . id ) cancel ( ) return err } 
func withttl ( ttl int ) sessionoption { return func ( so * sessionoptions ) { if ttl > 0 { so . ttl = ttl } } } 
func withlease ( leaseid v3 . leaseid ) sessionoption { return func ( so * sessionoptions ) { so . leaseid = leaseid } } 
func withcontext ( ctx context . context ) sessionoption { return func ( so * sessionoptions ) { so . ctx = ctx } } 
func ( ro * readonly ) addrequest ( index uint64 , m pb . message ) { ctx : = string ( m . entries [ 0 ] . data ) if , ok : = ro . pendingreadindex [ ctx ] ; ok { return } ro . pendingreadindex [ ctx ] = & readindexstatus { index : index , req : m , acks : make ( map [ uint64 ] struct { } ) } ro . readindexqueue = append ( ro . readindexqueue , ctx ) } 
func ( ro * readonly ) recvack ( m pb . message ) int { rs , ok : = ro . pendingreadindex [ string ( m . context ) ] if ! ok { return 0 } rs . acks [ m . from ] = struct { } { } return len ( rs . acks ) + 1 } 
func ( ro * readonly ) advance ( m pb . message ) [ ] * readindexstatus { var ( i int found bool ) ctx : = string ( m . context ) rss : = [ ] * readindexstatus { } for , okctx : = range ro . readindexqueue { i ++ rs , ok : = ro . pendingreadindex [ okctx ] if ! ok { panic ( " " ) } rss = append ( rss , rs ) if okctx == ctx { found = true break } } if found { ro . readindexqueue = ro . readindexqueue [ i : ] for , rs : = range rss { delete ( ro . pendingreadindex , string ( rs . req . entries [ 0 ] . data ) ) } return rss } return nil } 
func ( ro * readonly ) lastpendingrequestctx ( ) string { if len ( ro . readindexqueue ) == 0 { return " " } return ro . readindexqueue [ len ( ro . readindexqueue ) - 1 ] } 
func ( s * etcdserver ) start ( ) { s . start ( ) s . goattach ( func ( ) { s . adjustticks ( ) } ) s . goattach ( func ( ) { s . publish ( s . cfg . reqtimeout ( ) ) } ) s . goattach ( s . purgefile ) s . goattach ( func ( ) { monitorfiledescriptor ( s . getlogger ( ) , s . stopping ) } ) s . goattach ( s . monitorversions ) s . goattach ( s . linearizablereadloop ) s . goattach ( s . monitorkvhash ) } 
func ( s * etcdserver ) process ( ctx context . context , m raftpb . message ) error { if s . cluster . isidremoved ( types . id ( m . from ) ) { if lg : = s . getlogger ( ) ; lg ! = nil { lg . warn ( " " , zap . string ( " " , s . id ( ) . string ( ) ) , zap . string ( " " , types . id ( m . from ) . string ( ) ) , ) } else { plog . warningf ( " " , types . id ( m . from ) . string ( ) ) } return httptypes . newhttperror ( http . statusforbidden , " " ) } if m . type == raftpb . msgapp { s . stats . recvappendreq ( types . id ( m . from ) . string ( ) , m . size ( ) ) } return s . r . step ( ctx , m ) } 
func ( s * etcdserver ) reportsnapshot ( id uint64 , status raft . snapshotstatus ) { s . r . reportsnapshot ( id , status ) } 
func ( s * etcdserver ) transferleadership ( ) error { if ! s . isleader ( ) { if lg : = s . getlogger ( ) ; lg ! = nil { lg . info ( " " , zap . string ( " " , s . id ( ) . string ( ) ) , zap . string ( " " , types . id ( s . lead ( ) ) . string ( ) ) , ) } else { plog . printf ( " " ) } return nil } if ! s . ismultinode ( ) { if lg : = s . getlogger ( ) ; lg ! = nil { lg . info ( " " , zap . string ( " " , s . id ( ) . string ( ) ) , zap . string ( " " , types . id ( s . lead ( ) ) . string ( ) ) , ) } else { plog . printf ( " " ) } return nil } transferee , ok : = longestconnected ( s . r . transport , s . cluster . memberids ( ) ) if ! ok { return errunhealthy } tm : = s . cfg . reqtimeout ( ) ctx , cancel : = context . withtimeout ( s . ctx , tm ) err : = s . moveleader ( ctx , s . lead ( ) , uint64 ( transferee ) ) cancel ( ) return err } 
func ( s * etcdserver ) stop ( ) { if err : = s . transferleadership ( ) ; err ! = nil { if lg : = s . getlogger ( ) ; lg ! = nil { lg . warn ( " " , zap . string ( " " , s . id ( ) . string ( ) ) , zap . error ( err ) ) } else { plog . warningf ( " " , s . id ( ) , err ) } } s . hardstop ( ) } 
func ( s * etcdserver ) configure ( ctx context . context , cc raftpb . confchange ) ( [ ] * membership . member , error ) { cc . id = s . reqidgen . next ( ) ch : = s . w . register ( cc . id ) start : = time . now ( ) if err : = s . r . proposeconfchange ( ctx , cc ) ; err ! = nil { s . w . trigger ( cc . id , nil ) return nil , err } select { case x : = < - ch : if x == nil { if lg : = s . getlogger ( ) ; lg ! = nil { lg . panic ( " " ) } else { plog . panicf ( " " ) } } resp : = x . ( * confchangeresponse ) if lg : = s . getlogger ( ) ; lg ! = nil { lg . info ( " " , zap . string ( " " , s . id ( ) . string ( ) ) , zap . string ( " " , cc . type . string ( ) ) , zap . string ( " " , types . id ( cc . nodeid ) . string ( ) ) , ) } return resp . membs , resp . err case < - ctx . done ( ) : s . w . trigger ( cc . id , nil ) return nil , s . parseproposectxerr ( ctx . err ( ) , start ) case < - s . stopping : return nil , errstopped } } 
func ( s * etcdserver ) sync ( timeout time . duration ) { req : = pb . request { method : " " , id : s . reqidgen . next ( ) , time : time . now ( ) . unixnano ( ) , } data : = pbutil . mustmarshal ( & req ) ctx , cancel : = context . withtimeout ( s . ctx , timeout ) s . goattach ( func ( ) { s . r . propose ( ctx , data ) cancel ( ) } ) } 
func ( s * etcdserver ) apply ( es [ ] raftpb . entry , confstate * raftpb . confstate , ) ( appliedt uint64 , appliedi uint64 , shouldstop bool ) { for i : = range es { e : = es [ i ] switch e . type { case raftpb . entrynormal : s . applyentrynormal ( & e ) s . setappliedindex ( e . index ) s . setterm ( e . term ) case raftpb . entryconfchange : if e . index > s . consistindex . consistentindex ( ) { s . consistindex . setconsistentindex ( e . index ) } var cc raftpb . confchange pbutil . mustunmarshal ( & cc , e . data ) removedself , err : = s . applyconfchange ( cc , confstate ) s . setappliedindex ( e . index ) s . setterm ( e . term ) shouldstop = shouldstop | | removedself s . w . trigger ( cc . id , & confchangeresponse { s . cluster . members ( ) , err } ) default : if lg : = s . getlogger ( ) ; lg ! = nil { lg . panic ( " " , zap . string ( " " , e . type . string ( ) ) , ) } else { plog . panicf ( " " ) } } appliedi , appliedt = e . index , e . term } return appliedt , appliedi , shouldstop } 
func ( s * etcdserver ) cutpeer ( id types . id ) { tr , ok : = s . r . transport . ( * rafthttp . transport ) if ok { tr . cutpeer ( id ) } } 
func ( s * etcdserver ) monitorversions ( ) { for { select { case < - s . forceversionc : case < - time . after ( monitorversioninterval ) : case < - s . stopping : return } if s . leader ( ) ! = s . id ( ) { continue } v : = decideclusterversion ( s . getlogger ( ) , getversions ( s . getlogger ( ) , s . cluster , s . id , s . peerrt ) ) if v ! = nil { v = & semver . version { major : v . major , minor : v . minor , } } if s . cluster . version ( ) == nil { verstr : = version . minclusterversion if v ! = nil { verstr = v . string ( ) } s . goattach ( func ( ) { s . updateclusterversion ( verstr ) } ) continue } if v ! = nil && s . cluster . version ( ) . lessthan ( * v ) { s . goattach ( func ( ) { s . updateclusterversion ( v . string ( ) ) } ) } } } 
func ( s * etcdserver ) goattach ( f func ( ) ) { s . wgmu . rlock ( ) defer s . wgmu . runlock ( ) select { case < - s . stopping : if lg : = s . getlogger ( ) ; lg ! = nil { lg . warn ( " " ) } else { plog . warning ( " " ) } return default : } s . wg . add ( 1 ) go func ( ) { defer s . wg . done ( ) f ( ) } ( ) } 
func newroundrobinbalanced ( lg * zap . logger , scs [ ] balancer . subconn , addrtosc map [ resolver . address ] balancer . subconn , sctoaddr map [ balancer . subconn ] resolver . address , ) picker { return & rrbalanced { lg : lg , scs : scs , addrtosc : addrtosc , sctoaddr : sctoaddr , } } 
func ( rb * rrbalanced ) pick ( ctx context . context , opts balancer . pickoptions ) ( balancer . subconn , func ( balancer . doneinfo ) , error ) { rb . mu . rlock ( ) n : = len ( rb . scs ) rb . mu . runlock ( ) if n == 0 { return nil , nil , balancer . errnosubconnavailable } rb . mu . lock ( ) cur : = rb . next sc : = rb . scs [ cur ] picked : = rb . sctoaddr [ sc ] . addr rb . next = ( rb . next + 1 ) % len ( rb . scs ) rb . mu . unlock ( ) rb . lg . debug ( " " , zap . string ( " " , picked ) , zap . int ( " " , cur ) , zap . int ( " " , n ) , ) donefunc : = func ( info balancer . doneinfo ) { fss : = [ ] zapcore . field { zap . error ( info . err ) , zap . string ( " " , picked ) , zap . bool ( " " , info . err == nil ) , zap . bool ( " " , info . bytessent ) , zap . bool ( " " , info . bytesreceived ) , } if info . err == nil { rb . lg . debug ( " " , fss ... ) } else { rb . lg . warn ( " " , fss ... ) } } return sc , donefunc , nil } 
func newtlslistener ( l net . listener , tlsinfo * tlsinfo ) ( net . listener , error ) { check : = func ( context . context , * tls . conn ) error { return nil } return newtlslistener ( l , tlsinfo , check ) } 
func ( l * tlslistener ) acceptloop ( ) { var wg sync . waitgroup var pendingmu sync . mutex pending : = make ( map [ net . conn ] struct { } ) ctx , cancel : = context . withcancel ( context . background ( ) ) defer func ( ) { cancel ( ) pendingmu . lock ( ) for c : = range pending { c . close ( ) } pendingmu . unlock ( ) wg . wait ( ) close ( l . donec ) } ( ) for { conn , err : = l . listener . accept ( ) if err ! = nil { l . err = err return } pendingmu . lock ( ) pending [ conn ] = struct { } { } pendingmu . unlock ( ) wg . add ( 1 ) go func ( ) { defer func ( ) { if conn ! = nil { conn . close ( ) } wg . done ( ) } ( ) tlsconn : = conn . ( * tls . conn ) herr : = tlsconn . handshake ( ) pendingmu . lock ( ) delete ( pending , conn ) pendingmu . unlock ( ) if herr ! = nil { l . handshakefailure ( tlsconn , herr ) return } if err : = l . check ( ctx , tlsconn ) ; err ! = nil { l . handshakefailure ( tlsconn , err ) return } select { case l . connc < - tlsconn : conn = nil case < - ctx . done ( ) : } } ( ) } } 
func ( e * resolvergroup ) setendpoints ( endpoints [ ] string ) { addrs : = epstoaddrs ( endpoints ... ) e . mu . lock ( ) e . endpoints = endpoints for , r : = range e . resolvers { r . cc . newaddress ( addrs ) } e . mu . unlock ( ) } 
func ( e * resolvergroup ) target ( endpoint string ) string { return target ( e . id , endpoint ) } 
func target ( id , endpoint string ) string { return fmt . sprintf ( " " , scheme , id , endpoint ) } 
func ( b * builder ) build ( target resolver . target , cc resolver . clientconn , opts resolver . buildoption ) ( resolver . resolver , error ) { if len ( target . authority ) < 1 { return nil , fmt . errorf ( " " ) } id : = target . authority es , err : = b . getresolvergroup ( id ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } r : = & resolver { endpointid : id , cc : cc , } es . addresolver ( r ) return r , nil } 
func epstoaddrs ( eps ... string ) ( addrs [ ] resolver . address ) { addrs = make ( [ ] resolver . address , 0 , len ( eps ) ) for , ep : = range eps { addrs = append ( addrs , resolver . address { addr : ep } ) } return addrs } 
func parsetarget ( target string ) ( string , string , error ) { noprefix : = strings . trimprefix ( target , targetprefix ) if noprefix == target { return " " , " " , fmt . errorf ( " " , targetprefix , target ) } parts : = strings . splitn ( noprefix , " " , 2 ) if len ( parts ) ! = 2 { return " " , " " , fmt . errorf ( " " , scheme , target ) } return parts [ 0 ] , parts [ 1 ] , nil } 
func parsehostport ( hostport string ) ( host string , port string ) { parts : = strings . splitn ( hostport , " " , 2 ) host = parts [ 0 ] if len ( parts ) > 1 { port = parts [ 1 ] } return host , port } 
func ( r * requestv2 ) handle ( ctx context . context , v2api requestv2handler ) ( response , error ) { if r . method == " " && r . quorum { r . method = " " } switch r . method { case " " : return v2api . post ( ctx , r ) case " " : return v2api . put ( ctx , r ) case " " : return v2api . delete ( ctx , r ) case " " : return v2api . qget ( ctx , r ) case " " : return v2api . get ( ctx , r ) case " " : return v2api . head ( ctx , r ) } return response { } , errunknownmethod } 
func newelectioncommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : runelectionfunc , } cmd . flags ( ) . intvar ( & totalclientconnections , " " , 10 , " " ) return cmd } 
func nodetomember ( n * v2store . nodeextern ) ( * member , error ) { m : = & member { id : mustparsememberidfromkey ( n . key ) } attrs : = make ( map [ string ] [ ] byte ) raftattrkey : = path . join ( n . key , raftattributessuffix ) attrkey : = path . join ( n . key , attributessuffix ) for , nn : = range n . nodes { if nn . key ! = raftattrkey && nn . key ! = attrkey { return nil , fmt . errorf ( " " , nn . key ) } attrs [ nn . key ] = [ ] byte ( * nn . value ) } if data : = attrs [ raftattrkey ] ; data ! = nil { if err : = json . unmarshal ( data , & m . raftattributes ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } } else { return nil , fmt . errorf ( " " ) } if data : = attrs [ attrkey ] ; data ! = nil { if err : = json . unmarshal ( data , & m . attributes ) ; err ! = nil { return m , fmt . errorf ( " " , err ) } } return m , nil } 
func newtmpbackend ( batchinterval time . duration , batchlimit int ) ( * backend , string ) { dir , err : = ioutil . tempdir ( os . tempdir ( ) , " " ) if err ! = nil { panic ( err ) } tmppath : = filepath . join ( dir , " " ) bcfg : = defaultbackendconfig ( ) bcfg . path , bcfg . batchinterval , bcfg . batchlimit = tmppath , batchinterval , batchlimit return newbackend ( bcfg ) , tmppath } 
func newrevision ( lg * zap . logger , clock clockwork . clock , retention int64 , rg revgetter , c compactable ) * revision { rc : = & revision { lg : lg , clock : clock , retention : retention , rg : rg , c : c , } rc . ctx , rc . cancel = context . withcancel ( context . background ( ) ) return rc } 
func ( rc * revision ) pause ( ) { rc . mu . lock ( ) rc . paused = true rc . mu . unlock ( ) } 
func ( rc * revision ) resume ( ) { rc . mu . lock ( ) rc . paused = false rc . mu . unlock ( ) } 
func voterespmsgtype ( msgt pb . messagetype ) pb . messagetype { switch msgt { case pb . msgvote : return pb . msgvoteresp case pb . msgprevote : return pb . msgprevoteresp default : panic ( fmt . sprintf ( " " , msgt ) ) } } 
func describemessage ( m pb . message , f entryformatter ) string { var buf bytes . buffer fmt . fprintf ( & buf , " " , m . from , m . to , m . type , m . term , m . logterm , m . index ) if m . reject { fmt . fprintf ( & buf , " " , m . rejecthint ) } if m . commit ! = 0 { fmt . fprintf ( & buf , " " , m . commit ) } if len ( m . entries ) > 0 { fmt . fprintf ( & buf , " " ) for i , e : = range m . entries { if i ! = 0 { buf . writestring ( " " ) } buf . writestring ( describeentry ( e , f ) ) } fmt . fprintf ( & buf , " " ) } if ! isemptysnap ( m . snapshot ) { fmt . fprintf ( & buf , " " , m . snapshot ) } return buf . string ( ) } 
func describeentry ( e pb . entry , f entryformatter ) string { var formatted string if e . type == pb . entrynormal && f ! = nil { formatted = f ( e . data ) } else { formatted = fmt . sprintf ( " " , e . data ) } return fmt . sprintf ( " " , e . term , e . index , e . type , formatted ) } 
func describeentries ( ents [ ] pb . entry , f entryformatter ) string { var buf bytes . buffer for , e : = range ents { , = buf . writestring ( describeentry ( e , f ) + " \n " ) } return buf . string ( ) } 
func watchcommandfunc ( c * cli . context , ki client . keysapi ) { if len ( c . args ( ) ) == 0 { handleerror ( c , exitbadargs , errors . new ( " " ) ) } key : = c . args ( ) [ 0 ] recursive : = c . bool ( " " ) forever : = c . bool ( " " ) index : = c . int ( " " ) stop : = false w : = ki . watcher ( key , & client . watcheroptions { afterindex : uint64 ( index ) , recursive : recursive } ) sigch : = make ( chan os . signal , 1 ) signal . notify ( sigch , os . interrupt ) go func ( ) { < - sigch os . exit ( 0 ) } ( ) for ! stop { resp , err : = w . next ( context . todo ( ) ) if err ! = nil { handleerror ( c , exitservererror , err ) } if resp . node . dir { continue } if recursive { fmt . printf ( " \n " , resp . action , resp . node . key ) } printresponsekey ( resp , c . globalstring ( " " ) ) if ! forever { stop = true } } } 
func setlogger ( l grpclog . loggerv2 ) { lgmu . lock ( ) lg = logutil . newlogger ( l ) grpclog . setloggerv2 ( lg ) lgmu . unlock ( ) } 
func getlogger ( ) logutil . logger { lgmu . rlock ( ) l : = lg lgmu . runlock ( ) return l } 
func new ( s * etcdserver . etcdserver ) * clientv3 . client { c : = clientv3 . newctxclient ( context . background ( ) ) kvc : = adapter . kvservertokvclient ( v3rpc . newquotakvserver ( s ) ) c . kv = clientv3 . newkvfromkvclient ( kvc , c ) lc : = adapter . leaseservertoleaseclient ( v3rpc . newquotaleaseserver ( s ) ) c . lease = clientv3 . newleasefromleaseclient ( lc , c , time . second ) wc : = adapter . watchservertowatchclient ( v3rpc . newwatchserver ( s ) ) c . watcher = & watchwrapper { clientv3 . newwatchfromwatchclient ( wc , c ) } mc : = adapter . maintenanceservertomaintenanceclient ( v3rpc . newmaintenanceserver ( s ) ) c . maintenance = clientv3 . newmaintenancefrommaintenanceclient ( mc , c ) clc : = adapter . clusterservertoclusterclient ( v3rpc . newclusterserver ( s ) ) c . cluster = clientv3 . newclusterfromclusterclient ( clc , c ) return c } 
func ( u * unstable ) maybefirstindex ( ) ( uint64 , bool ) { if u . snapshot ! = nil { return u . snapshot . metadata . index + 1 , true } return 0 , false } 
func ( u * unstable ) maybelastindex ( ) ( uint64 , bool ) { if l : = len ( u . entries ) ; l ! = 0 { return u . offset + uint64 ( l ) - 1 , true } if u . snapshot ! = nil { return u . snapshot . metadata . index , true } return 0 , false } 
func ( u * unstable ) maybeterm ( i uint64 ) ( uint64 , bool ) { if i < u . offset { if u . snapshot == nil { return 0 , false } if u . snapshot . metadata . index == i { return u . snapshot . metadata . term , true } return 0 , false } last , ok : = u . maybelastindex ( ) if ! ok { return 0 , false } if i > last { return 0 , false } return u . entries [ i - u . offset ] . term , true } 
func ( u * unstable ) shrinkentriesarray ( ) { const lenmultiple = 2 if len ( u . entries ) == 0 { u . entries = nil } else if len ( u . entries ) * lenmultiple < cap ( u . entries ) { newentries : = make ( [ ] pb . entry , len ( u . entries ) ) copy ( newentries , u . entries ) u . entries = newentries } } 
func handlemetrics ( mux * http . servemux , c * http . client , eps [ ] string ) { r : = rand . new ( rand . newsource ( int64 ( time . now ( ) . nanosecond ( ) ) ) ) if len ( eps ) > 1 { eps = shuffleendpoints ( r , eps ) } pathmetrics : = etcdhttp . pathmetrics mux . handlefunc ( pathmetrics , func ( w http . responsewriter , r * http . request ) { target : = fmt . sprintf ( " " , eps [ 0 ] , pathmetrics ) if ! strings . hasprefix ( target , " " ) { scheme : = " " if r . tls ! = nil { scheme = " " } target = fmt . sprintf ( " " , scheme , target ) } resp , err : = c . get ( target ) if err ! = nil { http . error ( w , " " , http . statusinternalservererror ) } defer resp . body . close ( ) w . header ( ) . set ( " " , " " ) body , : = ioutil . readall ( resp . body ) fmt . fprintf ( w , " " , body ) } ) } 
func ( st * storage ) savesnap ( snap raftpb . snapshot ) error { walsnap : = walpb . snapshot { index : snap . metadata . index , term : snap . metadata . term , } err : = st . wal . savesnapshot ( walsnap ) if err ! = nil { return err } err = st . snapshotter . savesnap ( snap ) if err ! = nil { return err } return st . wal . releaselockto ( snap . metadata . index ) } 
func new ( cfg config ) ( * client , error ) { if len ( cfg . endpoints ) == 0 { return nil , errnoavailableendpoints } return newclient ( & cfg ) } 
func newctxclient ( ctx context . context ) * client { cctx , cancel : = context . withcancel ( ctx ) return & client { ctx : cctx , cancel : cancel } } 
func newfromurl ( url string ) ( * client , error ) { return new ( config { endpoints : [ ] string { url } } ) } 
func ( c * client ) close ( ) error { c . cancel ( ) c . watcher . close ( ) c . lease . close ( ) if c . resolvergroup ! = nil { c . resolvergroup . close ( ) } if c . conn ! = nil { return toerr ( c . ctx , c . conn . close ( ) ) } return c . ctx . err ( ) } 
func ( c * client ) endpoints ( ) [ ] string { c . mu . rlock ( ) defer c . mu . runlock ( ) eps : = make ( [ ] string , len ( c . cfg . endpoints ) ) copy ( eps , c . cfg . endpoints ) return eps } 
func ( c * client ) setendpoints ( eps ... string ) { c . mu . lock ( ) defer c . mu . unlock ( ) c . cfg . endpoints = eps c . resolvergroup . setendpoints ( eps ) } 
func ( c * client ) sync ( ctx context . context ) error { mresp , err : = c . memberlist ( ctx ) if err ! = nil { return err } var eps [ ] string for , m : = range mresp . members { eps = append ( eps , m . clienturls ... ) } c . setendpoints ( eps ... ) return nil } 
func ( c * client ) dialsetupopts ( creds * credentials . transportcredentials , dopts ... grpc . dialoption ) ( opts [ ] grpc . dialoption , err error ) { if c . cfg . dialkeepalivetime > 0 { params : = keepalive . clientparameters { time : c . cfg . dialkeepalivetime , timeout : c . cfg . dialkeepalivetimeout , permitwithoutstream : c . cfg . permitwithoutstream , } opts = append ( opts , grpc . withkeepaliveparams ( params ) ) } opts = append ( opts , dopts ... ) f : = func ( dialep string , t time . duration ) ( net . conn , error ) { proto , host , : = endpoint . parseendpoint ( dialep ) select { case < - c . ctx . done ( ) : return nil , c . ctx . err ( ) default : } dialer : = & net . dialer { timeout : t } return dialer . dialcontext ( c . ctx , proto , host ) } opts = append ( opts , grpc . withdialer ( f ) ) if creds ! = nil { opts = append ( opts , grpc . withtransportcredentials ( * creds ) ) } else { opts = append ( opts , grpc . withinsecure ( ) ) } rrbackoff : = withbackoff ( c . roundrobinquorumbackoff ( defaultbackoffwaitbetween , defaultbackoffjitterfraction ) ) opts = append ( opts , grpc . withstreaminterceptor ( c . streamclientinterceptor ( c . lg , withmax ( 0 ) , rrbackoff ) ) , grpc . withunaryinterceptor ( c . unaryclientinterceptor ( c . lg , withmax ( defaultunarymaxretries ) , rrbackoff ) ) , ) return opts , nil } 
func ( c * client ) dial ( ep string ) ( * grpc . clientconn , error ) { creds : = c . directdialcreds ( ep ) return c . dial ( fmt . sprintf ( " " , ep ) , creds ) } 
func ( c * client ) dialwithbalancer ( ep string , dopts ... grpc . dialoption ) ( * grpc . clientconn , error ) { , host , : = endpoint . parseendpoint ( ep ) target : = c . resolvergroup . target ( host ) creds : = c . dialwithbalancercreds ( ep ) return c . dial ( target , creds , dopts ... ) } 
func withrequireleader ( ctx context . context ) context . context { md : = metadata . pairs ( rpctypes . metadatarequireleaderkey , rpctypes . metadatahasleader ) return metadata . newoutgoingcontext ( ctx , md ) } 
func ( c * client ) roundrobinquorumbackoff ( waitbetween time . duration , jitterfraction float64 ) backofffunc { return func ( attempt uint ) time . duration { n : = uint ( len ( c . endpoints ( ) ) ) quorum : = ( n / 2 + 1 ) if attempt % quorum == 0 { c . lg . debug ( " " , zap . uint ( " " , attempt ) , zap . uint ( " " , quorum ) , zap . duration ( " " , waitbetween ) , zap . float64 ( " " , jitterfraction ) ) return jitterup ( waitbetween , jitterfraction ) } c . lg . debug ( " " , zap . uint ( " " , attempt ) , zap . uint ( " " , quorum ) ) return 0 } } 
func ishalterr ( ctx context . context , err error ) bool { if ctx ! = nil && ctx . err ( ) ! = nil { return true } if err == nil { return false } ev , : = status . fromerror ( err ) return ev . code ( ) ! = codes . unavailable && ev . code ( ) ! = codes . internal } 
func newlease ( l clientv3 . lease , prefix string ) clientv3 . lease { return & leaseprefix { l , [ ] byte ( prefix ) } } 
func ( e * event ) iscreate ( ) bool { return e . type == eventtypeput && e . kv . createrevision == e . kv . modrevision } 
func ( wr * watchresponse ) err ( ) error { switch { case wr . closeerr ! = nil : return v3rpc . error ( wr . closeerr ) case wr . compactrevision ! = 0 : return v3rpc . errcompacted case wr . canceled : if len ( wr . cancelreason ) ! = 0 { return v3rpc . error ( status . error ( codes . failedprecondition , wr . cancelreason ) ) } return v3rpc . errfuturerev } return nil } 
func ( wr * watchresponse ) isprogressnotify ( ) bool { return len ( wr . events ) == 0 && ! wr . canceled && ! wr . created && wr . compactrevision == 0 && wr . header . revision ! = 0 } 
func ( w * watcher ) requestprogress ( ctx context . context ) ( err error ) { ctxkey : = streamkeyfromctx ( ctx ) w . mu . lock ( ) if w . streams == nil { return fmt . errorf ( " " ) } wgs : = w . streams [ ctxkey ] if wgs == nil { wgs = w . newwatchergrpcstream ( ctx ) w . streams [ ctxkey ] = wgs } donec : = wgs . donec reqc : = wgs . reqc w . mu . unlock ( ) pr : = & progressrequest { } select { case reqc < - pr : return nil case < - ctx . done ( ) : if err == nil { return ctx . err ( ) } return err case < - donec : if wgs . closeerr ! = nil { return wgs . closeerr } return w . requestprogress ( ctx ) } } 
func ( w * watchgrpcstream ) nextresume ( ) * watcherstream { for len ( w . resuming ) ! = 0 { if w . resuming [ 0 ] ! = nil { return w . resuming [ 0 ] } w . resuming = w . resuming [ 1 : len ( w . resuming ) ] } return nil } 
func ( w * watchgrpcstream ) dispatchevent ( pbresp * pb . watchresponse ) bool { events : = make ( [ ] * event , len ( pbresp . events ) ) for i , ev : = range pbresp . events { events [ i ] = ( * event ) ( ev ) } wr : = & watchresponse { header : * pbresp . header , events : events , compactrevision : pbresp . compactrevision , created : pbresp . created , canceled : pbresp . canceled , cancelreason : pbresp . cancelreason , } if wr . isprogressnotify ( ) && pbresp . watchid == - 1 { return w . broadcastresponse ( wr ) } return w . unicastresponse ( wr , pbresp . watchid ) } 
func ( w * watchgrpcstream ) broadcastresponse ( wr * watchresponse ) bool { for , ws : = range w . substreams { select { case ws . recvc < - wr : case < - ws . donec : } } return true } 
func ( w * watchgrpcstream ) unicastresponse ( wr * watchresponse , watchid int64 ) bool { ws , ok : = w . substreams [ watchid ] if ! ok { return false } select { case ws . recvc < - wr : case < - ws . donec : return false } return true } 
func ( w * watchgrpcstream ) servewatchclient ( wc pb . watch watchclient ) { for { resp , err : = wc . recv ( ) if err ! = nil { select { case w . errc < - err : case < - w . donec : } return } select { case w . respc < - resp : case < - w . donec : return } } } 
func ( w * watchgrpcstream ) joinsubstreams ( ) { for , ws : = range w . substreams { < - ws . donec } for , ws : = range w . resuming { if ws ! = nil { < - ws . donec } } } 
func ( w * watchgrpcstream ) openwatchclient ( ) ( ws pb . watch watchclient , err error ) { backoff : = time . millisecond for { select { case < - w . ctx . done ( ) : if err == nil { return nil , w . ctx . err ( ) } return nil , err default : } if ws , err = w . remote . watch ( w . ctx , w . callopts ... ) ; ws ! = nil && err == nil { break } if ishalterr ( w . ctx , err ) { return nil , v3rpc . error ( err ) } if isunavailableerr ( w . ctx , err ) { if backoff < maxbackoff { backoff = backoff + backoff / 4 if backoff > maxbackoff { backoff = maxbackoff } } time . sleep ( backoff ) } } return ws , nil } 
func ( wr * watchrequest ) topb ( ) * pb . watchrequest { req : = & pb . watchcreaterequest { startrevision : wr . rev , key : [ ] byte ( wr . key ) , rangeend : [ ] byte ( wr . end ) , progressnotify : wr . progressnotify , filters : wr . filters , prevkv : wr . prevkv , fragment : wr . fragment , } cr : = & pb . watchrequest createrequest { createrequest : req } return & pb . watchrequest { requestunion : cr } } 
func ( pr * progressrequest ) topb ( ) * pb . watchrequest { req : = & pb . watchprogressrequest { } cr : = & pb . watchrequest progressrequest { progressrequest : req } return & pb . watchrequest { requestunion : cr } } 
func ( us * unsafeset ) contains ( value string ) ( exists bool ) { , exists = us . d [ value ] return exists } 
func ( us * unsafeset ) containsall ( values [ ] string ) bool { for , s : = range values { if ! us . contains ( s ) { return false } } return true } 
func ( us * unsafeset ) equals ( other set ) bool { v1 : = sort . stringslice ( us . values ( ) ) v2 : = sort . stringslice ( other . values ( ) ) v1 . sort ( ) v2 . sort ( ) return reflect . deepequal ( v1 , v2 ) } 
func ( us * unsafeset ) values ( ) ( values [ ] string ) { values = make ( [ ] string , 0 ) for val : = range us . d { values = append ( values , val ) } return values } 
func ( us * unsafeset ) copy ( ) set { cp : = newunsafeset ( ) for val : = range us . d { cp . add ( val ) } return cp } 
func ( us * unsafeset ) sub ( other set ) set { ovalues : = other . values ( ) result : = us . copy ( ) . ( * unsafeset ) for , val : = range ovalues { if , ok : = result . d [ val ] ; ! ok { continue } delete ( result . d , val ) } return result } 
func v2membersurl ( ep url . url ) * url . url { ep . path = path . join ( ep . path , defaultv2membersprefix ) return & ep } 
func newmigratecommand ( ) * cobra . command { mc : = & cobra . command { use : " " , short : " " , run : migratecommandfunc , } mc . flags ( ) . boolvar ( & migrateexcludettlkey , " " , false , " " ) mc . flags ( ) . stringvar ( & migratedatadir , " " , " " , " " ) mc . flags ( ) . stringvar ( & migratewaldir , " " , " " , " " ) mc . flags ( ) . stringvar ( & migratetransformer , " " , " " , " " ) return mc } 
func newraftnode ( id int , peers [ ] string , join bool , getsnapshot func ( ) ( [ ] byte , error ) , proposec < - chan string , confchangec < - chan raftpb . confchange ) ( < - chan * string , < - chan error , < - chan * snap . snapshotter ) { commitc : = make ( chan * string ) errorc : = make ( chan error ) rc : = & raftnode { proposec : proposec , confchangec : confchangec , commitc : commitc , errorc : errorc , id : id , peers : peers , join : join , waldir : fmt . sprintf ( " " , id ) , snapdir : fmt . sprintf ( " " , id ) , getsnapshot : getsnapshot , snapcount : defaultsnapshotcount , stopc : make ( chan struct { } ) , httpstopc : make ( chan struct { } ) , httpdonec : make ( chan struct { } ) , snapshotterready : make ( chan * snap . snapshotter , 1 ) , } go rc . startraft ( ) return commitc , errorc , rc . snapshotterready } 
func ( rc * raftnode ) publishentries ( ents [ ] raftpb . entry ) bool { for i : = range ents { switch ents [ i ] . type { case raftpb . entrynormal : if len ( ents [ i ] . data ) == 0 { break } s : = string ( ents [ i ] . data ) select { case rc . commitc < - & s : case < - rc . stopc : return false } case raftpb . entryconfchange : var cc raftpb . confchange cc . unmarshal ( ents [ i ] . data ) rc . confstate = * rc . node . applyconfchange ( cc ) switch cc . type { case raftpb . confchangeaddnode : if len ( cc . context ) > 0 { rc . transport . addpeer ( types . id ( cc . nodeid ) , [ ] string { string ( cc . context ) } ) } case raftpb . confchangeremovenode : if cc . nodeid == uint64 ( rc . id ) { log . println ( " " ) return false } rc . transport . removepeer ( types . id ( cc . nodeid ) ) } } rc . appliedindex = ents [ i ] . index if ents [ i ] . index == rc . lastindex { select { case rc . commitc < - nil : case < - rc . stopc : return false } } } return true } 
func ( rc * raftnode ) openwal ( snapshot * raftpb . snapshot ) * wal . wal { if ! wal . exist ( rc . waldir ) { if err : = os . mkdir ( rc . waldir , 0750 ) ; err ! = nil { log . fatalf ( " " , err ) } w , err : = wal . create ( zap . newexample ( ) , rc . waldir , nil ) if err ! = nil { log . fatalf ( " " , err ) } w . close ( ) } walsnap : = walpb . snapshot { } if snapshot ! = nil { walsnap . index , walsnap . term = snapshot . metadata . index , snapshot . metadata . term } log . printf ( " " , walsnap . term , walsnap . index ) w , err : = wal . open ( zap . newexample ( ) , rc . waldir , walsnap ) if err ! = nil { log . fatalf ( " " , err ) } return w } 
func ( rc * raftnode ) replaywal ( ) * wal . wal { log . printf ( " " , rc . id ) snapshot : = rc . loadsnapshot ( ) w : = rc . openwal ( snapshot ) , st , ents , err : = w . readall ( ) if err ! = nil { log . fatalf ( " " , err ) } rc . raftstorage = raft . newmemorystorage ( ) if snapshot ! = nil { rc . raftstorage . applysnapshot ( * snapshot ) } rc . raftstorage . sethardstate ( st ) rc . raftstorage . append ( ents ) if len ( ents ) > 0 { rc . lastindex = ents [ len ( ents ) - 1 ] . index } else { rc . commitc < - nil } return w } 
func newwatchcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : watchcommandfunc , } cmd . flags ( ) . boolvarp ( & watchinteractive , " " , " " , false , " " ) cmd . flags ( ) . boolvar ( & watchprefix , " " , false , " " ) cmd . flags ( ) . int64var ( & watchrev , " " , 0 , " " ) cmd . flags ( ) . boolvar ( & watchprevkey , " " , false , " " ) return cmd } 
func watchcommandfunc ( cmd * cobra . command , args [ ] string ) { envkey , envrange : = os . getenv ( " " ) , os . getenv ( " " ) if envkey == " " && envrange ! = " " { exitwitherror ( exitbadargs , fmt . errorf ( " " , envrange ) ) } if watchinteractive { watchinteractivefunc ( cmd , os . args , envkey , envrange ) return } watchargs , execargs , err : = parsewatchargs ( os . args , args , envkey , envrange , false ) if err ! = nil { exitwitherror ( exitbadargs , err ) } c : = mustclientfromcmd ( cmd ) wc , err : = getwatchchan ( c , watchargs ) if err ! = nil { exitwitherror ( exitbadargs , err ) } printwatchch ( c , wc , execargs ) if err = c . close ( ) ; err ! = nil { exitwitherror ( exitbadconnection , err ) } exitwitherror ( exitinterrupted , fmt . errorf ( " " ) ) } 
func ( ms * memorystorage ) initialstate ( ) ( pb . hardstate , pb . confstate , error ) { return ms . hardstate , ms . snapshot . metadata . confstate , nil } 
func ( ms * memorystorage ) sethardstate ( st pb . hardstate ) error { ms . lock ( ) defer ms . unlock ( ) ms . hardstate = st return nil } 
func ( ms * memorystorage ) entries ( lo , hi , maxsize uint64 ) ( [ ] pb . entry , error ) { ms . lock ( ) defer ms . unlock ( ) offset : = ms . ents [ 0 ] . index if lo <= offset { return nil , errcompacted } if hi > ms . lastindex ( ) + 1 { raftlogger . panicf ( " " , hi , ms . lastindex ( ) ) } if len ( ms . ents ) == 1 { return nil , errunavailable } ents : = ms . ents [ lo - offset : hi - offset ] return limitsize ( ents , maxsize ) , nil } 
func ( ms * memorystorage ) term ( i uint64 ) ( uint64 , error ) { ms . lock ( ) defer ms . unlock ( ) offset : = ms . ents [ 0 ] . index if i < offset { return 0 , errcompacted } if int ( i - offset ) >= len ( ms . ents ) { return 0 , errunavailable } return ms . ents [ i - offset ] . term , nil } 
func ( ms * memorystorage ) lastindex ( ) ( uint64 , error ) { ms . lock ( ) defer ms . unlock ( ) return ms . lastindex ( ) , nil } 
func ( ms * memorystorage ) firstindex ( ) ( uint64 , error ) { ms . lock ( ) defer ms . unlock ( ) return ms . firstindex ( ) , nil } 
func ( ms * memorystorage ) snapshot ( ) ( pb . snapshot , error ) { ms . lock ( ) defer ms . unlock ( ) return ms . snapshot , nil } 
func ( ms * memorystorage ) applysnapshot ( snap pb . snapshot ) error { ms . lock ( ) defer ms . unlock ( ) msindex : = ms . snapshot . metadata . index snapindex : = snap . metadata . index if msindex >= snapindex { return errsnapoutofdate } ms . snapshot = snap ms . ents = [ ] pb . entry { { term : snap . metadata . term , index : snap . metadata . index } } return nil } 
func ( ms * memorystorage ) createsnapshot ( i uint64 , cs * pb . confstate , data [ ] byte ) ( pb . snapshot , error ) { ms . lock ( ) defer ms . unlock ( ) if i <= ms . snapshot . metadata . index { return pb . snapshot { } , errsnapoutofdate } offset : = ms . ents [ 0 ] . index if i > ms . lastindex ( ) { raftlogger . panicf ( " " , i , ms . lastindex ( ) ) } ms . snapshot . metadata . index = i ms . snapshot . metadata . term = ms . ents [ i - offset ] . term if cs ! = nil { ms . snapshot . metadata . confstate = * cs } ms . snapshot . data = data return ms . snapshot , nil } 
func ( ms * memorystorage ) compact ( compactindex uint64 ) error { ms . lock ( ) defer ms . unlock ( ) offset : = ms . ents [ 0 ] . index if compactindex <= offset { return errcompacted } if compactindex > ms . lastindex ( ) { raftlogger . panicf ( " " , compactindex , ms . lastindex ( ) ) } i : = compactindex - offset ents : = make ( [ ] pb . entry , 1 , 1 + uint64 ( len ( ms . ents ) ) - i ) ents [ 0 ] . index = ms . ents [ i ] . index ents [ 0 ] . term = ms . ents [ i ] . term ents = append ( ents , ms . ents [ i + 1 : ] ... ) ms . ents = ents return nil } 
func ( ms * memorystorage ) append ( entries [ ] pb . entry ) error { if len ( entries ) == 0 { return nil } ms . lock ( ) defer ms . unlock ( ) first : = ms . firstindex ( ) last : = entries [ 0 ] . index + uint64 ( len ( entries ) ) - 1 if last < first { return nil } if first > entries [ 0 ] . index { entries = entries [ first - entries [ 0 ] . index : ] } offset : = entries [ 0 ] . index - ms . ents [ 0 ] . index switch { case uint64 ( len ( ms . ents ) ) > offset : ms . ents = append ( [ ] pb . entry { } , ms . ents [ : offset ] ... ) ms . ents = append ( ms . ents , entries ... ) case uint64 ( len ( ms . ents ) ) == offset : ms . ents = append ( ms . ents , entries ... ) default : raftlogger . panicf ( " " , ms . lastindex ( ) , entries [ 0 ] . index ) } return nil } 
func ( p * urlpicker ) unreachable ( u url . url ) { p . mu . lock ( ) defer p . mu . unlock ( ) if u == p . urls [ p . picked ] { p . picked = ( p . picked + 1 ) % len ( p . urls ) } } 
func newendpointcommand ( ) * cobra . command { ec : = & cobra . command { use : " " , short : " " , } ec . persistentflags ( ) . boolvar ( & epclusterendpoints , " " , false , " " ) ec . addcommand ( newephealthcommand ( ) ) ec . addcommand ( newepstatuscommand ( ) ) ec . addcommand ( newephashkvcommand ( ) ) return ec } 
func newelectcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : electcommandfunc , } cmd . flags ( ) . boolvarp ( & electlisten , " " , " " , false , " " ) return cmd } 
func newdefragcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : defragcommandfunc , } cmd . persistentflags ( ) . boolvar ( & epclusterendpoints , " " , false , " " ) cmd . flags ( ) . stringvar ( & defragdatadir , " " , " " , " " ) return cmd } 
func registerbuilder ( cfg config ) { bb : = & builder { cfg } balancer . register ( bb ) bb . cfg . logger . debug ( " " , zap . string ( " " , bb . cfg . policy . string ( ) ) , zap . string ( " " , bb . cfg . name ) , ) } 
func ( b * builder ) build ( cc balancer . clientconn , opt balancer . buildoptions ) balancer . balancer { bb : = & basebalancer { id : strconv . formatint ( time . now ( ) . unixnano ( ) , 36 ) , policy : b . cfg . policy , name : b . cfg . name , lg : b . cfg . logger , addrtosc : make ( map [ resolver . address ] balancer . subconn ) , sctoaddr : make ( map [ balancer . subconn ] resolver . address ) , sctost : make ( map [ balancer . subconn ] connectivity . state ) , currentconn : nil , csevltr : & connectivitystateevaluator { } , picker : picker . newerr ( balancer . errnosubconnavailable ) , } if bb . lg == nil { bb . lg = zap . newnop ( ) } bb . mu . lock ( ) bb . currentconn = cc bb . mu . unlock ( ) bb . lg . info ( " " , zap . string ( " " , bb . id ) , zap . string ( " " , bb . policy . string ( ) ) , zap . string ( " " , cc . target ( ) ) , ) return bb } 
func ( cse * connectivitystateevaluator ) recordtransition ( oldstate , newstate connectivity . state ) connectivity . state { for idx , state : = range [ ] connectivity . state { oldstate , newstate } { updateval : = 2 * uint64 ( idx ) - 1 switch state { case connectivity . ready : cse . numready += updateval case connectivity . connecting : cse . numconnecting += updateval case connectivity . transientfailure : cse . numtransientfailure += updateval } } if cse . numready > 0 { return connectivity . ready } if cse . numconnecting > 0 { return connectivity . connecting } return connectivity . transientfailure } 
func ( s * etcdserver ) doserialize ( ctx context . context , chk func ( * auth . authinfo ) error , get func ( ) ) error { ai , err : = s . authinfofromctx ( ctx ) if err ! = nil { return err } if ai == nil { ai = & auth . authinfo { } } if err = chk ( ai ) ; err ! = nil { return err } get ( ) if ai . revision ! = 0 && ai . revision ! = s . authstore . revision ( ) { return auth . errautholdrevision } return nil } 
func ( w * watcher ) send ( wr clientv3 . watchresponse ) { if wr . isprogressnotify ( ) && ! w . progress { return } if w . nextrev > wr . header . revision && len ( wr . events ) > 0 { return } if w . nextrev == 0 { w . nextrev = wr . header . revision + 1 } events : = make ( [ ] * mvccpb . event , 0 , len ( wr . events ) ) var lastrev int64 for i : = range wr . events { ev : = ( * mvccpb . event ) ( wr . events [ i ] ) if ev . kv . modrevision < w . nextrev { continue } else { lastrev = ev . kv . modrevision } filtered : = false for , filter : = range w . filters { if filter ( * ev ) { filtered = true break } } if filtered { continue } if ! w . prevkv { evcopy : = * ev evcopy . prevkv = nil ev = & evcopy } events = append ( events , ev ) } if lastrev >= w . nextrev { w . nextrev = lastrev + 1 } if ! wr . isprogressnotify ( ) && ! wr . created && len ( events ) == 0 && wr . compactrevision == 0 { return } w . lastheader = wr . header w . post ( & pb . watchresponse { header : & wr . header , created : wr . created , compactrevision : wr . compactrevision , canceled : wr . canceled , watchid : w . id , events : events , } ) } 
func ( w * watcher ) post ( wr * pb . watchresponse ) bool { select { case w . wps . watchch < - wr : case < - time . after ( 50 * time . millisecond ) : w . wps . cancel ( ) return false } return true } 
func ( ac * accesscontroller ) originallowed ( origin string ) bool { ac . corsmu . rlock ( ) defer ac . corsmu . runlock ( ) if len ( ac . cors ) == 0 { return true } , ok : = ac . cors [ " " ] if ok { return true } , ok = ac . cors [ origin ] return ok } 
func ( ac * accesscontroller ) ishostwhitelisted ( host string ) bool { ac . hostwhitelistmu . rlock ( ) defer ac . hostwhitelistmu . runlock ( ) if len ( ac . hostwhitelist ) == 0 { return true } , ok : = ac . hostwhitelist [ " " ] if ok { return true } , ok = ac . hostwhitelist [ host ] return ok } 
func ( ss * selectivestringvalue ) set ( s string ) error { if , ok : = ss . valids [ s ] ; ok { ss . v = s return nil } return errors . new ( " " ) } 
func ( ss * selectivestringvalue ) valids ( ) [ ] string { s : = make ( [ ] string , 0 , len ( ss . valids ) ) for k : = range ss . valids { s = append ( s , k ) } sort . strings ( s ) return s } 
func newselectivestringvalue ( valids ... string ) * selectivestringvalue { vm : = make ( map [ string ] struct { } ) for , v : = range valids { vm [ v ] = struct { } { } } return & selectivestringvalue { valids : vm , v : valids [ 0 ] } } 
func ( ss * selectivestringsvalue ) set ( s string ) error { vs : = strings . split ( s , " " ) for i : = range vs { if , ok : = ss . valids [ vs [ i ] ] ; ok { ss . vs = append ( ss . vs , vs [ i ] ) } else { return fmt . errorf ( " " , vs [ i ] ) } } sort . strings ( ss . vs ) return nil } 
func newselectivestringsvalue ( valids ... string ) * selectivestringsvalue { vm : = make ( map [ string ] struct { } ) for , v : = range valids { vm [ v ] = struct { } { } } return & selectivestringsvalue { valids : vm , vs : [ ] string { } } } 
func newkv ( kv clientv3 . kv , prefix string ) clientv3 . kv { return & kvprefix { kv , prefix } } 
func newtimeouttransport ( info tlsinfo , dialtimeoutd , rdtimeoutd , wtimeoutd time . duration ) ( * http . transport , error ) { tr , err : = newtransport ( info , dialtimeoutd ) if err ! = nil { return nil , err } if rdtimeoutd ! = 0 | | wtimeoutd ! = 0 { tr . maxidleconnsperhost = - 1 } else { tr . maxidleconnsperhost = 1024 } tr . dial = ( & rwtimeoutdialer { dialer : net . dialer { timeout : dialtimeoutd , keepalive : 30 * time . second , } , rdtimeoutd : rdtimeoutd , wtimeoutd : wtimeoutd , } ) . dial return tr , nil } 
func ( us * urlsvalue ) string ( ) string { all : = make ( [ ] string , len ( * us ) ) for i , u : = range * us { all [ i ] = u . string ( ) } return strings . join ( all , " " ) } 
func newurlsvalue ( s string ) * urlsvalue { if s == " " { return & urlsvalue { } } v : = & urlsvalue { } if err : = v . set ( s ) ; err ! = nil { plog . panicf ( " " , err ) } return v } 
func urlsfromflag ( fs * flag . flagset , urlsflagname string ) [ ] url . url { return [ ] url . url ( * fs . lookup ( urlsflagname ) . value . ( * urlsvalue ) ) } 
func ( e * etcd ) getlogger ( ) * zap . logger { e . cfg . loggermu . rlock ( ) l : = e . cfg . logger e . cfg . loggermu . runlock ( ) return l } 
func newstore ( lg * zap . logger , b backend . backend , le lease . lessor , ig consistentindexgetter ) * store { s : = & store { b : b , ig : ig , kvindex : newtreeindex ( lg ) , le : le , currentrev : 1 , compactmainrev : - 1 , bytesbuf8 : make ( [ ] byte , 8 ) , fifosched : schedule . newfifoscheduler ( ) , stopc : make ( chan struct { } ) , lg : lg , } s . readview = & readview { s } s . writeview = & writeview { s } if s . le ! = nil { s . le . setrangedeleter ( func ( ) lease . txndelete { return s . write ( ) } ) } tx : = s . b . batchtx ( ) tx . lock ( ) tx . unsafecreatebucket ( keybucketname ) tx . unsafecreatebucket ( metabucketname ) tx . unlock ( ) s . b . forcecommit ( ) s . mu . lock ( ) defer s . mu . unlock ( ) if err : = s . restore ( ) ; err ! = nil { panic ( " " ) } return s } 
func appendmarktombstone ( lg * zap . logger , b [ ] byte ) [ ] byte { if len ( b ) ! = revbyteslen { if lg ! = nil { lg . panic ( " " , zap . int ( " " , revbyteslen ) , zap . int ( " " , len ( b ) ) , ) } else { plog . panicf ( " " ) } } return append ( b , marktombstone ) } 
func isdirwriteable ( dir string ) error { f : = filepath . join ( dir , " " ) if err : = ioutil . writefile ( f , [ ] byte ( " " ) , privatefilemode ) ; err ! = nil { return err } return os . remove ( f ) } 
func touchdirall ( dir string ) error { err : = os . mkdirall ( dir , privatedirmode ) if err ! = nil { return err } return isdirwriteable ( dir ) } 
func createdirall ( dir string ) error { err : = touchdirall ( dir ) if err == nil { var ns [ ] string ns , err = readdir ( dir ) if err ! = nil { return err } if len ( ns ) ! = 0 { err = fmt . errorf ( " " , dir , ns ) } } return err } 
func zerotoend ( f * os . file ) error { off , err : = f . seek ( 0 , io . seekcurrent ) if err ! = nil { return err } lenf , lerr : = f . seek ( 0 , io . seekend ) if lerr ! = nil { return lerr } if err = f . truncate ( off ) ; err ! = nil { return err } if err = preallocate ( f , lenf , true ) ; err ! = nil { return err } , err = f . seek ( off , io . seekstart ) return err } 
func ( fp * filepipeline ) open ( ) ( f * fileutil . lockedfile , err error ) { select { case f = < - fp . filec : case err = < - fp . errc : } return f , err } 
func newraftlogger ( lcfg * zap . config ) ( raft . logger , error ) { if lcfg == nil { return nil , errors . new ( " " ) } lg , err : = lcfg . build ( zap . addcallerskip ( 1 ) ) if err ! = nil { return nil , err } return & zapraftlogger { lg : lg , sugar : lg . sugar ( ) } , nil } 
func newraftloggerfromzapcore ( cr zapcore . core , syncer zapcore . writesyncer ) raft . logger { lg : = zap . new ( cr , zap . addcaller ( ) , zap . addcallerskip ( 1 ) , zap . erroroutput ( syncer ) ) return & zapraftlogger { lg : lg , sugar : lg . sugar ( ) } } 
func newconfig ( fpath string ) ( * clientv3 . config , error ) { b , err : = ioutil . readfile ( fpath ) if err ! = nil { return nil , err } yc : = & yamlconfig { } err = yaml . unmarshal ( b , yc ) if err ! = nil { return nil , err } if yc . insecuretransport { return & yc . config , nil } var ( cert * tls . certificate cp * x509 . certpool ) if yc . certfile ! = " " && yc . keyfile ! = " " { cert , err = tlsutil . newcert ( yc . certfile , yc . keyfile , nil ) if err ! = nil { return nil , err } } if yc . trustedcafile ! = " " { cp , err = tlsutil . newcertpool ( [ ] string { yc . trustedcafile } ) if err ! = nil { return nil , err } } tlscfg : = & tls . config { minversion : tls . versiontls12 , insecureskipverify : yc . insecureskiptlsverify , rootcas : cp , } if cert ! = nil { tlscfg . certificates = [ ] tls . certificate { * cert } } yc . config . tls = tlscfg return & yc . config , nil } 
func updatecapability ( lg * zap . logger , v * semver . version ) { if v == nil { return } enablemapmu . lock ( ) if curversion ! = nil && ! curversion . lessthan ( * v ) { enablemapmu . unlock ( ) return } curversion = v enabledmap = capabilitymaps [ curversion . string ( ) ] enablemapmu . unlock ( ) if lg ! = nil { lg . info ( " " , zap . string ( " " , version . cluster ( v . string ( ) ) ) , ) } else { plog . infof ( " " , version . cluster ( v . string ( ) ) ) } } 
func newlockcommand ( ) * cobra . command { c : = & cobra . command { use : " " , short : " " , run : lockcommandfunc , } c . flags ( ) . intvarp ( & lockttl , " " , " " , lockttl , " " ) return c } 
func ( r * raftnode ) advanceticks ( ticks int ) { for i : = 0 ; i < ticks ; i ++ { r . tick ( ) } } 
func getids ( lg * zap . logger , snap * raftpb . snapshot , ents [ ] raftpb . entry ) [ ] uint64 { ids : = make ( map [ uint64 ] bool ) if snap ! = nil { for , id : = range snap . metadata . confstate . nodes { ids [ id ] = true } } for , e : = range ents { if e . type ! = raftpb . entryconfchange { continue } var cc raftpb . confchange pbutil . mustunmarshal ( & cc , e . data ) switch cc . type { case raftpb . confchangeaddnode : ids [ cc . nodeid ] = true case raftpb . confchangeremovenode : delete ( ids , cc . nodeid ) case raftpb . confchangeupdatenode : default : if lg ! = nil { lg . panic ( " " , zap . string ( " " , cc . type . string ( ) ) ) } else { plog . panicf ( " " ) } } } sids : = make ( types . uint64slice , 0 , len ( ids ) ) for id : = range ids { sids = append ( sids , id ) } sort . sort ( sids ) return [ ] uint64 ( sids ) } 
func createconfigchangeents ( lg * zap . logger , ids [ ] uint64 , self uint64 , term , index uint64 ) [ ] raftpb . entry { ents : = make ( [ ] raftpb . entry , 0 ) next : = index + 1 found : = false for , id : = range ids { if id == self { found = true continue } cc : = & raftpb . confchange { type : raftpb . confchangeremovenode , nodeid : id , } e : = raftpb . entry { type : raftpb . entryconfchange , data : pbutil . mustmarshal ( cc ) , term : term , index : next , } ents = append ( ents , e ) next ++ } if ! found { m : = membership . member { id : types . id ( self ) , raftattributes : membership . raftattributes { peerurls : [ ] string { " " } } , } ctx , err : = json . marshal ( m ) if err ! = nil { if lg ! = nil { lg . panic ( " " , zap . error ( err ) ) } else { plog . panicf ( " " , err ) } } cc : = & raftpb . confchange { type : raftpb . confchangeaddnode , nodeid : self , context : ctx , } e : = raftpb . entry { type : raftpb . entryconfchange , data : pbutil . mustmarshal ( cc ) , term : term , index : next , } ents = append ( ents , e ) } return ents } 
func newauthcommand ( ) * cobra . command { ac : = & cobra . command { use : " " , short : " " , } ac . addcommand ( newauthenablecommand ( ) ) ac . addcommand ( newauthdisablecommand ( ) ) return ac } 
func authenablecommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 0 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } ctx , cancel : = commandctx ( cmd ) cli : = mustclientfromcmd ( cmd ) var err error for err == nil { if , err = cli . authenable ( ctx ) ; err == nil { break } if err == rpctypes . errrootrolenotexist { if , err = cli . roleadd ( ctx , " " ) ; err ! = nil { break } if , err = cli . usergrantrole ( ctx , " " , " " ) ; err ! = nil { break } } } cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } fmt . println ( " " ) } 
func authdisablecommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 0 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } ctx , cancel : = commandctx ( cmd ) , err : = mustclientfromcmd ( cmd ) . auth . authdisable ( ctx ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } fmt . println ( " " ) } 
func issaferetryimmutablerpc ( err error ) bool { eerr : = rpctypes . error ( err ) if servererr , ok : = eerr . ( rpctypes . etcderror ) ; ok && servererr . code ( ) ! = codes . unavailable { return false } ev , ok : = status . fromerror ( err ) if ! ok { return false } return ev . code ( ) == codes . unavailable } 
func issaferetrymutablerpc ( err error ) bool { if ev , ok : = status . fromerror ( err ) ; ok && ev . code ( ) ! = codes . unavailable { return false } desc : = rpctypes . errordesc ( err ) return desc == " " | | desc == " " } 
func retrykvclient ( c * client ) pb . kvclient { return & retrykvclient { kc : pb . newkvclient ( c . conn ) , } } 
func retryleaseclient ( c * client ) pb . leaseclient { return & retryleaseclient { lc : pb . newleaseclient ( c . conn ) , } } 
func retryclusterclient ( c * client ) pb . clusterclient { return & retryclusterclient { cc : pb . newclusterclient ( c . conn ) , } } 
func retrymaintenanceclient ( c * client , conn * grpc . clientconn ) pb . maintenanceclient { return & retrymaintenanceclient { mc : pb . newmaintenanceclient ( conn ) , } } 
func retryauthclient ( c * client ) pb . authclient { return & retryauthclient { ac : pb . newauthclient ( c . conn ) , } } 
func newsetdircommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , flags : [ ] cli . flag { cli . intflag { name : " " , value : 0 , usage : " " } , } , action : func ( c * cli . context ) error { mkdircommandfunc ( c , mustnewkeyapi ( c ) , client . prevignore ) return nil } , } } 
func ( b * doublebarrier ) enter ( ) error { client : = b . s . client ( ) ek , err : = newuniqueephemeralkey ( b . s , b . key + " " ) if err ! = nil { return err } b . mykey = ek resp , err : = client . get ( b . ctx , b . key + " " , clientv3 . withprefix ( ) ) if err ! = nil { return err } if len ( resp . kvs ) > b . count { return errtoomanyclients } if len ( resp . kvs ) == b . count { , err = client . put ( b . ctx , b . key + " " , " " ) return err } , err = waitevents ( client , b . key + " " , ek . revision ( ) , [ ] mvccpb . event eventtype { mvccpb . put } ) return err } 
func ( b * doublebarrier ) leave ( ) error { client : = b . s . client ( ) resp , err : = client . get ( b . ctx , b . key + " " , clientv3 . withprefix ( ) ) if err ! = nil { return err } if len ( resp . kvs ) == 0 { return nil } lowest , highest : = resp . kvs [ 0 ] , resp . kvs [ 0 ] for , k : = range resp . kvs { if k . modrevision < lowest . modrevision { lowest = k } if k . modrevision > highest . modrevision { highest = k } } islowest : = string ( lowest . key ) == b . mykey . key ( ) if len ( resp . kvs ) == 1 { if , err = client . delete ( b . ctx , b . key + " " ) ; err ! = nil { return err } return b . mykey . delete ( ) } if islowest { , err = waitevents ( client , string ( highest . key ) , highest . modrevision , [ ] mvccpb . event eventtype { mvccpb . delete } ) if err ! = nil { return err } return b . leave ( ) } if err = b . mykey . delete ( ) ; err ! = nil { return err } key : = string ( lowest . key ) , err = waitevents ( client , key , lowest . modrevision , [ ] mvccpb . event eventtype { mvccpb . delete } ) if err ! = nil { return err } return b . leave ( ) } 
func handlebasic ( mux * http . servemux , server etcdserver . serverpeer ) { mux . handlefunc ( varspath , servevars ) mux . handlefunc ( configpath + " " , loghandlefunc ) handlemetricshealth ( mux , server ) mux . handlefunc ( versionpath , versionhandler ( server . cluster ( ) , serveversion ) ) } 
func loghandlefunc ( w http . responsewriter , r * http . request ) { if ! allowmethod ( w , r , " " ) { return } in : = struct { level string } { } d : = json . newdecoder ( r . body ) if err : = d . decode ( & in ) ; err ! = nil { writeerror ( nil , w , r , httptypes . newhttperror ( http . statusbadrequest , " " ) ) return } logl , err : = capnslog . parselevel ( strings . toupper ( in . level ) ) if err ! = nil { writeerror ( nil , w , r , httptypes . newhttperror ( http . statusbadrequest , " " + in . level ) ) return } plog . noticef ( " " , logl . string ( ) ) capnslog . setgloballoglevel ( logl ) w . writeheader ( http . statusnocontent ) } 
func ( c * raftcluster ) memberbyname ( name string ) * member { c . lock ( ) defer c . unlock ( ) var memb * member for , m : = range c . members { if m . name == name { if memb ! = nil { if c . lg ! = nil { c . lg . panic ( " " , zap . string ( " " , name ) ) } else { plog . panicf ( " " , name ) } } memb = m } } return memb . clone ( ) } 
func ( c * raftcluster ) peerurls ( ) [ ] string { c . lock ( ) defer c . unlock ( ) urls : = make ( [ ] string , 0 ) for , p : = range c . members { urls = append ( urls , p . peerurls ... ) } sort . strings ( urls ) return urls } 
func ( c * raftcluster ) addmember ( m * member ) { c . lock ( ) defer c . unlock ( ) if c . v2store ! = nil { mustsavemembertostore ( c . v2store , m ) } if c . be ! = nil { mustsavemembertobackend ( c . be , m ) } c . members [ m . id ] = m if c . lg ! = nil { c . lg . info ( " " , zap . string ( " " , c . cid . string ( ) ) , zap . string ( " " , c . localid . string ( ) ) , zap . string ( " " , m . id . string ( ) ) , zap . strings ( " " , m . peerurls ) , ) } else { plog . infof ( " " , m . id , m . peerurls , c . cid ) } } 
func ( c * raftcluster ) removemember ( id types . id ) { c . lock ( ) defer c . unlock ( ) if c . v2store ! = nil { mustdeletememberfromstore ( c . v2store , id ) } if c . be ! = nil { mustdeletememberfrombackend ( c . be , id ) } m , ok : = c . members [ id ] delete ( c . members , id ) c . removed [ id ] = true if c . lg ! = nil { if ok { c . lg . info ( " " , zap . string ( " " , c . cid . string ( ) ) , zap . string ( " " , c . localid . string ( ) ) , zap . string ( " " , id . string ( ) ) , zap . strings ( " " , m . peerurls ) , ) } else { c . lg . warn ( " " , zap . string ( " " , c . cid . string ( ) ) , zap . string ( " " , c . localid . string ( ) ) , zap . string ( " " , id . string ( ) ) , ) } } else { plog . infof ( " " , id , c . cid ) } } 
func validateclusterandassignids ( lg * zap . logger , local * raftcluster , existing * raftcluster ) error { ems : = existing . members ( ) lms : = local . members ( ) if len ( ems ) ! = len ( lms ) { return fmt . errorf ( " " ) } sort . sort ( membersbypeerurls ( ems ) ) sort . sort ( membersbypeerurls ( lms ) ) ctx , cancel : = context . withtimeout ( context . todo ( ) , 30 * time . second ) defer cancel ( ) for i : = range ems { if ok , err : = netutil . urlstringsequal ( ctx , lg , ems [ i ] . peerurls , lms [ i ] . peerurls ) ; ! ok { return fmt . errorf ( " " , err ) } lms [ i ] . id = ems [ i ] . id } local . members = make ( map [ types . id ] * member ) for , m : = range lms { local . members [ m . id ] = m } return nil } 
func ( ti * treeindex ) rangesince ( key , end [ ] byte , rev int64 ) [ ] revision { keyi : = & keyindex { key : key } ti . rlock ( ) defer ti . runlock ( ) if end == nil { item : = ti . tree . get ( keyi ) if item == nil { return nil } keyi = item . ( * keyindex ) return keyi . since ( ti . lg , rev ) } endi : = & keyindex { key : end } var revs [ ] revision ti . tree . ascendgreaterorequal ( keyi , func ( item btree . item ) bool { if len ( endi . key ) > 0 && ! item . less ( endi ) { return false } curkeyi : = item . ( * keyindex ) revs = append ( revs , curkeyi . since ( ti . lg , rev ) ... ) return true } ) sort . sort ( revisions ( revs ) ) return revs } 
func ( ti * treeindex ) keep ( rev int64 ) map [ revision ] struct { } { available : = make ( map [ revision ] struct { } ) ti . rlock ( ) defer ti . runlock ( ) ti . tree . ascend ( func ( i btree . item ) bool { keyi : = i . ( * keyindex ) keyi . keep ( rev , available ) return true } ) return available } 
func ( l * lessor ) closerequireleader ( ) { l . mu . lock ( ) defer l . mu . unlock ( ) for , ka : = range l . keepalives { reqidxs : = 0 for i , ctx : = range ka . ctxs { md , ok : = metadata . fromoutgoingcontext ( ctx ) if ! ok { continue } ks : = md [ rpctypes . metadatarequireleaderkey ] if len ( ks ) < 1 | | ks [ 0 ] ! = rpctypes . metadatahasleader { continue } close ( ka . chs [ i ] ) ka . chs [ i ] = nil reqidxs ++ } if reqidxs == 0 { continue } newchs : = make ( [ ] chan < - * leasekeepaliveresponse , len ( ka . chs ) - reqidxs ) newctxs : = make ( [ ] context . context , len ( newchs ) ) newidx : = 0 for i : = range ka . chs { if ka . chs [ i ] == nil { continue } newchs [ newidx ] , newctxs [ newidx ] = ka . chs [ i ] , ka . ctxs [ newidx ] newidx ++ } ka . chs , ka . ctxs = newchs , newctxs } } 
func ( l * lessor ) resetrecv ( ) ( pb . lease leasekeepaliveclient , error ) { sctx , cancel : = context . withcancel ( l . stopctx ) stream , err : = l . remote . leasekeepalive ( sctx , append ( l . callopts , withmax ( 0 ) ) ... ) if err ! = nil { cancel ( ) return nil , err } l . mu . lock ( ) defer l . mu . unlock ( ) if l . stream ! = nil && l . streamcancel ! = nil { l . streamcancel ( ) } l . streamcancel = cancel l . stream = stream go l . sendkeepaliveloop ( stream ) return stream , nil } 
func ( l * lessor ) recvkeepalive ( resp * pb . leasekeepaliveresponse ) { karesp : = & leasekeepaliveresponse { responseheader : resp . getheader ( ) , id : leaseid ( resp . id ) , ttl : resp . ttl , } l . mu . lock ( ) defer l . mu . unlock ( ) ka , ok : = l . keepalives [ karesp . id ] if ! ok { return } if karesp . ttl <= 0 { delete ( l . keepalives , karesp . id ) ka . close ( ) return } nextkeepalive : = time . now ( ) . add ( ( time . duration ( karesp . ttl ) * time . second ) / 3 . 0 ) ka . deadline = time . now ( ) . add ( time . duration ( karesp . ttl ) * time . second ) for , ch : = range ka . chs { select { case ch < - karesp : default : if l . lg ! = nil { l . lg . warn ( " " , zap . int ( " " , len ( ch ) ) , zap . int ( " " , cap ( ch ) ) , ) } } ka . nextkeepalive = nextkeepalive } } 
func ( l * lessor ) deadlineloop ( ) { for { select { case < - time . after ( time . second ) : case < - l . donec : return } now : = time . now ( ) l . mu . lock ( ) for id , ka : = range l . keepalives { if ka . deadline . before ( now ) { ka . close ( ) delete ( l . keepalives , id ) } } l . mu . unlock ( ) } } 
func ( l * lessor ) sendkeepaliveloop ( stream pb . lease leasekeepaliveclient ) { for { var tosend [ ] leaseid now : = time . now ( ) l . mu . lock ( ) for id , ka : = range l . keepalives { if ka . nextkeepalive . before ( now ) { tosend = append ( tosend , id ) } } l . mu . unlock ( ) for , id : = range tosend { r : = & pb . leasekeepaliverequest { id : int64 ( id ) } if err : = stream . send ( r ) ; err ! = nil { return } } select { case < - time . after ( retryconnwait ) : case < - stream . context ( ) . done ( ) : return case < - l . donec : return case < - l . stopctx . done ( ) : return } } } 
func newkv ( cl * v3 . client , pfx string , opts ... concurrency . sessionoption ) ( v3 . kv , func ( ) , error ) { cctx , cancel : = context . withcancel ( cl . ctx ( ) ) lkv : = & leasingkv { cl : cl , kv : cl . kv , pfx : pfx , leases : leasecache { revokes : make ( map [ string ] time . time ) } , ctx : cctx , cancel : cancel , sessionopts : opts , sessionc : make ( chan struct { } ) , } lkv . wg . add ( 2 ) go func ( ) { defer lkv . wg . done ( ) lkv . monitorsession ( ) } ( ) go func ( ) { defer lkv . wg . done ( ) lkv . leases . clearoldrevokes ( cctx ) } ( ) return lkv , lkv . close , lkv . waitsession ( cctx ) } 
func ( lkv * leasingkv ) rescind ( ctx context . context , key string , rev int64 ) { if lkv . leases . evict ( key ) > rev { return } cmp : = v3 . compare ( v3 . createrevision ( lkv . pfx + key ) , " " , rev ) op : = v3 . opdelete ( lkv . pfx + key ) for ctx . err ( ) == nil { if , err : = lkv . kv . txn ( ctx ) . if ( cmp ) . then ( op ) . commit ( ) ; err == nil { return } } } 
func leasevalue ( key string ) cmp { return cmp { key : [ ] byte ( key ) , target : pb . compare lease } } 
func ( cmp * cmp ) valuebytes ( ) [ ] byte { if tu , ok : = cmp . targetunion . ( * pb . compare value ) ; ok { return tu . value } return nil } 
func ( cmp cmp ) withrange ( end string ) cmp { cmp . rangeend = [ ] byte ( end ) return cmp } 
func ( cmp cmp ) withprefix ( ) cmp { cmp . rangeend = getprefix ( cmp . key ) return cmp } 
func mustint64 ( val interface { } ) int64 { if v , ok : = val . ( int64 ) ; ok { return v } if v , ok : = val . ( int ) ; ok { return int64 ( v ) } panic ( " " ) } 
func mustint64orleaseid ( val interface { } ) int64 { if v , ok : = val . ( leaseid ) ; ok { return int64 ( v ) } return mustint64 ( val ) } 
func ( gw * grpcwatcher ) next ( ) ( [ ] * naming . update , error ) { if gw . wch == nil { return gw . firstnext ( ) } if gw . err ! = nil { return nil , gw . err } wr , ok : = < - gw . wch if ! ok { gw . err = status . error ( codes . unavailable , errwatcherclosed . error ( ) ) return nil , gw . err } if gw . err = wr . err ( ) ; gw . err ! = nil { return nil , gw . err } updates : = make ( [ ] * naming . update , 0 , len ( wr . events ) ) for , e : = range wr . events { var jupdate naming . update var err error switch e . type { case etcd . eventtypeput : err = json . unmarshal ( e . kv . value , & jupdate ) jupdate . op = naming . add case etcd . eventtypedelete : err = json . unmarshal ( e . prevkv . value , & jupdate ) jupdate . op = naming . delete default : continue } if err == nil { updates = append ( updates , & jupdate ) } } return updates , nil } 
func getjournalwritesyncer ( ) ( zapcore . writesyncer , error ) { jw , err : = logutil . newjournalwriter ( os . stderr ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return zapcore . addsync ( jw ) , nil } 
func newkv ( store * store , nodepath string , value string , createdindex uint64 , parent * node , expiretime time . time ) * node { return & node { path : nodepath , createdindex : createdindex , modifiedindex : createdindex , parent : parent , store : store , expiretime : expiretime , value : value , } } 
func newdir ( store * store , nodepath string , createdindex uint64 , parent * node , expiretime time . time ) * node { return & node { path : nodepath , createdindex : createdindex , modifiedindex : createdindex , parent : parent , expiretime : expiretime , children : make ( map [ string ] * node ) , store : store , } } 
func ( n * node ) ishidden ( ) bool { , name : = path . split ( n . path ) return name [ 0 ] == ' ' } 
func ( n * node ) read ( ) ( string , * v2error . error ) { if n . isdir ( ) { return " " , v2error . newerror ( v2error . ecodenotfile , " " , n . store . currentindex ) } return n . value , nil } 
func ( n * node ) write ( value string , index uint64 ) * v2error . error { if n . isdir ( ) { return v2error . newerror ( v2error . ecodenotfile , " " , n . store . currentindex ) } n . value = value n . modifiedindex = index return nil } 
func ( n * node ) list ( ) ( [ ] * node , * v2error . error ) { if ! n . isdir ( ) { return nil , v2error . newerror ( v2error . ecodenotdir , " " , n . store . currentindex ) } nodes : = make ( [ ] * node , len ( n . children ) ) i : = 0 for , node : = range n . children { nodes [ i ] = node i ++ } return nodes , nil } 
func ( n * node ) getchild ( name string ) ( * node , * v2error . error ) { if ! n . isdir ( ) { return nil , v2error . newerror ( v2error . ecodenotdir , n . path , n . store . currentindex ) } child , ok : = n . children [ name ] if ok { return child , nil } return nil , nil } 
func ( n * node ) add ( child * node ) * v2error . error { if ! n . isdir ( ) { return v2error . newerror ( v2error . ecodenotdir , " " , n . store . currentindex ) } , name : = path . split ( child . path ) if , ok : = n . children [ name ] ; ok { return v2error . newerror ( v2error . ecodenodeexist , " " , n . store . currentindex ) } n . children [ name ] = child return nil } 
func ( n * node ) remove ( dir , recursive bool , callback func ( path string ) ) * v2error . error { if ! n . isdir ( ) { , name : = path . split ( n . path ) if n . parent ! = nil && n . parent . children [ name ] == n { delete ( n . parent . children , name ) } if callback ! = nil { callback ( n . path ) } if ! n . ispermanent ( ) { n . store . ttlkeyheap . remove ( n ) } return nil } if ! dir { return v2error . newerror ( v2error . ecodenotfile , n . path , n . store . currentindex ) } if len ( n . children ) ! = 0 && ! recursive { return v2error . newerror ( v2error . ecodedirnotempty , n . path , n . store . currentindex ) } for , child : = range n . children { child . remove ( true , true , callback ) } , name : = path . split ( n . path ) if n . parent ! = nil && n . parent . children [ name ] == n { delete ( n . parent . children , name ) if callback ! = nil { callback ( n . path ) } if ! n . ispermanent ( ) { n . store . ttlkeyheap . remove ( n ) } } return nil } 
func ( n * node ) compare ( prevvalue string , previndex uint64 ) ( ok bool , which int ) { indexmatch : = previndex == 0 | | n . modifiedindex == previndex valuematch : = prevvalue == " " | | n . value == prevvalue ok = valuematch && indexmatch switch { case valuematch && indexmatch : which = comparematch case indexmatch && ! valuematch : which = comparevaluenotmatch case valuematch && ! indexmatch : which = compareindexnotmatch default : which = comparenotmatch } return ok , which } 
func ( n * node ) clone ( ) * node { if ! n . isdir ( ) { newkv : = newkv ( n . store , n . path , n . value , n . createdindex , n . parent , n . expiretime ) newkv . modifiedindex = n . modifiedindex return newkv } clone : = newdir ( n . store , n . path , n . createdindex , n . parent , n . expiretime ) clone . modifiedindex = n . modifiedindex for key , child : = range n . children { clone . children [ key ] = child . clone ( ) } return clone } 
func ( n * node ) recoverandclean ( ) { if n . isdir ( ) { for , child : = range n . children { child . parent = n child . store = n . store child . recoverandclean ( ) } } if ! n . expiretime . iszero ( ) { n . store . ttlkeyheap . push ( n ) } } 
func isconnectedtoquorumsince ( transport rafthttp . transporter , since time . time , self types . id , members [ ] * membership . member ) bool { return numconnectedsince ( transport , since , self , members ) >= ( len ( members ) / 2 ) + 1 } 
func isconnectedsince ( transport rafthttp . transporter , since time . time , remote types . id ) bool { t : = transport . activesince ( remote ) return ! t . iszero ( ) && t . before ( since ) } 
func numconnectedsince ( transport rafthttp . transporter , since time . time , self types . id , members [ ] * membership . member ) int { connectednum : = 0 for , m : = range members { if m . id == self | | isconnectedsince ( transport , since , m . id ) { connectednum ++ } } return connectednum } 
func longestconnected ( tp rafthttp . transporter , membs [ ] types . id ) ( types . id , bool ) { var longest types . id var oldest time . time for , id : = range membs { tm : = tp . activesince ( id ) if tm . iszero ( ) { continue } if oldest . iszero ( ) { oldest = tm longest = id } if tm . before ( oldest ) { oldest = tm longest = id } } if uint64 ( longest ) == 0 { return longest , false } return longest , true } 
func ( d * decoder ) istornentry ( data [ ] byte ) bool { if len ( d . brs ) ! = 1 { return false } fileoff : = d . lastvalidoff + framesizebytes curoff : = 0 chunks : = [ ] [ ] byte { } for curoff < len ( data ) { chunklen : = int ( minsectorsize - ( fileoff % minsectorsize ) ) if chunklen > len ( data ) - curoff { chunklen = len ( data ) - curoff } chunks = append ( chunks , data [ curoff : curoff + chunklen ] ) fileoff += int64 ( chunklen ) curoff += chunklen } for , sect : = range chunks { iszero : = true for , v : = range sect { if v ! = 0 { iszero = false break } } if iszero { return true } } return false } 
func startmockserversonnetwork ( count int , network string ) ( ms * mockservers , err error ) { switch network { case " " : return startmockserverstcp ( count ) case " " : return startmockserversunix ( count ) default : return nil , fmt . errorf ( " " , network ) } } 
func ( ms * mockservers ) startat ( idx int ) ( err error ) { ms . mu . lock ( ) defer ms . mu . unlock ( ) if ms . servers [ idx ] . ln == nil { ms . servers [ idx ] . ln , err = net . listen ( ms . servers [ idx ] . network , ms . servers [ idx ] . address ) if err ! = nil { return fmt . errorf ( " " , err ) } } svr : = grpc . newserver ( ) pb . registerkvserver ( svr , & mockkvserver { } ) ms . servers [ idx ] . grpcserver = svr ms . wg . add ( 1 ) go func ( svr * grpc . server , l net . listener ) { svr . serve ( l ) } ( ms . servers [ idx ] . grpcserver , ms . servers [ idx ] . ln ) return nil } 
func ( ms * mockservers ) stopat ( idx int ) { ms . mu . lock ( ) defer ms . mu . unlock ( ) if ms . servers [ idx ] . ln == nil { return } ms . servers [ idx ] . grpcserver . stop ( ) ms . servers [ idx ] . grpcserver = nil ms . servers [ idx ] . ln = nil ms . wg . done ( ) } 
func ( ms * mockservers ) stop ( ) { for idx : = range ms . servers { ms . stopat ( idx ) } ms . wg . wait ( ) } 
func newcheckcommand ( ) * cobra . command { cc : = & cobra . command { use : " " , short : " " , } cc . addcommand ( newcheckperfcommand ( ) ) cc . addcommand ( newcheckdatascalecommand ( ) ) return cc } 
func newcheckperfcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : newcheckperfcommand , } cmd . flags ( ) . stringvar ( & checkperfload , " " , " " , " " ) cmd . flags ( ) . stringvar ( & checkperfprefix , " " , " " , " " ) cmd . flags ( ) . boolvar ( & autocompact , " " , false , " " ) cmd . flags ( ) . boolvar ( & autodefrag , " " , false , " " ) return cmd } 
func newcheckdatascalecommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , long : " " , run : newcheckdatascalecommand , } cmd . flags ( ) . stringvar ( & checkdatascaleload , " " , " " , " " ) cmd . flags ( ) . stringvar ( & checkdatascaleprefix , " " , " " , " " ) cmd . flags ( ) . boolvar ( & autocompact , " " , false , " " ) cmd . flags ( ) . boolvar ( & autodefrag , " " , false , " " ) return cmd } 
func newgetcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : getcommandfunc , } cmd . flags ( ) . stringvar ( & getconsistency , " " , " " , " " ) cmd . flags ( ) . stringvar ( & getsortorder , " " , " " , " " ) cmd . flags ( ) . stringvar ( & getsorttarget , " " , " " , " " ) cmd . flags ( ) . int64var ( & getlimit , " " , 0 , " " ) cmd . flags ( ) . boolvar ( & getprefix , " " , false , " " ) cmd . flags ( ) . boolvar ( & getfromkey , " " , false , " " ) cmd . flags ( ) . int64var ( & getrev , " " , 0 , " " ) cmd . flags ( ) . boolvar ( & getkeysonly , " " , false , " " ) cmd . flags ( ) . boolvar ( & printvalueonly , " " , false , ' only write values when using the " simple " output format ' ) return cmd } 
func getcommandfunc ( cmd * cobra . command , args [ ] string ) { key , opts : = getgetop ( args ) ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . get ( ctx , key , opts ... ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } if printvalueonly { dp , simple : = ( display ) . ( * simpleprinter ) if ! simple { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } dp . valueonly = true } display . get ( * resp ) } 
func newgetcommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , flags : [ ] cli . flag { cli . boolflag { name : " " , usage : " " } , cli . boolflag { name : " " , usage : " " } , } , action : func ( c * cli . context ) error { getcommandfunc ( c , mustnewkeyapi ( c ) ) return nil } , } } 
func getcommandfunc ( c * cli . context , ki client . keysapi ) { if len ( c . args ( ) ) == 0 { handleerror ( c , exitbadargs , errors . new ( " " ) ) } key : = c . args ( ) [ 0 ] sorted : = c . bool ( " " ) quorum : = c . bool ( " " ) ctx , cancel : = contextwithtotaltimeout ( c ) resp , err : = ki . get ( ctx , key , & client . getoptions { sort : sorted , quorum : quorum } ) cancel ( ) if err ! = nil { handleerror ( c , exitservererror , err ) } if resp . node . dir { fmt . fprintln ( os . stderr , fmt . sprintf ( " " , resp . node . key ) ) os . exit ( 1 ) } printresponsekey ( resp , c . globalstring ( " " ) ) } 
func newmember ( name string , peerurls types . urls , clustername string , now * time . time ) * member { m : = & member { raftattributes : raftattributes { peerurls : peerurls . stringslice ( ) } , attributes : attributes { name : name } , } var b [ ] byte sort . strings ( m . peerurls ) for , p : = range m . peerurls { b = append ( b , [ ] byte ( p ) ... ) } b = append ( b , [ ] byte ( clustername ) ... ) if now ! = nil { b = append ( b , [ ] byte ( fmt . sprintf ( " " , now . unix ( ) ) ) ... ) } hash : = sha1 . sum ( b ) m . id = types . id ( binary . bigendian . uint64 ( hash [ : 8 ] ) ) return m } 
func ( m * member ) pickpeerurl ( ) string { if len ( m . peerurls ) == 0 { panic ( " " ) } return m . peerurls [ rand . intn ( len ( m . peerurls ) ) ] } 
func handlemetricshealth ( mux * http . servemux , srv etcdserver . serverv2 ) { mux . handle ( pathmetrics , promhttp . handler ( ) ) mux . handle ( pathhealth , newhealthhandler ( func ( ) health { return checkhealth ( srv ) } ) ) } 
func newhealthhandler ( hfunc func ( ) health ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { if r . method ! = http . methodget { w . header ( ) . set ( " " , http . methodget ) http . error ( w , " " , http . statusmethodnotallowed ) return } h : = hfunc ( ) d , : = json . marshal ( h ) if h . health ! = " " { http . error ( w , string ( d ) , http . statusserviceunavailable ) return } w . writeheader ( http . statusok ) w . write ( d ) } } 
func checkhealth ( srv etcdserver . serverv2 ) health { h : = health { health : " " } as : = srv . alarms ( ) if len ( as ) > 0 { h . health = " " } if h . health == " " { if uint64 ( srv . leader ( ) ) == raft . none { h . health = " " } } if h . health == " " { ctx , cancel : = context . withtimeout ( context . background ( ) , time . second ) , err : = srv . do ( ctx , etcdserverpb . request { method : " " } ) cancel ( ) if err ! = nil { h . health = " " } } if h . health == " " { healthsuccess . inc ( ) } else { healthfailed . inc ( ) } return h } 
func newremovecommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , flags : [ ] cli . flag { cli . boolflag { name : " " , usage : " " } , cli . boolflag { name : " " , usage : " " } , cli . stringflag { name : " " , value : " " , usage : " " } , cli . intflag { name : " " , value : 0 , usage : " " } , } , action : func ( c * cli . context ) error { rmcommandfunc ( c , mustnewkeyapi ( c ) ) return nil } , } } 
func rmcommandfunc ( c * cli . context , ki client . keysapi ) { if len ( c . args ( ) ) == 0 { handleerror ( c , exitbadargs , errors . new ( " " ) ) } key : = c . args ( ) [ 0 ] recursive : = c . bool ( " " ) dir : = c . bool ( " " ) prevvalue : = c . string ( " " ) previndex : = c . int ( " " ) ctx , cancel : = contextwithtotaltimeout ( c ) resp , err : = ki . delete ( ctx , key , & client . deleteoptions { previndex : uint64 ( previndex ) , prevvalue : prevvalue , dir : dir , recursive : recursive } ) cancel ( ) if err ! = nil { handleerror ( c , exitservererror , err ) } if ! resp . node . dir | | c . globalstring ( " " ) ! = " " { printresponsekey ( resp , c . globalstring ( " " ) ) } } 
func reporteventreceived ( n int ) { pendingeventsgauge . sub ( float64 ( n ) ) totaleventscounter . add ( float64 ( n ) ) } 
func startetcd ( cfg * embed . config ) ( < - chan struct { } , < - chan error , error ) { e , err : = embed . startetcd ( cfg ) if err ! = nil { return nil , nil , err } osutil . registerinterrupthandler ( e . close ) select { case < - e . server . readynotify ( ) : case < - e . server . stopnotify ( ) : } return e . server . stopnotify ( ) , e . err ( ) , nil } 
func identifydatadirordie ( lg * zap . logger , dir string ) dirtype { names , err : = fileutil . readdir ( dir ) if err ! = nil { if os . isnotexist ( err ) { return dirempty } if lg ! = nil { lg . fatal ( " " , zap . string ( " " , dir ) , zap . error ( err ) ) } else { plog . fatalf ( " " , dir ) } } var m , p bool for , name : = range names { switch dirtype ( name ) { case dirmember : m = true case dirproxy : p = true default : if lg ! = nil { lg . warn ( " " , zap . string ( " " , name ) , zap . string ( " " , dir ) , ) } else { plog . warningf ( " " , name , dir ) } } } if m && p { if lg ! = nil { lg . fatal ( " " ) } else { plog . fatal ( " " ) } } if m { return dirmember } if p { return dirproxy } return dirempty } 
func openlast ( lg * zap . logger , dirpath string ) ( * fileutil . lockedfile , error ) { names , err : = readwalnames ( lg , dirpath ) if err ! = nil { return nil , err } last : = filepath . join ( dirpath , names [ len ( names ) - 1 ] ) return fileutil . lockfile ( last , os . o rdwr , fileutil . privatefilemode ) } 
func ( l * leader ) gotleader ( ) { l . mu . lock ( ) defer l . mu . unlock ( ) select { case < - l . leaderc : l . leaderc = make ( chan struct { } ) default : } } 
func ( l * leader ) lostnotify ( ) < - chan struct { } { l . mu . rlock ( ) defer l . mu . runlock ( ) return l . leaderc } 
func newgrpcproxycommand ( ) * cobra . command { lpc : = & cobra . command { use : " " , short : " " , } lpc . addcommand ( newgrpcproxystartcommand ( ) ) return lpc } 
func newmembercommand ( ) * cobra . command { mc : = & cobra . command { use : " " , short : " " , } mc . addcommand ( newmemberaddcommand ( ) ) mc . addcommand ( newmemberremovecommand ( ) ) mc . addcommand ( newmemberupdatecommand ( ) ) mc . addcommand ( newmemberlistcommand ( ) ) return mc } 
func newmemberaddcommand ( ) * cobra . command { cc : = & cobra . command { use : " " , short : " " , run : memberaddcommandfunc , } cc . flags ( ) . stringvar ( & memberpeerurls , " " , " " , " " ) return cc } 
func newmemberremovecommand ( ) * cobra . command { cc : = & cobra . command { use : " " , short : " " , run : memberremovecommandfunc , } return cc } 
func newmemberupdatecommand ( ) * cobra . command { cc : = & cobra . command { use : " " , short : " " , run : memberupdatecommandfunc , } cc . flags ( ) . stringvar ( & memberpeerurls , " " , " " , " " ) return cc } 
func newmemberlistcommand ( ) * cobra . command { cc : = & cobra . command { use : " " , short : " " , long : , run : memberlistcommandfunc , } return cc } 
func memberremovecommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } id , err : = strconv . parseuint ( args [ 0 ] , 16 , 64 ) if err ! = nil { exitwitherror ( exitbadargs , fmt . errorf ( " " , err ) ) } ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . memberremove ( ctx , id ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . memberremove ( id , * resp ) } 
func memberupdatecommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } id , err : = strconv . parseuint ( args [ 0 ] , 16 , 64 ) if err ! = nil { exitwitherror ( exitbadargs , fmt . errorf ( " " , err ) ) } if len ( memberpeerurls ) == 0 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } urls : = strings . split ( memberpeerurls , " " ) ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . memberupdate ( ctx , id , urls ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . memberupdate ( id , * resp ) } 
func memberlistcommandfunc ( cmd * cobra . command , args [ ] string ) { ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . memberlist ( ctx ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . memberlist ( * resp ) } 
func open ( lg * zap . logger , dirpath string , snap walpb . snapshot ) ( * wal , error ) { w , err : = openatindex ( lg , dirpath , snap , true ) if err ! = nil { return nil , err } if w . dirfile , err = fileutil . opendir ( w . dir ) ; err ! = nil { return nil , err } return w , nil } 
func openforread ( lg * zap . logger , dirpath string , snap walpb . snapshot ) ( * wal , error ) { return openatindex ( lg , dirpath , snap , false ) } 
func verify ( lg * zap . logger , waldir string , snap walpb . snapshot ) error { var metadata [ ] byte var err error var match bool rec : = & walpb . record { } names , nameindex , err : = selectwalfiles ( lg , waldir , snap ) if err ! = nil { return err } rs , , closer , err : = openwalfiles ( lg , waldir , names , nameindex , false ) if err ! = nil { return err } decoder : = newdecoder ( rs ... ) for err = decoder . decode ( rec ) ; err == nil ; err = decoder . decode ( rec ) { switch rec . type { case metadatatype : if metadata ! = nil && ! bytes . equal ( metadata , rec . data ) { return errmetadataconflict } metadata = rec . data case crctype : crc : = decoder . crc . sum32 ( ) if crc ! = 0 && rec . validate ( crc ) ! = nil { return errcrcmismatch } decoder . updatecrc ( rec . crc ) case snapshottype : var loadedsnap walpb . snapshot pbutil . mustunmarshal ( & loadedsnap , rec . data ) if loadedsnap . index == snap . index { if loadedsnap . term ! = snap . term { return errsnapshotmismatch } match = true } case entrytype : case statetype : default : return fmt . errorf ( " " , rec . type ) } } if closer ! = nil { closer ( ) } if err ! = io . eof && err ! = io . errunexpectedeof { return err } if ! match { return errsnapshotnotfound } return nil } 
func ( w * wal ) close ( ) error { w . mu . lock ( ) defer w . mu . unlock ( ) if w . fp ! = nil { w . fp . close ( ) w . fp = nil } if w . tail ( ) ! = nil { if err : = w . sync ( ) ; err ! = nil { return err } } for , l : = range w . locks { if l == nil { continue } if err : = l . close ( ) ; err ! = nil { if w . lg ! = nil { w . lg . warn ( " " , zap . error ( err ) ) } else { plog . errorf ( " " , err ) } } } return w . dirfile . close ( ) } 
func ( w * watcher ) notify ( e * event , originalpath bool , deleted bool ) bool { if ( w . recursive | | originalpath | | deleted ) && e . index ( ) >= w . sinceindex { select { case w . eventchan < - e : default : w . remove ( ) } return true } return false } 
func ( w * watcher ) remove ( ) { w . hub . mutex . lock ( ) defer w . hub . mutex . unlock ( ) close ( w . eventchan ) if w . remove ! = nil { w . remove ( ) } } 
func preallocate ( f * os . file , sizeinbytes int64 , extendfile bool ) error { if sizeinbytes == 0 { return nil } if extendfile { return preallocextend ( f , sizeinbytes ) } return preallocfixed ( f , sizeinbytes ) } 
func ( s * v2v3store ) mkpathdepth ( nodepath string , depth int ) string { normalform : = path . clean ( path . join ( " " , nodepath ) ) n : = strings . count ( normalform , " " ) + depth return fmt . sprintf ( " " , s . pfx , n , normalform ) } 
func ( s * v2v3store ) mkv2node ( kv * mvccpb . keyvalue ) * v2store . nodeextern { if kv == nil { return nil } n : = & v2store . nodeextern { key : s . mknodepath ( string ( kv . key ) ) , dir : kv . key [ len ( kv . key ) - 1 ] == ' / ' , createdindex : mkv2rev ( kv . createrevision ) , modifiedindex : mkv2rev ( kv . modrevision ) , } if ! n . dir { v : = string ( kv . value ) n . value = & v } return n } 
func prevkeyfromputs ( resp * clientv3 . txnresponse ) * mvccpb . keyvalue { for , r : = range resp . responses { pkv : = r . getresponseput ( ) . prevkv if pkv ! = nil && pkv . createrevision > 0 { return pkv } } return nil } 
func newweightedreport ( r report , precision string ) report { return & weightedreport { basereport : r , report : newreport ( precision ) , results : make ( chan result , 16 ) , } } 
func handlehealth ( mux * http . servemux , c * clientv3 . client ) { mux . handle ( etcdhttp . pathhealth , etcdhttp . newhealthhandler ( func ( ) etcdhttp . health { return checkhealth ( c ) } ) ) } 
func newurlsmapfromstringmap ( m map [ string ] string , sep string ) ( urlsmap , error ) { var err error um : = urlsmap { } for k , v : = range m { um [ k ] , err = newurls ( strings . split ( v , sep ) ) if err ! = nil { return nil , err } } return um , nil } 
func ( c urlsmap ) string ( ) string { var pairs [ ] string for name , urls : = range c { for , url : = range urls { pairs = append ( pairs , fmt . sprintf ( " " , name , url . string ( ) ) ) } } sort . strings ( pairs ) return strings . join ( pairs , " " ) } 
func ( c urlsmap ) urls ( ) [ ] string { var urls [ ] string for , us : = range c { for , u : = range us { urls = append ( urls , u . string ( ) ) } } sort . strings ( urls ) return urls } 
func parse ( s string ) map [ string ] [ ] string { m : = make ( map [ string ] [ ] string ) for s ! = " " { key : = s if i : = strings . indexany ( key , " " ) ; i >= 0 { key , s = key [ : i ] , key [ i + 1 : ] } else { s = " " } if key == " " { continue } value : = " " if i : = strings . index ( key , " " ) ; i >= 0 { key , value = key [ : i ] , key [ i + 1 : ] } m [ key ] = append ( m [ key ] , value ) } return m } 
func writekeyevent ( w http . responsewriter , resp etcdserver . response , novalueonsuccess bool ) error { ev : = resp . event if ev == nil { return errors . new ( " " ) } w . header ( ) . set ( " " , " " ) w . header ( ) . set ( " " , fmt . sprint ( ev . etcdindex ) ) w . header ( ) . set ( " " , fmt . sprint ( resp . index ) ) w . header ( ) . set ( " " , fmt . sprint ( resp . term ) ) if ev . iscreated ( ) { w . writeheader ( http . statuscreated ) } ev = trimeventprefix ( ev , etcdserver . storekeysprefix ) if novalueonsuccess && ( ev . action == v2store . set | | ev . action == v2store . compareandswap | | ev . action == v2store . create | | ev . action == v2store . update ) { ev . node = nil ev . prevnode = nil } return json . newencoder ( w ) . encode ( ev ) } 
func writekeyerror ( lg * zap . logger , w http . responsewriter , err error ) { if err == nil { return } switch e : = err . ( type ) { case * v2error . error : e . writeto ( w ) default : switch err { case etcdserver . errtimeoutduetoleaderfail , etcdserver . errtimeoutduetoconnectionlost : if lg ! = nil { lg . warn ( " " , zap . string ( " " , err . error ( ) ) , ) } else { mlog . mergeerror ( err ) } default : if lg ! = nil { lg . warn ( " " , zap . string ( " " , err . error ( ) ) , ) } else { mlog . mergeerrorf ( " " , err ) } } ee : = v2error . newerror ( v2error . ecoderaftinternal , err . error ( ) , 0 ) ee . writeto ( w ) } } 
func getuint64 ( form url . values , key string ) ( i uint64 , err error ) { if vals , ok : = form [ key ] ; ok { i , err = strconv . parseuint ( vals [ 0 ] , 10 , 64 ) } return } 
func getbool ( form url . values , key string ) ( b bool , err error ) { if vals , ok : = form [ key ] ; ok { b , err = strconv . parsebool ( vals [ 0 ] ) } return } 
func trimprefix ( p , prefix string ) ( s string ) { s = strings . trimprefix ( p , prefix ) s = strings . trimprefix ( s , " " ) return } 
func waitdeletes ( ctx context . context , client * v3 . client , pfx string , maxcreaterev int64 ) ( * pb . responseheader , error ) { getopts : = append ( v3 . withlastcreate ( ) , v3 . withmaxcreaterev ( maxcreaterev ) ) for { resp , err : = client . get ( ctx , pfx , getopts ... ) if err ! = nil { return nil , err } if len ( resp . kvs ) == 0 { return resp . header , nil } lastkey : = string ( resp . kvs [ 0 ] . key ) if err = waitdelete ( ctx , client , lastkey , resp . header . revision ) ; err ! = nil { return nil , err } } } 
func addoutputpaths ( cfg zap . config , outputpaths , erroroutputpaths [ ] string ) zap . config { outputs : = make ( map [ string ] struct { } ) for , v : = range cfg . outputpaths { outputs [ v ] = struct { } { } } for , v : = range outputpaths { outputs [ v ] = struct { } { } } outputslice : = make ( [ ] string , 0 ) if , ok : = outputs [ " " ] ; ok { outputslice = [ ] string { " " } } else { for k : = range outputs { outputslice = append ( outputslice , k ) } } cfg . outputpaths = outputslice sort . strings ( cfg . outputpaths ) erroutputs : = make ( map [ string ] struct { } ) for , v : = range cfg . erroroutputpaths { erroutputs [ v ] = struct { } { } } for , v : = range erroroutputpaths { erroutputs [ v ] = struct { } { } } erroutputslice : = make ( [ ] string , 0 ) if , ok : = erroutputs [ " " ] ; ok { erroutputslice = [ ] string { " " } } else { for k : = range erroutputs { erroutputslice = append ( erroutputslice , k ) } } cfg . erroroutputpaths = erroutputslice sort . strings ( cfg . erroroutputpaths ) return cfg } 
func newconfig ( ) * config { lpurl , : = url . parse ( defaultlistenpeerurls ) apurl , : = url . parse ( defaultinitialadvertisepeerurls ) lcurl , : = url . parse ( defaultlistenclienturls ) acurl , : = url . parse ( defaultadvertiseclienturls ) cfg : = & config { maxsnapfiles : defaultmaxsnapshots , maxwalfiles : defaultmaxwals , name : defaultname , snapshotcount : etcdserver . defaultsnapshotcount , snapshotcatchupentries : etcdserver . defaultsnapshotcatchupentries , maxtxnops : defaultmaxtxnops , maxrequestbytes : defaultmaxrequestbytes , grpckeepalivemintime : defaultgrpckeepalivemintime , grpckeepaliveinterval : defaultgrpckeepaliveinterval , grpckeepalivetimeout : defaultgrpckeepalivetimeout , tickms : 100 , electionms : 1000 , initialelectiontickadvance : true , lpurls : [ ] url . url { * lpurl } , lcurls : [ ] url . url { * lcurl } , apurls : [ ] url . url { * apurl } , acurls : [ ] url . url { * acurl } , clusterstate : clusterstateflagnew , initialclustertoken : " " , strictreconfigcheck : defaultstrictreconfigcheck , metrics : " " , enablev2 : defaultenablev2 , cors : map [ string ] struct { } { " " : { } } , hostwhitelist : map [ string ] struct { } { " " : { } } , authtoken : " " , bcryptcost : uint ( bcrypt . defaultcost ) , prevote : false , loggermu : new ( sync . rwmutex ) , logger : nil , logger : " " , deprecatedlogoutput : [ ] string { defaultlogoutput } , logoutputs : [ ] string { defaultlogoutput } , debug : false , logpkglevels : " " , } cfg . initialcluster = cfg . initialclusterfromname ( cfg . name ) return cfg } 
func ( cfg * config ) peerurlsmapandtoken ( which string ) ( urlsmap types . urlsmap , token string , err error ) { token = cfg . initialclustertoken switch { case cfg . durl ! = " " : urlsmap = types . urlsmap { } urlsmap [ cfg . name ] = cfg . apurls token = cfg . durl case cfg . dnscluster ! = " " : clusterstrs , cerr : = cfg . getdnsclusternames ( ) lg : = cfg . logger if cerr ! = nil { if lg ! = nil { lg . warn ( " " , zap . error ( cerr ) ) } else { plog . errorf ( " " , cerr ) } return nil , " " , cerr } for , s : = range clusterstrs { if lg ! = nil { lg . info ( " " , zap . string ( " " , s ) ) } else { plog . noticef ( " " , s ) } } clusterstr : = strings . join ( clusterstrs , " " ) if strings . contains ( clusterstr , " " ) && cfg . peertlsinfo . trustedcafile == " " { cfg . peertlsinfo . servername = cfg . dnscluster } urlsmap , err = types . newurlsmap ( clusterstr ) if which == " " { if , ok : = urlsmap [ cfg . name ] ; ! ok { return nil , " " , fmt . errorf ( " " , cfg . name ) } } default : urlsmap , err = types . newurlsmap ( cfg . initialcluster ) } return urlsmap , token , err } 
func ( cfg * config ) updatedefaultclusterfromname ( defaultinitialcluster string ) ( string , error ) { if defaulthostname == " " | | defaulthoststatus ! = nil { if cfg . name ! = defaultname && cfg . initialcluster == defaultinitialcluster { cfg . initialcluster = cfg . initialclusterfromname ( cfg . name ) } return " " , defaulthoststatus } used : = false pip , pport : = cfg . lpurls [ 0 ] . hostname ( ) , cfg . lpurls [ 0 ] . port ( ) if cfg . defaultpeerhost ( ) && pip == " " { cfg . apurls [ 0 ] = url . url { scheme : cfg . apurls [ 0 ] . scheme , host : fmt . sprintf ( " " , defaulthostname , pport ) } used = true } if cfg . name ! = defaultname && cfg . initialcluster == defaultinitialcluster { cfg . initialcluster = cfg . initialclusterfromname ( cfg . name ) } cip , cport : = cfg . lcurls [ 0 ] . hostname ( ) , cfg . lcurls [ 0 ] . port ( ) if cfg . defaultclienthost ( ) && cip == " " { cfg . acurls [ 0 ] = url . url { scheme : cfg . acurls [ 0 ] . scheme , host : fmt . sprintf ( " " , defaulthostname , cport ) } used = true } dhost : = defaulthostname if ! used { dhost = " " } return dhost , defaulthoststatus } 
func checkbindurls ( urls [ ] url . url ) error { for , url : = range urls { if url . scheme == " " | | url . scheme == " " { continue } host , , err : = net . splithostport ( url . host ) if err ! = nil { return err } if host == " " { continue } if net . parseip ( host ) == nil { return fmt . errorf ( " " , url . string ( ) ) } } return nil } 
func getclient ( service , domain string , servicename string ) ( * srvclients , error ) { var urls [ ] * url . url var srvs [ ] * net . srv updateurls : = func ( service , scheme string ) error { , addrs , err : = lookupsrv ( service , " " , domain ) if err ! = nil { return err } for , srv : = range addrs { urls = append ( urls , & url . url { scheme : scheme , host : net . joinhostport ( srv . target , fmt . sprintf ( " " , srv . port ) ) , } ) } srvs = append ( srvs , addrs ... ) return nil } errhttps : = updateurls ( getsrvservice ( service , servicename , " " ) , " " ) errhttp : = updateurls ( getsrvservice ( service , servicename , " " ) , " " ) if errhttps ! = nil && errhttp ! = nil { return nil , fmt . errorf ( " " , errhttps , errhttp ) } endpoints : = make ( [ ] string , len ( urls ) ) for i : = range urls { endpoints [ i ] = urls [ i ] . string ( ) } return & srvclients { endpoints : endpoints , srvs : srvs } , nil } 
func getsrvservice ( service , servicename string , scheme string ) ( srvservice string ) { if scheme == " " { service = fmt . sprintf ( " " , service ) } if servicename ! = " " { return fmt . sprintf ( " " , service , servicename ) } return service } 
func readdir ( d string , opts ... readdiroption ) ( [ ] string , error ) { op : = & readdirop { } op . applyopts ( opts ) dir , err : = os . open ( d ) if err ! = nil { return nil , err } defer dir . close ( ) names , err : = dir . readdirnames ( - 1 ) if err ! = nil { return nil , err } sort . strings ( names ) if op . ext ! = " " { tss : = make ( [ ] string , 0 ) for , v : = range names { if filepath . ext ( v ) == op . ext { tss = append ( tss , v ) } } names = tss } return names , nil } 
func ( s * etcdserver ) createmergedsnapshotmessage ( m raftpb . message , snapt , snapi uint64 , confstate raftpb . confstate ) snap . message { clone : = s . v2store . clone ( ) d , err : = clone . savenocopy ( ) if err ! = nil { if lg : = s . getlogger ( ) ; lg ! = nil { lg . panic ( " " , zap . error ( err ) ) } else { plog . panicf ( " " , err ) } } s . kv ( ) . commit ( ) dbsnap : = s . be . snapshot ( ) rc : = newsnapshotreadercloser ( s . getlogger ( ) , dbsnap ) snapshot : = raftpb . snapshot { metadata : raftpb . snapshotmetadata { index : snapi , term : snapt , confstate : confstate , } , data : d , } m . snapshot = snapshot return * snap . newmessage ( m , rc , dbsnap . size ( ) ) } 
func endpointmemorymetrics ( host string ) float64 { residentmemorykey : = " " var residentmemoryvalue string if ! strings . hasprefix ( host , ) { host = " " + host } url : = host + " " resp , err : = http . get ( url ) if err ! = nil { fmt . println ( fmt . sprintf ( " " , err ) ) return 0 . 0 } byts , readerr : = ioutil . readall ( resp . body ) resp . body . close ( ) if readerr ! = nil { fmt . println ( fmt . sprintf ( " " , url , readerr ) ) return 0 . 0 } for , line : = range strings . split ( string ( byts ) , " \n " ) { if strings . hasprefix ( line , residentmemorykey ) { residentmemoryvalue = strings . trimspace ( strings . trimprefix ( line , residentmemorykey ) ) break } } if residentmemoryvalue == " " { fmt . println ( fmt . sprintf ( " " , residentmemorykey ) ) return 0 . 0 } residentmemorybytes , parseerr : = strconv . parsefloat ( residentmemoryvalue , 64 ) if parseerr ! = nil { fmt . println ( fmt . sprintf ( " " , parseerr ) ) return 0 . 0 } return residentmemorybytes } 
func compact ( c * v3 . client , rev int64 ) { fmt . printf ( " \n " , rev ) ctx , cancel : = context . withtimeout ( context . background ( ) , 30 * time . second ) , err : = c . compact ( ctx , rev , v3 . withcompactphysical ( ) ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } fmt . printf ( " \n " , rev ) } 
func defrag ( c * v3 . client , ep string ) { fmt . printf ( " \n " , ep ) ctx , cancel : = context . withtimeout ( context . background ( ) , 30 * time . second ) , err : = c . defragment ( ctx , ep ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } fmt . printf ( " \n " , ep ) } 
func newusercommand ( ) * cobra . command { ac : = & cobra . command { use : " " , short : " " , } ac . addcommand ( newuseraddcommand ( ) ) ac . addcommand ( newuserdeletecommand ( ) ) ac . addcommand ( newusergetcommand ( ) ) ac . addcommand ( newuserlistcommand ( ) ) ac . addcommand ( newuserchangepasswordcommand ( ) ) ac . addcommand ( newusergrantrolecommand ( ) ) ac . addcommand ( newuserrevokerolecommand ( ) ) return ac } 
func useraddcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } var password string var user string if passwordfromflag ! = " " { user = args [ 0 ] password = passwordfromflag } else { splitted : = strings . splitn ( args [ 0 ] , " " , 2 ) if len ( splitted ) < 2 { user = args [ 0 ] if ! passwordinteractive { fmt . scanf ( " " , & password ) } else { password = readpasswordinteractive ( args [ 0 ] ) } } else { user = splitted [ 0 ] password = splitted [ 1 ] if len ( user ) == 0 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } } } resp , err : = mustclientfromcmd ( cmd ) . auth . useradd ( context . todo ( ) , user , password ) if err ! = nil { exitwitherror ( exiterror , err ) } display . useradd ( user , * resp ) } 
func usergetcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } name : = args [ 0 ] client : = mustclientfromcmd ( cmd ) resp , err : = client . auth . userget ( context . todo ( ) , name ) if err ! = nil { exitwitherror ( exiterror , err ) } if usershowdetail { fmt . printf ( " \n " , name ) for , role : = range resp . roles { fmt . printf ( " \n " ) roleresp , err : = client . auth . roleget ( context . todo ( ) , role ) if err ! = nil { exitwitherror ( exiterror , err ) } display . roleget ( role , * roleresp ) } } else { display . userget ( name , * resp ) } } 
func userchangepasswordcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } var password string if ! passwordinteractive { fmt . scanf ( " " , & password ) } else { password = readpasswordinteractive ( args [ 0 ] ) } resp , err : = mustclientfromcmd ( cmd ) . auth . userchangepassword ( context . todo ( ) , args [ 0 ] , password ) if err ! = nil { exitwitherror ( exiterror , err ) } display . userchangepassword ( * resp ) } 
func ( eh * eventhistory ) addevent ( e * event ) * event { eh . rwl . lock ( ) defer eh . rwl . unlock ( ) eh . queue . insert ( e ) eh . lastindex = e . index ( ) eh . startindex = eh . queue . events [ eh . queue . front ] . index ( ) return e } 
func ( eh * eventhistory ) scan ( key string , recursive bool , index uint64 ) ( * event , * v2error . error ) { eh . rwl . rlock ( ) defer eh . rwl . runlock ( ) if index < eh . startindex { return nil , v2error . newerror ( v2error . ecodeeventindexcleared , fmt . sprintf ( " " , eh . startindex , index ) , 0 ) } if index > eh . lastindex { return nil , nil } offset : = index - eh . startindex i : = ( eh . queue . front + int ( offset ) ) % eh . queue . capacity for { e : = eh . queue . events [ i ] if ! e . refresh { ok : = e . node . key == key if recursive { nkey : = path . clean ( key ) if nkey [ len ( nkey ) - 1 ] ! = ' / ' { nkey = nkey + " " } ok = ok | | strings . hasprefix ( e . node . key , nkey ) } if ( e . action == delete | | e . action == expire ) && e . prevnode ! = nil && e . prevnode . dir { ok = ok | | strings . hasprefix ( key , e . prevnode . key ) } if ok { return e , nil } } i = ( i + 1 ) % eh . queue . capacity if i == eh . queue . back { return nil , nil } } } 
func ( eh * eventhistory ) clone ( ) * eventhistory { clonedqueue : = eventqueue { capacity : eh . queue . capacity , events : make ( [ ] * event , eh . queue . capacity ) , size : eh . queue . size , front : eh . queue . front , back : eh . queue . back , } copy ( clonedqueue . events , eh . queue . events ) return & eventhistory { startindex : eh . startindex , queue : clonedqueue , lastindex : eh . lastindex , } } 
func opensnapshotbackend ( cfg serverconfig , ss * snap . snapshotter , snapshot raftpb . snapshot ) ( backend . backend , error ) { snappath , err : = ss . dbfilepath ( snapshot . metadata . index ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if err : = os . rename ( snappath , cfg . backendpath ( ) ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } return openbackend ( cfg ) , nil } 
func openbackend ( cfg serverconfig ) backend . backend { fn : = cfg . backendpath ( ) now , beopened : = time . now ( ) , make ( chan backend . backend ) go func ( ) { beopened < - newbackend ( cfg ) } ( ) select { case be : = < - beopened : if cfg . logger ! = nil { cfg . logger . info ( " " , zap . string ( " " , fn ) , zap . duration ( " " , time . since ( now ) ) ) } return be case < - time . after ( 10 * time . second ) : if cfg . logger ! = nil { cfg . logger . info ( " " , zap . string ( " " , fn ) , zap . duration ( " " , time . since ( now ) ) , ) } else { plog . warningf ( " " , fn ) plog . warningf ( " " ) } } return < - beopened } 
func recoversnapshotbackend ( cfg serverconfig , oldbe backend . backend , snapshot raftpb . snapshot ) ( backend . backend , error ) { var cindex consistentindex kv : = mvcc . new ( cfg . logger , oldbe , & lease . fakelessor { } , & cindex ) defer kv . close ( ) if snapshot . metadata . index <= kv . consistentindex ( ) { return oldbe , nil } oldbe . close ( ) return opensnapshotbackend ( cfg , snap . new ( cfg . logger , cfg . snapdir ( ) ) , snapshot ) } 
func newupdatecommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , flags : [ ] cli . flag { cli . intflag { name : " " , value : 0 , usage : " " } , } , action : func ( c * cli . context ) error { updatecommandfunc ( c , mustnewkeyapi ( c ) ) return nil } , } } 
func updatecommandfunc ( c * cli . context , ki client . keysapi ) { if len ( c . args ( ) ) == 0 { handleerror ( c , exitbadargs , errors . new ( " " ) ) } key : = c . args ( ) [ 0 ] value , err : = argorstdin ( c . args ( ) , os . stdin , 1 ) if err ! = nil { handleerror ( c , exitbadargs , errors . new ( " " ) ) } ttl : = c . int ( " " ) ctx , cancel : = contextwithtotaltimeout ( c ) resp , err : = ki . set ( ctx , key , value , & client . setoptions { ttl : time . duration ( ttl ) * time . second , prevexist : client . prevexist } ) cancel ( ) if err ! = nil { handleerror ( c , exitservererror , err ) } printresponsekey ( resp , c . globalstring ( " " ) ) } 
func ( q * statsqueue ) frontandback ( ) ( * requeststats , * requeststats ) { q . rwl . rlock ( ) defer q . rwl . runlock ( ) if q . size ! = 0 { return q . items [ q . front ] , q . items [ q . back ] } return nil , nil } 
func ( q * statsqueue ) insert ( p * requeststats ) { q . rwl . lock ( ) defer q . rwl . unlock ( ) q . back = ( q . back + 1 ) % queuecapacity if q . size == queuecapacity { q . totalreqsize - = q . items [ q . front ] . size q . front = ( q . back + 1 ) % queuecapacity } else { q . size ++ } q . items [ q . back ] = p q . totalreqsize += q . items [ q . back ] . size } 
func ( q * statsqueue ) rate ( ) ( float64 , float64 ) { front , back : = q . frontandback ( ) if front == nil | | back == nil { return 0 , 0 } if time . since ( back . sendingtime ) > time . second { q . clear ( ) return 0 , 0 } sampleduration : = back . sendingtime . sub ( front . sendingtime ) pr : = float64 ( q . len ( ) ) / float64 ( sampleduration ) * float64 ( time . second ) br : = float64 ( q . reqsize ( ) ) / float64 ( sampleduration ) * float64 ( time . second ) return pr , br } 
func ( q * statsqueue ) clear ( ) { q . rwl . lock ( ) defer q . rwl . unlock ( ) q . back = - 1 q . front = 0 q . size = 0 q . totalreqsize = 0 } 
func uniquestrings ( slen uint , n int ) ( ss [ ] string ) { exist : = make ( map [ string ] struct { } ) ss = make ( [ ] string , 0 , n ) for len ( ss ) < n { s : = randstring ( slen ) if , ok : = exist [ s ] ; ! ok { ss = append ( ss , s ) exist [ s ] = struct { } { } } } return ss } 
func randomstrings ( slen uint , n int ) ( ss [ ] string ) { ss = make ( [ ] string , 0 , n ) for i : = 0 ; i < n ; i ++ { ss = append ( ss , randstring ( slen ) ) } return ss } 
func iskeynotfound ( err error ) bool { if cerr , ok : = err . ( error ) ; ok { return cerr . code == errorcodekeynotfound } return false } 
func isrolenotfound ( err error ) bool { if ae , ok : = err . ( autherror ) ; ok { return rolenotfoundregexp . matchstring ( ae . message ) } return false } 
func isusernotfound ( err error ) bool { if ae , ok : = err . ( autherror ) ; ok { return usernotfoundregexp . matchstring ( ae . message ) } return false } 
func joincluster ( lg * zap . logger , durl , dproxyurl string , id types . id , config string ) ( string , error ) { d , err : = newdiscovery ( lg , durl , dproxyurl , id ) if err ! = nil { return " " , err } return d . joincluster ( config ) } 
func getcluster ( lg * zap . logger , durl , dproxyurl string ) ( string , error ) { d , err : = newdiscovery ( lg , durl , dproxyurl , 0 ) if err ! = nil { return " " , err } return d . getcluster ( ) } 
func newproxyfunc ( lg * zap . logger , proxy string ) ( func ( * http . request ) ( * url . url , error ) , error ) { if proxy == " " { return nil , nil } proxyurl , err : = url . parse ( proxy ) if err ! = nil | | ! strings . hasprefix ( proxyurl . scheme , " " ) { var err2 error proxyurl , err2 = url . parse ( " " + proxy ) if err2 == nil { err = nil } } if err ! = nil { return nil , fmt . errorf ( " " , proxy , err ) } if lg ! = nil { lg . info ( " " , zap . string ( " " , proxyurl . string ( ) ) ) } else { plog . infof ( " " , proxyurl . string ( ) ) } return http . proxyurl ( proxyurl ) , nil } 
func ( c * client ) streamclientinterceptor ( logger * zap . logger , optfuncs ... retryoption ) grpc . streamclientinterceptor { intopts : = reuseornewwithcalloptions ( defaultoptions , optfuncs ) return func ( ctx context . context , desc * grpc . streamdesc , cc * grpc . clientconn , method string , streamer grpc . streamer , opts ... grpc . calloption ) ( grpc . clientstream , error ) { grpcopts , retryopts : = filtercalloptions ( opts ) callopts : = reuseornewwithcalloptions ( intopts , retryopts ) if callopts . max == 0 { return streamer ( ctx , desc , cc , method , grpcopts ... ) } if desc . clientstreams { return nil , grpc . errorf ( codes . unimplemented , " " ) } newstreamer , err : = streamer ( ctx , desc , cc , method , grpcopts ... ) logger . warn ( " " , zap . error ( err ) ) if err ! = nil { return nil , err } retryingstreamer : = & serverstreamingretryingstream { client : c , clientstream : newstreamer , callopts : callopts , ctx : ctx , streamercall : func ( ctx context . context ) ( grpc . clientstream , error ) { return streamer ( ctx , desc , cc , method , grpcopts ... ) } , } return retryingstreamer , nil } } 
func issaferetry ( lg * zap . logger , err error , callopts * options ) bool { if iscontexterror ( err ) { return false } switch callopts . retrypolicy { case repeatable : return issaferetryimmutablerpc ( err ) case nonrepeatable : return issaferetrymutablerpc ( err ) default : lg . warn ( " " , zap . string ( " " , callopts . retrypolicy . string ( ) ) ) return false } } 
func withretrypolicy ( rp retrypolicy ) retryoption { return retryoption { applyfunc : func ( o * options ) { o . retrypolicy = rp } } } 
func withauthretry ( retryauth bool ) retryoption { return retryoption { applyfunc : func ( o * options ) { o . retryauth = retryauth } } } 
func withmax ( maxretries uint ) retryoption { return retryoption { applyfunc : func ( o * options ) { o . max = maxretries } } } 
func withbackoff ( bf backofffunc ) retryoption { return retryoption { applyfunc : func ( o * options ) { o . backofffunc = bf } } } 
func backofflinearwithjitter ( waitbetween time . duration , jitterfraction float64 ) backofffunc { return func ( attempt uint ) time . duration { return jitterup ( waitbetween , jitterfraction ) } } 
func ( ss * serverstats ) recvappendreq ( leader string , reqsize int ) { ss . lock ( ) defer ss . unlock ( ) now : = time . now ( ) ss . state = raft . statefollower if leader ! = ss . leaderinfo . name { ss . leaderinfo . name = leader ss . leaderinfo . starttime = now } ss . recvratequeue . insert ( & requeststats { sendingtime : now , size : reqsize , } , ) ss . recvappendrequestcnt ++ } 
func ( ss * serverstats ) sendappendreq ( reqsize int ) { ss . lock ( ) defer ss . unlock ( ) ss . becomeleader ( ) ss . sendratequeue . insert ( & requeststats { sendingtime : time . now ( ) , size : reqsize , } , ) ss . sendappendrequestcnt ++ } 
func newpackagelogger ( repo , pkg string ) logger { return & packagelogger { p : capnslog . newpackagelogger ( repo , pkg ) } } 
func ( bb * bucketbuffer ) merge ( bbsrc * bucketbuffer ) { for i : = 0 ; i < bbsrc . used ; i ++ { bb . add ( bbsrc . buf [ i ] . key , bbsrc . buf [ i ] . val ) } if bb . used == bbsrc . used { return } if bytes . compare ( bb . buf [ ( bb . used - bbsrc . used ) - 1 ] . key , bbsrc . buf [ 0 ] . key ) < 0 { return } sort . stable ( bb ) widx : = 0 for ridx : = 1 ; ridx < bb . used ; ridx ++ { if ! bytes . equal ( bb . buf [ ridx ] . key , bb . buf [ widx ] . key ) { widx ++ } bb . buf [ widx ] = bb . buf [ ridx ] } bb . used = widx + 1 } 
func deleterevkey ( kv v3 . kv , key string , rev int64 ) ( bool , error ) { cmp : = v3 . compare ( v3 . modrevision ( key ) , " " , rev ) req : = v3 . opdelete ( key ) txnresp , err : = kv . txn ( context . todo ( ) ) . if ( cmp ) . then ( req ) . commit ( ) if err ! = nil { return false , err } else if ! txnresp . succeeded { return false , nil } return true , nil } 
func ismemberbootstrapped ( lg * zap . logger , cl * membership . raftcluster , member string , rt http . roundtripper , timeout time . duration ) bool { rcl , err : = getclusterfromremotepeers ( lg , getremotepeerurls ( cl , member ) , timeout , false , rt ) if err ! = nil { return false } id : = cl . memberbyname ( member ) . id m : = rcl . member ( id ) if m == nil { return false } if len ( m . clienturls ) > 0 { return true } return false } 
func getclusterfromremotepeers ( lg * zap . logger , urls [ ] string , rt http . roundtripper ) ( * membership . raftcluster , error ) { return getclusterfromremotepeers ( lg , urls , 10 * time . second , true , rt ) } 
func getremotepeerurls ( cl * membership . raftcluster , local string ) [ ] string { us : = make ( [ ] string , 0 ) for , m : = range cl . members ( ) { if m . name == local { continue } us = append ( us , m . peerurls ... ) } sort . strings ( us ) return us } 
func getversions ( lg * zap . logger , cl * membership . raftcluster , local types . id , rt http . roundtripper ) map [ string ] * version . versions { members : = cl . members ( ) vers : = make ( map [ string ] * version . versions ) for , m : = range members { if m . id == local { cv : = " " if cl . version ( ) ! = nil { cv = cl . version ( ) . string ( ) } vers [ m . id . string ( ) ] = & version . versions { server : version . version , cluster : cv } continue } ver , err : = getversion ( lg , m , rt ) if err ! = nil { if lg ! = nil { lg . warn ( " " , zap . string ( " " , m . id . string ( ) ) , zap . error ( err ) ) } else { plog . warningf ( " " , m . id , err ) } vers [ m . id . string ( ) ] = nil } else { vers [ m . id . string ( ) ] = ver } } return vers } 
func decideclusterversion ( lg * zap . logger , vers map [ string ] * version . versions ) * semver . version { var cv * semver . version lv : = semver . must ( semver . newversion ( version . version ) ) for mid , ver : = range vers { if ver == nil { return nil } v , err : = semver . newversion ( ver . server ) if err ! = nil { if lg ! = nil { lg . warn ( " " , zap . string ( " " , mid ) , zap . string ( " " , ver . server ) , zap . error ( err ) , ) } else { plog . errorf ( " " , mid , err ) } return nil } if lv . lessthan ( * v ) { if lg ! = nil { lg . warn ( " " , zap . string ( " " , lv . string ( ) ) , zap . string ( " " , mid ) , zap . string ( " " , ver . server ) , ) } else { plog . warningf ( " " , lv . string ( ) ) plog . warningf ( " " , mid , ver . server ) } } if cv == nil { cv = v } else if v . lessthan ( * cv ) { cv = v } } return cv } 
func iscompatiblewithcluster ( lg * zap . logger , cl * membership . raftcluster , local types . id , rt http . roundtripper ) bool { vers : = getversions ( lg , cl , local , rt ) minv : = semver . must ( semver . newversion ( version . minclusterversion ) ) maxv : = semver . must ( semver . newversion ( version . version ) ) maxv = & semver . version { major : maxv . major , minor : maxv . minor , } return iscompatiblewithvers ( lg , vers , local , minv , maxv ) } 
func newtimeoutdetector ( maxduration time . duration ) * timeoutdetector { return & timeoutdetector { maxduration : maxduration , records : make ( map [ uint64 ] time . time ) , } } 
func ( td * timeoutdetector ) reset ( ) { td . mu . lock ( ) defer td . mu . unlock ( ) td . records = make ( map [ uint64 ] time . time ) } 
func ( td * timeoutdetector ) observe ( which uint64 ) ( bool , time . duration ) { td . mu . lock ( ) defer td . mu . unlock ( ) ok : = true now : = time . now ( ) exceed : = time . duration ( 0 ) if pt , found : = td . records [ which ] ; found { exceed = now . sub ( pt ) - td . maxduration if exceed > 0 { ok = false } } td . records [ which ] = now return ok , exceed } 
func ( ki * keyindex ) put ( lg * zap . logger , main int64 , sub int64 ) { rev : = revision { main : main , sub : sub } if ! rev . greaterthan ( ki . modified ) { if lg ! = nil { lg . panic ( " " , zap . int64 ( " " , rev . main ) , zap . int64 ( " " , rev . sub ) , zap . int64 ( " " , ki . modified . main ) , zap . int64 ( " " , ki . modified . sub ) , ) } else { plog . panicf ( " " , rev , ki . modified ) } } if len ( ki . generations ) == 0 { ki . generations = append ( ki . generations , generation { } ) } g : = & ki . generations [ len ( ki . generations ) - 1 ] if len ( g . revs ) == 0 { keysgauge . inc ( ) g . created = rev } g . revs = append ( g . revs , rev ) g . ver ++ ki . modified = rev } 
func ( ki * keyindex ) tombstone ( lg * zap . logger , main int64 , sub int64 ) error { if ki . isempty ( ) { if lg ! = nil { lg . panic ( " " , zap . string ( " " , string ( ki . key ) ) , ) } else { plog . panicf ( " " , string ( ki . key ) ) } } if ki . generations [ len ( ki . generations ) - 1 ] . isempty ( ) { return errrevisionnotfound } ki . put ( lg , main , sub ) ki . generations = append ( ki . generations , generation { } ) keysgauge . dec ( ) return nil } 
func ( ki * keyindex ) get ( lg * zap . logger , atrev int64 ) ( modified , created revision , ver int64 , err error ) { if ki . isempty ( ) { if lg ! = nil { lg . panic ( " " , zap . string ( " " , string ( ki . key ) ) , ) } else { plog . panicf ( " " , string ( ki . key ) ) } } g : = ki . findgeneration ( atrev ) if g . isempty ( ) { return revision { } , revision { } , 0 , errrevisionnotfound } n : = g . walk ( func ( rev revision ) bool { return rev . main > atrev } ) if n ! = - 1 { return g . revs [ n ] , g . created , g . ver - int64 ( len ( g . revs ) - n - 1 ) , nil } return revision { } , revision { } , 0 , errrevisionnotfound } 
func ( ki * keyindex ) since ( lg * zap . logger , rev int64 ) [ ] revision { if ki . isempty ( ) { if lg ! = nil { lg . panic ( " " , zap . string ( " " , string ( ki . key ) ) , ) } else { plog . panicf ( " " , string ( ki . key ) ) } } since : = revision { rev , 0 } var gi int for gi = len ( ki . generations ) - 1 ; gi > 0 ; gi -- { g : = ki . generations [ gi ] if g . isempty ( ) { continue } if since . greaterthan ( g . created ) { break } } var revs [ ] revision var last int64 for ; gi < len ( ki . generations ) ; gi ++ { for , r : = range ki . generations [ gi ] . revs { if since . greaterthan ( r ) { continue } if r . main == last { revs [ len ( revs ) - 1 ] = r continue } revs = append ( revs , r ) last = r . main } } return revs } 
func ( ki * keyindex ) compact ( lg * zap . logger , atrev int64 , available map [ revision ] struct { } ) { if ki . isempty ( ) { if lg ! = nil { lg . panic ( " " , zap . string ( " " , string ( ki . key ) ) , ) } else { plog . panicf ( " " , string ( ki . key ) ) } } genidx , revindex : = ki . docompact ( atrev , available ) g : = & ki . generations [ genidx ] if ! g . isempty ( ) { if revindex ! = - 1 { g . revs = g . revs [ revindex : ] } if len ( g . revs ) == 1 && genidx ! = len ( ki . generations ) - 1 { delete ( available , g . revs [ 0 ] ) genidx ++ } } ki . generations = ki . generations [ genidx : ] } 
func ( ki * keyindex ) keep ( atrev int64 , available map [ revision ] struct { } ) { if ki . isempty ( ) { return } genidx , revindex : = ki . docompact ( atrev , available ) g : = & ki . generations [ genidx ] if ! g . isempty ( ) { if revindex == len ( g . revs ) - 1 && genidx ! = len ( ki . generations ) - 1 { delete ( available , g . revs [ revindex ] ) } } } 
func ( ki * keyindex ) findgeneration ( rev int64 ) * generation { lastg : = len ( ki . generations ) - 1 cg : = lastg for cg >= 0 { if len ( ki . generations [ cg ] . revs ) == 0 { cg -- continue } g : = ki . generations [ cg ] if cg ! = lastg { if tomb : = g . revs [ len ( g . revs ) - 1 ] . main ; tomb <= rev { return nil } } if g . revs [ 0 ] . main <= rev { return & ki . generations [ cg ] } cg -- } return nil } 
func ( g * generation ) walk ( f func ( rev revision ) bool ) int { l : = len ( g . revs ) for i : = range g . revs { ok : = f ( g . revs [ l - i - 1 ] ) if ! ok { return l - i - 1 } } return - 1 } 
func ( s * store ) createorupdateuser ( user user ) ( out user , created bool , err error ) { , err = s . getuser ( user . user , true ) if err == nil { out , err = s . updateuser ( user ) return out , false , err } u , err : = s . createuser ( user ) return u , true , err } 
func ( r role ) merge ( lg * zap . logger , n role ) ( role , error ) { var out role var err error if r . role ! = n . role { return out , autherr ( http . statusconflict , " " , r . role , n . role ) } out . role = r . role out . permissions , err = r . permissions . grant ( n . grant ) if err ! = nil { return out , err } out . permissions , err = out . permissions . revoke ( lg , n . revoke ) return out , err } 
func ( p permissions ) grant ( n * permissions ) ( permissions , error ) { var out permissions var err error if n == nil { return p , nil } out . kv , err = p . kv . grant ( n . kv ) return out , err } 
func ( p permissions ) revoke ( lg * zap . logger , n * permissions ) ( permissions , error ) { var out permissions var err error if n == nil { return p , nil } out . kv , err = p . kv . revoke ( lg , n . kv ) return out , err } 
func ( rw rwpermission ) grant ( n rwpermission ) ( rwpermission , error ) { var out rwpermission currentread : = types . newunsafeset ( rw . read ... ) for , r : = range n . read { if currentread . contains ( r ) { return out , autherr ( http . statusconflict , " " , r ) } currentread . add ( r ) } currentwrite : = types . newunsafeset ( rw . write ... ) for , w : = range n . write { if currentwrite . contains ( w ) { return out , autherr ( http . statusconflict , " " , w ) } currentwrite . add ( w ) } out . read = currentread . values ( ) out . write = currentwrite . values ( ) sort . strings ( out . read ) sort . strings ( out . write ) return out , nil } 
func ( rw rwpermission ) revoke ( lg * zap . logger , n rwpermission ) ( rwpermission , error ) { var out rwpermission currentread : = types . newunsafeset ( rw . read ... ) for , r : = range n . read { if ! currentread . contains ( r ) { if lg ! = nil { lg . info ( " " , zap . string ( " " , r ) , ) } else { plog . noticef ( " " , r ) } continue } currentread . remove ( r ) } currentwrite : = types . newunsafeset ( rw . write ... ) for , w : = range n . write { if ! currentwrite . contains ( w ) { if lg ! = nil { lg . info ( " " , zap . string ( " " , w ) , ) } else { plog . noticef ( " " , w ) } continue } currentwrite . remove ( w ) } out . read = currentread . values ( ) out . write = currentwrite . values ( ) sort . strings ( out . read ) sort . strings ( out . write ) return out , nil } 
func ( s * watchablestore ) cancelwatcher ( wa * watcher ) { for { s . mu . lock ( ) if s . unsynced . delete ( wa ) { slowwatchergauge . dec ( ) break } else if s . synced . delete ( wa ) { break } else if wa . compacted { break } else if wa . ch == nil { break } if ! wa . victim { panic ( " " ) } var victimbatch watcherbatch for , wb : = range s . victims { if wb [ wa ] ! = nil { victimbatch = wb break } } if victimbatch ! = nil { slowwatchergauge . dec ( ) delete ( victimbatch , wa ) break } s . mu . unlock ( ) time . sleep ( time . millisecond ) } watchergauge . dec ( ) wa . ch = nil s . mu . unlock ( ) } 
func ( s * watchablestore ) syncwatchersloop ( ) { defer s . wg . done ( ) for { s . mu . rlock ( ) st : = time . now ( ) lastunsyncedwatchers : = s . unsynced . size ( ) s . mu . runlock ( ) unsyncedwatchers : = 0 if lastunsyncedwatchers > 0 { unsyncedwatchers = s . syncwatchers ( ) } syncduration : = time . since ( st ) waitduration : = 100 * time . millisecond if unsyncedwatchers ! = 0 && lastunsyncedwatchers > unsyncedwatchers { waitduration = syncduration } select { case < - time . after ( waitduration ) : case < - s . stopc : return } } } 
func ( s * watchablestore ) syncvictimsloop ( ) { defer s . wg . done ( ) for { for s . movevictims ( ) ! = 0 { } s . mu . rlock ( ) isempty : = len ( s . victims ) == 0 s . mu . runlock ( ) var tickc < - chan time . time if ! isempty { tickc = time . after ( 10 * time . millisecond ) } select { case < - tickc : case < - s . victimc : case < - s . stopc : return } } } 
func ( s * watchablestore ) movevictims ( ) ( moved int ) { s . mu . lock ( ) victims : = s . victims s . victims = nil s . mu . unlock ( ) var newvictim watcherbatch for , wb : = range victims { for w , eb : = range wb { rev : = w . minrev - 1 if w . send ( watchresponse { watchid : w . id , events : eb . evs , revision : rev } ) { pendingeventsgauge . add ( float64 ( len ( eb . evs ) ) ) } else { if newvictim == nil { newvictim = make ( watcherbatch ) } newvictim [ w ] = eb continue } moved ++ } s . mu . lock ( ) s . store . revmu . rlock ( ) currev : = s . store . currentrev for w , eb : = range wb { if newvictim ! = nil && newvictim [ w ] ! = nil { continue } w . victim = false if eb . morerev ! = 0 { w . minrev = eb . morerev } if w . minrev <= currev { s . unsynced . add ( w ) } else { slowwatchergauge . dec ( ) s . synced . add ( w ) } } s . store . revmu . runlock ( ) s . mu . unlock ( ) } if len ( newvictim ) > 0 { s . mu . lock ( ) s . victims = append ( s . victims , newvictim ) s . mu . unlock ( ) } return moved } 
func kvstoevents ( lg * zap . logger , wg * watchergroup , revs , vals [ ] [ ] byte ) ( evs [ ] mvccpb . event ) { for i , v : = range vals { var kv mvccpb . keyvalue if err : = kv . unmarshal ( v ) ; err ! = nil { if lg ! = nil { lg . panic ( " " , zap . error ( err ) ) } else { plog . panicf ( " " , err ) } } if ! wg . contains ( string ( kv . key ) ) { continue } ty : = mvccpb . put if istombstone ( revs [ i ] ) { ty = mvccpb . delete kv . modrevision = bytestorev ( revs [ i ] ) . main } evs = append ( evs , mvccpb . event { kv : & kv , type : ty } ) } return evs } 
func ( s * watchablestore ) notify ( rev int64 , evs [ ] mvccpb . event ) { var victim watcherbatch for w , eb : = range newwatcherbatch ( & s . synced , evs ) { if eb . revs ! = 1 { if s . store ! = nil && s . store . lg ! = nil { s . store . lg . panic ( " " , zap . int ( " " , eb . revs ) , ) } else { plog . panicf ( " " ) } } if w . send ( watchresponse { watchid : w . id , events : eb . evs , revision : rev } ) { pendingeventsgauge . add ( float64 ( len ( eb . evs ) ) ) } else { w . minrev = rev + 1 if victim == nil { victim = make ( watcherbatch ) } w . victim = true victim [ w ] = eb s . synced . delete ( w ) slowwatchergauge . inc ( ) } } s . addvictim ( victim ) } 
func isopfunccalled ( op string , opts [ ] opoption ) bool { for , opt : = range opts { v : = reflect . valueof ( opt ) if v . kind ( ) == reflect . func { if opfunc : = runtime . funcforpc ( v . pointer ( ) ) ; opfunc ! = nil { if strings . contains ( opfunc . name ( ) , op ) { return true } } } } return false } 
func ( t * batchtx ) unsafeput ( bucketname [ ] byte , key [ ] byte , value [ ] byte ) { t . unsafeput ( bucketname , key , value , false ) } 
func ( t * batchtx ) unsafeseqput ( bucketname [ ] byte , key [ ] byte , value [ ] byte ) { t . unsafeput ( bucketname , key , value , true ) } 
func ( t * batchtx ) unsaferange ( bucketname , key , endkey [ ] byte , limit int64 ) ( [ ] [ ] byte , [ ] [ ] byte ) { bucket : = t . tx . bucket ( bucketname ) if bucket == nil { if t . backend . lg ! = nil { t . backend . lg . fatal ( " " , zap . string ( " " , string ( bucketname ) ) , ) } else { plog . fatalf ( " " , bucketname ) } } return unsaferange ( bucket . cursor ( ) , key , endkey , limit ) } 
func ( t * batchtx ) unsafedelete ( bucketname [ ] byte , key [ ] byte ) { bucket : = t . tx . bucket ( bucketname ) if bucket == nil { if t . backend . lg ! = nil { t . backend . lg . fatal ( " " , zap . string ( " " , string ( bucketname ) ) , ) } else { plog . fatalf ( " " , bucketname ) } } err : = bucket . delete ( key ) if err ! = nil { if t . backend . lg ! = nil { t . backend . lg . fatal ( " " , zap . string ( " " , string ( bucketname ) ) , zap . error ( err ) , ) } else { plog . fatalf ( " " , err ) } } t . pending ++ } 
func ( t * batchtx ) unsafeforeach ( bucketname [ ] byte , visitor func ( k , v [ ] byte ) error ) error { return unsafeforeach ( t . tx , bucketname , visitor ) } 
func ( t * batchtx ) commit ( ) { t . lock ( ) t . commit ( false ) t . unlock ( ) } 
func ( t * batchtx ) commitandstop ( ) { t . lock ( ) t . commit ( true ) t . unlock ( ) } 
func ( le * lessor ) renew ( id leaseid ) ( int64 , error ) { le . mu . rlock ( ) if ! le . isprimary ( ) { le . mu . runlock ( ) return - 1 , errnotprimary } demotec : = le . demotec l : = le . leasemap [ id ] if l == nil { le . mu . runlock ( ) return - 1 , errleasenotfound } clearremainingttl : = le . cp ! = nil && l . remainingttl > 0 le . mu . runlock ( ) if l . expired ( ) { select { case < - l . revokec : return - 1 , errleasenotfound case < - demotec : return - 1 , errnotprimary case < - le . stopc : return - 1 , errnotprimary } } if clearremainingttl { le . cp ( context . background ( ) , & pb . leasecheckpointrequest { checkpoints : [ ] * pb . leasecheckpoint { { id : int64 ( l . id ) , remaining ttl : 0 } } } ) } le . mu . lock ( ) l . refresh ( 0 ) item : = & leasewithtime { id : l . id , time : l . expiry . unixnano ( ) } heap . push ( & le . leaseheap , item ) le . mu . unlock ( ) leaserenewed . inc ( ) return l . ttl , nil } 
func ( le * lessor ) attach ( id leaseid , items [ ] leaseitem ) error { le . mu . lock ( ) defer le . mu . unlock ( ) l : = le . leasemap [ id ] if l == nil { return errleasenotfound } l . mu . lock ( ) for , it : = range items { l . itemset [ it ] = struct { } { } le . itemmap [ it ] = id } l . mu . unlock ( ) return nil } 
func ( le * lessor ) revokeexpiredleases ( ) { var ls [ ] * lease revokelimit : = leaserevokerate / 2 le . mu . rlock ( ) if le . isprimary ( ) { ls = le . findexpiredleases ( revokelimit ) } le . mu . runlock ( ) if len ( ls ) ! = 0 { select { case < - le . stopc : return case le . expiredc < - ls : default : } } } 
func ( le * lessor ) checkpointscheduledleases ( ) { var cps [ ] * pb . leasecheckpoint for i : = 0 ; i < leasecheckpointrate / 2 ; i ++ { le . mu . lock ( ) if le . isprimary ( ) { cps = le . findduescheduledcheckpoints ( maxleasecheckpointbatchsize ) } le . mu . unlock ( ) if len ( cps ) ! = 0 { le . cp ( context . background ( ) , & pb . leasecheckpointrequest { checkpoints : cps } ) } if len ( cps ) < maxleasecheckpointbatchsize { return } } } 
func ( le * lessor ) expireexists ( ) ( l * lease , ok bool , next bool ) { if le . leaseheap . len ( ) == 0 { return nil , false , false } item : = le . leaseheap [ 0 ] l = le . leasemap [ item . id ] if l == nil { heap . pop ( & le . leaseheap ) return nil , false , true } if time . now ( ) . unixnano ( ) < item . time / * expiration time * / { return l , false , false } heap . pop ( & le . leaseheap ) return l , true , false } 
func ( le * lessor ) findexpiredleases ( limit int ) [ ] * lease { leases : = make ( [ ] * lease , 0 , 16 ) for { l , ok , next : = le . expireexists ( ) if ! ok && ! next { break } if ! ok { continue } if next { continue } if l . expired ( ) { leases = append ( leases , l ) if len ( leases ) == limit { break } } } return leases } 
func ( l * lease ) remainingttl ( ) int64 { if l . remainingttl > 0 { return l . remainingttl } return l . ttl } 
func ( l * lease ) refresh ( extend time . duration ) { newexpiry : = time . now ( ) . add ( extend + time . duration ( l . remainingttl ( ) ) * time . second ) l . expirymu . lock ( ) defer l . expirymu . unlock ( ) l . expiry = newexpiry } 
func ( l * lease ) forever ( ) { l . expirymu . lock ( ) defer l . expirymu . unlock ( ) l . expiry = forever } 
func ( l * lease ) keys ( ) [ ] string { l . mu . rlock ( ) keys : = make ( [ ] string , 0 , len ( l . itemset ) ) for k : = range l . itemset { keys = append ( keys , k . key ) } l . mu . runlock ( ) return keys } 
func ( l * lease ) remaining ( ) time . duration { l . expirymu . rlock ( ) defer l . expirymu . runlock ( ) if l . expiry . iszero ( ) { return time . duration ( math . maxint64 ) } return time . until ( l . expiry ) } 
func newcompactioncommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : compactioncommandfunc , } cmd . flags ( ) . boolvar ( & compactphysical , " " , false , " " ) return cmd } 
func compactioncommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } rev , err : = strconv . parseint ( args [ 0 ] , 10 , 64 ) if err ! = nil { exitwitherror ( exiterror , err ) } var opts [ ] clientv3 . compactoption if compactphysical { opts = append ( opts , clientv3 . withcompactphysical ( ) ) } c : = mustclientfromcmd ( cmd ) ctx , cancel : = commandctx ( cmd ) , cerr : = c . compact ( ctx , rev , opts ... ) cancel ( ) if cerr ! = nil { exitwitherror ( exiterror , cerr ) } fmt . println ( " " , rev ) } 
func casesensitivejsoniterator ( ) jsoniter . api { config : = jsoniter . config { escapehtml : true , sortmapkeys : true , validatejsonrawmessage : true , casesensitive : true , } . froze ( ) config . registerextension ( & customnumberextension { } ) return config } 
func newputcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , long : , run : putcommandfunc , } cmd . flags ( ) . stringvar ( & leasestr , " " , " " , " " ) cmd . flags ( ) . boolvar ( & putprevkv , " " , false , " " ) cmd . flags ( ) . boolvar ( & putignoreval , " " , false , " " ) cmd . flags ( ) . boolvar ( & putignorelease , " " , false , " " ) return cmd } 
func putcommandfunc ( cmd * cobra . command , args [ ] string ) { key , value , opts : = getputop ( args ) ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . put ( ctx , key , value , opts ... ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . put ( * resp ) } 
func newsetcommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , description : , flags : [ ] cli . flag { cli . intflag { name : " " , value : 0 , usage : " " } , cli . stringflag { name : " " , value : " " , usage : " " } , cli . intflag { name : " " , value : 0 , usage : " " } , } , action : func ( c * cli . context ) error { setcommandfunc ( c , mustnewkeyapi ( c ) ) return nil } , } } 
func setcommandfunc ( c * cli . context , ki client . keysapi ) { if len ( c . args ( ) ) == 0 { handleerror ( c , exitbadargs , errors . new ( " " ) ) } key : = c . args ( ) [ 0 ] value , err : = argorstdin ( c . args ( ) , os . stdin , 1 ) if err ! = nil { handleerror ( c , exitbadargs , errors . new ( " " ) ) } ttl : = c . int ( " " ) prevvalue : = c . string ( " " ) previndex : = c . int ( " " ) ctx , cancel : = contextwithtotaltimeout ( c ) resp , err : = ki . set ( ctx , key , value , & client . setoptions { ttl : time . duration ( ttl ) * time . second , previndex : uint64 ( previndex ) , prevvalue : prevvalue } ) cancel ( ) if err ! = nil { handleerror ( c , exitservererror , err ) } printresponsekey ( resp , c . globalstring ( " " ) ) } 
func ( rwm * rwmutex ) waitonlastrev ( pfx string ) ( bool , error ) { client : = rwm . s . client ( ) opts : = append ( v3 . withlastrev ( ) , v3 . withmaxmodrev ( rwm . mykey . revision ( ) - 1 ) ) lastkey , err : = client . get ( rwm . ctx , pfx , opts ... ) if err ! = nil { return false , err } if len ( lastkey . kvs ) == 0 { return true , nil } , err = waitevents ( client , string ( lastkey . kvs [ 0 ] . key ) , rwm . mykey . revision ( ) , [ ] mvccpb . event eventtype { mvccpb . delete } ) return false , err } 
func getdefaultinterfaces ( ) ( map [ string ] uint8 , error ) { return nil , fmt . errorf ( " " , runtime . goos , runtime . goarch ) } 
func newsnapshotcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , } cmd . addcommand ( newsnapshotsavecommand ( ) ) cmd . addcommand ( newsnapshotrestorecommand ( ) ) cmd . addcommand ( newsnapshotstatuscommand ( ) ) return cmd } 
func newmoveleadercommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : transferleadershipcommandfunc , } return cmd } 
func transferleadershipcommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 1 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } target , err : = strconv . parseuint ( args [ 0 ] , 16 , 64 ) if err ! = nil { exitwitherror ( exitbadargs , err ) } c : = mustclientfromcmd ( cmd ) eps : = c . endpoints ( ) c . close ( ) ctx , cancel : = commandctx ( cmd ) var leadercli * clientv3 . client var leaderid uint64 for , ep : = range eps { cfg : = clientconfigfromcmd ( cmd ) cfg . endpoints = [ ] string { ep } cli : = cfg . mustclient ( ) resp , serr : = cli . status ( ctx , ep ) if serr ! = nil { exitwitherror ( exiterror , serr ) } if resp . header . getmemberid ( ) == resp . leader { leadercli = cli leaderid = resp . leader break } cli . close ( ) } if leadercli == nil { exitwitherror ( exitbadargs , fmt . errorf ( " " , eps ) ) } var resp * clientv3 . moveleaderresponse resp , err = leadercli . moveleader ( ctx , target ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . moveleader ( leaderid , target , * resp ) } 
func opendir ( path string ) ( * os . file , error ) { fd , err : = opendir ( path ) if err ! = nil { return nil , err } return os . newfile ( uintptr ( fd ) , path ) , nil } 
func newremovedircommand ( ) cli . command { return cli . command { name : " " , usage : " " , argsusage : " " , action : func ( c * cli . context ) error { rmdircommandfunc ( c , mustnewkeyapi ( c ) ) return nil } , } } 
func rmdircommandfunc ( c * cli . context , ki client . keysapi ) { if len ( c . args ( ) ) == 0 { handleerror ( c , exitbadargs , errors . new ( " " ) ) } key : = c . args ( ) [ 0 ] ctx , cancel : = contextwithtotaltimeout ( c ) resp , err : = ki . delete ( ctx , key , & client . deleteoptions { dir : true } ) cancel ( ) if err ! = nil { handleerror ( c , exitservererror , err ) } if ! resp . node . dir | | c . globalstring ( " " ) ! = " " { printresponsekey ( resp , c . globalstring ( " " ) ) } } 
func newdelcommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : delcommandfunc , } cmd . flags ( ) . boolvar ( & delprefix , " " , false , " " ) cmd . flags ( ) . boolvar ( & delprevkv , " " , false , " " ) cmd . flags ( ) . boolvar ( & delfromkey , " " , false , " " ) return cmd } 
func delcommandfunc ( cmd * cobra . command , args [ ] string ) { key , opts : = getdelop ( args ) ctx , cancel : = commandctx ( cmd ) resp , err : = mustclientfromcmd ( cmd ) . delete ( ctx , key , opts ... ) cancel ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . del ( * resp ) } 
func archive ( basedir , etcdlogpath , datadir string ) error { dir : = filepath . join ( basedir , " " , time . now ( ) . format ( time . rfc3339 ) ) if existdir ( dir ) { dir = filepath . join ( basedir , " " , time . now ( ) . add ( time . second ) . format ( time . rfc3339 ) ) } if err : = fileutil . touchdirall ( dir ) ; err ! = nil { return err } if err : = os . rename ( etcdlogpath , filepath . join ( dir , " " ) ) ; err ! = nil { if ! os . isnotexist ( err ) { return err } } if err : = os . rename ( datadir , filepath . join ( dir , filepath . base ( datadir ) ) ) ; err ! = nil { if ! os . isnotexist ( err ) { return err } } return nil } 
func newexpect ( name string , arg ... string ) ( ep * expectprocess , err error ) { return newexpectwithenv ( name , arg , nil ) } 
func newexpectwithenv ( name string , args [ ] string , env [ ] string ) ( ep * expectprocess , err error ) { cmd : = exec . command ( name , args ... ) cmd . env = env ep = & expectprocess { cmd : cmd , stopsignal : syscall . sigkill , } ep . cond = sync . newcond ( & ep . mu ) ep . cmd . stderr = ep . cmd . stdout ep . cmd . stdin = nil if ep . fpty , err = pty . start ( ep . cmd ) ; err ! = nil { return nil , err } ep . wg . add ( 1 ) go ep . read ( ) return ep , nil } 
func ( ep * expectprocess ) expectfunc ( f func ( string ) bool ) ( string , error ) { ep . mu . lock ( ) for { for len ( ep . lines ) == 0 && ep . err == nil { ep . cond . wait ( ) } if len ( ep . lines ) == 0 { break } l : = ep . lines [ 0 ] ep . lines = ep . lines [ 1 : ] if f ( l ) { ep . mu . unlock ( ) return l , nil } } ep . mu . unlock ( ) return " " , ep . err } 
func ( ep * expectprocess ) expect ( s string ) ( string , error ) { return ep . expectfunc ( func ( txt string ) bool { return strings . contains ( txt , s ) } ) } 
func ( ep * expectprocess ) linecount ( ) int { ep . mu . lock ( ) defer ep . mu . unlock ( ) return ep . count } 
func ( ep * expectprocess ) signal ( sig os . signal ) error { return ep . cmd . process . signal ( sig ) } 
func keyfunc ( req * pb . rangerequest ) string { b , err : = req . marshal ( ) if err ! = nil { panic ( err ) } return string ( b ) } 
func ( c * cache ) add ( req * pb . rangerequest , resp * pb . rangeresponse ) { key : = keyfunc ( req ) c . mu . lock ( ) defer c . mu . unlock ( ) if req . revision > c . compactedrev { c . lru . add ( key , resp ) } if req . revision ! = 0 { return } var ( iv * adt . intervalvalue ivl adt . interval ) if len ( req . rangeend ) ! = 0 { ivl = adt . newstringaffineinterval ( string ( req . key ) , string ( req . rangeend ) ) } else { ivl = adt . newstringaffinepoint ( string ( req . key ) ) } iv = c . cachedranges . find ( ivl ) if iv == nil { val : = map [ string ] struct { } { key : { } } c . cachedranges . insert ( ivl , val ) } else { val : = iv . val . ( map [ string ] struct { } ) val [ key ] = struct { } { } iv . val = val } } 
func ( c * cache ) get ( req * pb . rangerequest ) ( * pb . rangeresponse , error ) { key : = keyfunc ( req ) c . mu . lock ( ) defer c . mu . unlock ( ) if req . revision > 0 && req . revision < c . compactedrev { c . lru . remove ( key ) return nil , errcompacted } if resp , ok : = c . lru . get ( key ) ; ok { return resp . ( * pb . rangeresponse ) , nil } return nil , errors . new ( " " ) } 
func ( c * cache ) invalidate ( key , endkey [ ] byte ) { c . mu . lock ( ) defer c . mu . unlock ( ) var ( ivs [ ] * adt . intervalvalue ivl adt . interval ) if len ( endkey ) == 0 { ivl = adt . newstringaffinepoint ( string ( key ) ) } else { ivl = adt . newstringaffineinterval ( string ( key ) , string ( endkey ) ) } ivs = c . cachedranges . stab ( ivl ) for , iv : = range ivs { keys : = iv . val . ( map [ string ] struct { } ) for key : = range keys { c . lru . remove ( key ) } } c . cachedranges . delete ( ivl ) } 
func ( c * cache ) compact ( revision int64 ) { c . mu . lock ( ) defer c . mu . unlock ( ) if revision > c . compactedrev { c . compactedrev = revision } } 
func ( us * uniqueurls ) string ( ) string { all : = make ( [ ] string , 0 , len ( us . values ) ) for u : = range us . values { all = append ( all , u ) } sort . strings ( all ) return strings . join ( all , " " ) } 
func newuniqueurlswithexceptions ( s string , exceptions ... string ) * uniqueurls { us : = & uniqueurls { values : make ( map [ string ] struct { } ) , allowed : make ( map [ string ] struct { } ) } for , v : = range exceptions { us . allowed [ v ] = struct { } { } } if s == " " { return us } if err : = us . set ( s ) ; err ! = nil { plog . panicf ( " " , err ) } return us } 
func uniqueurlsfromflag ( fs * flag . flagset , urlsflagname string ) [ ] url . url { return ( * fs . lookup ( urlsflagname ) . value . ( * uniqueurls ) ) . uss } 
func uniqueurlsmapfromflag ( fs * flag . flagset , urlsflagname string ) map [ string ] struct { } { return ( * fs . lookup ( urlsflagname ) . value . ( * uniqueurls ) ) . values } 
func ( b * barrier ) hold ( ) error { , err : = newkey ( b . client , b . key , v3 . nolease ) return err } 
func ( b * barrier ) release ( ) error { , err : = b . client . delete ( b . ctx , b . key ) return err } 
func ( b * barrier ) wait ( ) error { resp , err : = b . client . get ( b . ctx , b . key , v3 . withfirstkey ( ) ... ) if err ! = nil { return err } if len ( resp . kvs ) == 0 { return nil } , err = waitevents ( b . client , b . key , resp . header . revision , [ ] mvccpb . event eventtype { mvccpb . put , mvccpb . delete } ) return err } 
func newlockracercommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : runracerfunc , } cmd . flags ( ) . intvar ( & totalclientconnections , " " , 10 , " " ) return cmd } 
func ( m * member ) electiontimeout ( ) time . duration { return time . duration ( m . etcd . electiontimeoutms ) * time . millisecond } 
func ( m * member ) dialetcdgrpcserver ( opts ... grpc . dialoption ) ( * grpc . clientconn , error ) { dialopts : = [ ] grpc . dialoption { grpc . withtimeout ( 5 * time . second ) , grpc . withblock ( ) , } secure : = false for , cu : = range m . etcd . advertiseclienturls { u , err : = url . parse ( cu ) if err ! = nil { return nil , err } if u . scheme == " " { secure = true } } if secure { tlsinfo : = transport . tlsinfo { certfile : m . clientcertpath , keyfile : m . clientkeypath , trustedcafile : m . clienttrustedcapath , insecureskipverify : true , } tlsconfig , err : = tlsinfo . clientconfig ( ) if err ! = nil { return nil , err } creds : = credentials . newtls ( tlsconfig ) dialopts = append ( dialopts , grpc . withtransportcredentials ( creds ) ) } else { dialopts = append ( dialopts , grpc . withinsecure ( ) ) } dialopts = append ( dialopts , opts ... ) return grpc . dial ( m . etcdclientendpoint , dialopts ... ) } 
func ( m * member ) createetcdclientconfig ( opts ... grpc . dialoption ) ( cfg * clientv3 . config , err error ) { secure : = false for , cu : = range m . etcd . advertiseclienturls { var u * url . url u , err = url . parse ( cu ) if err ! = nil { return nil , err } if u . scheme == " " { secure = true } } cfg = & clientv3 . config { endpoints : [ ] string { m . etcdclientendpoint } , dialtimeout : 10 * time . second , dialoptions : opts , } if secure { tlsinfo : = transport . tlsinfo { certfile : m . clientcertpath , keyfile : m . clientkeypath , trustedcafile : m . clienttrustedcapath , insecureskipverify : true , } var tlsconfig * tls . config tlsconfig , err = tlsinfo . clientconfig ( ) if err ! = nil { return nil , err } cfg . tls = tlsconfig } return cfg , err } 
func ( m * member ) createetcdclient ( opts ... grpc . dialoption ) ( * clientv3 . client , error ) { cfg , err : = m . createetcdclientconfig ( opts ... ) if err ! = nil { return nil , err } return clientv3 . new ( * cfg ) } 
func ( m * member ) checkcompact ( rev int64 ) error { cli , err : = m . createetcdclient ( ) if err ! = nil { return fmt . errorf ( " " , err , m . etcdclientendpoint ) } defer cli . close ( ) ctx , cancel : = context . withtimeout ( context . background ( ) , 5 * time . second ) wch : = cli . watch ( ctx , " \ x00 " , clientv3 . withfromkey ( ) , clientv3 . withrev ( rev - 1 ) ) wr , ok : = < - wch cancel ( ) if ! ok { return fmt . errorf ( " " , m . etcdclientendpoint ) } if wr . compactrevision ! = rev { return fmt . errorf ( " " , wr . compactrevision , rev , m . etcdclientendpoint ) } return nil } 
func ( m * member ) defrag ( ) error { cli , err : = m . createetcdclient ( ) if err ! = nil { return fmt . errorf ( " " , err , m . etcdclientendpoint ) } defer cli . close ( ) ctx , cancel : = context . withtimeout ( context . background ( ) , 5 * time . minute ) , err = cli . defragment ( ctx , m . etcdclientendpoint ) cancel ( ) return err } 
func ( m * member ) revhash ( ) ( int64 , int64 , error ) { conn , err : = m . dialetcdgrpcserver ( ) if err ! = nil { return 0 , 0 , err } defer conn . close ( ) mt : = pb . newmaintenanceclient ( conn ) ctx , cancel : = context . withtimeout ( context . background ( ) , 5 * time . second ) resp , err : = mt . hash ( ctx , & pb . hashrequest { } , grpc . failfast ( false ) ) cancel ( ) if err ! = nil { return 0 , 0 , err } return resp . header . revision , int64 ( resp . hash ) , nil } 
func ( m * member ) rev ( ctx context . context ) ( int64 , error ) { cli , err : = m . createetcdclient ( ) if err ! = nil { return 0 , fmt . errorf ( " " , err , m . etcdclientendpoint ) } defer cli . close ( ) resp , err : = cli . status ( ctx , m . etcdclientendpoint ) if err ! = nil { return 0 , err } return resp . header . revision , nil } 
func ( m * member ) compact ( rev int64 , timeout time . duration ) error { cli , err : = m . createetcdclient ( ) if err ! = nil { return fmt . errorf ( " " , err , m . etcdclientendpoint ) } defer cli . close ( ) ctx , cancel : = context . withtimeout ( context . background ( ) , timeout ) , err = cli . compact ( ctx , rev , clientv3 . withcompactphysical ( ) ) cancel ( ) return err } 
func ( m * member ) isleader ( ) ( bool , error ) { cli , err : = m . createetcdclient ( ) if err ! = nil { return false , fmt . errorf ( " " , err , m . etcdclientendpoint ) } defer cli . close ( ) resp , err : = cli . status ( context . background ( ) , m . etcdclientendpoint ) if err ! = nil { return false , err } return resp . header . memberid == resp . leader , nil } 
func ( m * member ) writehealthkey ( ) error { cli , err : = m . createetcdclient ( ) if err ! = nil { return fmt . errorf ( " " , err , m . etcdclientendpoint ) } defer cli . close ( ) ctx , cancel : = context . withtimeout ( context . background ( ) , 5 * time . second ) , err = cli . put ( ctx , " " , " " ) cancel ( ) if err ! = nil { return fmt . errorf ( " " , err , m . etcdclientendpoint ) } return nil } 
func newwatcher ( w clientv3 . watcher , prefix string ) clientv3 . watcher { return & watcherprefix { watcher : w , pfx : prefix , stopc : make ( chan struct { } ) } } 
func register ( c * clientv3 . client , prefix string , addr string , ttl int ) < - chan struct { } { rm : = rate . newlimiter ( rate . limit ( registerretryrate ) , registerretryrate ) donec : = make ( chan struct { } ) go func ( ) { defer close ( donec ) for rm . wait ( c . ctx ( ) ) == nil { ss , err : = registersession ( c , prefix , addr , ttl ) if err ! = nil { plog . warningf ( " " , err ) continue } select { case < - c . ctx ( ) . done ( ) : ss . close ( ) return case < - ss . done ( ) : plog . warning ( " " ) plog . warning ( " " ) continue } } } ( ) return donec } 
func newrawnode ( config * config , peers [ ] peer ) ( * rawnode , error ) { if config . id == 0 { panic ( " " ) } r : = newraft ( config ) rn : = & rawnode { raft : r , } lastindex , err : = config . storage . lastindex ( ) if err ! = nil { panic ( err ) } if lastindex == 0 { r . becomefollower ( 1 , none ) ents : = make ( [ ] pb . entry , len ( peers ) ) for i , peer : = range peers { cc : = pb . confchange { type : pb . confchangeaddnode , nodeid : peer . id , context : peer . context } data , err : = cc . marshal ( ) if err ! = nil { panic ( " " ) } ents [ i ] = pb . entry { type : pb . entryconfchange , term : 1 , index : uint64 ( i + 1 ) , data : data } } r . raftlog . append ( ents ... ) r . raftlog . committed = uint64 ( len ( ents ) ) for , peer : = range peers { r . addnode ( peer . id ) } } rn . prevsoftst = r . softstate ( ) if lastindex == 0 { rn . prevhardst = emptystate } else { rn . prevhardst = r . hardstate ( ) } return rn , nil } 
func ( rn * rawnode ) campaign ( ) error { return rn . raft . step ( pb . message { type : pb . msghup , } ) } 
func ( rn * rawnode ) propose ( data [ ] byte ) error { return rn . raft . step ( pb . message { type : pb . msgprop , from : rn . raft . id , entries : [ ] pb . entry { { data : data } , } } ) } 
func ( rn * rawnode ) proposeconfchange ( cc pb . confchange ) error { data , err : = cc . marshal ( ) if err ! = nil { return err } return rn . raft . step ( pb . message { type : pb . msgprop , entries : [ ] pb . entry { { type : pb . entryconfchange , data : data } , } , } ) } 
func ( rn * rawnode ) applyconfchange ( cc pb . confchange ) * pb . confstate { if cc . nodeid == none { return & pb . confstate { nodes : rn . raft . nodes ( ) , learners : rn . raft . learnernodes ( ) } } switch cc . type { case pb . confchangeaddnode : rn . raft . addnode ( cc . nodeid ) case pb . confchangeaddlearnernode : rn . raft . addlearner ( cc . nodeid ) case pb . confchangeremovenode : rn . raft . removenode ( cc . nodeid ) case pb . confchangeupdatenode : default : panic ( " " ) } return & pb . confstate { nodes : rn . raft . nodes ( ) , learners : rn . raft . learnernodes ( ) } } 
func ( rn * rawnode ) step ( m pb . message ) error { if islocalmsg ( m . type ) { return errsteplocalmsg } if pr : = rn . raft . getprogress ( m . from ) ; pr ! = nil | | ! isresponsemsg ( m . type ) { return rn . raft . step ( m ) } return errsteppeernotfound } 
func ( rn * rawnode ) ready ( ) ready { rd : = rn . newready ( ) rn . raft . msgs = nil rn . raft . reduceuncommittedsize ( rd . committedentries ) return rd } 
func ( rn * rawnode ) hasready ( ) bool { r : = rn . raft if ! r . softstate ( ) . equal ( rn . prevsoftst ) { return true } if hardst : = r . hardstate ( ) ; ! isemptyhardstate ( hardst ) && ! ishardstateequal ( hardst , rn . prevhardst ) { return true } if r . raftlog . unstable . snapshot ! = nil && ! isemptysnap ( * r . raftlog . unstable . snapshot ) { return true } if len ( r . msgs ) > 0 | | len ( r . raftlog . unstableentries ( ) ) > 0 | | r . raftlog . hasnextents ( ) { return true } if len ( r . readstates ) ! = 0 { return true } return false } 
func ( rn * rawnode ) withprogress ( visitor func ( id uint64 , typ progresstype , pr progress ) ) { for id , pr : = range rn . raft . prs { pr : = * pr pr . ins = nil visitor ( id , progresstypepeer , pr ) } for id , pr : = range rn . raft . learnerprs { pr : = * pr pr . ins = nil visitor ( id , progresstypelearner , pr ) } } 
func ( rn * rawnode ) reportunreachable ( id uint64 ) { = rn . raft . step ( pb . message { type : pb . msgunreachable , from : id } ) } 
func ( rn * rawnode ) reportsnapshot ( id uint64 , status snapshotstatus ) { rej : = status == snapshotfailure = rn . raft . step ( pb . message { type : pb . msgsnapstatus , from : id , reject : rej } ) } 
func ( rn * rawnode ) transferleader ( transferee uint64 ) { = rn . raft . step ( pb . message { type : pb . msgtransferleader , from : transferee } ) } 
func ( rn * rawnode ) readindex ( rctx [ ] byte ) { = rn . raft . step ( pb . message { type : pb . msgreadindex , entries : [ ] pb . entry { { data : rctx } } } ) } 
func printcurl ( req * http . request ) error { if ! curldebug { return nil } var ( command string b [ ] byte err error ) if req . url ! = nil { command = fmt . sprintf ( " " , req . method , req . url . string ( ) ) } if req . body ! = nil { b , err = ioutil . readall ( req . body ) if err ! = nil { return err } command += fmt . sprintf ( " " , string ( b ) ) } fmt . fprintf ( os . stderr , " \n " , command ) body : = bytes . newbuffer ( b ) req . body = ioutil . nopcloser ( body ) return nil } 
func fsync ( f * os . file ) error { , , errno : = syscall . syscall ( syscall . sys fcntl , f . fd ( ) , uintptr ( syscall . f fullfsync ) , uintptr ( 0 ) ) if errno == 0 { return nil } return errno } 
func ( rd ready ) appliedcursor ( ) uint64 { if n : = len ( rd . committedentries ) ; n > 0 { return rd . committedentries [ n - 1 ] . index } if index : = rd . snapshot . metadata . index ; index > 0 { return index } return 0 } 
func startnode ( c * config , peers [ ] peer ) node { r : = newraft ( c ) r . becomefollower ( 1 , none ) for , peer : = range peers { cc : = pb . confchange { type : pb . confchangeaddnode , nodeid : peer . id , context : peer . context } d , err : = cc . marshal ( ) if err ! = nil { panic ( " " ) } e : = pb . entry { type : pb . entryconfchange , term : 1 , index : r . raftlog . lastindex ( ) + 1 , data : d } r . raftlog . append ( e ) } r . raftlog . committed = r . raftlog . lastindex ( ) for , peer : = range peers { r . addnode ( peer . id ) } n : = newnode ( ) n . logger = c . logger go n . run ( r ) return & n } 
func restartnode ( c * config ) node { r : = newraft ( c ) n : = newnode ( ) n . logger = c . logger go n . run ( r ) return & n } 
func ( n * node ) tick ( ) { select { case n . tickc < - struct { } { } : case < - n . done : default : n . logger . warningf ( " " ) } } 
func ( n * node ) stepwithwaitoption ( ctx context . context , m pb . message , wait bool ) error { if m . type ! = pb . msgprop { select { case n . recvc < - m : return nil case < - ctx . done ( ) : return ctx . err ( ) case < - n . done : return errstopped } } ch : = n . propc pm : = msgwithresult { m : m } if wait { pm . result = make ( chan error , 1 ) } select { case ch < - pm : if ! wait { return nil } case < - ctx . done ( ) : return ctx . err ( ) case < - n . done : return errstopped } select { case err : = < - pm . result : if err ! = nil { return err } case < - ctx . done ( ) : return ctx . err ( ) case < - n . done : return errstopped } return nil } 
func mustsync ( st , prevst pb . hardstate , entsnum int ) bool { return entsnum ! = 0 | | st . vote ! = prevst . vote | | st . term ! = prevst . term } 
func newgrpc17health ( eps [ ] string , timeout time . duration , dialfunc dialfunc , ) * grpc17health { notifych : = make ( chan [ ] grpc . address ) addrs : = eps2addrs ( eps ) hb : = & grpc17health { addrs : addrs , eps : eps , notifych : notifych , readyc : make ( chan struct { } ) , healthcheck : func ( ep string ) ( bool , error ) { return grpchealthcheck ( ep , dialfunc ) } , unhealthyhostports : make ( map [ string ] time . time ) , upc : make ( chan struct { } ) , stopc : make ( chan struct { } ) , downc : make ( chan struct { } ) , donec : make ( chan struct { } ) , updateaddrsc : make ( chan notifymsg ) , hostport2ep : gethostport2ep ( eps ) , } if timeout < minhealthretryduration { timeout = minhealthretryduration } hb . healthchecktimeout = timeout close ( hb . downc ) go hb . updatenotifyloop ( ) hb . wg . add ( 1 ) go func ( ) { defer hb . wg . done ( ) hb . updateunhealthy ( ) } ( ) return hb } 
func ( b * grpc17health ) needupdate ( ) bool { b . mu . rlock ( ) update : = ! hasaddr ( b . addrs , b . pinaddr ) b . mu . runlock ( ) return update } 
func dflsignal ( sig syscall . signal ) { var sigactbuf [ 32 ] uint64 ptr : = unsafe . pointer ( & sigactbuf ) syscall . syscall6 ( uintptr ( syscall . sys rt sigaction ) , uintptr ( sig ) , uintptr ( ptr ) , 0 , 8 , 0 , 0 ) } 
func new ( namespaces ... string ) store { s : = newstore ( namespaces ... ) s . clock = clockwork . newrealclock ( ) return s } 
func ( s * store ) index ( ) uint64 { s . worldlock . rlock ( ) defer s . worldlock . runlock ( ) return s . currentindex } 
func ( s * store ) get ( nodepath string , recursive , sorted bool ) ( * event , error ) { var err * v2error . error s . worldlock . rlock ( ) defer s . worldlock . runlock ( ) defer func ( ) { if err == nil { s . stats . inc ( getsuccess ) if recursive { reportreadsuccess ( getrecursive ) } else { reportreadsuccess ( get ) } return } s . stats . inc ( getfail ) if recursive { reportreadfailure ( getrecursive ) } else { reportreadfailure ( get ) } } ( ) n , err : = s . internalget ( nodepath ) if err ! = nil { return nil , err } e : = newevent ( get , nodepath , n . modifiedindex , n . createdindex ) e . etcdindex = s . currentindex e . node . loadinternalnode ( n , recursive , sorted , s . clock ) return e , nil } 
func ( s * store ) create ( nodepath string , dir bool , value string , unique bool , expireopts ttloptionset ) ( * event , error ) { var err * v2error . error s . worldlock . lock ( ) defer s . worldlock . unlock ( ) defer func ( ) { if err == nil { s . stats . inc ( createsuccess ) reportwritesuccess ( create ) return } s . stats . inc ( createfail ) reportwritefailure ( create ) } ( ) e , err : = s . internalcreate ( nodepath , dir , value , unique , false , expireopts . expiretime , create ) if err ! = nil { return nil , err } e . etcdindex = s . currentindex s . watcherhub . notify ( e ) return e , nil } 
func ( s * store ) set ( nodepath string , dir bool , value string , expireopts ttloptionset ) ( * event , error ) { var err * v2error . error s . worldlock . lock ( ) defer s . worldlock . unlock ( ) defer func ( ) { if err == nil { s . stats . inc ( setsuccess ) reportwritesuccess ( set ) return } s . stats . inc ( setfail ) reportwritefailure ( set ) } ( ) n , geterr : = s . internalget ( nodepath ) if geterr ! = nil && geterr . errorcode ! = v2error . ecodekeynotfound { err = geterr return nil , err } if expireopts . refresh { if geterr ! = nil { err = geterr return nil , err } value = n . value } e , err : = s . internalcreate ( nodepath , dir , value , false , true , expireopts . expiretime , set ) if err ! = nil { return nil , err } e . etcdindex = s . currentindex if geterr == nil { prev : = newevent ( get , nodepath , n . modifiedindex , n . createdindex ) prev . node . loadinternalnode ( n , false , false , s . clock ) e . prevnode = prev . node } if ! expireopts . refresh { s . watcherhub . notify ( e ) } else { e . setrefresh ( ) s . watcherhub . add ( e ) } return e , nil } 
func getcomparefailcause ( n * node , which int , prevvalue string , previndex uint64 ) string { switch which { case compareindexnotmatch : return fmt . sprintf ( " " , previndex , n . modifiedindex ) case comparevaluenotmatch : return fmt . sprintf ( " " , prevvalue , n . value ) default : return fmt . sprintf ( " " , prevvalue , n . value , previndex , n . modifiedindex ) } } 
func ( s * store ) delete ( nodepath string , dir , recursive bool ) ( * event , error ) { var err * v2error . error s . worldlock . lock ( ) defer s . worldlock . unlock ( ) defer func ( ) { if err == nil { s . stats . inc ( deletesuccess ) reportwritesuccess ( delete ) return } s . stats . inc ( deletefail ) reportwritefailure ( delete ) } ( ) nodepath = path . clean ( path . join ( " " , nodepath ) ) if s . readonlyset . contains ( nodepath ) { return nil , v2error . newerror ( v2error . ecoderootronly , " " , s . currentindex ) } if recursive { dir = true } n , err : = s . internalget ( nodepath ) if err ! = nil { return nil , err } nextindex : = s . currentindex + 1 e : = newevent ( delete , nodepath , nextindex , n . createdindex ) e . etcdindex = nextindex e . prevnode = n . repr ( false , false , s . clock ) enode : = e . node if n . isdir ( ) { enode . dir = true } callback : = func ( path string ) { s . watcherhub . notifywatchers ( e , path , true ) } err = n . remove ( dir , recursive , callback ) if err ! = nil { return nil , err } s . currentindex ++ s . watcherhub . notify ( e ) return e , nil } 
func ( s * store ) walk ( nodepath string , walkfunc func ( prev * node , component string ) ( * node , * v2error . error ) ) ( * node , * v2error . error ) { components : = strings . split ( nodepath , " " ) curr : = s . root var err * v2error . error for i : = 1 ; i < len ( components ) ; i ++ { if len ( components [ i ] ) == 0 { return curr , nil } curr , err = walkfunc ( curr , components [ i ] ) if err ! = nil { return nil , err } } return curr , nil } 
func ( s * store ) internalget ( nodepath string ) ( * node , * v2error . error ) { nodepath = path . clean ( path . join ( " " , nodepath ) ) walkfunc : = func ( parent * node , name string ) ( * node , * v2error . error ) { if ! parent . isdir ( ) { err : = v2error . newerror ( v2error . ecodenotdir , parent . path , s . currentindex ) return nil , err } child , ok : = parent . children [ name ] if ok { return child , nil } return nil , v2error . newerror ( v2error . ecodekeynotfound , path . join ( parent . path , name ) , s . currentindex ) } f , err : = s . walk ( nodepath , walkfunc ) if err ! = nil { return nil , err } return f , nil } 
func ( s * store ) deleteexpiredkeys ( cutoff time . time ) { s . worldlock . lock ( ) defer s . worldlock . unlock ( ) for { node : = s . ttlkeyheap . top ( ) if node == nil | | node . expiretime . after ( cutoff ) { break } s . currentindex ++ e : = newevent ( expire , node . path , s . currentindex , node . createdindex ) e . etcdindex = s . currentindex e . prevnode = node . repr ( false , false , s . clock ) if node . isdir ( ) { e . node . dir = true } callback : = func ( path string ) { s . watcherhub . notifywatchers ( e , path , true ) } s . ttlkeyheap . pop ( ) node . remove ( true , true , callback ) reportexpiredkey ( ) s . stats . inc ( expirecount ) s . watcherhub . notify ( e ) } } 
func ( s * store ) checkdir ( parent * node , dirname string ) ( * node , * v2error . error ) { node , ok : = parent . children [ dirname ] if ok { if node . isdir ( ) { return node , nil } return nil , v2error . newerror ( v2error . ecodenotdir , node . path , s . currentindex ) } n : = newdir ( s , path . join ( parent . path , dirname ) , s . currentindex + 1 , parent , permanent ) parent . children [ dirname ] = n return n , nil } 
func ( s * store ) save ( ) ( [ ] byte , error ) { b , err : = json . marshal ( s . clone ( ) ) if err ! = nil { return nil , err } return b , nil } 
func ( s * store ) recovery ( state [ ] byte ) error { s . worldlock . lock ( ) defer s . worldlock . unlock ( ) err : = json . unmarshal ( state , s ) if err ! = nil { return err } s . ttlkeyheap = newttlkeyheap ( ) s . root . recoverandclean ( ) return nil } 
func ( g * generator ) next ( ) uint64 { suffix : = atomic . adduint64 ( & g . suffix , 1 ) id : = g . prefix | lowbit ( suffix , suffixlen ) return id } 
func newmakemirrorcommand ( ) * cobra . command { c : = & cobra . command { use : " " , short : " " , run : makemirrorcommandfunc , } c . flags ( ) . stringvar ( & mmprefix , " " , " " , " " ) c . flags ( ) . stringvar ( & mmdestprefix , " " , " " , " " ) c . flags ( ) . boolvar ( & mmnodestprefix , " " , false , " " ) c . flags ( ) . stringvar ( & mmcert , " " , " " , " " ) c . flags ( ) . stringvar ( & mmkey , " " , " " , " " ) c . flags ( ) . stringvar ( & mmcacert , " " , " " , " " ) c . flags ( ) . boolvar ( & mminsecuretr , " " , true , " " ) return c } 
func ( cfg config ) getlogger ( ) * zap . logger { cfg . loggermu . rlock ( ) l : = cfg . logger cfg . loggermu . runlock ( ) return l } 
func newzapcoreloggerbuilder ( lg * zap . logger , cr zapcore . core , syncer zapcore . writesyncer ) func ( * config ) error { return func ( cfg * config ) error { cfg . loggermu . lock ( ) defer cfg . loggermu . unlock ( ) cfg . logger = lg cfg . loggerconfig = nil cfg . loggercore = cr cfg . loggerwritesyncer = syncer grpclogonce . do ( func ( ) { grpclog . setloggerv2 ( logutil . newgrpcloggerv2fromzapcore ( cr , syncer ) ) } ) return nil } } 
func newsyncer ( c * clientv3 . client , prefix string , rev int64 ) syncer { return & syncer { c : c , prefix : prefix , rev : rev } } 
func dropport ( port int ) error { cmdstr : = fmt . sprintf ( " " , port ) if , err : = exec . command ( " " , " " , cmdstr ) . output ( ) ; err ! = nil { return err } cmdstr = fmt . sprintf ( " " , port ) , err : = exec . command ( " " , " " , cmdstr ) . output ( ) return err } 
func setlatency ( ms , rv int ) error { ifces , err : = getdefaultinterfaces ( ) if err ! = nil { return err } if rv > ms { rv = 1 } for ifce : = range ifces { cmdstr : = fmt . sprintf ( " " , ifce , ms , rv ) , err = exec . command ( " " , " " , cmdstr ) . output ( ) if err ! = nil { cmdstr = fmt . sprintf ( " " , ifce , ms , rv ) , err = exec . command ( " " , " " , cmdstr ) . output ( ) if err ! = nil { return err } } } return nil } 
func removelatency ( ) error { ifces , err : = getdefaultinterfaces ( ) if err ! = nil { return err } for ifce : = range ifces { , err = exec . command ( " " , " " , fmt . sprintf ( " " , ifce ) ) . output ( ) if err ! = nil { return err } } return nil } 
func newtxncommand ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , run : txncommandfunc , } cmd . flags ( ) . boolvarp ( & txninteractive , " " , " " , false , " " ) return cmd } 
func txncommandfunc ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = 0 { exitwitherror ( exitbadargs , fmt . errorf ( " " ) ) } reader : = bufio . newreader ( os . stdin ) txn : = mustclientfromcmd ( cmd ) . txn ( context . background ( ) ) promptinteractive ( " " ) txn . if ( readcompares ( reader ) ... ) promptinteractive ( " " ) txn . then ( readops ( reader ) ... ) promptinteractive ( " " ) txn . else ( readops ( reader ) ... ) resp , err : = txn . commit ( ) if err ! = nil { exitwitherror ( exiterror , err ) } display . txn ( * resp ) } 
func new ( lg * zap . logger , mode string , retention time . duration , rg revgetter , c compactable , ) ( compactor , error ) { switch mode { case modeperiodic : return newperiodic ( lg , clockwork . newrealclock ( ) , retention , rg , c ) , nil case moderevision : return newrevision ( lg , clockwork . newrealclock ( ) , int64 ( retention ) , rg , c ) , nil default : return nil , fmt . errorf ( " " , mode ) } } 
func printresponsekey ( resp * client . response , format string ) { switch format { case " " : if resp . action ! = " " { fmt . println ( resp . node . value ) } else { fmt . println ( " " , resp . prevnode . value ) } case " " : fmt . println ( " " , resp . node . key ) fmt . println ( " " , resp . node . createdindex ) fmt . println ( " " , resp . node . modifiedindex ) if resp . prevnode ! = nil { fmt . println ( " " , resp . prevnode . value ) } fmt . println ( " " , resp . node . ttl ) fmt . println ( " " , resp . index ) if resp . action ! = " " { fmt . println ( " " ) fmt . println ( resp . node . value ) } case " " : b , err : = json . marshal ( resp ) if err ! = nil { panic ( err ) } fmt . println ( string ( b ) ) default : fmt . fprintln ( os . stderr , " " , format ) } } 
func addcorsheader ( w http . responsewriter , origin string ) { w . header ( ) . add ( " " , " " ) w . header ( ) . add ( " " , origin ) w . header ( ) . add ( " " , " " ) } 
func wrapcors ( cors map [ string ] struct { } , h http . handler ) http . handler { return & corshandler { ac : & etcdserver . accesscontroller { cors : cors } , h : h , } } 
func ( txn * txnleasing ) fallback ( ops [ ] v3 . op ) ( fbops [ ] v3 . op ) { for , op : = range ops { if op . isget ( ) { continue } lkey , lend : = txn . lkv . pfx + string ( op . keybytes ( ) ) , " " if len ( op . rangebytes ( ) ) > 0 { lend = txn . lkv . pfx + string ( op . rangebytes ( ) ) } fbops = append ( fbops , v3 . opget ( lkey , v3 . withrange ( lend ) ) ) } return fbops } 
func idfromstring ( s string ) ( id , error ) { i , err : = strconv . parseuint ( s , 16 , 64 ) return id ( i ) , err } 
func acquiredirectorylock ( dirpath string , pidfilename string , readonly bool ) ( * directorylockguard , error ) { abspidfilepath , err : = filepath . abs ( filepath . join ( dirpath , pidfilename ) ) if err ! = nil { return nil , errors . wrap ( err , " " ) } f , err : = os . open ( dirpath ) if err ! = nil { return nil , errors . wrapf ( err , " " , dirpath ) } opts : = unix . lock ex | unix . lock nb if readonly { opts = unix . lock sh | unix . lock nb } err = unix . flock ( int ( f . fd ( ) ) , opts ) if err ! = nil { f . close ( ) return nil , errors . wrapf ( err , " " , dirpath ) } if ! readonly { err = ioutil . writefile ( abspidfilepath , [ ] byte ( fmt . sprintf ( " \n " , os . getpid ( ) ) ) , 0666 ) if err ! = nil { f . close ( ) return nil , errors . wrapf ( err , " " , abspidfilepath ) } } return & directorylockguard { f , abspidfilepath , readonly } , nil } 
func ( guard * directorylockguard ) release ( ) error { var err error if ! guard . readonly { err = os . remove ( guard . path ) } if closeerr : = guard . f . close ( ) ; err == nil { err = closeerr } guard . path = " " guard . f = nil return err } 
func ( v * valuestruct ) encodedsize ( ) uint16 { sz : = len ( v . value ) + 2 if v . expiresat == 0 { return uint16 ( sz + 1 ) } enc : = sizevarint ( v . expiresat ) return uint16 ( sz + enc ) } 
func ( v * valuestruct ) decode ( b [ ] byte ) { v . meta = b [ 0 ] v . usermeta = b [ 1 ] var sz int v . expiresat , sz = binary . uvarint ( b [ 2 : ] ) v . value = b [ 2 + sz : ] } 
func ( v * valuestruct ) encode ( b [ ] byte ) { b [ 0 ] = v . meta b [ 1 ] = v . usermeta sz : = binary . putuvarint ( b [ 2 : ] , v . expiresat ) copy ( b [ 2 + sz : ] , v . value ) } 
func ( v * valuestruct ) encodeto ( buf * bytes . buffer ) { buf . writebyte ( v . meta ) buf . writebyte ( v . usermeta ) var enc [ binary . maxvarintlen64 ] byte sz : = binary . putuvarint ( enc [ : ] , v . expiresat ) buf . write ( enc [ : sz ] ) buf . write ( v . value ) } 
func newmergeiterator ( iters [ ] iterator , reversed bool ) * mergeiterator { m : = & mergeiterator { all : iters , reversed : reversed } m . h = make ( elemheap , 0 , len ( iters ) ) m . initheap ( ) return m } 
func ( s * mergeiterator ) initheap ( ) { s . h = s . h [ : 0 ] for idx , itr : = range s . all { if ! itr . valid ( ) { continue } e : = & elem { itr : itr , nice : idx , reversed : s . reversed } s . h = append ( s . h , e ) } heap . init ( & s . h ) for len ( s . h ) > 0 { it : = s . h [ 0 ] . itr if it == nil | | ! it . valid ( ) { heap . pop ( & s . h ) continue } s . storekey ( s . h [ 0 ] . itr ) break } } 
func ( s * mergeiterator ) valid ( ) bool { if s == nil { return false } if len ( s . h ) == 0 { return false } return s . h [ 0 ] . itr . valid ( ) } 
func ( s * mergeiterator ) key ( ) [ ] byte { if len ( s . h ) == 0 { return nil } return s . h [ 0 ] . itr . key ( ) } 
func ( s * mergeiterator ) value ( ) valuestruct { if len ( s . h ) == 0 { return valuestruct { } } return s . h [ 0 ] . itr . value ( ) } 
func ( s * mergeiterator ) next ( ) { if len ( s . h ) == 0 { return } smallest : = s . h [ 0 ] . itr smallest . next ( ) for len ( s . h ) > 0 { smallest = s . h [ 0 ] . itr if ! smallest . valid ( ) { heap . pop ( & s . h ) continue } heap . fix ( & s . h , 0 ) smallest = s . h [ 0 ] . itr if smallest . valid ( ) { if ! bytes . equal ( smallest . key ( ) , s . curkey ) { break } smallest . next ( ) } } if ! smallest . valid ( ) { return } s . storekey ( smallest ) } 
func ( s * mergeiterator ) rewind ( ) { for , itr : = range s . all { itr . rewind ( ) } s . initheap ( ) } 
func ( s * mergeiterator ) seek ( key [ ] byte ) { for , itr : = range s . all { itr . seek ( key ) } s . initheap ( ) } 
func ( s * mergeiterator ) close ( ) error { for , itr : = range s . all { if err : = itr . close ( ) ; err ! = nil { return errors . wrap ( err , " " ) } } return nil } 
func ( p valuepointer ) encode ( b [ ] byte ) [ ] byte { binary . bigendian . putuint32 ( b [ : 4 ] , p . fid ) binary . bigendian . putuint32 ( b [ 4 : 8 ] , p . len ) binary . bigendian . putuint32 ( b [ 8 : 12 ] , p . offset ) return b [ : vptrsize ] } 
func ( h * header ) decode ( buf [ ] byte ) { h . klen = binary . bigendian . uint32 ( buf [ 0 : 4 ] ) h . vlen = binary . bigendian . uint32 ( buf [ 4 : 8 ] ) h . expiresat = binary . bigendian . uint64 ( buf [ 8 : 16 ] ) h . meta = buf [ 16 ] h . usermeta = buf [ 17 ] } 
func encodeentry ( e * entry , buf * bytes . buffer ) ( int , error ) { h : = header { klen : uint32 ( len ( e . key ) ) , vlen : uint32 ( len ( e . value ) ) , expiresat : e . expiresat , meta : e . meta , usermeta : e . usermeta , } var headerenc [ headerbufsize ] byte h . encode ( headerenc [ : ] ) hash : = crc32 . new ( y . castagnolicrctable ) buf . write ( headerenc [ : ] ) hash . write ( headerenc [ : ] ) buf . write ( e . key ) hash . write ( e . key ) buf . write ( e . value ) hash . write ( e . value ) var crcbuf [ crc32 . size ] byte binary . bigendian . putuint32 ( crcbuf [ : ] , hash . sum32 ( ) ) buf . write ( crcbuf [ : ] ) return len ( headerenc ) + len ( e . key ) + len ( e . value ) + len ( crcbuf ) , nil } 
func ( db * db ) newwritebatch ( ) * writebatch { txn : = db . newtransaction ( true , true ) txn . readts = db . orc . readmark . doneuntil ( ) return & writebatch { db : db , txn : txn } } 
func ( wb * writebatch ) setentry ( e * entry ) error { wb . lock ( ) defer wb . unlock ( ) if err : = wb . txn . setentry ( e ) ; err ! = errtxntoobig { return err } if cerr : = wb . commit ( ) ; cerr ! = nil { return cerr } if err : = wb . txn . setentry ( e ) ; err ! = nil { wb . err = err return err } return nil } 
func ( wb * writebatch ) set ( k , v [ ] byte , meta byte ) error { e : = & entry { key : k , value : v , usermeta : meta } return wb . setentry ( e ) } 
func ( wb * writebatch ) setwithttl ( key , val [ ] byte , dur time . duration ) error { expire : = time . now ( ) . add ( dur ) . unix ( ) e : = & entry { key : key , value : val , expiresat : uint64 ( expire ) } return wb . setentry ( e ) } 
func ( wb * writebatch ) delete ( k [ ] byte ) error { wb . lock ( ) defer wb . unlock ( ) if err : = wb . txn . delete ( k ) ; err ! = errtxntoobig { return err } if err : = wb . commit ( ) ; err ! = nil { return err } if err : = wb . txn . delete ( k ) ; err ! = nil { wb . err = err return err } return nil } 
func ( wb * writebatch ) commit ( ) error { if wb . err ! = nil { return wb . err } wb . wg . add ( 1 ) wb . txn . commitwith ( wb . callback ) wb . txn = wb . db . newtransaction ( true , true ) wb . txn . readts = wb . db . orc . readmark . doneuntil ( ) return wb . err } 
func ( wb * writebatch ) flush ( ) error { wb . lock ( ) = wb . commit ( ) wb . txn . discard ( ) wb . unlock ( ) wb . wg . wait ( ) return wb . err } 
func ( wb * writebatch ) error ( ) error { wb . lock ( ) defer wb . unlock ( ) return wb . err } 
func ( db * db ) getmemtables ( ) ( [ ] * skl . skiplist , func ( ) ) { db . rlock ( ) defer db . runlock ( ) tables : = make ( [ ] * skl . skiplist , len ( db . imm ) + 1 ) tables [ 0 ] = db . mt tables [ 0 ] . incrref ( ) last : = len ( db . imm ) - 1 for i : = range db . imm { tables [ i + 1 ] = db . imm [ last - i ] tables [ i + 1 ] . incrref ( ) } return tables , func ( ) { for , tbl : = range tables { tbl . decrref ( ) } } } 
func ( db * db ) get ( key [ ] byte ) ( y . valuestruct , error ) { tables , decr : = db . getmemtables ( ) defer decr ( ) var maxvs * y . valuestruct var version uint64 if bytes . hasprefix ( key , badgermove ) { maxvs = & y . valuestruct { } version = y . parsets ( key ) } y . numgets . add ( 1 ) for i : = 0 ; i < len ( tables ) ; i ++ { vs : = tables [ i ] . get ( key ) y . nummemtablegets . add ( 1 ) if vs . meta == 0 && vs . value == nil { continue } if maxvs == nil | | vs . version == version { return vs , nil } if maxvs . version < vs . version { * maxvs = vs } } return db . lc . get ( key , maxvs ) } 
func ( db * db ) writerequests ( reqs [ ] * request ) error { if len ( reqs ) == 0 { return nil } done : = func ( err error ) { for , r : = range reqs { r . err = err r . wg . done ( ) } } db . elog . printf ( " " ) err : = db . vlog . write ( reqs ) if err ! = nil { done ( err ) return err } db . elog . printf ( " " ) var count int for , b : = range reqs { if len ( b . entries ) == 0 { continue } count += len ( b . entries ) var i uint64 for err = db . ensureroomforwrite ( ) ; err == errnoroom ; err = db . ensureroomforwrite ( ) { i ++ if i % 100 == 0 { db . elog . printf ( " " ) } time . sleep ( 10 * time . millisecond ) } if err ! = nil { done ( err ) return errors . wrap ( err , " " ) } if err : = db . writetolsm ( b ) ; err ! = nil { done ( err ) return errors . wrap ( err , " " ) } db . updatehead ( b . ptrs ) } done ( nil ) db . elog . printf ( " " , count ) return nil } 
func ( db * db ) batchset ( entries [ ] * entry ) error { req , err : = db . sendtowritech ( entries ) if err ! = nil { return err } return req . wait ( ) } 
func ( db * db ) batchsetasync ( entries [ ] * entry , f func ( error ) ) error { req , err : = db . sendtowritech ( entries ) if err ! = nil { return err } go func ( ) { err : = req . wait ( ) f ( err ) } ( ) return nil } 
func ( db * db ) ensureroomforwrite ( ) error { var err error db . lock ( ) defer db . unlock ( ) if db . mt . memsize ( ) < db . opt . maxtablesize { return nil } y . asserttrue ( db . mt ! = nil ) select { case db . flushchan < - flushtask { mt : db . mt , vptr : db . vhead } : db . elog . printf ( " " ) err = db . vlog . sync ( db . vhead . fid ) if err ! = nil { return err } db . elog . printf ( " \n " , db . mt . memsize ( ) , len ( db . flushchan ) ) db . imm = append ( db . imm , db . mt ) db . mt = skl . newskiplist ( arenasize ( db . opt ) ) return nil default : return errnoroom } } 
func writelevel0table ( ft flushtask , f io . writer ) error { iter : = ft . mt . newiterator ( ) defer iter . close ( ) b : = table . newtablebuilder ( ) defer b . close ( ) for iter . seektofirst ( ) ; iter . valid ( ) ; iter . next ( ) { if len ( ft . dropprefix ) > 0 && bytes . hasprefix ( iter . key ( ) , ft . dropprefix ) { continue } if err : = b . add ( iter . key ( ) , iter . value ( ) ) ; err ! = nil { return err } } , err : = f . write ( b . finish ( ) ) return err } 
func ( db * db ) flushmemtable ( lc * y . closer ) error { defer lc . done ( ) for ft : = range db . flushchan { if ft . mt == nil { continue } for { err : = db . handleflushtask ( ft ) if err == nil { db . lock ( ) y . asserttrue ( ft . mt == db . imm [ 0 ] ) db . imm = db . imm [ 1 : ] ft . mt . decrref ( ) db . unlock ( ) break } db . opt . errorf ( " \n " , err ) time . sleep ( time . second ) } } return nil } 
func ( db * db ) calculatesize ( ) { newint : = func ( val int64 ) * expvar . int { v : = new ( expvar . int ) v . add ( val ) return v } totalsize : = func ( dir string ) ( int64 , int64 ) { var lsmsize , vlogsize int64 err : = filepath . walk ( dir , func ( path string , info os . fileinfo , err error ) error { if err ! = nil { return err } ext : = filepath . ext ( path ) if ext == " " { lsmsize += info . size ( ) } else if ext == " " { vlogsize += info . size ( ) } return nil } ) if err ! = nil { db . elog . printf ( " " , dir ) } return lsmsize , vlogsize } lsmsize , vlogsize : = totalsize ( db . opt . dir ) y . lsmsize . set ( db . opt . dir , newint ( lsmsize ) ) if db . opt . valuedir ! = db . opt . dir { , vlogsize = totalsize ( db . opt . valuedir ) } y . vlogsize . set ( db . opt . dir , newint ( vlogsize ) ) } 
func ( db * db ) runvalueloggc ( discardratio float64 ) error { if discardratio >= 1 . 0 | | discardratio <= 0 . 0 { return errinvalidrequest } headkey : = y . keywithts ( head , math . maxuint64 ) val , err : = db . lc . get ( headkey , nil ) if err ! = nil { return errors . wrap ( err , " " ) } var head valuepointer if len ( val . value ) > 0 { head . decode ( val . value ) } return db . vlog . rungc ( discardratio , head ) } 
func ( db * db ) size ( ) ( lsm , vlog int64 ) { if y . lsmsize . get ( db . opt . dir ) == nil { lsm , vlog = 0 , 0 return } lsm = y . lsmsize . get ( db . opt . dir ) . ( * expvar . int ) . value ( ) vlog = y . vlogsize . get ( db . opt . dir ) . ( * expvar . int ) . value ( ) return } 
func ( seq * sequence ) next ( ) ( uint64 , error ) { seq . lock ( ) defer seq . unlock ( ) if seq . next >= seq . leased { if err : = seq . updatelease ( ) ; err ! = nil { return 0 , err } } val : = seq . next seq . next ++ return val , nil } 
func ( seq * sequence ) release ( ) error { seq . lock ( ) defer seq . unlock ( ) err : = seq . db . update ( func ( txn * txn ) error { var buf [ 8 ] byte binary . bigendian . putuint64 ( buf [ : ] , seq . next ) return txn . set ( seq . key , buf [ : ] ) } ) if err ! = nil { return err } seq . leased = seq . next return nil } 
func ( db * db ) getsequence ( key [ ] byte , bandwidth uint64 ) ( * sequence , error ) { if db . opt . managedtxns { panic ( " " ) } switch { case len ( key ) == 0 : return nil , erremptykey case bandwidth == 0 : return nil , errzerobandwidth } seq : = & sequence { db : db , key : key , next : 0 , leased : 0 , bandwidth : bandwidth , } err : = seq . updatelease ( ) return seq , err } 
func ( db * db ) keysplits ( prefix [ ] byte ) [ ] string { var splits [ ] string for , ti : = range db . tables ( ) { if bytes . hasprefix ( ti . right , prefix ) { splits = append ( splits , string ( ti . right ) ) } } sort . strings ( splits ) return splits } 
func ( db * db ) dropall ( ) error { db . opt . infof ( " " ) f : = db . preparetodrop ( ) defer f ( ) db . lock ( ) defer db . unlock ( ) db . mt . decrref ( ) for , mt : = range db . imm { mt . decrref ( ) } db . imm = db . imm [ : 0 ] db . mt = skl . newskiplist ( arenasize ( db . opt ) ) num , err : = db . lc . droptree ( ) if err ! = nil { return err } db . opt . infof ( " \n " , num ) num , err = db . vlog . dropall ( ) if err ! = nil { return err } db . vhead = valuepointer { } db . opt . infof ( " \n " , num ) return nil } 
func ( db * db ) dropprefix ( prefix [ ] byte ) error { db . opt . infof ( " " , hex . dump ( prefix ) ) f : = db . preparetodrop ( ) defer f ( ) db . lock ( ) defer db . unlock ( ) db . imm = append ( db . imm , db . mt ) for , memtable : = range db . imm { if memtable . empty ( ) { memtable . decrref ( ) continue } task : = flushtask { mt : memtable , vptr : db . vhead , dropprefix : prefix , } db . opt . debugf ( " " ) if err : = db . handleflushtask ( task ) ; err ! = nil { db . opt . errorf ( " " , err ) return err } memtable . decrref ( ) } db . imm = db . imm [ : 0 ] db . mt = skl . newskiplist ( arenasize ( db . opt ) ) if err : = db . lc . dropprefix ( prefix ) ; err ! = nil { return err } db . opt . infof ( " " ) return nil } 
func mmap ( fd * os . file , writable bool , size int64 ) ( [ ] byte , error ) { mtype : = unix . prot read if writable { mtype | = unix . prot write } return unix . mmap ( int ( fd . fd ( ) ) , 0 , int ( size ) , mtype , unix . map shared ) } 
func madvise ( b [ ] byte , readahead bool ) error { flags : = unix . madv normal if ! readahead { flags = unix . madv random } return madvise ( b , flags ) } 
func ( o * oracle ) setdiscardts ( ts uint64 ) { o . lock ( ) defer o . unlock ( ) o . discardts = ts } 
func ( o * oracle ) hasconflict ( txn * txn ) bool { if len ( txn . reads ) == 0 { return false } for , ro : = range txn . reads { if ts , has : = o . commits [ ro ] ; has && ts > txn . readts { return true } } return false } 
func ( txn * txn ) set ( key , val [ ] byte ) error { e : = & entry { key : key , value : val , } return txn . setentry ( e ) } 
func ( txn * txn ) setwithmeta ( key , val [ ] byte , meta byte ) error { e : = & entry { key : key , value : val , usermeta : meta } return txn . setentry ( e ) } 
func ( txn * txn ) delete ( key [ ] byte ) error { e : = & entry { key : key , meta : bitdelete , } return txn . modify ( e ) } 
func ( txn * txn ) get ( key [ ] byte ) ( item * item , rerr error ) { if len ( key ) == 0 { return nil , erremptykey } else if txn . discarded { return nil , errdiscardedtxn } item = new ( item ) if txn . update { if e , has : = txn . pendingwrites [ string ( key ) ] ; has && bytes . equal ( key , e . key ) { if isdeletedorexpired ( e . meta , e . expiresat ) { return nil , errkeynotfound } item . meta = e . meta item . val = e . value item . usermeta = e . usermeta item . key = key item . status = prefetched item . version = txn . readts item . expiresat = e . expiresat return item , nil } txn . addreadkey ( key ) } seek : = y . keywithts ( key , txn . readts ) vs , err : = txn . db . get ( seek ) if err ! = nil { return nil , errors . wrapf ( err , " " , key ) } if vs . value == nil && vs . meta == 0 { return nil , errkeynotfound } if isdeletedorexpired ( vs . meta , vs . expiresat ) { return nil , errkeynotfound } item . key = key item . version = vs . version item . meta = vs . meta item . usermeta = vs . usermeta item . db = txn . db item . vptr = vs . value item . txn = txn item . expiresat = vs . expiresat return item , nil } 
func ( txn * txn ) discard ( ) { if txn . discarded { return } if atomic . loadint32 ( & txn . numiterators ) > 0 { panic ( " " ) } txn . discarded = true if ! txn . db . orc . ismanaged { txn . db . orc . readmark . done ( txn . readts ) } if txn . update { txn . db . orc . decrref ( ) } } 
func ( txn * txn ) commit ( ) error { txn . commitprecheck ( ) defer txn . discard ( ) if len ( txn . writes ) == 0 { return nil } txncb , err : = txn . commitandsend ( ) if err ! = nil { return err } return txncb ( ) } 
func ( txn * txn ) commitwith ( cb func ( error ) ) { txn . commitprecheck ( ) defer txn . discard ( ) if cb == nil { panic ( " " ) } if len ( txn . writes ) == 0 { go runtxncallback ( & txncb { user : cb , err : nil } ) return } commitcb , err : = txn . commitandsend ( ) if err ! = nil { go runtxncallback ( & txncb { user : cb , err : err } ) return } go runtxncallback ( & txncb { user : cb , commit : commitcb } ) } 
func ( db * db ) newtransaction ( update bool ) * txn { return db . newtransaction ( update , false ) } 
func ( db * db ) view ( fn func ( txn * txn ) error ) error { var txn * txn if db . opt . managedtxns { txn = db . newtransactionat ( math . maxuint64 , false ) } else { txn = db . newtransaction ( false ) } defer txn . discard ( ) return fn ( txn ) } 
func ( db * db ) update ( fn func ( txn * txn ) error ) error { if db . opt . managedtxns { panic ( " " ) } txn : = db . newtransaction ( true ) defer txn . discard ( ) if err : = fn ( txn ) ; err ! = nil { return err } return txn . commit ( ) } 
func ( itr * blockiterator ) seek ( key [ ] byte , whence int ) { itr . err = nil switch whence { case origin : itr . reset ( ) case current : } var done bool for itr . init ( ) ; itr . valid ( ) ; itr . next ( ) { k : = itr . key ( ) if y . comparekeys ( k , key ) >= 0 { done = true break } } if ! done { itr . err = io . eof } } 
func ( itr * blockiterator ) seektolast ( ) { itr . err = nil for itr . init ( ) ; itr . valid ( ) ; itr . next ( ) { } itr . prev ( ) } 
func ( itr * blockiterator ) parsekv ( h header ) { if cap ( itr . key ) < int ( h . plen + h . klen ) { sz : = int ( h . plen ) + int ( h . klen ) itr . key = make ( [ ] byte , 2 * sz ) } itr . key = itr . key [ : h . plen + h . klen ] copy ( itr . key , itr . basekey [ : h . plen ] ) copy ( itr . key [ h . plen : ] , itr . data [ itr . pos : itr . pos + uint32 ( h . klen ) ] ) itr . pos += uint32 ( h . klen ) if itr . pos + uint32 ( h . vlen ) > uint32 ( len ( itr . data ) ) { itr . err = errors . errorf ( " " , itr . pos , h . klen , h . vlen , len ( itr . data ) , h ) return } itr . val = y . safecopy ( itr . val , itr . data [ itr . pos : itr . pos + uint32 ( h . vlen ) ] ) itr . pos += uint32 ( h . vlen ) } 
func ( t * table ) newiterator ( reversed bool ) * iterator { t . incrref ( ) ti : = & iterator { t : t , reversed : reversed } ti . next ( ) return ti } 
func ( itr * iterator ) seekfrom ( key [ ] byte , whence int ) { itr . err = nil switch whence { case origin : itr . reset ( ) case current : } idx : = sort . search ( len ( itr . t . blockindex ) , func ( idx int ) bool { ko : = itr . t . blockindex [ idx ] return y . comparekeys ( ko . key , key ) > 0 } ) if idx == 0 { itr . seekhelper ( 0 , key ) return } itr . seekhelper ( idx - 1 , key ) if itr . err == io . eof { if idx == len ( itr . t . blockindex ) { return } itr . seekhelper ( idx , key ) } } 
func ( itr * iterator ) seekforprev ( key [ ] byte ) { itr . seekfrom ( key , origin ) if ! bytes . equal ( itr . key ( ) , key ) { itr . prev ( ) } } 
func ( itr * iterator ) value ( ) ( ret y . valuestruct ) { ret . decode ( itr . bi . value ( ) ) return } 
func ( itr * iterator ) seek ( key [ ] byte ) { if ! itr . reversed { itr . seek ( key ) } else { itr . seekforprev ( key ) } } 
func newconcatiterator ( tbls [ ] * table , reversed bool ) * concatiterator { iters : = make ( [ ] * iterator , len ( tbls ) ) for i : = 0 ; i < len ( tbls ) ; i ++ { iters [ i ] = tbls [ i ] . newiterator ( reversed ) } return & concatiterator { reversed : reversed , iters : iters , tables : tbls , idx : - 1 , } } 
func ( s * concatiterator ) rewind ( ) { if len ( s . iters ) == 0 { return } if ! s . reversed { s . setidx ( 0 ) } else { s . setidx ( len ( s . iters ) - 1 ) } s . cur . rewind ( ) } 
func ( s * concatiterator ) valid ( ) bool { return s . cur ! = nil && s . cur . valid ( ) } 
func ( s * concatiterator ) seek ( key [ ] byte ) { var idx int if ! s . reversed { idx = sort . search ( len ( s . tables ) , func ( i int ) bool { return y . comparekeys ( s . tables [ i ] . biggest ( ) , key ) >= 0 } ) } else { n : = len ( s . tables ) idx = n - 1 - sort . search ( n , func ( i int ) bool { return y . comparekeys ( s . tables [ n - 1 - i ] . smallest ( ) , key ) <= 0 } ) } if idx >= len ( s . tables ) | | idx < 0 { s . setidx ( - 1 ) return } s . setidx ( idx ) s . cur . seek ( key ) } 
func ( s * concatiterator ) next ( ) { s . cur . next ( ) if s . cur . valid ( ) { return } for { if ! s . reversed { s . setidx ( s . idx + 1 ) } else { s . setidx ( s . idx - 1 ) } if s . cur == nil { return } s . cur . rewind ( ) if s . cur . valid ( ) { break } } } 
func ( s * concatiterator ) close ( ) error { for , it : = range s . iters { if err : = it . close ( ) ; err ! = nil { return errors . wrap ( err , " " ) } } return nil } 
func openexistingfile ( filename string , flags uint32 ) ( * os . file , error ) { openflags : = os . o rdwr if flags & readonly ! = 0 { openflags = os . o rdonly } if flags & sync ! = 0 { openflags | = datasyncfileflag } return os . openfile ( filename , openflags , 0 ) } 
func createsyncedfile ( filename string , sync bool ) ( * os . file , error ) { flags : = os . o rdwr | os . o create | os . o excl if sync { flags | = datasyncfileflag } return os . openfile ( filename , flags , 0666 ) } 
func copy ( a [ ] byte ) [ ] byte { b : = make ( [ ] byte , len ( a ) ) copy ( b , a ) return b } 
func keywithts ( key [ ] byte , ts uint64 ) [ ] byte { out : = make ( [ ] byte , len ( key ) + 8 ) copy ( out , key ) binary . bigendian . putuint64 ( out [ len ( key ) : ] , math . maxuint64 - ts ) return out } 
func parsets ( key [ ] byte ) uint64 { if len ( key ) <= 8 { return 0 } return math . maxuint64 - binary . bigendian . uint64 ( key [ len ( key ) - 8 : ] ) } 
func comparekeys ( key1 , key2 [ ] byte ) int { asserttrue ( len ( key1 ) > 8 && len ( key2 ) > 8 ) if cmp : = bytes . compare ( key1 [ : len ( key1 ) - 8 ] , key2 [ : len ( key2 ) - 8 ] ) ; cmp ! = 0 { return cmp } return bytes . compare ( key1 [ len ( key1 ) - 8 : ] , key2 [ len ( key2 ) - 8 : ] ) } 
func parsekey ( key [ ] byte ) [ ] byte { if key == nil { return nil } asserttrue ( len ( key ) > 8 ) return key [ : len ( key ) - 8 ] } 
func samekey ( src , dst [ ] byte ) bool { if len ( src ) ! = len ( dst ) { return false } return bytes . equal ( parsekey ( src ) , parsekey ( dst ) ) } 
func ( s * slice ) resize ( sz int ) [ ] byte { if cap ( s . buf ) < sz { s . buf = make ( [ ] byte , sz ) } return s . buf [ 0 : sz ] } 
func fixedduration ( d time . duration ) string { str : = fmt . sprintf ( " " , int ( d . seconds ( ) ) % 60 ) if d >= time . minute { str = fmt . sprintf ( " " , int ( d . minutes ( ) ) % 60 ) + str } if d >= time . hour { str = fmt . sprintf ( " " , int ( d . hours ( ) ) ) + str } return str } 
func newcloser ( initial int ) * closer { ret : = & closer { closed : make ( chan struct { } ) } ret . waiting . add ( initial ) return ret } 
func newthrottle ( max int ) * throttle { return & throttle { ch : make ( chan struct { } , max ) , errch : make ( chan error , max ) , } } 
func ( t * throttle ) do ( ) error { for { select { case t . ch < - struct { } { } : t . wg . add ( 1 ) return nil case err : = < - t . errch : if err ! = nil { return err } } } } 
func ( t * throttle ) done ( err error ) { if err ! = nil { t . errch < - err } select { case < - t . ch : default : panic ( " " ) } t . wg . done ( ) } 
func ( t * throttle ) finish ( ) error { t . wg . wait ( ) close ( t . ch ) close ( t . errch ) for err : = range t . errch { if err ! = nil { return err } } return nil } 
func openmanaged ( opts options ) ( * db , error ) { opts . managedtxns = true return open ( opts ) } 
func ( db * db ) newtransactionat ( readts uint64 , update bool ) * txn { if ! db . opt . managedtxns { panic ( " " ) } txn : = db . newtransaction ( update , true ) txn . readts = readts return txn } 
func ( txn * txn ) commitat ( committs uint64 , callback func ( error ) ) error { if ! txn . db . opt . managedtxns { panic ( " " ) } txn . committs = committs if callback == nil { return txn . commit ( ) } txn . commitwith ( callback ) return nil } 
func ( db * db ) setdiscardts ( ts uint64 ) { if ! db . opt . managedtxns { panic ( " " ) } db . orc . setdiscardts ( ts ) } 
func ( lf * logfile ) openreadonly ( ) error { var err error lf . fd , err = os . openfile ( lf . path , os . o rdonly , 0666 ) if err ! = nil { return errors . wrapf ( err , " " , lf . path ) } fi , err : = lf . fd . stat ( ) if err ! = nil { return errors . wrapf ( err , " " , lf . path ) } y . asserttrue ( fi . size ( ) <= math . maxuint32 ) lf . size = uint32 ( fi . size ( ) ) if err = lf . mmap ( fi . size ( ) ) ; err ! = nil { = lf . fd . close ( ) return y . wrapf ( err , " " ) } return nil } 
func ( lf * logfile ) read ( p valuepointer , s * y . slice ) ( buf [ ] byte , err error ) { var nbr int64 offset : = p . offset if lf . loadingmode == options . fileio { buf = s . resize ( int ( p . len ) ) var n int n , err = lf . fd . readat ( buf , int64 ( offset ) ) nbr = int64 ( n ) } else { size : = int64 ( len ( lf . fmap ) ) valsz : = p . len if int64 ( offset ) >= size | | int64 ( offset + valsz ) > size { err = y . erreof } else { buf = lf . fmap [ offset : offset + valsz ] nbr = int64 ( valsz ) } } y . numreads . add ( 1 ) y . numbytesread . add ( nbr ) return buf , err } 
func ( vlog * valuelog ) sortedfids ( ) [ ] uint32 { tobedeleted : = make ( map [ uint32 ] struct { } ) for , fid : = range vlog . filestobedeleted { tobedeleted [ fid ] = struct { } { } } ret : = make ( [ ] uint32 , 0 , len ( vlog . filesmap ) ) for fid : = range vlog . filesmap { if , ok : = tobedeleted [ fid ] ; ! ok { ret = append ( ret , fid ) } } sort . slice ( ret , func ( i , j int ) bool { return ret [ i ] < ret [ j ] } ) return ret } 
func ( vlog * valuelog ) sync ( fid uint32 ) error { if vlog . opt . syncwrites { return nil } vlog . fileslock . rlock ( ) maxfid : = atomic . loaduint32 ( & vlog . maxfid ) if fid < maxfid | | len ( vlog . filesmap ) == 0 { vlog . fileslock . runlock ( ) return nil } curlf : = vlog . filesmap [ maxfid ] if curlf == nil { vlog . fileslock . runlock ( ) return nil } curlf . lock . rlock ( ) vlog . fileslock . runlock ( ) err : = curlf . sync ( ) curlf . lock . runlock ( ) return err } 
func ( vlog * valuelog ) getfilerlocked ( fid uint32 ) ( * logfile , error ) { vlog . fileslock . rlock ( ) defer vlog . fileslock . runlock ( ) ret , ok : = vlog . filesmap [ fid ] if ! ok { return nil , errretry } ret . lock . rlock ( ) return ret , nil } 
func ( vlog * valuelog ) read ( vp valuepointer , s * y . slice ) ( [ ] byte , func ( ) , error ) { maxfid : = atomic . loaduint32 ( & vlog . maxfid ) if vp . fid == maxfid && vp . offset >= vlog . woffset ( ) { return nil , nil , errors . errorf ( " " , vp . offset , vlog . woffset ( ) ) } buf , cb , err : = vlog . readvaluebytes ( vp , s ) if err ! = nil { return nil , cb , err } var h header h . decode ( buf ) n : = uint32 ( headerbufsize ) + h . klen return buf [ n : n + h . vlen ] , cb , nil } 
func ( vlog * valuelog ) encodeddiscardstats ( ) [ ] byte { vlog . lfdiscardstats . lock ( ) defer vlog . lfdiscardstats . unlock ( ) encodedstats , : = json . marshal ( vlog . lfdiscardstats . m ) return encodedstats } 
func ( vlog * valuelog ) populatediscardstats ( ) error { discardstatskey : = y . keywithts ( lfdiscardstatskey , math . maxuint64 ) vs , err : = vlog . db . get ( discardstatskey ) if err ! = nil { return err } if vs . value == nil | | len ( vs . value ) == 0 { vlog . lfdiscardstats = & lfdiscardstats { m : make ( map [ uint32 ] int64 ) } return nil } var statsmap map [ uint32 ] int64 if err : = json . unmarshal ( vs . value , & statsmap ) ; err ! = nil { return err } vlog . opt . debugf ( " " , statsmap ) vlog . lfdiscardstats = & lfdiscardstats { m : statsmap } return nil } 
func ( db * db ) backup ( w io . writer , since uint64 ) ( uint64 , error ) { stream : = db . newstream ( ) stream . logprefix = " " return stream . backup ( w , since ) } 
func ( st * stream ) tolist ( key [ ] byte , itr * iterator ) ( * pb . kvlist , error ) { list : = & pb . kvlist { } for ; itr . valid ( ) ; itr . next ( ) { item : = itr . item ( ) if item . isdeletedorexpired ( ) { break } if ! bytes . equal ( key , item . key ( ) ) { break } valcopy , err : = item . valuecopy ( nil ) if err ! = nil { return nil , err } kv : = & pb . kv { key : item . keycopy ( nil ) , value : valcopy , usermeta : [ ] byte { item . usermeta ( ) } , version : item . version ( ) , expiresat : item . expiresat ( ) , } list . kv = append ( list . kv , kv ) if st . db . opt . numversionstokeep == 1 { break } if item . discardearlierversions ( ) { break } } return list , nil } 
func ( st * stream ) produceranges ( ctx context . context ) { splits : = st . db . keysplits ( st . prefix ) start : = y . safecopy ( nil , st . prefix ) for , key : = range splits { st . rangech < - keyrange { left : start , right : y . safecopy ( nil , [ ] byte ( key ) ) } start = y . safecopy ( nil , [ ] byte ( key ) ) } st . rangech < - keyrange { left : start } close ( st . rangech ) } 
func ( st * stream ) orchestrate ( ctx context . context ) error { st . rangech = make ( chan keyrange , 3 ) st . kvchan = make ( chan * pb . kvlist , 16 ) if st . keytolist == nil { st . keytolist = st . tolist } go st . produceranges ( ctx ) errch : = make ( chan error , 1 ) var wg sync . waitgroup for i : = 0 ; i < st . numgo ; i ++ { wg . add ( 1 ) go func ( ) { defer wg . done ( ) if err : = st . producekvs ( ctx ) ; err ! = nil { select { case errch < - err : default : } } } ( ) } kverr : = make ( chan error , 1 ) go func ( ) { kverr < - st . streamkvs ( ctx ) } ( ) wg . wait ( ) close ( st . kvchan ) select { case err : = < - errch : return err default : } err : = < - kverr return err } 
func ( db * db ) newstream ( ) * stream { if db . opt . managedtxns { panic ( " " ) } return db . newstream ( ) } 
func ( db * db ) newstreamat ( readts uint64 ) * stream { if ! db . opt . managedtxns { panic ( " " ) } stream : = db . newstream ( ) stream . readts = readts return stream } 
func ( t * table ) decrref ( ) error { newref : = atomic . addint32 ( & t . ref , - 1 ) if newref == 0 { if t . loadingmode == options . memorymap { y . munmap ( t . mmap ) } if err : = t . fd . truncate ( 0 ) ; err ! = nil { return err } filename : = t . fd . name ( ) if err : = t . fd . close ( ) ; err ! = nil { return err } if err : = os . remove ( filename ) ; err ! = nil { return err } } return nil } 
func ( t * table ) close ( ) error { if t . loadingmode == options . memorymap { y . munmap ( t . mmap ) } return t . fd . close ( ) } 
func parsefileid ( name string ) ( uint64 , bool ) { name = path . base ( name ) if ! strings . hassuffix ( name , filesuffix ) { return 0 , false } name = strings . trimsuffix ( name , filesuffix ) id , err : = strconv . atoi ( name ) if err ! = nil { return 0 , false } y . asserttrue ( id >= 0 ) return uint64 ( id ) , true } 
func newfilename ( id uint64 , dir string ) string { return filepath . join ( dir , idtofilename ( id ) ) } 
func ( db * db ) printhistogram ( keyprefix [ ] byte ) { if db == nil { fmt . println ( " \n " ) return } histogram : = db . buildhistogram ( keyprefix ) fmt . printf ( " \n " ) histogram . keysizehistogram . printhistogram ( ) fmt . printf ( " \n " ) histogram . valuesizehistogram . printhistogram ( ) } 
func newsizehistogram ( ) * sizehistogram { keybins : = createhistogrambins ( 1 , 16 ) valuebins : = createhistogrambins ( 1 , 30 ) return & sizehistogram { keysizehistogram : histogramdata { bins : keybins , countperbin : make ( [ ] int64 , len ( keybins ) + 1 ) , max : math . minint64 , min : math . maxint64 , sum : 0 , } , valuesizehistogram : histogramdata { bins : valuebins , countperbin : make ( [ ] int64 , len ( valuebins ) + 1 ) , max : math . minint64 , min : math . maxint64 , sum : 0 , } , } } 
func createhistogrambins ( minexponent , maxexponent uint32 ) [ ] int64 { var bins [ ] int64 for i : = minexponent ; i <= maxexponent ; i ++ { bins = append ( bins , int64 ( 1 ) < < i ) } return bins } 
func ( histogram * histogramdata ) update ( value int64 ) { if value > histogram . max { histogram . max = value } if value < histogram . min { histogram . min = value } histogram . sum += value histogram . totalcount ++ for index : = 0 ; index <= len ( histogram . bins ) ; index ++ { if index == len ( histogram . bins ) { histogram . countperbin [ index ] ++ break } if value < int64 ( histogram . bins [ index ] ) { histogram . countperbin [ index ] ++ break } } } 
func ( db * db ) buildhistogram ( keyprefix [ ] byte ) * sizehistogram { txn : = db . newtransaction ( false ) defer txn . discard ( ) itr : = txn . newiterator ( defaultiteratoroptions ) defer itr . close ( ) badgerhistogram : = newsizehistogram ( ) for itr . seek ( keyprefix ) ; itr . validforprefix ( keyprefix ) ; itr . next ( ) { item : = itr . item ( ) badgerhistogram . keysizehistogram . update ( item . keysize ( ) ) badgerhistogram . valuesizehistogram . update ( item . valuesize ( ) ) } return badgerhistogram } 
func ( histogram histogramdata ) printhistogram ( ) { fmt . printf ( " \n " , histogram . totalcount ) fmt . printf ( " \n " , histogram . min ) fmt . printf ( " \n " , histogram . max ) fmt . printf ( " \n " , float64 ( histogram . sum ) / float64 ( histogram . totalcount ) ) fmt . printf ( " \n " , " " , " " ) numbins : = len ( histogram . bins ) for index , count : = range histogram . countperbin { if count == 0 { continue } if index == len ( histogram . countperbin ) - 1 { lowerbound : = int ( histogram . bins [ numbins - 1 ] ) fmt . printf ( " \n " , lowerbound , " " , count ) continue } upperbound : = int ( histogram . bins [ index ] ) lowerbound : = 0 if index > 0 { lowerbound = int ( histogram . bins [ index - 1 ] ) } fmt . printf ( " \n " , lowerbound , upperbound , count ) } fmt . println ( ) } 
func ( w * watermark ) init ( closer * closer ) { w . markch = make ( chan mark , 100 ) w . elog = trace . neweventlog ( " " , w . name ) go w . process ( closer ) } 
func ( w * watermark ) begin ( index uint64 ) { atomic . storeuint64 ( & w . lastindex , index ) w . markch < - mark { index : index , done : false } } 
func ( w * watermark ) beginmany ( indices [ ] uint64 ) { atomic . storeuint64 ( & w . lastindex , indices [ len ( indices ) - 1 ] ) w . markch < - mark { index : 0 , indices : indices , done : false } } 
func ( w * watermark ) done ( index uint64 ) { w . markch < - mark { index : index , done : true } } 
func ( w * watermark ) donemany ( indices [ ] uint64 ) { w . markch < - mark { index : 0 , indices : indices , done : true } } 
func ( w * watermark ) setdoneuntil ( val uint64 ) { atomic . storeuint64 ( & w . doneuntil , val ) } 
func ( w * watermark ) waitformark ( ctx context . context , index uint64 ) error { if w . doneuntil ( ) >= index { return nil } waitch : = make ( chan struct { } ) w . markch < - mark { index : index , waiter : waitch } select { case < - ctx . done ( ) : return ctx . err ( ) case < - waitch : return nil } } 
func ( h header ) encode ( b [ ] byte ) { binary . bigendian . putuint16 ( b [ 0 : 2 ] , h . plen ) binary . bigendian . putuint16 ( b [ 2 : 4 ] , h . klen ) binary . bigendian . putuint16 ( b [ 4 : 6 ] , h . vlen ) binary . bigendian . putuint32 ( b [ 6 : 10 ] , h . prev ) } 
func ( h * header ) decode ( buf [ ] byte ) int { h . plen = binary . bigendian . uint16 ( buf [ 0 : 2 ] ) h . klen = binary . bigendian . uint16 ( buf [ 2 : 4 ] ) h . vlen = binary . bigendian . uint16 ( buf [ 4 : 6 ] ) h . prev = binary . bigendian . uint32 ( buf [ 6 : 10 ] ) return h . size ( ) } 
func newtablebuilder ( ) * builder { return & builder { keybuf : newbuffer ( 1 < < 20 ) , buf : newbuffer ( 1 < < 20 ) , prevoffset : math . maxuint32 , } } 
func ( b builder ) keydiff ( newkey [ ] byte ) [ ] byte { var i int for i = 0 ; i < len ( newkey ) && i < len ( b . basekey ) ; i ++ { if newkey [ i ] ! = b . basekey [ i ] { break } } return newkey [ i : ] } 
func ( b * builder ) add ( key [ ] byte , value y . valuestruct ) error { if b . counter >= restartinterval { b . finishblock ( ) b . restarts = append ( b . restarts , uint32 ( b . buf . len ( ) ) ) b . counter = 0 b . basekey = [ ] byte { } b . baseoffset = uint32 ( b . buf . len ( ) ) b . prevoffset = math . maxuint32 } b . addhelper ( key , value ) return nil } 
func ( b * builder ) reachedcapacity ( cap int64 ) bool { estimatesz : = b . buf . len ( ) + 8 / * empty header * / + 4 * len ( b . restarts ) + 8 return int64 ( estimatesz ) > cap } 
func ( b * builder ) blockindex ( ) [ ] byte { b . restarts = append ( b . restarts , uint32 ( b . buf . len ( ) ) ) sz : = 4 * len ( b . restarts ) + 4 out : = make ( [ ] byte , sz ) buf : = out for , r : = range b . restarts { binary . bigendian . putuint32 ( buf [ : 4 ] , r ) buf = buf [ 4 : ] } binary . bigendian . putuint32 ( buf [ : 4 ] , uint32 ( len ( b . restarts ) ) ) return out } 
func ( b * builder ) finish ( ) [ ] byte { bf : = bbloom . new ( float64 ( b . keycount ) , 0 . 01 ) var klen [ 2 ] byte key : = make ( [ ] byte , 1024 ) for { if , err : = b . keybuf . read ( klen [ : ] ) ; err == io . eof { break } else if err ! = nil { y . check ( err ) } kl : = int ( binary . bigendian . uint16 ( klen [ : ] ) ) if cap ( key ) < kl { key = make ( [ ] byte , 2 * int ( kl ) ) } key = key [ : kl ] y . check2 ( b . keybuf . read ( key ) ) bf . add ( key ) } b . finishblock ( ) index : = b . blockindex ( ) b . buf . write ( index ) bdata : = bf . jsonmarshal ( ) n , err : = b . buf . write ( bdata ) y . check ( err ) var buf [ 4 ] byte binary . bigendian . putuint32 ( buf [ : ] , uint32 ( n ) ) b . buf . write ( buf [ : ] ) return b . buf . bytes ( ) } 
func ( opt * options ) errorf ( format string , v ... interface { } ) { if opt . logger == nil { return } opt . logger . errorf ( format , v ... ) } 
func ( opt * options ) infof ( format string , v ... interface { } ) { if opt . logger == nil { return } opt . logger . infof ( format , v ... ) } 
func ( opt * options ) warningf ( format string , v ... interface { } ) { if opt . logger == nil { return } opt . logger . warningf ( format , v ... ) } 
func ( opt * options ) debugf ( format string , v ... interface { } ) { if opt . logger == nil { return } opt . logger . debugf ( format , v ... ) } 
func ( s * skiplist ) decrref ( ) { newref : = atomic . addint32 ( & s . ref , - 1 ) if newref > 0 { return } s . arena . reset ( ) s . arena = nil } 
func newskiplist ( arenasize int64 ) * skiplist { arena : = newarena ( arenasize ) head : = newnode ( arena , nil , y . valuestruct { } , maxheight ) return & skiplist { height : 1 , head : head , arena : arena , ref : 1 , } } 
func randomheight ( ) int { h : = 1 for h < maxheight && rand . uint32 ( ) <= heightincrease { h ++ } return h } 
func ( s * skiplist ) findnear ( key [ ] byte , less bool , allowequal bool ) ( * node , bool ) { x : = s . head level : = int ( s . getheight ( ) - 1 ) for { next : = s . getnext ( x , level ) if next == nil { if level > 0 { level -- continue } if ! less { return nil , false } if x == s . head { return nil , false } return x , false } nextkey : = next . key ( s . arena ) cmp : = y . comparekeys ( key , nextkey ) if cmp > 0 { x = next continue } if cmp == 0 { if allowequal { return next , true } if ! less { return s . getnext ( next , 0 ) , false } if level > 0 { level -- continue } if x == s . head { return nil , false } return x , false } if level > 0 { level -- continue } if ! less { return next , false } if x == s . head { return nil , false } return x , false } } 
func ( s * skiplist ) findspliceforlevel ( key [ ] byte , before * node , level int ) ( * node , * node ) { for { next : = s . getnext ( before , level ) if next == nil { return before , next } nextkey : = next . key ( s . arena ) cmp : = y . comparekeys ( key , nextkey ) if cmp == 0 { return next , next } if cmp < 0 { return before , next } before = next } } 
func ( s * skiplist ) findlast ( ) * node { n : = s . head level : = int ( s . getheight ( ) ) - 1 for { next : = s . getnext ( n , level ) if next ! = nil { n = next continue } if level == 0 { if n == s . head { return nil } return n } level -- } } 
func ( s * skiplist ) get ( key [ ] byte ) y . valuestruct { n , : = s . findnear ( key , false , true ) if n == nil { return y . valuestruct { } } nextkey : = s . arena . getkey ( n . keyoffset , n . keysize ) if ! y . samekey ( key , nextkey ) { return y . valuestruct { } } valoffset , valsize : = n . getvalueoffset ( ) vs : = s . arena . getval ( valoffset , valsize ) vs . version = y . parsets ( nextkey ) return vs } 
func ( s * iterator ) key ( ) [ ] byte { return s . list . arena . getkey ( s . n . keyoffset , s . n . keysize ) } 
func ( s * iterator ) value ( ) y . valuestruct { valoffset , valsize : = s . n . getvalueoffset ( ) return s . list . arena . getval ( valoffset , valsize ) } 
func ( s * iterator ) next ( ) { y . asserttrue ( s . valid ( ) ) s . n = s . list . getnext ( s . n , 0 ) } 
func ( s * iterator ) prev ( ) { y . asserttrue ( s . valid ( ) ) s . n , = s . list . findnear ( s . key ( ) , true , false ) } 
func ( s * iterator ) seek ( target [ ] byte ) { s . n , = s . list . findnear ( target , false , true ) } 
func ( s * iterator ) seekforprev ( target [ ] byte ) { s . n , = s . list . findnear ( target , true , true ) } 
func ( s * iterator ) seektofirst ( ) { s . n = s . list . getnext ( s . list . head , 0 ) } 
func ( s * skiplist ) newuniiterator ( reversed bool ) * uniiterator { return & uniiterator { iter : s . newiterator ( ) , reversed : reversed , } } 
func ( s * uniiterator ) next ( ) { if ! s . reversed { s . iter . next ( ) } else { s . iter . prev ( ) } } 
func ( s * uniiterator ) rewind ( ) { if ! s . reversed { s . iter . seektofirst ( ) } else { s . iter . seektolast ( ) } } 
func ( s * uniiterator ) seek ( key [ ] byte ) { if ! s . reversed { s . iter . seek ( key ) } else { s . iter . seekforprev ( key ) } } 
func ( m * manifest ) aschanges ( ) [ ] * pb . manifestchange { changes : = make ( [ ] * pb . manifestchange , 0 , len ( m . tables ) ) for id , tm : = range m . tables { changes = append ( changes , newcreatechange ( id , int ( tm . level ) , tm . checksum ) ) } return changes } 
func ( mf * manifestfile ) addchanges ( changesparam [ ] * pb . manifestchange ) error { changes : = pb . manifestchangeset { changes : changesparam } buf , err : = changes . marshal ( ) if err ! = nil { return err } mf . appendlock . lock ( ) if err : = applychangeset ( & mf . manifest , & changes ) ; err ! = nil { mf . appendlock . unlock ( ) return err } if mf . manifest . deletions > mf . deletionsrewritethreshold && mf . manifest . deletions > manifestdeletionsratio * ( mf . manifest . creations - mf . manifest . deletions ) { if err : = mf . rewrite ( ) ; err ! = nil { mf . appendlock . unlock ( ) return err } } else { var lencrcbuf [ 8 ] byte binary . bigendian . putuint32 ( lencrcbuf [ 0 : 4 ] , uint32 ( len ( buf ) ) ) binary . bigendian . putuint32 ( lencrcbuf [ 4 : 8 ] , crc32 . checksum ( buf , y . castagnolicrctable ) ) buf = append ( lencrcbuf [ : ] , buf ... ) if , err : = mf . fp . write ( buf ) ; err ! = nil { mf . appendlock . unlock ( ) return err } } mf . appendlock . unlock ( ) return mf . fp . sync ( ) } 
func ( mf * manifestfile ) rewrite ( ) error { if err : = mf . fp . close ( ) ; err ! = nil { return err } fp , netcreations , err : = helprewrite ( mf . directory , & mf . manifest ) if err ! = nil { return err } mf . fp = fp mf . manifest . creations = netcreations mf . manifest . deletions = 0 return nil } 
func applychangeset ( build * manifest , changeset * pb . manifestchangeset ) error { for , change : = range changeset . changes { if err : = applymanifestchange ( build , change ) ; err ! = nil { return err } } return nil } 
func ( s * levelhandler ) validate ( ) error { if s . level == 0 { return nil } s . rlock ( ) defer s . runlock ( ) numtables : = len ( s . tables ) for j : = 1 ; j < numtables ; j ++ { if j >= len ( s . tables ) { return errors . errorf ( " " , s . level , j , numtables ) } if y . comparekeys ( s . tables [ j - 1 ] . biggest ( ) , s . tables [ j ] . smallest ( ) ) >= 0 { return errors . errorf ( " \n \n \n \n " , hex . dump ( s . tables [ j - 1 ] . biggest ( ) ) , hex . dump ( s . tables [ j ] . smallest ( ) ) , s . level , j , numtables ) } if y . comparekeys ( s . tables [ j ] . smallest ( ) , s . tables [ j ] . biggest ( ) ) > 0 { return errors . errorf ( " " , s . tables [ j ] . smallest ( ) , s . tables [ j ] . biggest ( ) , s . level , j , numtables ) } } return nil } 
func ( s * levelscontroller ) reservefileid ( ) uint64 { id : = atomic . adduint64 ( & s . nextfileid , 1 ) return id - 1 } 
func acquiredirectorylock ( dirpath string , pidfilename string , readonly bool ) ( * directorylockguard , error ) { if readonly { return nil , errwindowsnotsupported } abslockfilepath , err : = filepath . abs ( filepath . join ( dirpath , pidfilename ) ) if err ! = nil { return nil , errors . wrap ( err , " " ) } h , err : = syscall . createfile ( syscall . stringtoutf16ptr ( abslockfilepath ) , 0 , 0 , nil , syscall . open always , uint32 ( file attribute temporary | file flag delete on close ) , 0 ) if err ! = nil { return nil , errors . wrapf ( err , " " , abslockfilepath ) } return & directorylockguard { h : h , path : abslockfilepath } , nil } 
func ( g * directorylockguard ) release ( ) error { g . path = " " return syscall . closehandle ( g . h ) } 
func asserttruef ( b bool , format string , args ... interface { } ) { if ! b { log . fatalf ( " " , errors . errorf ( format , args ... ) ) } } 
func wrapf ( err error , format string , args ... interface { } ) error { if ! debugmode { if err == nil { return nil } return fmt . errorf ( format + " " , append ( args , err ) ... ) } return errors . wrapf ( err , format , args ... ) } 
func ( s * levelhandler ) inittables ( tables [ ] * table . table ) { s . lock ( ) defer s . unlock ( ) s . tables = tables s . totalsize = 0 for , t : = range tables { s . totalsize += t . size ( ) } if s . level == 0 { sort . slice ( s . tables , func ( i , j int ) bool { return s . tables [ i ] . id ( ) < s . tables [ j ] . id ( ) } ) } else { sort . slice ( s . tables , func ( i , j int ) bool { return y . comparekeys ( s . tables [ i ] . smallest ( ) , s . tables [ j ] . smallest ( ) ) < 0 } ) } } 
func ( s * levelhandler ) deletetables ( todel [ ] * table . table ) error { s . lock ( ) todelmap : = make ( map [ uint64 ] struct { } ) for , t : = range todel { todelmap [ t . id ( ) ] = struct { } { } } var newtables [ ] * table . table for , t : = range s . tables { , found : = todelmap [ t . id ( ) ] if ! found { newtables = append ( newtables , t ) continue } s . totalsize - = t . size ( ) } s . tables = newtables s . unlock ( ) return decrrefs ( todel ) } 
func ( s * levelhandler ) replacetables ( todel , toadd [ ] * table . table ) error { s . lock ( ) todelmap : = make ( map [ uint64 ] struct { } ) for , t : = range todel { todelmap [ t . id ( ) ] = struct { } { } } var newtables [ ] * table . table for , t : = range s . tables { , found : = todelmap [ t . id ( ) ] if ! found { newtables = append ( newtables , t ) continue } s . totalsize - = t . size ( ) } for , t : = range toadd { s . totalsize += t . size ( ) t . incrref ( ) newtables = append ( newtables , t ) } s . tables = newtables sort . slice ( s . tables , func ( i , j int ) bool { return y . comparekeys ( s . tables [ i ] . smallest ( ) , s . tables [ j ] . smallest ( ) ) < 0 } ) s . unlock ( ) return decrrefs ( todel ) } 
func ( s * levelhandler ) tryaddlevel0table ( t * table . table ) bool { y . asserttrue ( s . level == 0 ) s . lock ( ) defer s . unlock ( ) if len ( s . tables ) >= s . db . opt . numlevelzerotablesstall { return false } s . tables = append ( s . tables , t ) t . incrref ( ) s . totalsize += t . size ( ) return true } 
func ( s * levelhandler ) gettableforkey ( key [ ] byte ) ( [ ] * table . table , func ( ) error ) { s . rlock ( ) defer s . runlock ( ) if s . level == 0 { out : = make ( [ ] * table . table , 0 , len ( s . tables ) ) for i : = len ( s . tables ) - 1 ; i >= 0 ; i -- { out = append ( out , s . tables [ i ] ) s . tables [ i ] . incrref ( ) } return out , func ( ) error { for , t : = range out { if err : = t . decrref ( ) ; err ! = nil { return err } } return nil } } idx : = sort . search ( len ( s . tables ) , func ( i int ) bool { return y . comparekeys ( s . tables [ i ] . biggest ( ) , key ) >= 0 } ) if idx >= len ( s . tables ) { return nil , func ( ) error { return nil } } tbl : = s . tables [ idx ] tbl . incrref ( ) return [ ] * table . table { tbl } , tbl . decrref } 
func ( s * levelhandler ) get ( key [ ] byte ) ( y . valuestruct , error ) { tables , decr : = s . gettableforkey ( key ) keynots : = y . parsekey ( key ) var maxvs y . valuestruct for , th : = range tables { if th . doesnothave ( keynots ) { y . numlsmbloomhits . add ( s . strlevel , 1 ) continue } it : = th . newiterator ( false ) defer it . close ( ) y . numlsmgets . add ( s . strlevel , 1 ) it . seek ( key ) if ! it . valid ( ) { continue } if y . samekey ( key , it . key ( ) ) { if version : = y . parsets ( it . key ( ) ) ; maxvs . version < version { maxvs = it . value ( ) maxvs . version = version } } } return maxvs , decr ( ) } 
func ( s * levelhandler ) appenditerators ( iters [ ] y . iterator , opt * iteratoroptions ) [ ] y . iterator { s . rlock ( ) defer s . runlock ( ) tables : = make ( [ ] * table . table , 0 , len ( s . tables ) ) for , t : = range s . tables { if opt . picktable ( t ) { tables = append ( tables , t ) } } if len ( tables ) == 0 { return iters } if s . level == 0 { return appenditeratorsreversed ( iters , tables , opt . reverse ) } return append ( iters , table . newconcatiterator ( tables , opt . reverse ) ) } 
func ( s * levelhandler ) overlappingtables ( levelhandlerrlocked , kr keyrange ) ( int , int ) { if len ( kr . left ) == 0 | | len ( kr . right ) == 0 { return 0 , 0 } left : = sort . search ( len ( s . tables ) , func ( i int ) bool { return y . comparekeys ( kr . left , s . tables [ i ] . biggest ( ) ) <= 0 } ) right : = sort . search ( len ( s . tables ) , func ( i int ) bool { return y . comparekeys ( kr . right , s . tables [ i ] . smallest ( ) ) < 0 } ) return left , right } 
func ( item * item ) string ( ) string { return fmt . sprintf ( " " , item . key ( ) , item . version ( ) , item . meta ) } 
func ( item * item ) keycopy ( dst [ ] byte ) [ ] byte { return y . safecopy ( dst , item . key ) } 
func ( item * item ) value ( fn func ( val [ ] byte ) error ) error { item . wg . wait ( ) if item . status == prefetched { if item . err == nil && fn ! = nil { if err : = fn ( item . val ) ; err ! = nil { return err } } return item . err } buf , cb , err : = item . yielditemvalue ( ) defer runcallback ( cb ) if err ! = nil { return err } if fn ! = nil { return fn ( buf ) } return nil } 
func ( item * item ) estimatedsize ( ) int64 { if ! item . hasvalue ( ) { return 0 } if ( item . meta & bitvaluepointer ) == 0 { return int64 ( len ( item . key ) + len ( item . vptr ) ) } var vp valuepointer vp . decode ( item . vptr ) return int64 ( vp . len ) } 
func ( item * item ) valuesize ( ) int64 { if ! item . hasvalue ( ) { return 0 } if ( item . meta & bitvaluepointer ) == 0 { return int64 ( len ( item . vptr ) ) } var vp valuepointer vp . decode ( item . vptr ) klen : = int64 ( len ( item . key ) + 8 ) return int64 ( vp . len ) - klen - headerbufsize - crc32 . size } 
func ( txn * txn ) newiterator ( opt iteratoroptions ) * iterator { if txn . discarded { panic ( " " ) } if atomic . addint32 ( & txn . numiterators , 1 ) > 1 && txn . update { atomic . addint32 ( & txn . numiterators , - 1 ) panic ( " " ) } tables , decr : = txn . db . getmemtables ( ) defer decr ( ) txn . db . vlog . incriteratorcount ( ) var iters [ ] y . iterator if itr : = txn . newpendingwritesiterator ( opt . reverse ) ; itr ! = nil { iters = append ( iters , itr ) } for i : = 0 ; i < len ( tables ) ; i ++ { iters = append ( iters , tables [ i ] . newuniiterator ( opt . reverse ) ) } iters = txn . db . lc . appenditerators ( iters , & opt ) res : = & iterator { txn : txn , iitr : y . newmergeiterator ( iters , opt . reverse ) , opt : opt , readts : txn . readts , } return res } 
func ( txn * txn ) newkeyiterator ( key [ ] byte , opt iteratoroptions ) * iterator { if len ( opt . prefix ) > 0 { panic ( " " ) } opt . prefix = key opt . prefixiskey = true return txn . newiterator ( opt ) } 
func ( it * iterator ) item ( ) * item { tx : = it . txn tx . addreadkey ( it . item . key ( ) ) return it . item } 
func ( it * iterator ) valid ( ) bool { if it . item == nil { return false } return bytes . hasprefix ( it . item . key , it . opt . prefix ) } 
func ( it * iterator ) validforprefix ( prefix [ ] byte ) bool { return it . valid ( ) && bytes . hasprefix ( it . item . key , prefix ) } 
func ( it * iterator ) close ( ) { if it . closed { return } it . closed = true it . iitr . close ( ) waitfor : = func ( l list ) { item : = l . pop ( ) for item ! = nil { item . wg . wait ( ) item = l . pop ( ) } } waitfor ( it . waste ) waitfor ( it . data ) = it . txn . db . vlog . decriteratorcount ( ) atomic . addint32 ( & it . txn . numiterators , - 1 ) } 
func ( it * iterator ) next ( ) { it . item . wg . wait ( ) it . waste . push ( it . item ) it . item = it . data . pop ( ) for it . iitr . valid ( ) { if it . parseitem ( ) { break } } } 
func ( it * iterator ) seek ( key [ ] byte ) { for i : = it . data . pop ( ) ; i ! = nil ; i = it . data . pop ( ) { i . wg . wait ( ) it . waste . push ( i ) } it . lastkey = it . lastkey [ : 0 ] if len ( key ) == 0 { key = it . opt . prefix } if len ( key ) == 0 { it . iitr . rewind ( ) it . prefetch ( ) return } if ! it . opt . reverse { key = y . keywithts ( key , it . txn . readts ) } else { key = y . keywithts ( key , 0 ) } it . iitr . seek ( key ) it . prefetch ( ) } 
func ( db * db ) getmergeoperator ( key [ ] byte , f mergefunc , dur time . duration ) * mergeoperator { op : = & mergeoperator { f : f , db : db , key : key , closer : y . newcloser ( 1 ) , } go op . runcompactions ( dur ) return op } 
func ( op * mergeoperator ) add ( val [ ] byte ) error { return op . db . update ( func ( txn * txn ) error { return txn . set ( op . key , val ) } ) } 
func ( op * mergeoperator ) get ( ) ( [ ] byte , error ) { op . rlock ( ) defer op . runlock ( ) var existing [ ] byte err : = op . db . view ( func ( txn * txn ) ( err error ) { existing , err = op . iterateandmerge ( txn ) return err } ) if err == errnomerge { return existing , nil } return existing , err } 
func ( cs * compactstatus ) compareandadd ( thisandnextlevelrlocked , cd compactdef ) bool { cs . lock ( ) defer cs . unlock ( ) level : = cd . thislevel . level y . asserttruef ( level < len ( cs . levels ) - 1 , " " , level , len ( cs . levels ) ) thislevel : = cs . levels [ level ] nextlevel : = cs . levels [ level + 1 ] if thislevel . overlapswith ( cd . thisrange ) { return false } if nextlevel . overlapswith ( cd . nextrange ) { return false } thislevel . ranges = append ( thislevel . ranges , cd . thisrange ) nextlevel . ranges = append ( nextlevel . ranges , cd . nextrange ) thislevel . delsize += cd . thissize return true } 
func newarena ( n int64 ) * arena { out : = & arena { n : 1 , buf : make ( [ ] byte , n ) , } return out } 
func ( s * arena ) putnode ( height int ) uint32 { unusedsize : = ( maxheight - height ) * offsetsize l : = uint32 ( maxnodesize - unusedsize + nodealign ) n : = atomic . adduint32 ( & s . n , l ) y . asserttruef ( int ( n ) <= len ( s . buf ) , " " , l , n , len ( s . buf ) ) m : = ( n - l + uint32 ( nodealign ) ) & ^ uint32 ( nodealign ) return m } 
func ( s * arena ) putval ( v y . valuestruct ) uint32 { l : = uint32 ( v . encodedsize ( ) ) n : = atomic . adduint32 ( & s . n , l ) y . asserttruef ( int ( n ) <= len ( s . buf ) , " " , l , n , len ( s . buf ) ) m : = n - l v . encode ( s . buf [ m : ] ) return m } 
func ( s * arena ) getnode ( offset uint32 ) * node { if offset == 0 { return nil } return ( * node ) ( unsafe . pointer ( & s . buf [ offset ] ) ) } 
func ( s * arena ) getkey ( offset uint32 , size uint16 ) [ ] byte { return s . buf [ offset : offset + uint32 ( size ) ] } 
func ( s * arena ) getval ( offset uint32 , size uint16 ) ( ret y . valuestruct ) { ret . decode ( s . buf [ offset : offset + uint32 ( size ) ] ) return } 
func ( s * arena ) getnodeoffset ( nd * node ) uint32 { if nd == nil { return 0 } return uint32 ( uintptr ( unsafe . pointer ( nd ) ) - uintptr ( unsafe . pointer ( & s . buf [ 0 ] ) ) ) } 
func init ( ) { numreads = expvar . newint ( " " ) numwrites = expvar . newint ( " " ) numbytesread = expvar . newint ( " " ) numbyteswritten = expvar . newint ( " " ) numlsmgets = expvar . newmap ( " " ) numlsmbloomhits = expvar . newmap ( " " ) numgets = expvar . newint ( " " ) numputs = expvar . newint ( " " ) numblockedputs = expvar . newint ( " " ) nummemtablegets = expvar . newint ( " " ) lsmsize = expvar . newmap ( " " ) vlogsize = expvar . newmap ( " " ) pendingwrites = expvar . newmap ( " " ) } 
func reverttomanifest ( kv * db , mf * manifest , idmap map [ uint64 ] struct { } ) error { for id : = range mf . tables { if , ok : = idmap [ id ] ; ! ok { return fmt . errorf ( " " , id ) } } for id : = range idmap { if , ok : = mf . tables [ id ] ; ! ok { kv . elog . printf ( " \n " , id ) filename : = table . newfilename ( id , kv . opt . dir ) if err : = os . remove ( filename ) ; err ! = nil { return y . wrapf ( err , " " , id ) } } } return nil } 
func closealltables ( tables [ ] [ ] * table . table ) { for , tableslice : = range tables { for , table : = range tableslice { = table . close ( ) } } } 
func ( s * levelscontroller ) droptree ( ) ( int , error ) { var all [ ] * table . table for , l : = range s . levels { l . rlock ( ) all = append ( all , l . tables ... ) l . runlock ( ) } if len ( all ) == 0 { return 0 , nil } changes : = [ ] * pb . manifestchange { } for , table : = range all { changes = append ( changes , newdeletechange ( table . id ( ) ) ) } changeset : = pb . manifestchangeset { changes : changes } if err : = s . kv . manifest . addchanges ( changeset . changes ) ; err ! = nil { return 0 , err } for , l : = range s . levels { l . lock ( ) l . totalsize = 0 l . tables = l . tables [ : 0 ] l . unlock ( ) } for , table : = range all { if err : = table . decrref ( ) ; err ! = nil { return 0 , err } } return len ( all ) , nil } 
func ( s * levelscontroller ) islevel0compactable ( ) bool { return s . levels [ 0 ] . numtables ( ) >= s . kv . opt . numlevelzerotables } 
func ( l * levelhandler ) iscompactable ( delsize int64 ) bool { return l . gettotalsize ( ) - delsize >= l . maxtotalsize } 
func ( s * levelscontroller ) docompact ( p compactionpriority ) error { l : = p . level y . asserttrue ( l + 1 < s . kv . opt . maxlevels ) cd : = compactdef { elog : trace . new ( fmt . sprintf ( " " , l ) , " " ) , thislevel : s . levels [ l ] , nextlevel : s . levels [ l + 1 ] , dropprefix : p . dropprefix , } cd . elog . setmaxevents ( 100 ) defer cd . elog . finish ( ) s . kv . opt . infof ( " " , p ) if l == 0 { if ! s . filltablesl0 ( & cd ) { return errfilltables } } else { if ! s . filltables ( & cd ) { return errfilltables } } defer s . cstatus . delete ( cd ) s . kv . opt . infof ( " \n " , cd . thislevel . level ) s . cstatus . tolog ( cd . elog ) if err : = s . runcompactdef ( l , cd ) ; err ! = nil { s . kv . opt . warningf ( " " , err , cd ) return err } s . cstatus . tolog ( cd . elog ) s . kv . opt . infof ( " " , cd . thislevel . level ) return nil } 
func ( s * levelscontroller ) get ( key [ ] byte , maxvs * y . valuestruct ) ( y . valuestruct , error ) { version : = y . parsets ( key ) for , h : = range s . levels { vs , err : = h . get ( key ) if err ! = nil { return y . valuestruct { } , errors . wrapf ( err , " " , key ) } if vs . value == nil && vs . meta == 0 { continue } if maxvs == nil | | vs . version == version { return vs , nil } if maxvs . version < vs . version { * maxvs = vs } } if maxvs ! = nil { return * maxvs , nil } return y . valuestruct { } , nil } 
func ( s * levelscontroller ) appenditerators ( iters [ ] y . iterator , opt * iteratoroptions ) [ ] y . iterator { for , level : = range s . levels { iters = level . appenditerators ( iters , opt ) } return iters } 
func seektotal ( txn * badger . txn ) ( [ ] account , error ) { expected : = uint64 ( numaccounts ) * uint64 ( initialbal ) var accounts [ ] account var total uint64 for i : = 0 ; i < numaccounts ; i ++ { item , err : = txn . get ( key ( i ) ) if err ! = nil { log . printf ( " \n " , i , err , key ( i ) ) return accounts , err } val , err : = item . valuecopy ( nil ) if err ! = nil { return accounts , err } acc : = account { id : i , bal : touint64 ( val ) , } accounts = append ( accounts , acc ) total += acc . bal } if total ! = expected { log . printf ( " " , expected , total ) atomic . addint32 ( & stopall , 1 ) return accounts , errfailure } return accounts , nil } 
func findfirstinvalidtxn ( db * badger . db , lowts , hights uint64 ) uint64 { checkat : = func ( ts uint64 ) error { txn : = db . newtransactionat ( ts , false ) , err : = seektotal ( txn ) txn . discard ( ) return err } if hights - lowts < 1 { log . printf ( " \n " , lowts ) err : = checkat ( lowts ) if err == errfailure { fmt . printf ( " \n " , lowts ) return lowts } else if err ! = nil { log . printf ( " \n " , lowts , err ) return 0 } fmt . printf ( " \n " , lowts ) return 0 } midts : = ( lowts + hights ) / 2 log . println ( ) log . printf ( " \n " , lowts , hights , midts ) err : = checkat ( midts ) if err == badger . errkeynotfound | | err == nil { return findfirstinvalidtxn ( db , midts + 1 , hights ) } return findfirstinvalidtxn ( db , lowts , midts ) } 
func ( m * inmemsnapshotstore ) create ( version snapshotversion , index , term uint64 , configuration configuration , configurationindex uint64 , trans transport ) ( snapshotsink , error ) { if version ! = 1 { return nil , fmt . errorf ( " " , version ) } name : = snapshotname ( term , index ) m . lock ( ) defer m . unlock ( ) sink : = & inmemsnapshotsink { meta : snapshotmeta { version : version , id : name , index : index , term : term , peers : encodepeers ( configuration , trans ) , configuration : configuration , configurationindex : configurationindex , } , contents : & bytes . buffer { } , } m . hassnapshot = true m . latest = sink return sink , nil } 
func ( m * inmemsnapshotstore ) list ( ) ( [ ] * snapshotmeta , error ) { m . rlock ( ) defer m . runlock ( ) if ! m . hassnapshot { return [ ] * snapshotmeta { } , nil } return [ ] * snapshotmeta { & m . latest . meta } , nil } 
func ( m * inmemsnapshotstore ) open ( id string ) ( * snapshotmeta , io . readcloser , error ) { m . rlock ( ) defer m . runlock ( ) if m . latest . meta . id ! = id { return nil , nil , fmt . errorf ( " " , id ) } return & m . latest . meta , ioutil . nopcloser ( m . latest . contents ) , nil } 
func ( s * inmemsnapshotsink ) write ( p [ ] byte ) ( n int , err error ) { written , err : = io . copy ( s . contents , bytes . newreader ( p ) ) s . meta . size += written return int ( written ) , err } 
func newfilesnapshotstorewithlogger ( base string , retain int , logger * log . logger ) ( * filesnapshotstore , error ) { if retain < 1 { return nil , fmt . errorf ( " " ) } if logger == nil { logger = log . new ( os . stderr , " " , log . lstdflags ) } path : = filepath . join ( base , snappath ) if err : = os . mkdirall ( path , 0755 ) ; err ! = nil && ! os . isexist ( err ) { return nil , fmt . errorf ( " " , err ) } store : = & filesnapshotstore { path : path , retain : retain , logger : logger , } if err : = store . testpermissions ( ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } return store , nil } 
func newfilesnapshotstore ( base string , retain int , logoutput io . writer ) ( * filesnapshotstore , error ) { if logoutput == nil { logoutput = os . stderr } return newfilesnapshotstorewithlogger ( base , retain , log . new ( logoutput , " " , log . lstdflags ) ) } 
func snapshotname ( term , index uint64 ) string { now : = time . now ( ) msec : = now . unixnano ( ) / int64 ( time . millisecond ) return fmt . sprintf ( " " , term , index , msec ) } 
func ( f * filesnapshotstore ) list ( ) ( [ ] * snapshotmeta , error ) { snapshots , err : = f . getsnapshots ( ) if err ! = nil { f . logger . printf ( " " , err ) return nil , err } var snapmeta [ ] * snapshotmeta for , meta : = range snapshots { snapmeta = append ( snapmeta , & meta . snapshotmeta ) if len ( snapmeta ) == f . retain { break } } return snapmeta , nil } 
func ( f * filesnapshotstore ) getsnapshots ( ) ( [ ] * filesnapshotmeta , error ) { snapshots , err : = ioutil . readdir ( f . path ) if err ! = nil { f . logger . printf ( " " , err ) return nil , err } var snapmeta [ ] * filesnapshotmeta for , snap : = range snapshots { if ! snap . isdir ( ) { continue } dirname : = snap . name ( ) if strings . hassuffix ( dirname , tmpsuffix ) { f . logger . printf ( " " , dirname ) continue } meta , err : = f . readmeta ( dirname ) if err ! = nil { f . logger . printf ( " " , dirname , err ) continue } if meta . version < snapshotversionmin | | meta . version > snapshotversionmax { f . logger . printf ( " " , dirname , meta . version ) continue } snapmeta = append ( snapmeta , meta ) } sort . sort ( sort . reverse ( snapmetaslice ( snapmeta ) ) ) return snapmeta , nil } 
func ( f * filesnapshotstore ) readmeta ( name string ) ( * filesnapshotmeta , error ) { metapath : = filepath . join ( f . path , name , metafilepath ) fh , err : = os . open ( metapath ) if err ! = nil { return nil , err } defer fh . close ( ) buffered : = bufio . newreader ( fh ) meta : = & filesnapshotmeta { } dec : = json . newdecoder ( buffered ) if err : = dec . decode ( meta ) ; err ! = nil { return nil , err } return meta , nil } 
func ( f * filesnapshotstore ) open ( id string ) ( * snapshotmeta , io . readcloser , error ) { meta , err : = f . readmeta ( id ) if err ! = nil { f . logger . printf ( " " , err ) return nil , nil , err } statepath : = filepath . join ( f . path , id , statefilepath ) fh , err : = os . open ( statepath ) if err ! = nil { f . logger . printf ( " " , err ) return nil , nil , err } statehash : = crc64 . new ( crc64 . maketable ( crc64 . ecma ) ) , err = io . copy ( statehash , fh ) if err ! = nil { f . logger . printf ( " " , err ) fh . close ( ) return nil , nil , err } computed : = statehash . sum ( nil ) if bytes . compare ( meta . crc , computed ) ! = 0 { f . logger . printf ( " " , meta . crc , computed ) fh . close ( ) return nil , nil , fmt . errorf ( " " ) } if , err : = fh . seek ( 0 , 0 ) ; err ! = nil { f . logger . printf ( " " , err ) fh . close ( ) return nil , nil , err } buffered : = & bufferedfile { bh : bufio . newreader ( fh ) , fh : fh , } return & meta . snapshotmeta , buffered , nil } 
func ( f * filesnapshotstore ) reapsnapshots ( ) error { snapshots , err : = f . getsnapshots ( ) if err ! = nil { f . logger . printf ( " " , err ) return err } for i : = f . retain ; i < len ( snapshots ) ; i ++ { path : = filepath . join ( f . path , snapshots [ i ] . id ) f . logger . printf ( " " , path ) if err : = os . removeall ( path ) ; err ! = nil { f . logger . printf ( " " , path , err ) return err } } return nil } 
func ( s * filesnapshotsink ) write ( b [ ] byte ) ( int , error ) { return s . buffered . write ( b ) } 
func ( s * filesnapshotsink ) close ( ) error { if s . closed { return nil } s . closed = true if err : = s . finalize ( ) ; err ! = nil { s . logger . printf ( " " , err ) if delerr : = os . removeall ( s . dir ) ; delerr ! = nil { s . logger . printf ( " " , s . dir , delerr ) return delerr } return err } if err : = s . writemeta ( ) ; err ! = nil { s . logger . printf ( " " , err ) return err } newpath : = strings . trimsuffix ( s . dir , tmpsuffix ) if err : = os . rename ( s . dir , newpath ) ; err ! = nil { s . logger . printf ( " " , err ) return err } if runtime . goos ! = " " { parentfh , err : = os . open ( s . parentdir ) defer parentfh . close ( ) if err ! = nil { s . logger . printf ( " " , s . parentdir , err ) return err } if err = parentfh . sync ( ) ; err ! = nil { s . logger . printf ( " " , s . parentdir , err ) return err } } if err : = s . store . reapsnapshots ( ) ; err ! = nil { return err } return nil } 
func ( s * filesnapshotsink ) cancel ( ) error { if s . closed { return nil } s . closed = true if err : = s . finalize ( ) ; err ! = nil { s . logger . printf ( " " , err ) return err } return os . removeall ( s . dir ) } 
func ( s * filesnapshotsink ) finalize ( ) error { if err : = s . buffered . flush ( ) ; err ! = nil { return err } if err : = s . statefile . sync ( ) ; err ! = nil { return err } stat , staterr : = s . statefile . stat ( ) if err : = s . statefile . close ( ) ; err ! = nil { return err } if staterr ! = nil { return staterr } s . meta . size = stat . size ( ) s . meta . crc = s . statehash . sum ( nil ) return nil } 
func ( s * filesnapshotsink ) writemeta ( ) error { metapath : = filepath . join ( s . dir , metafilepath ) fh , err : = os . create ( metapath ) if err ! = nil { return err } defer fh . close ( ) buffered : = bufio . newwriter ( fh ) enc : = json . newencoder ( buffered ) if err : = enc . encode ( & s . meta ) ; err ! = nil { return err } if err = buffered . flush ( ) ; err ! = nil { return err } if err = fh . sync ( ) ; err ! = nil { return err } return nil } 
func newnetworktransportwithconfig ( config * networktransportconfig , ) * networktransport { if config . logger == nil { config . logger = log . new ( os . stderr , " " , log . lstdflags ) } trans : = & networktransport { connpool : make ( map [ serveraddress ] [ ] * netconn ) , consumech : make ( chan rpc ) , logger : config . logger , maxpool : config . maxpool , shutdownch : make ( chan struct { } ) , stream : config . stream , timeout : config . timeout , timeoutscale : defaulttimeoutscale , serveraddressprovider : config . serveraddressprovider , } trans . setupstreamcontext ( ) go trans . listen ( ) return trans } 
func newnetworktransport ( stream streamlayer , maxpool int , timeout time . duration , logoutput io . writer , ) * networktransport { if logoutput == nil { logoutput = os . stderr } logger : = log . new ( logoutput , " " , log . lstdflags ) config : = & networktransportconfig { stream : stream , maxpool : maxpool , timeout : timeout , logger : logger } return newnetworktransportwithconfig ( config ) } 
func newnetworktransportwithlogger ( stream streamlayer , maxpool int , timeout time . duration , logger * log . logger , ) * networktransport { config : = & networktransportconfig { stream : stream , maxpool : maxpool , timeout : timeout , logger : logger } return newnetworktransportwithconfig ( config ) } 
func ( n * networktransport ) setupstreamcontext ( ) { ctx , cancel : = context . withcancel ( context . background ( ) ) n . streamctx = ctx n . streamcancel = cancel } 
func ( n * networktransport ) getstreamcontext ( ) context . context { n . streamctxlock . rlock ( ) defer n . streamctxlock . runlock ( ) return n . streamctx } 
func ( n * networktransport ) setheartbeathandler ( cb func ( rpc rpc ) ) { n . heartbeatfnlock . lock ( ) defer n . heartbeatfnlock . unlock ( ) n . heartbeatfn = cb } 
func ( n * networktransport ) closestreams ( ) { n . connpoollock . lock ( ) defer n . connpoollock . unlock ( ) for k , e : = range n . connpool { for , conn : = range e { conn . release ( ) } delete ( n . connpool , k ) } n . streamctxlock . lock ( ) n . streamcancel ( ) n . setupstreamcontext ( ) n . streamctxlock . unlock ( ) } 
func ( n * networktransport ) close ( ) error { n . shutdownlock . lock ( ) defer n . shutdownlock . unlock ( ) if ! n . shutdown { close ( n . shutdownch ) n . stream . close ( ) n . shutdown = true } return nil } 
func ( n * networktransport ) getpooledconn ( target serveraddress ) * netconn { n . connpoollock . lock ( ) defer n . connpoollock . unlock ( ) conns , ok : = n . connpool [ target ] if ! ok | | len ( conns ) == 0 { return nil } var conn * netconn num : = len ( conns ) conn , conns [ num - 1 ] = conns [ num - 1 ] , nil n . connpool [ target ] = conns [ : num - 1 ] return conn } 
func ( n * networktransport ) getconnfromaddressprovider ( id serverid , target serveraddress ) ( * netconn , error ) { address : = n . getprovideraddressorfallback ( id , target ) return n . getconn ( address ) } 
func ( n * networktransport ) getconn ( target serveraddress ) ( * netconn , error ) { if conn : = n . getpooledconn ( target ) ; conn ! = nil { return conn , nil } conn , err : = n . stream . dial ( target , n . timeout ) if err ! = nil { return nil , err } netconn : = & netconn { target : target , conn : conn , r : bufio . newreader ( conn ) , w : bufio . newwriter ( conn ) , } netconn . dec = codec . newdecoder ( netconn . r , & codec . msgpackhandle { } ) netconn . enc = codec . newencoder ( netconn . w , & codec . msgpackhandle { } ) return netconn , nil } 
func ( n * networktransport ) returnconn ( conn * netconn ) { n . connpoollock . lock ( ) defer n . connpoollock . unlock ( ) key : = conn . target conns , : = n . connpool [ key ] if ! n . isshutdown ( ) && len ( conns ) < n . maxpool { n . connpool [ key ] = append ( conns , conn ) } else { conn . release ( ) } } 
func ( n * networktransport ) appendentriespipeline ( id serverid , target serveraddress ) ( appendpipeline , error ) { conn , err : = n . getconnfromaddressprovider ( id , target ) if err ! = nil { return nil , err } return newnetpipeline ( n , conn ) , nil } 
func ( n * networktransport ) appendentries ( id serverid , target serveraddress , args * appendentriesrequest , resp * appendentriesresponse ) error { return n . genericrpc ( id , target , rpcappendentries , args , resp ) } 
func ( n * networktransport ) requestvote ( id serverid , target serveraddress , args * requestvoterequest , resp * requestvoteresponse ) error { return n . genericrpc ( id , target , rpcrequestvote , args , resp ) } 
func ( n * networktransport ) genericrpc ( id serverid , target serveraddress , rpctype uint8 , args interface { } , resp interface { } ) error { conn , err : = n . getconnfromaddressprovider ( id , target ) if err ! = nil { return err } if n . timeout > 0 { conn . conn . setdeadline ( time . now ( ) . add ( n . timeout ) ) } if err = sendrpc ( conn , rpctype , args ) ; err ! = nil { return err } canreturn , err : = decoderesponse ( conn , resp ) if canreturn { n . returnconn ( conn ) } return err } 
func ( n * networktransport ) installsnapshot ( id serverid , target serveraddress , args * installsnapshotrequest , resp * installsnapshotresponse , data io . reader ) error { conn , err : = n . getconnfromaddressprovider ( id , target ) if err ! = nil { return err } defer conn . release ( ) if n . timeout > 0 { timeout : = n . timeout * time . duration ( args . size / int64 ( n . timeoutscale ) ) if timeout < n . timeout { timeout = n . timeout } conn . conn . setdeadline ( time . now ( ) . add ( timeout ) ) } if err = sendrpc ( conn , rpcinstallsnapshot , args ) ; err ! = nil { return err } if , err = io . copy ( conn . w , data ) ; err ! = nil { return err } if err = conn . w . flush ( ) ; err ! = nil { return err } , err = decoderesponse ( conn , resp ) return err } 
func ( n * networktransport ) encodepeer ( id serverid , p serveraddress ) [ ] byte { address : = n . getprovideraddressorfallback ( id , p ) return [ ] byte ( address ) } 
func ( n * networktransport ) listen ( ) { const basedelay = 5 * time . millisecond const maxdelay = 1 * time . second var loopdelay time . duration for { conn , err : = n . stream . accept ( ) if err ! = nil { if loopdelay == 0 { loopdelay = basedelay } else { loopdelay * = 2 } if loopdelay > maxdelay { loopdelay = maxdelay } if ! n . isshutdown ( ) { n . logger . printf ( " " , err ) } select { case < - n . shutdownch : return case < - time . after ( loopdelay ) : continue } } loopdelay = 0 n . logger . printf ( " " , n . localaddr ( ) , conn . remoteaddr ( ) ) go n . handleconn ( n . getstreamcontext ( ) , conn ) } } 
func ( n * networktransport ) handleconn ( connctx context . context , conn net . conn ) { defer conn . close ( ) r : = bufio . newreader ( conn ) w : = bufio . newwriter ( conn ) dec : = codec . newdecoder ( r , & codec . msgpackhandle { } ) enc : = codec . newencoder ( w , & codec . msgpackhandle { } ) for { select { case < - connctx . done ( ) : n . logger . println ( " " ) return default : } if err : = n . handlecommand ( r , dec , enc ) ; err ! = nil { if err ! = io . eof { n . logger . printf ( " " , err ) } return } if err : = w . flush ( ) ; err ! = nil { n . logger . printf ( " " , err ) return } } } 
func decoderesponse ( conn * netconn , resp interface { } ) ( bool , error ) { var rpcerror string if err : = conn . dec . decode ( & rpcerror ) ; err ! = nil { conn . release ( ) return false , err } if err : = conn . dec . decode ( resp ) ; err ! = nil { conn . release ( ) return false , err } if rpcerror ! = " " { return true , fmt . errorf ( rpcerror ) } return true , nil } 
func sendrpc ( conn * netconn , rpctype uint8 , args interface { } ) error { if err : = conn . w . writebyte ( rpctype ) ; err ! = nil { conn . release ( ) return err } if err : = conn . enc . encode ( args ) ; err ! = nil { conn . release ( ) return err } if err : = conn . w . flush ( ) ; err ! = nil { conn . release ( ) return err } return nil } 
func newnetpipeline ( trans * networktransport , conn * netconn ) * netpipeline { n : = & netpipeline { conn : conn , trans : trans , donech : make ( chan appendfuture , rpcmaxpipeline ) , inprogressch : make ( chan * appendfuture , rpcmaxpipeline ) , shutdownch : make ( chan struct { } ) , } go n . decoderesponses ( ) return n } 
func ( n * netpipeline ) decoderesponses ( ) { timeout : = n . trans . timeout for { select { case future : = < - n . inprogressch : if timeout > 0 { n . conn . conn . setreaddeadline ( time . now ( ) . add ( timeout ) ) } , err : = decoderesponse ( n . conn , future . resp ) future . respond ( err ) select { case n . donech < - future : case < - n . shutdownch : return } case < - n . shutdownch : return } } } 
func ( n * netpipeline ) appendentries ( args * appendentriesrequest , resp * appendentriesresponse ) ( appendfuture , error ) { future : = & appendfuture { start : time . now ( ) , args : args , resp : resp , } future . init ( ) if timeout : = n . trans . timeout ; timeout > 0 { n . conn . conn . setwritedeadline ( time . now ( ) . add ( timeout ) ) } if err : = sendrpc ( n . conn , rpcappendentries , future . args ) ; err ! = nil { return nil , err } select { case n . inprogressch < - future : return future , nil case < - n . shutdownch : return nil , errpipelineshutdown } } 
func ( n * netpipeline ) close ( ) error { n . shutdownlock . lock ( ) defer n . shutdownlock . unlock ( ) if n . shutdown { return nil } n . conn . release ( ) n . shutdown = true close ( n . shutdownch ) return nil } 
func newobserver ( channel chan observation , blocking bool , filter filterfn ) * observer { return & observer { channel : channel , blocking : blocking , filter : filter , id : atomic . adduint64 ( & nextobserverid , 1 ) , } } 
func ( r * raft ) registerobserver ( or * observer ) { r . observerslock . lock ( ) defer r . observerslock . unlock ( ) r . observers [ or . id ] = or } 
func ( r * raft ) deregisterobserver ( or * observer ) { r . observerslock . lock ( ) defer r . observerslock . unlock ( ) delete ( r . observers , or . id ) } 
func ( r * raft ) observe ( o interface { } ) { r . observerslock . rlock ( ) defer r . observerslock . runlock ( ) for , or : = range r . observers { ob : = observation { raft : r , data : o } if or . filter ! = nil && ! or . filter ( & ob ) { continue } if or . channel == nil { continue } if or . blocking { or . channel < - ob atomic . adduint64 ( & or . numobserved , 1 ) } else { select { case or . channel < - ob : atomic . adduint64 ( & or . numobserved , 1 ) default : atomic . adduint64 ( & or . numdropped , 1 ) } } } } 
func newinmemstore ( ) * inmemstore { i : = & inmemstore { logs : make ( map [ uint64 ] * log ) , kv : make ( map [ string ] [ ] byte ) , kvint : make ( map [ string ] uint64 ) , } return i } 
func ( i * inmemstore ) firstindex ( ) ( uint64 , error ) { i . l . rlock ( ) defer i . l . runlock ( ) return i . lowindex , nil } 
func ( i * inmemstore ) lastindex ( ) ( uint64 , error ) { i . l . rlock ( ) defer i . l . runlock ( ) return i . highindex , nil } 
func ( i * inmemstore ) getlog ( index uint64 , log * log ) error { i . l . rlock ( ) defer i . l . runlock ( ) l , ok : = i . logs [ index ] if ! ok { return errlognotfound } * log = * l return nil } 
func ( i * inmemstore ) storelog ( log * log ) error { return i . storelogs ( [ ] * log { log } ) } 
func ( i * inmemstore ) storelogs ( logs [ ] * log ) error { i . l . lock ( ) defer i . l . unlock ( ) for , l : = range logs { i . logs [ l . index ] = l if i . lowindex == 0 { i . lowindex = l . index } if l . index > i . highindex { i . highindex = l . index } } return nil } 
func ( i * inmemstore ) deleterange ( min , max uint64 ) error { i . l . lock ( ) defer i . l . unlock ( ) for j : = min ; j <= max ; j ++ { delete ( i . logs , j ) } if min <= i . lowindex { i . lowindex = max + 1 } if max >= i . highindex { i . highindex = min - 1 } if i . lowindex > i . highindex { i . lowindex = 0 i . highindex = 0 } return nil } 
func ( i * inmemstore ) set ( key [ ] byte , val [ ] byte ) error { i . l . lock ( ) defer i . l . unlock ( ) i . kv [ string ( key ) ] = val return nil } 
func ( i * inmemstore ) get ( key [ ] byte ) ( [ ] byte , error ) { i . l . rlock ( ) defer i . l . runlock ( ) val : = i . kv [ string ( key ) ] if val == nil { return nil , errors . new ( " " ) } return val , nil } 
func ( i * inmemstore ) setuint64 ( key [ ] byte , val uint64 ) error { i . l . lock ( ) defer i . l . unlock ( ) i . kvint [ string ( key ) ] = val return nil } 
func ( i * inmemstore ) getuint64 ( key [ ] byte ) ( uint64 , error ) { i . l . rlock ( ) defer i . l . runlock ( ) return i . kvint [ string ( key ) ] , nil } 
func newlogcache ( capacity int , store logstore ) ( * logcache , error ) { if capacity <= 0 { return nil , fmt . errorf ( " " ) } c : = & logcache { store : store , cache : make ( [ ] * log , capacity ) , } return c , nil } 
func newinmemtransportwithtimeout ( addr serveraddress , timeout time . duration ) ( serveraddress , * inmemtransport ) { if string ( addr ) == " " { addr = newinmemaddr ( ) } trans : = & inmemtransport { consumerch : make ( chan rpc , 16 ) , localaddr : addr , peers : make ( map [ serveraddress ] * inmemtransport ) , timeout : timeout , } return addr , trans } 
func ( i * inmemtransport ) appendentriespipeline ( id serverid , target serveraddress ) ( appendpipeline , error ) { i . lock ( ) defer i . unlock ( ) peer , ok : = i . peers [ target ] if ! ok { return nil , fmt . errorf ( " " , target ) } pipeline : = newinmempipeline ( i , peer , target ) i . pipelines = append ( i . pipelines , pipeline ) return pipeline , nil } 
func ( i * inmemtransport ) appendentries ( id serverid , target serveraddress , args * appendentriesrequest , resp * appendentriesresponse ) error { rpcresp , err : = i . makerpc ( target , args , nil , i . timeout ) if err ! = nil { return err } out : = rpcresp . response . ( * appendentriesresponse ) * resp = * out return nil } 
func ( i * inmemtransport ) requestvote ( id serverid , target serveraddress , args * requestvoterequest , resp * requestvoteresponse ) error { rpcresp , err : = i . makerpc ( target , args , nil , i . timeout ) if err ! = nil { return err } out : = rpcresp . response . ( * requestvoteresponse ) * resp = * out return nil } 
func ( i * inmemtransport ) installsnapshot ( id serverid , target serveraddress , args * installsnapshotrequest , resp * installsnapshotresponse , data io . reader ) error { rpcresp , err : = i . makerpc ( target , args , data , 10 * i . timeout ) if err ! = nil { return err } out : = rpcresp . response . ( * installsnapshotresponse ) * resp = * out return nil } 
func ( i * inmemtransport ) encodepeer ( id serverid , p serveraddress ) [ ] byte { return [ ] byte ( p ) } 
func ( i * inmemtransport ) connect ( peer serveraddress , t transport ) { trans : = t . ( * inmemtransport ) i . lock ( ) defer i . unlock ( ) i . peers [ peer ] = trans } 
func ( i * inmemtransport ) disconnect ( peer serveraddress ) { i . lock ( ) defer i . unlock ( ) delete ( i . peers , peer ) n : = len ( i . pipelines ) for idx : = 0 ; idx < n ; idx ++ { if i . pipelines [ idx ] . peeraddr == peer { i . pipelines [ idx ] . close ( ) i . pipelines [ idx ] , i . pipelines [ n - 1 ] = i . pipelines [ n - 1 ] , nil idx -- n -- } } i . pipelines = i . pipelines [ : n ] } 
func ( i * inmemtransport ) disconnectall ( ) { i . lock ( ) defer i . unlock ( ) i . peers = make ( map [ serveraddress ] * inmemtransport ) for , pipeline : = range i . pipelines { pipeline . close ( ) } i . pipelines = nil } 
func ( r * rpc ) respond ( resp interface { } , err error ) { r . respchan < - rpcresponse { resp , err } } 
func ( u * usersnapshotfuture ) open ( ) ( * snapshotmeta , io . readcloser , error ) { if u . opener == nil { return nil , nil , fmt . errorf ( " " ) } else { defer func ( ) { u . opener = nil } ( ) return u . opener ( ) } } 
func ( v * verifyfuture ) vote ( leader bool ) { v . votelock . lock ( ) defer v . votelock . unlock ( ) if v . notifych == nil { return } if leader { v . votes ++ if v . votes >= v . quorumsize { v . notifych < - v v . notifych = nil } } else { v . notifych < - v v . notifych = nil } } 
func ( s * followerreplication ) notifyall ( leader bool ) { s . notifylock . lock ( ) n : = s . notify s . notify = make ( map [ * verifyfuture ] struct { } ) s . notifylock . unlock ( ) for v , : = range n { v . vote ( leader ) } } 
func ( s * followerreplication ) cleannotify ( v * verifyfuture ) { s . notifylock . lock ( ) delete ( s . notify , v ) s . notifylock . unlock ( ) } 
func ( s * followerreplication ) lastcontact ( ) time . time { s . lastcontactlock . rlock ( ) last : = s . lastcontact s . lastcontactlock . runlock ( ) return last } 
func ( s * followerreplication ) setlastcontact ( ) { s . lastcontactlock . lock ( ) s . lastcontact = time . now ( ) s . lastcontactlock . unlock ( ) } 
func ( r * raft ) replicate ( s * followerreplication ) { stopheartbeat : = make ( chan struct { } ) defer close ( stopheartbeat ) r . gofunc ( func ( ) { r . heartbeat ( s , stopheartbeat ) } ) rpc : shouldstop : = false for ! shouldstop { select { case maxindex : = < - s . stopch : if maxindex > 0 { r . replicateto ( s , maxindex ) } return case < - s . triggerch : lastlogidx , : = r . getlastlog ( ) shouldstop = r . replicateto ( s , lastlogidx ) case < - randomtimeout ( r . conf . committimeout ) : lastlogidx , : = r . getlastlog ( ) shouldstop = r . replicateto ( s , lastlogidx ) } if ! shouldstop && s . allowpipeline { goto pipeline } } return pipeline : s . allowpipeline = false if err : = r . pipelinereplicate ( s ) ; err ! = nil { if err ! = errpipelinereplicationnotsupported { r . logger . error ( fmt . sprintf ( " " , s . peer , err ) ) } } goto rpc } 
func ( r * raft ) heartbeat ( s * followerreplication , stopch chan struct { } ) { var failures uint64 req : = appendentriesrequest { rpcheader : r . getrpcheader ( ) , term : s . currentterm , leader : r . trans . encodepeer ( r . localid , r . localaddr ) , } var resp appendentriesresponse for { select { case < - s . notifych : case < - randomtimeout ( r . conf . heartbeattimeout / 10 ) : case < - stopch : return } start : = time . now ( ) if err : = r . trans . appendentries ( s . peer . id , s . peer . address , & req , & resp ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , s . peer . address , err ) ) failures ++ select { case < - time . after ( backoff ( failurewait , failures , maxfailurescale ) ) : case < - stopch : } } else { s . setlastcontact ( ) failures = 0 metrics . measuresince ( [ ] string { " " , " " , " " , string ( s . peer . id ) } , start ) s . notifyall ( resp . success ) } } } 
func ( r * raft ) pipelinereplicate ( s * followerreplication ) error { pipeline , err : = r . trans . appendentriespipeline ( s . peer . id , s . peer . address ) if err ! = nil { return err } defer pipeline . close ( ) r . logger . info ( fmt . sprintf ( " " , s . peer ) ) defer r . logger . info ( fmt . sprintf ( " " , s . peer ) ) stopch : = make ( chan struct { } ) finishch : = make ( chan struct { } ) r . gofunc ( func ( ) { r . pipelinedecode ( s , pipeline , stopch , finishch ) } ) nextindex : = s . nextindex shouldstop : = false send : for ! shouldstop { select { case < - finishch : break send case maxindex : = < - s . stopch : if maxindex > 0 { r . pipelinesend ( s , pipeline , & nextindex , maxindex ) } break send case < - s . triggerch : lastlogidx , : = r . getlastlog ( ) shouldstop = r . pipelinesend ( s , pipeline , & nextindex , lastlogidx ) case < - randomtimeout ( r . conf . committimeout ) : lastlogidx , : = r . getlastlog ( ) shouldstop = r . pipelinesend ( s , pipeline , & nextindex , lastlogidx ) } } close ( stopch ) select { case < - finishch : case < - r . shutdownch : } return nil } 
func ( r * raft ) pipelinesend ( s * followerreplication , p appendpipeline , nextidx * uint64 , lastindex uint64 ) ( shouldstop bool ) { req : = new ( appendentriesrequest ) if err : = r . setupappendentries ( s , req , * nextidx , lastindex ) ; err ! = nil { return true } if , err : = p . appendentries ( req , new ( appendentriesresponse ) ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , s . peer , err ) ) return true } if n : = len ( req . entries ) ; n > 0 { last : = req . entries [ n - 1 ] * nextidx = last . index + 1 } return false } 
func ( r * raft ) pipelinedecode ( s * followerreplication , p appendpipeline , stopch , finishch chan struct { } ) { defer close ( finishch ) respch : = p . consumer ( ) for { select { case ready : = < - respch : req , resp : = ready . request ( ) , ready . response ( ) appendstats ( string ( s . peer . id ) , ready . start ( ) , float32 ( len ( req . entries ) ) ) if resp . term > req . term { r . handlestaleterm ( s ) return } s . setlastcontact ( ) if ! resp . success { return } updatelastappended ( s , req ) case < - stopch : return } } } 
func ( r * raft ) setupappendentries ( s * followerreplication , req * appendentriesrequest , nextindex , lastindex uint64 ) error { req . rpcheader = r . getrpcheader ( ) req . term = s . currentterm req . leader = r . trans . encodepeer ( r . localid , r . localaddr ) req . leadercommitindex = r . getcommitindex ( ) if err : = r . setpreviouslog ( req , nextindex ) ; err ! = nil { return err } if err : = r . setnewlogs ( req , nextindex , lastindex ) ; err ! = nil { return err } return nil } 
func ( r * raft ) setpreviouslog ( req * appendentriesrequest , nextindex uint64 ) error { lastsnapidx , lastsnapterm : = r . getlastsnapshot ( ) if nextindex == 1 { req . prevlogentry = 0 req . prevlogterm = 0 } else if ( nextindex - 1 ) == lastsnapidx { req . prevlogentry = lastsnapidx req . prevlogterm = lastsnapterm } else { var l log if err : = r . logs . getlog ( nextindex - 1 , & l ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , nextindex - 1 , err ) ) return err } req . prevlogentry = l . index req . prevlogterm = l . term } return nil } 
func ( r * raft ) setnewlogs ( req * appendentriesrequest , nextindex , lastindex uint64 ) error { req . entries = make ( [ ] * log , 0 , r . conf . maxappendentries ) maxindex : = min ( nextindex + uint64 ( r . conf . maxappendentries ) - 1 , lastindex ) for i : = nextindex ; i <= maxindex ; i ++ { oldlog : = new ( log ) if err : = r . logs . getlog ( i , oldlog ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , i , err ) ) return err } req . entries = append ( req . entries , oldlog ) } return nil } 
func appendstats ( peer string , start time . time , logs float32 ) { metrics . measuresince ( [ ] string { " " , " " , " " , " " , peer } , start ) metrics . incrcounter ( [ ] string { " " , " " , " " , " " , peer } , logs ) } 
func ( r * raft ) handlestaleterm ( s * followerreplication ) { r . logger . error ( fmt . sprintf ( " " , s . peer ) ) s . notifyall ( false ) asyncnotifych ( s . stepdown ) } 
func updatelastappended ( s * followerreplication , req * appendentriesrequest ) { if logs : = req . entries ; len ( logs ) > 0 { last : = logs [ len ( logs ) - 1 ] s . nextindex = last . index + 1 s . commitment . match ( s . peer . id , last . index ) } s . notifyall ( true ) } 
func ( t * transport ) appendentries ( id raft . serverid , target raft . serveraddress , args * raft . appendentriesrequest , resp * raft . appendentriesresponse ) error { ae : = appendentries { source : t . node , target : target , firstindex : firstindex ( args ) , lastindex : lastindex ( args ) , commitindex : args . leadercommitindex , } if len ( t . ae ) < cap ( t . ae ) { t . ae = append ( t . ae , ae ) } return t . sendrpc ( string ( target ) , args , resp ) } 
func ( t * transport ) requestvote ( id raft . serverid , target raft . serveraddress , args * raft . requestvoterequest , resp * raft . requestvoteresponse ) error { return t . sendrpc ( string ( target ) , args , resp ) } 
func ( t * transport ) installsnapshot ( id raft . serverid , target raft . serveraddress , args * raft . installsnapshotrequest , resp * raft . installsnapshotresponse , data io . reader ) error { t . log . printf ( " " ) return errors . new ( " " ) } 
func ( t * transport ) encodepeer ( id raft . serverid , p raft . serveraddress ) [ ] byte { return [ ] byte ( p ) } 
func ( t * transport ) decodepeer ( p [ ] byte ) raft . serveraddress { return raft . serveraddress ( p ) } 
func ( t * transport ) appendentriespipeline ( id raft . serverid , target raft . serveraddress ) ( raft . appendpipeline , error ) { p : = & pipeline { t : t , id : id , target : target , work : make ( chan * appendentry , 100 ) , consumer : make ( chan raft . appendfuture , 100 ) , } go p . run ( ) return p , nil } 
func ( p * pipeline ) appendentries ( args * raft . appendentriesrequest , resp * raft . appendentriesresponse ) ( raft . appendfuture , error ) { e : = & appendentry { req : args , res : resp , start : time . now ( ) , ready : make ( chan error ) , consumer : p . consumer , } p . work < - e return e , nil } 
func readpeersjson ( path string ) ( configuration , error ) { buf , err : = ioutil . readfile ( path ) if err ! = nil { return configuration { } , err } var peers [ ] string dec : = json . newdecoder ( bytes . newreader ( buf ) ) if err : = dec . decode ( & peers ) ; err ! = nil { return configuration { } , err } var configuration configuration for , peer : = range peers { server : = server { suffrage : voter , id : serverid ( peer ) , address : serveraddress ( peer ) , } configuration . servers = append ( configuration . servers , server ) } if err : = checkconfiguration ( configuration ) ; err ! = nil { return configuration { } , err } return configuration , nil } 
func readconfigjson ( path string ) ( configuration , error ) { buf , err : = ioutil . readfile ( path ) if err ! = nil { return configuration { } , err } var peers [ ] configentry dec : = json . newdecoder ( bytes . newreader ( buf ) ) if err : = dec . decode ( & peers ) ; err ! = nil { return configuration { } , err } var configuration configuration for , peer : = range peers { suffrage : = voter if peer . nonvoter { suffrage = nonvoter } server : = server { suffrage : suffrage , id : peer . id , address : peer . address , } configuration . servers = append ( configuration . servers , server ) } if err : = checkconfiguration ( configuration ) ; err ! = nil { return configuration { } , err } return configuration , nil } 
func newtcptransport ( bindaddr string , advertise net . addr , maxpool int , timeout time . duration , logoutput io . writer , ) ( * networktransport , error ) { return newtcptransport ( bindaddr , advertise , func ( stream streamlayer ) * networktransport { return newnetworktransport ( stream , maxpool , timeout , logoutput ) } ) } 
func newtcptransportwithlogger ( bindaddr string , advertise net . addr , maxpool int , timeout time . duration , logger * log . logger , ) ( * networktransport , error ) { return newtcptransport ( bindaddr , advertise , func ( stream streamlayer ) * networktransport { return newnetworktransportwithlogger ( stream , maxpool , timeout , logger ) } ) } 
func newtcptransportwithconfig ( bindaddr string , advertise net . addr , config * networktransportconfig , ) ( * networktransport , error ) { return newtcptransport ( bindaddr , advertise , func ( stream streamlayer ) * networktransport { config . stream = stream return newnetworktransportwithconfig ( config ) } ) } 
func ( t * tcpstreamlayer ) dial ( address serveraddress , timeout time . duration ) ( net . conn , error ) { return net . dialtimeout ( " " , string ( address ) , timeout ) } 
func ( t * tcpstreamlayer ) accept ( ) ( c net . conn , err error ) { return t . listener . accept ( ) } 
func ( t * tcpstreamlayer ) addr ( ) net . addr { if t . advertise ! = nil { return t . advertise } return t . listener . addr ( ) } 
func bootstrapcluster ( conf * config , logs logstore , stable stablestore , snaps snapshotstore , trans transport , configuration configuration ) error { if err : = validateconfig ( conf ) ; err ! = nil { return err } if err : = checkconfiguration ( configuration ) ; err ! = nil { return err } hasstate , err : = hasexistingstate ( logs , stable , snaps ) if err ! = nil { return fmt . errorf ( " " , err ) } if hasstate { return errcantbootstrap } if err : = stable . setuint64 ( keycurrentterm , 1 ) ; err ! = nil { return fmt . errorf ( " " , err ) } entry : = & log { index : 1 , term : 1 , } if conf . protocolversion < 3 { entry . type = logremovepeerdeprecated entry . data = encodepeers ( configuration , trans ) } else { entry . type = logconfiguration entry . data = encodeconfiguration ( configuration ) } if err : = logs . storelog ( entry ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func hasexistingstate ( logs logstore , stable stablestore , snaps snapshotstore ) ( bool , error ) { currentterm , err : = stable . getuint64 ( keycurrentterm ) if err == nil { if currentterm > 0 { return true , nil } } else { if err . error ( ) ! = " " { return false , fmt . errorf ( " " , err ) } } lastindex , err : = logs . lastindex ( ) if err ! = nil { return false , fmt . errorf ( " " , err ) } if lastindex > 0 { return true , nil } snapshots , err : = snaps . list ( ) if err ! = nil { return false , fmt . errorf ( " " , err ) } if len ( snapshots ) > 0 { return true , nil } return false , nil } 
func ( r * raft ) restoresnapshot ( ) error { snapshots , err : = r . snapshots . list ( ) if err ! = nil { r . logger . error ( fmt . sprintf ( " " , err ) ) return err } for , snapshot : = range snapshots { , source , err : = r . snapshots . open ( snapshot . id ) if err ! = nil { r . logger . error ( fmt . sprintf ( " " , snapshot . id , err ) ) continue } defer source . close ( ) if err : = r . fsm . restore ( source ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , snapshot . id , err ) ) continue } r . logger . info ( fmt . sprintf ( " " , snapshot . id ) ) r . setlastapplied ( snapshot . index ) r . setlastsnapshot ( snapshot . index , snapshot . term ) if snapshot . version > 0 { r . configurations . committed = snapshot . configuration r . configurations . committedindex = snapshot . configurationindex r . configurations . latest = snapshot . configuration r . configurations . latestindex = snapshot . configurationindex } else { configuration : = decodepeers ( snapshot . peers , r . trans ) r . configurations . committed = configuration r . configurations . committedindex = snapshot . index r . configurations . latest = configuration r . configurations . latestindex = snapshot . index } return nil } if len ( snapshots ) > 0 { return fmt . errorf ( " " ) } return nil } 
func ( r * raft ) bootstrapcluster ( configuration configuration ) future { bootstrapreq : = & bootstrapfuture { } bootstrapreq . init ( ) bootstrapreq . configuration = configuration select { case < - r . shutdownch : return errorfuture { errraftshutdown } case r . bootstrapch < - bootstrapreq : return bootstrapreq } } 
func ( r * raft ) leader ( ) serveraddress { r . leaderlock . rlock ( ) leader : = r . leader r . leaderlock . runlock ( ) return leader } 
func ( r * raft ) apply ( cmd [ ] byte , timeout time . duration ) applyfuture { metrics . incrcounter ( [ ] string { " " , " " } , 1 ) var timer < - chan time . time if timeout > 0 { timer = time . after ( timeout ) } logfuture : = & logfuture { log : log { type : logcommand , data : cmd , } , } logfuture . init ( ) select { case < - timer : return errorfuture { errenqueuetimeout } case < - r . shutdownch : return errorfuture { errraftshutdown } case r . applych < - logfuture : return logfuture } } 
func ( r * raft ) barrier ( timeout time . duration ) future { metrics . incrcounter ( [ ] string { " " , " " } , 1 ) var timer < - chan time . time if timeout > 0 { timer = time . after ( timeout ) } logfuture : = & logfuture { log : log { type : logbarrier , } , } logfuture . init ( ) select { case < - timer : return errorfuture { errenqueuetimeout } case < - r . shutdownch : return errorfuture { errraftshutdown } case r . applych < - logfuture : return logfuture } } 
func ( r * raft ) verifyleader ( ) future { metrics . incrcounter ( [ ] string { " " , " " } , 1 ) verifyfuture : = & verifyfuture { } verifyfuture . init ( ) select { case < - r . shutdownch : return errorfuture { errraftshutdown } case r . verifych < - verifyfuture : return verifyfuture } } 
func ( r * raft ) getconfiguration ( ) configurationfuture { configreq : = & configurationsfuture { } configreq . init ( ) select { case < - r . shutdownch : configreq . respond ( errraftshutdown ) return configreq case r . configurationsch < - configreq : return configreq } } 
func ( r * raft ) addpeer ( peer serveraddress ) future { if r . protocolversion > 2 { return errorfuture { errunsupportedprotocol } } return r . requestconfigchange ( configurationchangerequest { command : addstaging , serverid : serverid ( peer ) , serveraddress : peer , previndex : 0 , } , 0 ) } 
func ( r * raft ) removepeer ( peer serveraddress ) future { if r . protocolversion > 2 { return errorfuture { errunsupportedprotocol } } return r . requestconfigchange ( configurationchangerequest { command : removeserver , serverid : serverid ( peer ) , previndex : 0 , } , 0 ) } 
func ( r * raft ) addvoter ( id serverid , address serveraddress , previndex uint64 , timeout time . duration ) indexfuture { if r . protocolversion < 2 { return errorfuture { errunsupportedprotocol } } return r . requestconfigchange ( configurationchangerequest { command : addstaging , serverid : id , serveraddress : address , previndex : previndex , } , timeout ) } 
func ( r * raft ) removeserver ( id serverid , previndex uint64 , timeout time . duration ) indexfuture { if r . protocolversion < 2 { return errorfuture { errunsupportedprotocol } } return r . requestconfigchange ( configurationchangerequest { command : removeserver , serverid : id , previndex : previndex , } , timeout ) } 
func ( r * raft ) shutdown ( ) future { r . shutdownlock . lock ( ) defer r . shutdownlock . unlock ( ) if ! r . shutdown { close ( r . shutdownch ) r . shutdown = true r . setstate ( shutdown ) return & shutdownfuture { r } } return & shutdownfuture { nil } } 
func ( r * raft ) snapshot ( ) snapshotfuture { future : = & usersnapshotfuture { } future . init ( ) select { case r . usersnapshotch < - future : return future case < - r . shutdownch : future . respond ( errraftshutdown ) return future } } 
func ( r * raft ) restore ( meta * snapshotmeta , reader io . reader , timeout time . duration ) error { metrics . incrcounter ( [ ] string { " " , " " } , 1 ) var timer < - chan time . time if timeout > 0 { timer = time . after ( timeout ) } restore : = & userrestorefuture { meta : meta , reader : reader , } restore . init ( ) select { case < - timer : return errenqueuetimeout case < - r . shutdownch : return errraftshutdown case r . userrestorech < - restore : if err : = restore . error ( ) ; err ! = nil { return err } } noop : = & logfuture { log : log { type : lognoop , } , } noop . init ( ) select { case < - timer : return errenqueuetimeout case < - r . shutdownch : return errraftshutdown case r . applych < - noop : return noop . error ( ) } } 
func ( r * raft ) string ( ) string { return fmt . sprintf ( " " , r . localaddr , r . getstate ( ) ) } 
func ( r * raft ) lastcontact ( ) time . time { r . lastcontactlock . rlock ( ) last : = r . lastcontact r . lastcontactlock . runlock ( ) return last } 
func ( a * loggeradapter ) logf ( s string , v ... interface { } ) { a . log . printf ( s , v ... ) } 
func ( c * cluster ) leader ( timeout time . duration ) * raftnode { start : = time . now ( ) for true { for , n : = range c . nodes { if n . raft . state ( ) == raft . leader { return n } } if time . now ( ) . sub ( start ) > timeout { return nil } time . sleep ( time . millisecond ) } return nil } 
func containsnode ( nodes [ ] * raftnode , n * raftnode ) bool { for , rn : = range nodes { if rn == n { return true } } return false } 
func ( c * cluster ) leaderplus ( n int ) [ ] * raftnode { r : = make ( [ ] * raftnode , 0 , n + 1 ) ldr : = c . leader ( time . second ) if ldr ! = nil { r = append ( r , ldr ) } if len ( r ) >= n { return r } for , node : = range c . nodes { if ! containsnode ( r , node ) { r = append ( r , node ) if len ( r ) >= n { return r } } } return r } 
func ( c * cluster ) waittiluptodate ( t * testing . t , maxwait time . duration ) { idx : = c . lastapplysuccess . index ( ) start : = time . now ( ) for true { allatidx : = true for i : = 0 ; i < len ( c . nodes ) ; i ++ { nodeappliedidx : = c . nodes [ i ] . raft . appliedindex ( ) if nodeappliedidx < idx { allatidx = false break } else if nodeappliedidx > idx { allatidx = false idx = nodeappliedidx break } } if allatidx { t . logf ( " " , idx ) return } if time . now ( ) . sub ( start ) > maxwait { t . fatalf ( " " , idx , c . appliedindexes ( ) ) } time . sleep ( time . millisecond * 10 ) } } 
func assertlogentryequal ( t * testing . t , node string , exp * raft . log , act * raft . log ) bool { res : = true if exp . term ! = act . term { t . errorf ( " " , exp . index , node , exp . term , act . term ) res = false } if exp . index ! = act . index { t . errorf ( " " , node , exp . index , act . index ) res = false } if exp . type ! = act . type { t . errorf ( " " , node , exp . index , exp . type , act . type ) res = false } if ! bytes . equal ( exp . data , act . data ) { t . errorf ( " " , node , exp . index , exp . data , act . data ) res = false } return res } 
func ( c * configuration ) clone ( ) ( copy configuration ) { copy . servers = append ( copy . servers , c . servers ... ) return } 
func ( c * configurations ) clone ( ) ( copy configurations ) { copy . committed = c . committed . clone ( ) copy . committedindex = c . committedindex copy . latest = c . latest . clone ( ) copy . latestindex = c . latestindex return } 
func hasvote ( configuration configuration , id serverid ) bool { for , server : = range configuration . servers { if server . id == id { return server . suffrage == voter } } return false } 
func checkconfiguration ( configuration configuration ) error { idset : = make ( map [ serverid ] bool ) addressset : = make ( map [ serveraddress ] bool ) var voters int for , server : = range configuration . servers { if server . id == " " { return fmt . errorf ( " " , configuration ) } if server . address == " " { return fmt . errorf ( " " , server ) } if idset [ server . id ] { return fmt . errorf ( " " , server . id ) } idset [ server . id ] = true if addressset [ server . address ] { return fmt . errorf ( " " , server . address ) } addressset [ server . address ] = true if server . suffrage == voter { voters ++ } } if voters == 0 { return fmt . errorf ( " " , configuration ) } return nil } 
func encodepeers ( configuration configuration , trans transport ) [ ] byte { var encpeers [ ] [ ] byte for , server : = range configuration . servers { if server . suffrage == voter { encpeers = append ( encpeers , trans . encodepeer ( server . id , server . address ) ) } } buf , err : = encodemsgpack ( encpeers ) if err ! = nil { panic ( fmt . errorf ( " " , err ) ) } return buf . bytes ( ) } 
func decodepeers ( buf [ ] byte , trans transport ) configuration { var encpeers [ ] [ ] byte if err : = decodemsgpack ( buf , & encpeers ) ; err ! = nil { panic ( fmt . errorf ( " " , err ) ) } var servers [ ] server for , enc : = range encpeers { p : = trans . decodepeer ( enc ) servers = append ( servers , server { suffrage : voter , id : serverid ( p ) , address : serveraddress ( p ) , } ) } return configuration { servers : servers , } } 
func encodeconfiguration ( configuration configuration ) [ ] byte { buf , err : = encodemsgpack ( configuration ) if err ! = nil { panic ( fmt . errorf ( " " , err ) ) } return buf . bytes ( ) } 
func decodeconfiguration ( buf [ ] byte ) configuration { var configuration configuration if err : = decodemsgpack ( buf , & configuration ) ; err ! = nil { panic ( fmt . errorf ( " " , err ) ) } return configuration } 
func ( r * raftstate ) gofunc ( f func ( ) ) { r . routinesgroup . add ( 1 ) go func ( ) { defer r . routinesgroup . done ( ) f ( ) } ( ) } 
func ( r * raftstate ) getlastindex ( ) uint64 { r . lastlock . lock ( ) defer r . lastlock . unlock ( ) return max ( r . lastlogindex , r . lastsnapshotindex ) } 
func ( r * raftstate ) getlastentry ( ) ( uint64 , uint64 ) { r . lastlock . lock ( ) defer r . lastlock . unlock ( ) if r . lastlogindex >= r . lastsnapshotindex { return r . lastlogindex , r . lastlogterm } return r . lastsnapshotindex , r . lastsnapshotterm } 
func resolvedirectory ( dir string , create bool ) ( string , error ) { var resolved string if filepath . isabs ( dir ) { resolved = dir } else { execdir , err : = filepath . abs ( filepath . dir ( os . args [ 0 ] ) ) if err ! = nil { return " " , err } resolved = filepath . join ( execdir , dir ) } if create { if , err : = os . stat ( resolved ) ; os . isnotexist ( err ) { if err : = os . mkdirall ( resolved , 0744 ) ; err ! = nil { return " " , err } } } return resolved , nil } 
func ( r * raft ) checkrpcheader ( rpc rpc ) error { wh , ok : = rpc . command . ( withrpcheader ) if ! ok { return fmt . errorf ( " " ) } header : = wh . getrpcheader ( ) if header . protocolversion < protocolversionmin | | header . protocolversion > protocolversionmax { return errunsupportedprotocol } if header . protocolversion < r . conf . protocolversion - 1 { return errunsupportedprotocol } return nil } 
func ( r * raft ) setleader ( leader serveraddress ) { r . leaderlock . lock ( ) oldleader : = r . leader r . leader = leader r . leaderlock . unlock ( ) if oldleader ! = leader { r . observe ( leaderobservation { leader : leader } ) } } 
func ( r * raft ) requestconfigchange ( req configurationchangerequest , timeout time . duration ) indexfuture { var timer < - chan time . time if timeout > 0 { timer = time . after ( timeout ) } future : = & configurationchangefuture { req : req , } future . init ( ) select { case < - timer : return errorfuture { errenqueuetimeout } case r . configurationchangech < - future : return future case < - r . shutdownch : return errorfuture { errraftshutdown } } } 
func ( r * raft ) run ( ) { for { select { case < - r . shutdownch : r . setleader ( " " ) return default : } switch r . getstate ( ) { case follower : r . runfollower ( ) case candidate : r . runcandidate ( ) case leader : r . runleader ( ) } } } 
func ( r * raft ) livebootstrap ( configuration configuration ) error { err : = bootstrapcluster ( & r . conf , r . logs , r . stable , r . snapshots , r . trans , configuration ) if err ! = nil { return err } var entry log if err : = r . logs . getlog ( 1 , & entry ) ; err ! = nil { panic ( err ) } r . setcurrentterm ( 1 ) r . setlastlog ( entry . index , entry . term ) r . processconfigurationlogentry ( & entry ) return nil } 
func ( r * raft ) configurationchangechifstable ( ) chan * configurationchangefuture { if r . configurations . latestindex == r . configurations . committedindex && r . getcommitindex ( ) >= r . leaderstate . commitment . startindex { return r . configurationchangech } return nil } 
func ( r * raft ) verifyleader ( v * verifyfuture ) { v . votes = 1 v . quorumsize = r . quorumsize ( ) if v . quorumsize == 1 { v . respond ( nil ) return } v . notifych = r . verifych r . leaderstate . notify [ v ] = struct { } { } for , repl : = range r . leaderstate . replstate { repl . notifylock . lock ( ) repl . notify [ v ] = struct { } { } repl . notifylock . unlock ( ) asyncnotifych ( repl . notifych ) } } 
func ( r * raft ) checkleaderlease ( ) time . duration { contacted : = 1 var maxdiff time . duration now : = time . now ( ) for peer , f : = range r . leaderstate . replstate { diff : = now . sub ( f . lastcontact ( ) ) if diff <= r . conf . leaderleasetimeout { contacted ++ if diff > maxdiff { maxdiff = diff } } else { if diff <= 3 * r . conf . leaderleasetimeout { r . logger . warn ( fmt . sprintf ( " " , peer , diff ) ) } else { r . logger . debug ( fmt . sprintf ( " " , peer , diff ) ) } } metrics . addsample ( [ ] string { " " , " " , " " } , float32 ( diff / time . millisecond ) ) } quorum : = r . quorumsize ( ) if contacted < quorum { r . logger . warn ( " " ) r . setstate ( follower ) metrics . incrcounter ( [ ] string { " " , " " , " " } , 1 ) } return maxdiff } 
func ( r * raft ) quorumsize ( ) int { voters : = 0 for , server : = range r . configurations . latest . servers { if server . suffrage == voter { voters ++ } } return voters / 2 + 1 } 
func ( r * raft ) appendconfigurationentry ( future * configurationchangefuture ) { configuration , err : = nextconfiguration ( r . configurations . latest , r . configurations . latestindex , future . req ) if err ! = nil { future . respond ( err ) return } r . logger . info ( fmt . sprintf ( " " , future . req . command , future . req . serverid , future . req . serveraddress , configuration . servers ) ) if r . protocolversion < 2 { future . log = log { type : logremovepeerdeprecated , data : encodepeers ( configuration , r . trans ) , } } else { future . log = log { type : logconfiguration , data : encodeconfiguration ( configuration ) , } } r . dispatchlogs ( [ ] * logfuture { & future . logfuture } ) index : = future . index ( ) r . configurations . latest = configuration r . configurations . latestindex = index r . leaderstate . commitment . setconfiguration ( configuration ) r . startstopreplication ( ) } 
func ( r * raft ) dispatchlogs ( applylogs [ ] * logfuture ) { now : = time . now ( ) defer metrics . measuresince ( [ ] string { " " , " " , " " } , now ) term : = r . getcurrentterm ( ) lastindex : = r . getlastindex ( ) n : = len ( applylogs ) logs : = make ( [ ] * log , n ) metrics . setgauge ( [ ] string { " " , " " , " " } , float32 ( n ) ) for idx , applylog : = range applylogs { applylog . dispatch = now lastindex ++ applylog . log . index = lastindex applylog . log . term = term logs [ idx ] = & applylog . log r . leaderstate . inflight . pushback ( applylog ) } if err : = r . logs . storelogs ( logs ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , err ) ) for , applylog : = range applylogs { applylog . respond ( err ) } r . setstate ( follower ) return } r . leaderstate . commitment . match ( r . localid , lastindex ) r . setlastlog ( lastindex , term ) for , f : = range r . leaderstate . replstate { asyncnotifych ( f . triggerch ) } } 
func ( r * raft ) processlogs ( index uint64 , future * logfuture ) { lastapplied : = r . getlastapplied ( ) if index <= lastapplied { r . logger . warn ( fmt . sprintf ( " " , index ) ) return } for idx : = r . getlastapplied ( ) + 1 ; idx <= index ; idx ++ { if future ! = nil && future . log . index == idx { r . processlog ( & future . log , future ) } else { l : = new ( log ) if err : = r . logs . getlog ( idx , l ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , idx , err ) ) panic ( err ) } r . processlog ( l , nil ) } r . setlastapplied ( idx ) } } 
func ( r * raft ) processlog ( l * log , future * logfuture ) { switch l . type { case logbarrier : fallthrough case logcommand : select { case r . fsmmutatech < - & committuple { l , future } : case < - r . shutdownch : if future ! = nil { future . respond ( errraftshutdown ) } } return case logconfiguration : case logaddpeerdeprecated : case logremovepeerdeprecated : case lognoop : default : panic ( fmt . errorf ( " " , l ) ) } if future ! = nil { future . respond ( nil ) } } 
func ( r * raft ) processrpc ( rpc rpc ) { if err : = r . checkrpcheader ( rpc ) ; err ! = nil { rpc . respond ( nil , err ) return } switch cmd : = rpc . command . ( type ) { case * appendentriesrequest : r . appendentries ( rpc , cmd ) case * requestvoterequest : r . requestvote ( rpc , cmd ) case * installsnapshotrequest : r . installsnapshot ( rpc , cmd ) default : r . logger . error ( fmt . sprintf ( " " , rpc . command ) ) rpc . respond ( nil , fmt . errorf ( " " ) ) } } 
func ( r * raft ) processheartbeat ( rpc rpc ) { defer metrics . measuresince ( [ ] string { " " , " " , " " } , time . now ( ) ) select { case < - r . shutdownch : return default : } switch cmd : = rpc . command . ( type ) { case * appendentriesrequest : r . appendentries ( rpc , cmd ) default : r . logger . error ( fmt . sprintf ( " " , rpc . command ) ) rpc . respond ( nil , fmt . errorf ( " " ) ) } } 
func ( r * raft ) processconfigurationlogentry ( entry * log ) { if entry . type == logconfiguration { r . configurations . committed = r . configurations . latest r . configurations . committedindex = r . configurations . latestindex r . configurations . latest = decodeconfiguration ( entry . data ) r . configurations . latestindex = entry . index } else if entry . type == logaddpeerdeprecated | | entry . type == logremovepeerdeprecated { r . configurations . committed = r . configurations . latest r . configurations . committedindex = r . configurations . latestindex r . configurations . latest = decodepeers ( entry . data , r . trans ) r . configurations . latestindex = entry . index } } 
func ( r * raft ) setlastcontact ( ) { r . lastcontactlock . lock ( ) r . lastcontact = time . now ( ) r . lastcontactlock . unlock ( ) } 
func ( r * raft ) persistvote ( term uint64 , candidate [ ] byte ) error { if err : = r . stable . setuint64 ( keylastvoteterm , term ) ; err ! = nil { return err } if err : = r . stable . set ( keylastvotecand , candidate ) ; err ! = nil { return err } return nil } 
func ( r * raft ) setcurrentterm ( t uint64 ) { if err : = r . stable . setuint64 ( keycurrentterm , t ) ; err ! = nil { panic ( fmt . errorf ( " " , err ) ) } r . raftstate . setcurrentterm ( t ) } 
func ( r * raft ) setstate ( state raftstate ) { r . setleader ( " " ) oldstate : = r . raftstate . getstate ( ) r . raftstate . setstate ( state ) if oldstate ! = state { r . observe ( state ) } } 
func newcommitment ( commitch chan struct { } , configuration configuration , startindex uint64 ) * commitment { matchindexes : = make ( map [ serverid ] uint64 ) for , server : = range configuration . servers { if server . suffrage == voter { matchindexes [ server . id ] = 0 } } return & commitment { commitch : commitch , matchindexes : matchindexes , commitindex : 0 , startindex : startindex , } } 
func ( c * commitment ) setconfiguration ( configuration configuration ) { c . lock ( ) defer c . unlock ( ) oldmatchindexes : = c . matchindexes c . matchindexes = make ( map [ serverid ] uint64 ) for , server : = range configuration . servers { if server . suffrage == voter { c . matchindexes [ server . id ] = oldmatchindexes [ server . id ] } } c . recalculate ( ) } 
func ( c * commitment ) getcommitindex ( ) uint64 { c . lock ( ) defer c . unlock ( ) return c . commitindex } 
func ( c * commitment ) match ( server serverid , matchindex uint64 ) { c . lock ( ) defer c . unlock ( ) if prev , hasvote : = c . matchindexes [ server ] ; hasvote && matchindex > prev { c . matchindexes [ server ] = matchindex c . recalculate ( ) } } 
func ( c * commitment ) recalculate ( ) { if len ( c . matchindexes ) == 0 { return } matched : = make ( [ ] uint64 , 0 , len ( c . matchindexes ) ) for , idx : = range c . matchindexes { matched = append ( matched , idx ) } sort . sort ( uint64slice ( matched ) ) quorummatchindex : = matched [ ( len ( matched ) - 1 ) / 2 ] if quorummatchindex > c . commitindex && quorummatchindex >= c . startindex { c . commitindex = quorummatchindex asyncnotifych ( c . commitch ) } } 
func newseed ( ) int64 { r , err : = crand . int ( crand . reader , big . newint ( math . maxint64 ) ) if err ! = nil { panic ( fmt . errorf ( " " , err ) ) } return r . int64 ( ) } 
func randomtimeout ( minval time . duration ) < - chan time . time { if minval == 0 { return nil } extra : = ( time . duration ( rand . int63 ( ) ) % minval ) return time . after ( minval + extra ) } 
func generateuuid ( ) string { buf : = make ( [ ] byte , 16 ) if , err : = crand . read ( buf ) ; err ! = nil { panic ( fmt . errorf ( " " , err ) ) } return fmt . sprintf ( " " , buf [ 0 : 4 ] , buf [ 4 : 6 ] , buf [ 6 : 8 ] , buf [ 8 : 10 ] , buf [ 10 : 16 ] ) } 
func decodemsgpack ( buf [ ] byte , out interface { } ) error { r : = bytes . newbuffer ( buf ) hd : = codec . msgpackhandle { } dec : = codec . newdecoder ( r , & hd ) return dec . decode ( out ) } 
func encodemsgpack ( in interface { } ) ( * bytes . buffer , error ) { buf : = bytes . newbuffer ( nil ) hd : = codec . msgpackhandle { } enc : = codec . newencoder ( buf , & hd ) err : = enc . encode ( in ) return buf , err } 
func backoff ( base time . duration , round , limit uint64 ) time . duration { power : = min ( round , limit ) for power > 2 { base * = 2 power -- } return base } 
func newapplysource ( seed string ) * applysource { h : = fnv . new32 ( ) h . write ( [ ] byte ( seed ) ) s : = & applysource { seed : int64 ( h . sum32 ( ) ) } s . reset ( ) return s } 
func ( a * applysource ) reset ( ) { a . rnd = rand . new ( rand . newsource ( a . seed ) ) } 
func ( a * applysource ) apply ( t * testing . t , c * cluster , n uint ) * clusterapplier { ap : = & clusterapplier { stopch : make ( chan bool ) , src : a } go ap . apply ( t , c , n ) return ap } 
func defaultconfig ( ) * config { return & config { protocolversion : protocolversionmax , heartbeattimeout : 1000 * time . millisecond , electiontimeout : 1000 * time . millisecond , committimeout : 50 * time . millisecond , maxappendentries : 64 , shutdownonremove : true , trailinglogs : 10240 , snapshotinterval : 120 * time . second , snapshotthreshold : 8192 , leaderleasetimeout : 500 * time . millisecond , loglevel : " " , } } 
func validateconfig ( config * config ) error { protocolmin : = protocolversionmin if protocolmin == 0 { protocolmin = 1 } if config . protocolversion < protocolmin | | config . protocolversion > protocolversionmax { return fmt . errorf ( " " , config . protocolversion , protocolmin , protocolversionmax ) } if len ( config . localid ) == 0 { return fmt . errorf ( " " ) } if config . heartbeattimeout < 5 * time . millisecond { return fmt . errorf ( " " ) } if config . electiontimeout < 5 * time . millisecond { return fmt . errorf ( " " ) } if config . committimeout < time . millisecond { return fmt . errorf ( " " ) } if config . maxappendentries <= 0 { return fmt . errorf ( " " ) } if config . maxappendentries > 1024 { return fmt . errorf ( " " ) } if config . snapshotinterval < 5 * time . millisecond { return fmt . errorf ( " " ) } if config . leaderleasetimeout < 5 * time . millisecond { return fmt . errorf ( " " ) } if config . leaderleasetimeout > config . heartbeattimeout { return fmt . errorf ( " " ) } if config . electiontimeout < config . heartbeattimeout { return fmt . errorf ( " " ) } return nil } 
func ( r * raft ) runsnapshots ( ) { for { select { case < - randomtimeout ( r . conf . snapshotinterval ) : if ! r . shouldsnapshot ( ) { continue } if , err : = r . takesnapshot ( ) ; err ! = nil { r . logger . error ( fmt . sprintf ( " " , err ) ) } case future : = < - r . usersnapshotch : id , err : = r . takesnapshot ( ) if err ! = nil { r . logger . error ( fmt . sprintf ( " " , err ) ) } else { future . opener = func ( ) ( * snapshotmeta , io . readcloser , error ) { return r . snapshots . open ( id ) } } future . respond ( err ) case < - r . shutdownch : return } } } 
func ( r * raft ) shouldsnapshot ( ) bool { lastsnap , : = r . getlastsnapshot ( ) lastidx , err : = r . logs . lastindex ( ) if err ! = nil { r . logger . error ( fmt . sprintf ( " " , err ) ) return false } delta : = lastidx - lastsnap return delta >= r . conf . snapshotthreshold } 
func ( r * raft ) compactlogs ( snapidx uint64 ) error { defer metrics . measuresince ( [ ] string { " " , " " } , time . now ( ) ) minlog , err : = r . logs . firstindex ( ) if err ! = nil { return fmt . errorf ( " " , err ) } lastlogidx , : = r . getlastlog ( ) if lastlogidx <= r . conf . trailinglogs { return nil } maxlog : = min ( snapidx , lastlogidx - r . conf . trailinglogs ) r . logger . info ( fmt . sprintf ( " " , minlog , maxlog ) ) if err : = r . logs . deleterange ( minlog , maxlog ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func webpackcheck ( r * runner ) error { fmt . println ( " " ) if ! r . app . withwebpack { return nil } box : = webpack . templates f , err : = box . findstring ( " " ) if err ! = nil { return err } tmpl , err : = template . new ( " " ) . parse ( f ) if err ! = nil { return err } bb : = & bytes . buffer { } err = tmpl . execute ( bb , map [ string ] interface { } { " " : & webpack . options { app : r . app , } , } ) if err ! = nil { return err } b , err : = ioutil . readfile ( " " ) if err ! = nil { return err } if string ( b ) == bb . string ( ) { return nil } if ! ask ( " \n " ) { fmt . println ( " \ t " ) return nil } wf , err : = os . create ( " " ) if err ! = nil { return err } , err = wf . write ( bb . bytes ( ) ) if err ! = nil { return err } return wf . close ( ) } 
func auto ( ctx context . context , i interface { } ) renderer { e : = new ( options { } ) return e . auto ( ctx , i ) } 
func ( e * engine ) auto ( ctx context . context , i interface { } ) renderer { ct , : = ctx . value ( " " ) . ( string ) if ct == " " { ct = e . defaultcontenttype } ct = strings . trimspace ( strings . tolower ( ct ) ) if strings . contains ( ct , " " ) { return e . json ( i ) } if strings . contains ( ct , " " ) { return e . xml ( i ) } return htmlautorenderer { engine : e , model : i , } } 
func ( opts * options ) validate ( ) error { if opts . options == nil { opts . options = & core . options { } } if err : = opts . options . validate ( ) ; err ! = nil { return err } if opts . docker ! = nil { if opts . docker . app . iszero ( ) { opts . docker . app = opts . app } if err : = opts . docker . validate ( ) ; err ! = nil { return err } } if opts . webpack ! = nil { if opts . webpack . app . iszero ( ) { opts . webpack . app = opts . app } if err : = opts . webpack . validate ( ) ; err ! = nil { return err } } if opts . standard ! = nil && opts . webpack ! = nil { return errors . new ( " " ) } return nil } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) if err : = opts . validate ( ) ; err ! = nil { return g , err } if opts . provider == " " { return g , nil } box : = packr . new ( " " , " " ) s , err : = box . findstring ( " " ) if err ! = nil { return g , err } p : = opts . provider n : = fmt . sprintf ( " " , p ) g . file ( genny . newfiles ( n , s ) ) g . command ( exec . command ( p , " " ) ) args : = [ ] string { " " , " " } if p == " " { args = append ( args , " " ) } g . command ( exec . command ( p , args ... ) ) g . command ( exec . command ( p , " " , " " , " " , " " ) ) return g , nil } 
func ( s * listener ) setaddr ( addr string ) { if s . server . addr == " " { s . server . addr = addr } } 
func unixsocket ( addr string ) ( * listener , error ) { listener , err : = net . listen ( " " , addr ) if err ! = nil { return nil , err } return & listener { server : & http . server { } , listener : listener , } , nil } 
func ( e errorhandlers ) get ( status int ) errorhandler { if eh , ok : = e [ status ] ; ok { return eh } if eh , ok : = e [ 0 ] ; ok { return eh } return defaulterrorhandler } 
func ( a * app ) panichandler ( next handler ) handler { return func ( c context ) error { defer func ( ) { r : = recover ( ) var err error if r ! = nil { switch t : = r . ( type ) { case error : err = t case string : err = errors . new ( t ) default : err = errors . new ( fmt . sprint ( t ) ) } err = err events . emiterror ( events . errpanic , err , map [ string ] interface { } { " " : c , " " : a , } , ) eh : = a . errorhandlers . get ( 500 ) eh ( 500 , err , c ) } } ( ) return next ( c ) } } 
func ( opts * options ) validate ( ) error { if opts . app . iszero ( ) { opts . app = meta . new ( " " ) } if len ( opts . version ) == 0 { opts . version = runtime . version } if len ( opts . provider ) == 0 { return errors . new ( " " ) } opts . provider = strings . tolower ( opts . provider ) var found bool for , a : = range available { if opts . provider == a { found = true break } if opts . provider == a + " " { opts . provider = a found = true break } } if ! found { return fmt . errorf ( " " , opts . provider , strings . join ( available , " " ) ) } found = false for , d : = range pop . availabledialects { if d == opts . dbtype { found = true break } } if ! found { return fmt . errorf ( " " , opts . dbtype , strings . join ( pop . availabledialects , " " ) ) } return nil } 
func ( s templaterenderer ) partialfeeder ( name string ) ( string , error ) { ct : = strings . tolower ( s . contenttype ) d , f : = filepath . split ( name ) name = filepath . join ( d , " " + f ) name = fixextension ( name , ct ) return s . templatesbox . findstring ( name ) } 
func template ( c string , names ... string ) renderer { e : = new ( options { } ) return e . template ( c , names ... ) } 
func ( e * engine ) template ( c string , names ... string ) renderer { return & templaterenderer { engine : e , contenttype : c , names : names , } } 
func ( s * simple ) setaddr ( addr string ) { if s . server . addr == " " { s . server . addr = addr } } 
func ( m * message ) writeto ( w io . writer ) ( int64 , error ) { mw : = & messagewriter { w : w } mw . writemessage ( m ) return mw . n , mw . err } 
func app ( ) * buffalo . app { if app == nil { app = buffalo . new ( buffalo . options { env : env , sessionname : " " , } ) app . use ( forcessl ( ) ) app . use ( paramlogger . parameterlogger ) app . use ( csrf . new ) app . use ( popmw . transaction ( models . db ) ) app . use ( translations ( ) ) app . get ( " " , homehandler ) app . servefiles ( " " , assetsbox ) } return app } 
func ( sm smtpsender ) send ( message message ) error { gm : = gomail . newmessage ( ) gm . setheader ( " " , message . from ) gm . setheader ( " " , message . to ... ) gm . setheader ( " " , message . subject ) gm . setheader ( " " , message . cc ... ) gm . setheader ( " " , message . bcc ... ) sm . addbodies ( message , gm ) sm . addattachments ( message , gm ) for field , value : = range message . headers { gm . setheader ( field , value ) } err : = sm . dialer . dialandsend ( gm ) if err ! = nil { return err } return nil } 
func newsmtpsender ( host string , port string , user string , password string ) ( smtpsender , error ) { iport , err : = strconv . atoi ( port ) if err ! = nil { return smtpsender { } , errors . new ( " " ) } dialer : = & gomail . dialer { host : host , port : iport , } if user ! = " " { dialer . username = user dialer . password = password } return smtpsender { dialer : dialer , } , nil } 
func ( d * defaultcontext ) param ( key string ) string { return d . params ( ) . get ( key ) } 
func ( d * defaultcontext ) set ( key string , value interface { } ) { d . moot . lock ( ) d . data [ key ] = value d . moot . unlock ( ) } 
func ( d * defaultcontext ) value ( key interface { } ) interface { } { if k , ok : = key . ( string ) ; ok { d . moot . rlock ( ) defer d . moot . runlock ( ) if v , ok : = d . data [ k ] ; ok { return v } } return d . context . value ( key ) } 
func ( d * defaultcontext ) bind ( value interface { } ) error { return binding . exec ( d . request ( ) , value ) } 
func ( d * defaultcontext ) logfield ( key string , value interface { } ) { d . logger = d . logger . withfield ( key , value ) } 
func ( d * defaultcontext ) logfields ( values map [ string ] interface { } ) { d . logger = d . logger . withfields ( values ) } 
func ( d * defaultcontext ) redirect ( status int , url string , args ... interface { } ) error { d . flash ( ) . persist ( d . session ( ) ) if strings . hassuffix ( url , " " ) { if len ( args ) > 1 { return fmt . errorf ( " " , args ) } var m map [ string ] interface { } if len ( args ) == 1 { rv : = reflect . indirect ( reflect . valueof ( args [ 0 ] ) ) if ! rv . type ( ) . convertibleto ( maptype ) { return fmt . errorf ( " " , args ) } m = rv . convert ( maptype ) . interface ( ) . ( map [ string ] interface { } ) } h , ok : = d . value ( strings . trimsuffix ( url , " " ) ) . ( routehelperfunc ) if ! ok { return fmt . errorf ( " " , url ) } url , err : = h ( m ) if err ! = nil { return err } http . redirect ( d . response ( ) , d . request ( ) , string ( url ) , status ) return nil } if len ( args ) > 0 { url = fmt . sprintf ( url , args ... ) } http . redirect ( d . response ( ) , d . request ( ) , url , status ) return nil } 
func ( d * defaultcontext ) data ( ) map [ string ] interface { } { d . moot . lock ( ) m : = map [ string ] interface { } { } for k , v : = range d . data { m [ k ] = v } d . moot . unlock ( ) return m } 
func ( d * defaultcontext ) file ( name string ) ( binding . file , error ) { req : = d . request ( ) if err : = req . parsemultipartform ( 5 * 1024 * 1024 ) ; err ! = nil { return binding . file { } , err } f , h , err : = req . formfile ( name ) bf : = binding . file { file : f , fileheader : h , } if err ! = nil { return bf , err } return bf , nil } 
func ( d * defaultcontext ) marshaljson ( ) ( [ ] byte , error ) { m : = map [ string ] interface { } { } data : = d . data ( ) for k , v : = range data { if , ok : = v . ( * defaultcontext ) ; ok { continue } if , err : = json . marshal ( v ) ; err == nil { m [ k ] = v } } return json . marshal ( m ) } 
func new ( opts * options ) ( * genny . group , error ) { if err : = opts . validate ( ) ; err ! = nil { return nil , err } gg , err : = core . new ( opts . options ) if err ! = nil { return gg , err } g : = genny . new ( ) data : = map [ string ] interface { } { " " : opts , } helpers : = template . funcmap { } t : = gogen . templatetransformer ( data , helpers ) g . transformer ( t ) g . box ( packr . new ( " " , " " ) ) gg . add ( g ) return gg , nil } 
func new ( opts options ) * app { loadplugins ( ) envy . load ( ) opts = optionswithdefaults ( opts ) a : = & app { options : opts , errorhandlers : errorhandlers { 404 : defaulterrorhandler , 500 : defaulterrorhandler , } , router : mux . newrouter ( ) , moot : & sync . rwmutex { } , routes : routelist { } , children : [ ] * app { } , } dem : = a . defaulterrormiddleware a . middleware = newmiddlewarestack ( dem ) notfoundhandler : = func ( errorf string , code int ) http . handlerfunc { return func ( res http . responsewriter , req * http . request ) { c : = a . newcontext ( routeinfo { } , res , req ) err : = fmt . errorf ( errorf , req . method , req . url . path ) a . errorhandlers . get ( code ) ( code , err , c ) } } a . router . notfoundhandler = notfoundhandler ( " " , 404 ) a . router . methodnotallowedhandler = notfoundhandler ( " " , 405 ) if a . methodoverride == nil { a . methodoverride = methodoverride } a . use ( a . panichandler ) a . use ( requestlogger ) a . use ( sessionsaver ) return a } 
func ( v baseresource ) list ( c context ) error { return c . error ( 404 , errors . new ( " " ) ) } 
func ( s funcrenderer ) render ( w io . writer , data data ) error { return s . renderfunc ( w , data ) } 
func func ( s string , fn rendererfunc ) renderer { return funcrenderer { contenttype : s , renderfunc : fn , } } 
func ( e * engine ) func ( s string , fn rendererfunc ) renderer { return func ( s , fn ) } 
func ( opts * options ) validate ( ) error { if opts . app . iszero ( ) { opts . app = meta . new ( " " ) } if opts . out . writer == nil { opts . out = rx . newwriter ( os . stdout ) } return nil } 
func buildactions ( pres * presenter ) genny . runfn { return func ( r * genny . runner ) error { fn : = fmt . sprintf ( " " , pres . name . file ( ) ) xf , err : = r . findfile ( fn ) if err ! = nil { return buildnewactions ( fn , pres ) ( r ) } if err : = appendactions ( xf , pres ) ( r ) ; err ! = nil { return err } return nil } } 
func buildnewactions ( fn string , pres * presenter ) genny . runfn { return func ( r * genny . runner ) error { for , a : = range pres . options . actions { pres . actions = append ( pres . actions , name . new ( a ) ) } h , err : = box . findstring ( " " ) if err ! = nil { return err } a , err : = box . findstring ( " " ) if err ! = nil { return err } f : = genny . newfiles ( fn + " " , h + a ) f , err = transform ( pres , f ) if err ! = nil { return err } return r . file ( f ) } } 
func appendactions ( f genny . file , pres * presenter ) genny . runfn { return func ( r * genny . runner ) error { body : = f . string ( ) for , ac : = range pres . options . actions { a : = name . new ( ac ) x : = fmt . sprintf ( " " , pres . name . pascalize ( ) , a . pascalize ( ) ) if strings . contains ( body , x ) { continue } pres . actions = append ( pres . actions , a ) } a , err : = box . findstring ( " " ) if err ! = nil { return err } f = genny . newfiles ( f . name ( ) + " " , f . string ( ) + a ) f , err = transform ( pres , f ) if err ! = nil { return err } return r . file ( f ) } } 
func ( s * session ) save ( ) error { return s . session . save ( s . req , s . res ) } 
func ( s * session ) getonce ( name interface { } ) interface { } { if x , ok : = s . session . values [ name ] ; ok { s . delete ( name ) return x } return nil } 
func ( s * session ) set ( name , value interface { } ) { s . session . values [ name ] = value } 
func ( s * session ) clear ( ) { for k : = range s . session . values { s . delete ( k ) } } 
func ( a * app ) getsession ( r * http . request , w http . responsewriter ) * session { if a . root ! = nil { return a . root . getsession ( r , w ) } session , : = a . sessionstore . get ( r , a . sessionname ) return & session { session : session , req : r , res : w , } } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) if err : = opts . validate ( ) ; err ! = nil { return g , err } data : = map [ string ] interface { } { " " : opts , } t : = gogen . templatetransformer ( data , template . funcmap { } ) g . transformer ( t ) g . runfn ( func ( r * genny . runner ) error { return genfile ( r , opts ) } ) return g , nil } 
func string ( s string , args ... interface { } ) renderer { e : = new ( options { } ) return e . string ( s , args ... ) } 
func ( e * engine ) string ( s string , args ... interface { } ) renderer { if len ( args ) > 0 { s = fmt . sprintf ( s , args ... ) } return stringrenderer { engine : e , body : s , } } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) if err : = opts . validate ( ) ; err ! = nil { return g , err } g . runfn ( func ( r * genny . runner ) error { if , err : = r . lookpath ( " " ) ; err ! = nil { return errors . new ( " " ) } return nil } ) g . box ( templates ) data : = map [ string ] interface { } { " " : opts , } t : = gogen . templatetransformer ( data , gogen . templatehelpers ) g . transformer ( t ) g . transformer ( genny . dot ( ) ) g . runfn ( func ( r * genny . runner ) error { return installpkgs ( r , opts ) } ) return g , nil } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) if err : = opts . validate ( ) ; err ! = nil { return g , err } g . box ( packr . new ( " " , " " ) ) ctx : = plush . newcontext ( ) ctx . set ( " " , opts . app ) g . transformer ( plushgen . transformer ( ctx ) ) g . transformer ( genny . dot ( ) ) return g , nil } 
func execute ( ) { if err : = rootcmd . execute ( ) ; err ! = nil { if strings . contains ( err . error ( ) , dbnotfound ) | | strings . contains ( err . error ( ) , popnotfound ) { logrus . errorf ( popinstallinstructions ) os . exit ( - 1 ) } logrus . errorf ( " " , err ) if strings . contains ( err . error ( ) , dbnotfound ) | | strings . contains ( err . error ( ) , popnotfound ) { fmt . println ( popinstallinstructions ) os . exit ( - 1 ) } os . exit ( - 1 ) } } 
func ( opts * options ) validate ( ) error { pwd , : = os . getwd ( ) if opts . app . iszero ( ) { opts . app = meta . new ( pwd ) } if len ( opts . environment ) == 0 { opts . environment = " " } if opts . buildtime . iszero ( ) { opts . buildtime = time . now ( ) } if len ( opts . buildversion ) == 0 { opts . buildversion = opts . buildtime . format ( time . rfc3339 ) } if opts . rollback == nil { opts . rollback = & sync . map { } } if len ( opts . gocommand ) == 0 { opts . gocommand = " " } return nil } 
func ( opts * options ) validate ( ) error { if opts . app . iszero ( ) { opts . app = meta . new ( " " ) } if len ( opts . name ) == 0 { return errors . new ( " " ) } if len ( opts . model ) == 0 { opts . model = opts . name } if strings . contains ( opts . model , " " ) { parts : = strings . split ( opts . model , " " ) opts . model = parts [ len ( parts ) - 1 ] } if opts . app . asapi { opts . skiptemplates = true } return nil } 
func newmessage ( settings ... messagesetting ) * message { m : = & message { header : make ( header ) , charset : " " , encoding : quotedprintable , } m . applysettings ( settings ) if m . encoding == base64 { m . hencoder = bencoding } else { m . hencoder = qencoding } return m } 
func ( m * message ) reset ( ) { for k : = range m . header { delete ( m . header , k ) } m . parts = nil m . attachments = nil m . embedded = nil } 
func ( m * message ) setheader ( field string , value ... string ) { m . encodeheader ( value ) m . header [ field ] = value } 
func ( m * message ) setheaders ( h map [ string ] [ ] string ) { for k , v : = range h { m . setheader ( k , v ... ) } } 
func ( m * message ) setaddressheader ( field , address , name string ) { m . header [ field ] = [ ] string { m . formataddress ( address , name ) } } 
func ( m * message ) formataddress ( address , name string ) string { if name == " " { return address } enc : = m . encodestring ( name ) if enc == name { m . buf . writebyte ( ' " ' ) for i : = 0 ; i < len ( name ) ; i ++ { b : = name [ i ] if b == ' \ \ ' | | b == ' " ' { m . buf . writebyte ( ' \ \ ' ) } m . buf . writebyte ( b ) } m . buf . writebyte ( ' " ' ) } else if hasspecials ( name ) { m . buf . writestring ( bencoding . encode ( m . charset , name ) ) } else { m . buf . writestring ( enc ) } m . buf . writestring ( " " ) m . buf . writestring ( address ) m . buf . writebyte ( ' > ' ) addr : = m . buf . string ( ) m . buf . reset ( ) return addr } 
func ( m * message ) setdateheader ( field string , date time . time ) { m . header [ field ] = [ ] string { m . formatdate ( date ) } } 
func ( m * message ) formatdate ( date time . time ) string { return date . format ( time . rfc1123z ) } 
func ( m * message ) setbody ( contenttype , body string , settings ... partsetting ) { m . setbodywriter ( contenttype , newcopier ( body ) , settings ... ) } 
func ( m * message ) setbodywriter ( contenttype string , f func ( io . writer ) error , settings ... partsetting ) { m . parts = [ ] * part { m . newpart ( contenttype , f , settings ) } } 
func ( m * message ) addalternativewriter ( contenttype string , f func ( io . writer ) error , settings ... partsetting ) { m . parts = append ( m . parts , m . newpart ( contenttype , f , settings ) ) } 
func setpartencoding ( e encoding ) partsetting { return partsetting ( func ( p * part ) { p . encoding = e } ) } 
func setheader ( h map [ string ] [ ] string ) filesetting { return func ( f * file ) { for k , v : = range h { f . header [ k ] = v } } } 
func setcopyfunc ( f func ( io . writer ) error ) filesetting { return func ( fi * file ) { fi . copyfunc = f } } 
func ( m * message ) attachreader ( name string , r io . reader , settings ... filesetting ) { m . attachments = m . appendfile ( m . attachments , filefromreader ( name , r ) , settings ) } 
func ( m * message ) attach ( filename string , settings ... filesetting ) { m . attachments = m . appendfile ( m . attachments , filefromfilename ( filename ) , settings ) } 
func ( m * message ) embedreader ( name string , r io . reader , settings ... filesetting ) { m . embedded = m . appendfile ( m . embedded , filefromreader ( name , r ) , settings ) } 
func ( m * message ) embed ( filename string , settings ... filesetting ) { m . embedded = m . appendfile ( m . embedded , filefromfilename ( filename ) , settings ) } 
func validatetemplates ( walk packd . walker , tvs [ ] templatevalidator ) genny . runfn { if len ( tvs ) == 0 { return func ( r * genny . runner ) error { return nil } } return func ( r * genny . runner ) error { var errs [ ] string err : = packd . skipwalker ( walk , packd . commonskipprefixes , func ( path string , file packd . file ) error { info , err : = file . fileinfo ( ) if err ! = nil { return err } if info . isdir ( ) { return nil } f : = genny . newfile ( path , file ) for , tv : = range tvs { err : = safe . run ( func ( ) { if err : = tv ( f ) ; err ! = nil { errs = append ( errs , fmt . sprintf ( " " , path , err . error ( ) ) ) } } ) if err ! = nil { return err } } return nil } ) if err ! = nil { return err } if len ( errs ) == 0 { return nil } return errors . new ( strings . join ( errs , " \n " ) ) } } 
func plushvalidator ( f genny . file ) error { if ! genny . hasext ( f , " " , " " , " " ) { return nil } , err : = plush . parse ( f . string ( ) ) return err } 
func gotemplatevalidator ( f genny . file ) error { if ! genny . hasext ( f , " " ) { return nil } t : = template . new ( f . name ( ) ) , err : = t . parse ( f . string ( ) ) return err } 
func ( opts * options ) validate ( ) error { if opts . app . iszero ( ) { opts . app = meta . new ( " " ) } var found bool for , a : = range available { if opts . provider == a { found = true break } } if ! found { return fmt . errorf ( " " , opts . provider , strings . join ( available , " " ) ) } return nil } 
func ( opts * options ) validate ( ) error { if opts . app . iszero ( ) { opts . app = meta . new ( " " ) } if len ( opts . name . string ( ) ) == 0 { return errors . new ( " " ) } return nil } 
func loadplugins ( ) error { var err error oncer . do ( " " , func ( ) { if envy . get ( " " , " " ) == " " { return } plugs , err : = plugins . available ( ) if err ! = nil { err = err return } for , cmds : = range plugs { for , c : = range cmds { if c . buffalocommand ! = " " { continue } err : = func ( c plugins . command ) error { return safe . rune ( func ( ) error { n : = fmt . sprintf ( " " , c . binary , c . name ) fn : = func ( e events . event ) { b , err : = json . marshal ( e ) if err ! = nil { fmt . println ( " " , e , err ) return } cmd : = exec . command ( c . binary , c . usecommand , string ( b ) ) cmd . stderr = os . stderr cmd . stdout = os . stdout cmd . stdin = os . stdin if err : = cmd . run ( ) ; err ! = nil { fmt . println ( " " , strings . join ( cmd . args , " " ) , err ) } } , err : = events . namedlisten ( n , events . filter ( c . listenfor , fn ) ) if err ! = nil { return err } return nil } ) } ( c ) if err ! = nil { err = err return } } } } ) return err } 
func ( w * response ) writeheader ( i int ) { w . status = i w . responsewriter . writeheader ( i ) } 
func ( w * response ) write ( b [ ] byte ) ( int , error ) { w . size = binary . size ( b ) return w . responsewriter . write ( b ) } 
func ( w * response ) flush ( ) { if f , ok : = w . responsewriter . ( http . flusher ) ; ok { f . flush ( ) } } 
func run ( ) error { fmt . printf ( " \n " , runtime . version ) if ! ask ( " " ) { fmt . println ( " " ) return nil } r : = & runner { app : meta . new ( " " ) , warnings : [ ] string { } , } defer func ( ) { if len ( r . warnings ) == 0 { return } fmt . println ( " \n \n " ) fmt . printf ( " \n \n " , len ( r . warnings ) ) for , w : = range r . warnings { fmt . printf ( " \n " , w ) } } ( ) for , c : = range checks { if err : = c ( r ) ; err ! = nil { return err } } return nil } 
func onlyrelevantfiles ( p string , fi os . fileinfo , err error , fn func ( p string ) error ) error { if err ! = nil { return err } if fi . isdir ( ) { base : = filepath . base ( p ) if strings . hasprefix ( base , " " ) { return filepath . skipdir } for , n : = range [ ] string { " " , " " , " " } { if base == n { return filepath . skipdir } } return nil } ext : = filepath . ext ( p ) if ext ! = " " { return nil } return fn ( p ) } 
func gotemplateengine ( input string , data map [ string ] interface { } , helpers map [ string ] interface { } ) ( string , error ) { data [ " " ] = map [ string ] interface { } { } t : = template . new ( input ) if helpers ! = nil { t = t . funcs ( helpers ) } t , err : = t . parse ( input ) if err ! = nil { return " " , err } bb : = & bytes . buffer { } err = t . execute ( bb , data ) return bb . string ( ) , err } 
func ( a * app ) redirect ( status int , from , to string ) * routeinfo { return a . get ( from , func ( c context ) error { return c . redirect ( status , to ) } ) } 
func ( a * app ) group ( grouppath string ) * app { g : = new ( a . options ) g . prefix = path . join ( a . prefix , grouppath ) g . name = g . prefix g . router = a . router g . middleware = a . middleware . clone ( ) g . errorhandlers = a . errorhandlers g . root = a if a . root ! = nil { g . root = a . root } a . children = append ( a . children , g ) return g } 
func ( a * app ) routehelpers ( ) map [ string ] routehelperfunc { rh : = map [ string ] routehelperfunc { } for , route : = range a . routes ( ) { croute : = route rh [ croute . pathname ] = croute . buildpathhelper ( ) } return rh } 
func ( a * app ) buildroutename ( p string ) string { if p == " " | | p == " " { return " " } resultparts : = [ ] string { } parts : = strings . split ( p , " " ) for index , part : = range parts { if strings . contains ( part , " " ) | | part == " " { continue } shouldsingularize : = ( len ( parts ) > index + 1 ) && strings . contains ( parts [ index + 1 ] , " " ) if shouldsingularize { part = flect . singularize ( part ) } if parts [ index ] == " " | | parts [ index ] == " " { resultparts = append ( [ ] string { part } , resultparts ... ) continue } if index > 0 && strings . contains ( parts [ index - 1 ] , " " ) { resultparts = append ( resultparts , part ) continue } resultparts = append ( resultparts , part ) } if len ( resultparts ) == 0 { return " " } underscore : = strings . trimspace ( strings . join ( resultparts , " " ) ) return name . varcase ( underscore ) } 
func new ( opts * options ) ( * genny . group , error ) { gg : = & genny . group { } if err : = opts . validate ( ) ; err ! = nil { return gg , err } if ! opts . skipinit { g , err : = initgenerator ( opts ) if err ! = nil { return gg , err } gg . add ( g ) } g : = genny . new ( ) h : = template . funcmap { } data : = map [ string ] interface { } { " " : opts , } t : = gogen . templatetransformer ( data , h ) g . transformer ( t ) fn : = opts . name . file ( ) . string ( ) g . file ( genny . newfiles ( " " + fn + " " , mailertmpl ) ) g . file ( genny . newfiles ( " " + fn + " " , mailtmpl ) ) gg . add ( g ) return gg , nil } 
func newdialer ( host string , port int , username , password string ) * dialer { return & dialer { host : host , port : port , username : username , password : password , ssl : port == 465 , timeout : 10 * time . second , retryfailure : true , } } 
func ( d * dialer ) dialandsend ( m ... * message ) error { s , err : = d . dial ( ) if err ! = nil { return err } defer s . close ( ) return send ( s , m ... ) } 
func requestloggerfunc ( h handler ) handler { return func ( c context ) error { var irid interface { } if irid = c . session ( ) . get ( " " ) ; irid == nil { irid = randx . string ( 10 ) c . session ( ) . set ( " " , irid ) c . session ( ) . save ( ) } rid : = irid . ( string ) + " " + randx . string ( 10 ) c . set ( " " , rid ) c . logfield ( " " , rid ) start : = time . now ( ) defer func ( ) { ws , ok : = c . response ( ) . ( * response ) if ! ok { ws = & response { responsewriter : c . response ( ) } ws . status = 200 } req : = c . request ( ) ct : = httpx . contenttype ( req ) if ct ! = " " { c . logfield ( " " , ct ) } c . logfields ( map [ string ] interface { } { " " : req . method , " " : req . url . string ( ) , " " : time . since ( start ) , " " : ws . size , " " : humanize . bytes ( uint64 ( ws . size ) ) , " " : ws . status , } ) c . logger ( ) . info ( req . url . string ( ) ) } ( ) return h ( c ) } } 
func ( f flash ) set ( key string , values [ ] string ) { f . data [ key ] = values } 
func ( f flash ) add ( key , value string ) { if len ( f . data [ key ] ) == 0 { f . data [ key ] = [ ] string { value } return } f . data [ key ] = append ( f . data [ key ] , value ) } 
func ( f flash ) persist ( session * session ) { b , : = json . marshal ( f . data ) session . set ( flashkey , b ) session . save ( ) } 
func newflash ( session * session ) * flash { result : = & flash { data : map [ string ] [ ] string { } , } if session . session ! = nil { if f : = session . get ( flashkey ) ; f ! = nil { json . unmarshal ( f . ( [ ] byte ) , & result . data ) } } return result } 
func ( c * cookies ) set ( name , value string , maxage time . duration ) { ck : = http . cookie { name : name , value : value , maxage : int ( maxage . seconds ( ) ) , } http . setcookie ( c . res , & ck ) } 
func ( c * cookies ) setwithexpirationtime ( name , value string , expires time . time ) { ck : = http . cookie { name : name , value : value , expires : expires , } http . setcookie ( c . res , & ck ) } 
func ( c * cookies ) setwithpath ( name , value , path string ) { ck : = http . cookie { name : name , value : value , path : path , } http . setcookie ( c . res , & ck ) } 
func ( c * cookies ) delete ( name string ) { ck : = http . cookie { name : name , value : " " , expires : time . unix ( 0 , 0 ) , } http . setcookie ( c . res , & ck ) } 
func newmessage ( ) message { return message { context : context . background ( ) , headers : map [ string ] string { } , data : render . data { } , moot : & sync . rwmutex { } , } } 
func newfromdata ( data render . data ) message { d : = render . data { } for k , v : = range data { d [ k ] = v } m : = newmessage ( ) m . data = d return m } 
func new ( c buffalo . context ) message { m : = newfromdata ( c . data ( ) ) m . context = c return m } 
func ( es * eventsource ) closenotify ( ) < - chan bool { if cn , ok : = es . w . ( closenotifier ) ; ok { return cn . closenotify ( ) } return nil } 
func newsimplewithcontext ( ctx context . context ) * simple { ctx , cancel : = context . withcancel ( ctx ) l : = logrus . new ( ) l . level = logrus . infolevel l . formatter = & logrus . textformatter { } return & simple { logger : l , ctx : ctx , cancel : cancel , handlers : map [ string ] handler { } , moot : & sync . mutex { } , } } 
func ( w * simple ) register ( name string , h handler ) error { w . moot . lock ( ) defer w . moot . unlock ( ) if , ok : = w . handlers [ name ] ; ok { return fmt . errorf ( " " , name ) } w . handlers [ name ] = h return nil } 
func ( w simple ) perform ( job job ) error { w . logger . debugf ( " " , job ) if job . handler == " " { err : = fmt . errorf ( " " , job ) w . logger . error ( err ) return err } w . moot . lock ( ) defer w . moot . unlock ( ) if h , ok : = w . handlers [ job . handler ] ; ok { go func ( ) { err : = safe . rune ( func ( ) error { return h ( job . args ) } ) if err ! = nil { w . logger . error ( err ) } w . logger . debugf ( " " , job ) } ( ) return nil } err : = fmt . errorf ( " " , job . handler ) w . logger . error ( err ) return err } 
func ( w simple ) performat ( job job , t time . time ) error { return w . performin ( job , time . until ( t ) ) } 
func ( w simple ) performin ( job job , d time . duration ) error { go func ( ) { select { case < - time . after ( d ) : w . perform ( job ) case < - w . ctx . done ( ) : w . cancel ( ) } } ( ) return nil } 
func ( ri routeinfo ) string ( ) string { b , : = json . marshalindent ( ri , " " , " " ) return string ( b ) } 
func ( ri * routeinfo ) alias ( aliases ... string ) * routeinfo { ri . aliases = append ( ri . aliases , aliases ... ) for , a : = range aliases { ri . app . router . handle ( a , ri ) . methods ( ri . method ) } return ri } 
func ( ri * routeinfo ) name ( name string ) * routeinfo { routeindex : = - 1 for index , route : = range ri . app . routes ( ) { if route . path == ri . path && route . method == ri . method { routeindex = index break } } name = flect . camelize ( name ) if ! strings . hassuffix ( name , " " ) { name = name + " " } ri . pathname = name if routeindex ! = - 1 { ri . app . routes ( ) [ routeindex ] = reflect . valueof ( ri ) . interface ( ) . ( * routeinfo ) } return ri } 
func ( ri * routeinfo ) buildpathhelper ( ) routehelperfunc { croute : = ri return func ( opts map [ string ] interface { } ) ( template . html , error ) { pairs : = [ ] string { } for k , v : = range opts { pairs = append ( pairs , k ) pairs = append ( pairs , fmt . sprintf ( " " , v ) ) } url , err : = croute . muxroute . url ( pairs ... ) if err ! = nil { return " " , errors . wrapf ( err , " " , croute . path ) } result : = url . path result = addextraparamsto ( result , opts ) return template . html ( result ) , nil } } 
func ( s * tls ) setaddr ( addr string ) { if s . server . addr == " " { s . server . addr = addr } } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) if err : = opts . validate ( ) ; err ! = nil { return g , err } g . transformer ( genny . replace ( " " , " " ) ) g . transformer ( genny . dot ( ) ) box : = packr . new ( " " , " " ) var fname string switch opts . provider { case " " , " " : fname = " " case " " , " " : if opts . app . withpop { fname = " " } else { fname = " " } default : return g , fmt . errorf ( " " , opts . provider ) } f , err : = box . findstring ( fname ) if err ! = nil { return g , err } g . file ( genny . newfiles ( fname , f ) ) data : = map [ string ] interface { } { " " : opts , } if opts . dbtype == " " { data [ " " ] = " " + opts . app . name . file ( ) . string ( ) + " " } else if opts . dbtype == " " { data [ " " ] = " " + opts . app . name . file ( ) . string ( ) + " " } else { data [ " " ] = " " } helpers : = template . funcmap { } t : = gogen . templatetransformer ( data , helpers ) g . transformer ( t ) return g , nil } 
func download ( ctx context . context , name string , r io . reader ) renderer { return downloadrenderer { ctx : ctx , name : name , reader : r , } } 
func ( e * engine ) download ( ctx context . context , name string , r io . reader ) renderer { return download ( ctx , name , r ) } 
func javascript ( names ... string ) renderer { e : = new ( options { } ) return e . javascript ( names ... ) } 
func ( e * engine ) javascript ( names ... string ) renderer { if e . javascriptlayout ! = " " && len ( names ) == 1 { names = append ( names , e . javascriptlayout ) } hr : = & templaterenderer { engine : e , contenttype : " " , names : names , } return hr } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) if err : = opts . validate ( ) ; err ! = nil { return g , err } g . runfn ( construct ( opts ) ) return g , nil } 
func registercustomdecoder ( fn customtypedecoder , types [ ] interface { } , fields [ ] interface { } ) { rawfunc : = ( func ( [ ] string ) ( interface { } , error ) ) ( fn ) decoder . registercustomtype ( rawfunc , types , fields ) } 
func register ( contenttype string , fn binder ) { lock . lock ( ) defer lock . unlock ( ) binders [ strings . tolower ( contenttype ) ] = fn } 
func methodoverride ( res http . responsewriter , req * http . request ) { if req . method == " " { req . method = defaults . string ( req . formvalue ( " " ) , " " ) req . form . del ( " " ) req . postform . del ( " " ) } } 
func ( ms * middlewarestack ) clear ( ) { ms . stack = [ ] middlewarefunc { } ms . skips = map [ string ] bool { } } 
func ( ms * middlewarestack ) use ( mw ... middlewarefunc ) { ms . stack = append ( ms . stack , mw ... ) } 
func ( ms * middlewarestack ) skip ( mw middlewarefunc , handlers ... handler ) { for , h : = range handlers { key : = funckey ( mw , h ) ms . skips [ key ] = true } } 
func ( ms * middlewarestack ) replace ( mw1 middlewarefunc , mw2 middlewarefunc ) { m1k : = funckey ( mw1 ) stack : = [ ] middlewarefunc { } for , mw : = range ms . stack { if funckey ( mw ) == m1k { stack = append ( stack , mw2 ) } else { stack = append ( stack , mw ) } } ms . stack = stack } 
func ( a * app ) routes ( ) routelist { if a . root ! = nil { return a . root . routes } return a . routes } 
func ( a routelist ) lookup ( name string ) ( * routeinfo , error ) { for , ri : = range a { if ri . pathname == name { return ri , nil } } return nil , errors . new ( " " ) } 
func ( c importconverter ) match ( importpath string ) ( string , bool ) { for key , value : = range c . data { if ! strings . hasprefix ( importpath , key ) { continue } result : = strings . replace ( importpath , key , value , 1 ) return result , true } return importpath , false } 
func ( opts * options ) validate ( ) error { if len ( opts . name ) == 0 { return errors . new ( " " ) } if len ( opts . actions ) == 0 { return errors . new ( " " ) } if opts . app . iszero ( ) { opts . app = meta . new ( " " ) } if len ( opts . method ) == 0 { opts . method = " " } return nil } 
func ( f sendfunc ) send ( from string , to [ ] string , msg io . writerto ) error { return f ( from , to , msg ) } 
func send ( s sender , msg ... * message ) error { for i , m : = range msg { if err : = send ( s , m ) ; err ! = nil { return & senderror { cause : err , index : uint ( i ) } } } return nil } 
func ( opts options ) last ( n name . ident ) bool { return opts . parts [ len ( opts . parts ) - 1 ] . string ( ) == n . string ( ) } 
func ( a * app ) stop ( err error ) error { a . cancel ( ) if err ! = nil && errors . cause ( err ) ! = context . canceled { a . logger . error ( err ) return err } return nil } 
func depensure ( r * runner ) error { if r . app . withpop { upkg = append ( upkg , " " , " " ) } if ! r . app . withdep { fmt . println ( " " ) return modgetupdate ( r ) } fmt . println ( " " ) return rundepensure ( r ) } 
func plain ( names ... string ) renderer { e : = new ( options { } ) return e . plain ( names ... ) } 
func ( e * engine ) plain ( names ... string ) renderer { hr : = & templaterenderer { engine : e , contenttype : " " , names : names , } return hr } 
func ( b buildinfo ) string ( ) string { return fmt . sprintf ( " " , b . version , b . time ) } 
func ( m * message ) addbody ( r render . renderer , data render . data ) error { buf : = bytes . newbuffer ( [ ] byte { } ) err : = r . render ( buf , m . merge ( data ) ) if err ! = nil { return err } m . bodies = append ( m . bodies , body { content : buf . string ( ) , contenttype : r . contenttype ( ) , } ) return nil } 
func ( m * message ) addbodies ( data render . data , renderers ... render . renderer ) error { for , r : = range renderers { err : = m . addbody ( r , data ) if err ! = nil { return err } } return nil } 
func ( m * message ) addattachment ( name , contenttype string , r io . reader ) error { m . attachments = append ( m . attachments , attachment { name : name , contenttype : contenttype , reader : r , embedded : false , } ) return nil } 
func ( m * message ) addembedded ( name string , r io . reader ) error { m . attachments = append ( m . attachments , attachment { name : name , reader : r , embedded : true , } ) return nil } 
func ( m * message ) setheader ( field , value string ) { m . headers [ field ] = value } 
func new ( opts * options ) ( * genny . group , error ) { if err : = opts . validate ( ) ; err ! = nil { return nil , err } gg , err : = core . new ( opts . options ) if err ! = nil { return gg , err } g : = genny . new ( ) g . transformer ( genny . dot ( ) ) data : = map [ string ] interface { } { " " : opts , } helpers : = template . funcmap { } t : = gogen . templatetransformer ( data , helpers ) g . transformer ( t ) g . box ( packr . new ( " " , " " ) ) gg . add ( g ) if opts . webpack ! = nil { g , err = webpack . new ( opts . webpack ) if err ! = nil { return gg , err } gg . add ( g ) } if opts . standard ! = nil { g , err = standard . new ( opts . standard ) if err ! = nil { return gg , err } gg . add ( g ) } return gg , nil } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) g . box ( packr . new ( " " , " " ) ) data : = map [ string ] interface { } { } h : = template . funcmap { } t : = gogen . templatetransformer ( data , h ) g . transformer ( t ) g . runfn ( func ( r * genny . runner ) error { f , err : = r . findfile ( " " ) if err ! = nil { return err } s : = strings . replace ( f . string ( ) , " " , " \n " + bs4 , 1 ) return r . file ( genny . newfiles ( f . name ( ) , s ) ) } ) return g , nil } 
func new ( opts * options ) ( * genny . generator , error ) { g : = genny . new ( ) if err : = opts . validate ( ) ; err ! = nil { return g , errors . withstack ( err ) } g . runfn ( appdetails ( opts ) ) cbox : = packr . folder ( filepath . join ( opts . app . root , " " ) ) g . runfn ( configs ( opts , cbox ) ) abox : = packr . folder ( opts . app . root ) g . runfn ( pkgchecks ( opts , abox ) ) return g , nil } 
func cleanup ( opts * options ) genny . runfn { return func ( r * genny . runner ) error { defer os . removeall ( filepath . join ( opts . root , " " ) ) if err : = jam . clean ( ) ; err ! = nil { return err } var err error opts . rollback . range ( func ( k , v interface { } ) bool { f : = genny . newfiles ( k . ( string ) , v . ( string ) ) r . logger . debugf ( " " , f . name ( ) ) if err = r . file ( f ) ; err ! = nil { return false } r . disk . remove ( f . name ( ) ) return true } ) if err ! = nil { return err } for , f : = range r . disk . files ( ) { if err : = r . disk . delete ( f . name ( ) ) ; err ! = nil { return err } } if envy . mods ( ) { if err : = r . exec ( exec . command ( genny . gobin ( ) , " " , " " ) ) ; err ! = nil { return err } } return nil } } 
func ( opts * options ) validate ( ) error { if opts . options == nil { opts . options = & core . options { } } return opts . options . validate ( ) } 
func html ( names ... string ) renderer { e : = new ( options { } ) return e . html ( names ... ) } 
func ( e * engine ) html ( names ... string ) renderer { if e . htmllayout ! = " " && len ( names ) == 1 { names = append ( names , e . htmllayout ) } hr : = & templaterenderer { engine : e , contenttype : " " , names : names , } return hr } 
func mdtemplateengine ( input string , data map [ string ] interface { } , helpers map [ string ] interface { } ) ( string , error ) { if ct , ok : = data [ " " ] . ( string ) ; ok && ct == " " { return plush . buffalorenderer ( input , data , helpers ) } source : = github flavored markdown . markdown ( [ ] byte ( input ) ) source = [ ] byte ( html . unescapestring ( string ( source ) ) ) return plush . buffalorenderer ( string ( source ) , data , helpers ) } 
func filterchanges ( cfg plugins . configupdater , changes [ ] github . pullrequestchange , log * logrus . entry ) map [ configmapid ] [ ] configmapupdate { toupdate : = map [ configmapid ] [ ] configmapupdate { } for , change : = range changes { var cm plugins . configmapspec found : = false for key , configmap : = range cfg . maps { var matcherr error found , matcherr = zglob . match ( key , change . filename ) if matcherr ! = nil { log . witherror ( matcherr ) . info ( " " ) continue } if found { cm = configmap break } } if ! found { continue } for , ns : = range append ( cm . namespaces ) { id : = configmapid { name : cm . name , namespace : ns } key : = cm . key if key == " " { key = path . base ( change . filename ) if change . status == github . pullrequestfilerenamed { oldkey : = path . base ( change . previousfilename ) toupdate [ id ] = append ( toupdate [ id ] , configmapupdate { key : oldkey } ) } } if change . status == github . pullrequestfileremoved { toupdate [ id ] = append ( toupdate [ id ] , configmapupdate { key : key } ) } else { gzip : = cfg . gzip if cm . gzip ! = nil { gzip = * cm . gzip } toupdate [ id ] = append ( toupdate [ id ] , configmapupdate { key : key , filename : change . filename , gzip : gzip } ) } } } return toupdate } 
func getlabelsfromrematches ( matches [ ] [ ] string ) ( labels [ ] string ) { for , match : = range matches { for , label : = range strings . split ( match [ 0 ] , " " ) [ 1 : ] { label = strings . tolower ( match [ 1 ] + " " + strings . trimspace ( label ) ) labels = append ( labels , label ) } } return } 
func getlabelsfromgenericmatches ( matches [ ] [ ] string , additionallabels [ ] string ) [ ] string { if len ( additionallabels ) == 0 { return nil } var labels [ ] string for , match : = range matches { parts : = strings . split ( match [ 0 ] , " " ) if ( ( parts [ 0 ] ! = " " ) && ( parts [ 0 ] ! = " " ) ) | | len ( parts ) ! = 2 { continue } for , l : = range additionallabels { if l == parts [ 1 ] { labels = append ( labels , parts [ 1 ] ) } } } return labels } 
func ( ca * agent ) start ( prowconfig , jobconfig string ) error { c , err : = load ( prowconfig , jobconfig ) if err ! = nil { return err } ca . set ( c ) go func ( ) { var lastmodtime time . time skips : = 0 for range time . tick ( 1 * time . second ) { if skips < 600 { prowstat , err : = os . stat ( prowconfig ) if err ! = nil { logrus . withfield ( " " , prowconfig ) . witherror ( err ) . error ( " " ) continue } recentmodtime : = prowstat . modtime ( ) if jobconfig ! = " " { jobconfigstat , err : = os . stat ( jobconfig ) if err ! = nil { logrus . withfield ( " " , jobconfig ) . witherror ( err ) . error ( " " ) continue } if jobconfigstat . modtime ( ) . after ( recentmodtime ) { recentmodtime = jobconfigstat . modtime ( ) } } if ! recentmodtime . after ( lastmodtime ) { skips ++ continue } lastmodtime = recentmodtime } if c , err : = load ( prowconfig , jobconfig ) ; err ! = nil { logrus . withfield ( " " , prowconfig ) . withfield ( " " , jobconfig ) . witherror ( err ) . error ( " " ) } else { skips = 0 ca . set ( c ) } } } ( ) return nil } 
func ( ca * agent ) subscribe ( subscription deltachan ) { ca . mut . lock ( ) defer ca . mut . unlock ( ) ca . subscriptions = append ( ca . subscriptions , subscription ) } 
func ( ca * agent ) config ( ) * config { ca . mut . rlock ( ) defer ca . mut . runlock ( ) return ca . c } 
func ( ca * agent ) set ( c * config ) { ca . mut . lock ( ) defer ca . mut . unlock ( ) var oldconfig config if ca . c ! = nil { oldconfig = * ca . c } delta : = delta { oldconfig , * c } ca . c = c for , subscription : = range ca . subscriptions { go func ( sub deltachan ) { end : = time . newtimer ( time . minute ) select { case sub < - delta : case < - end . c : } if ! end . stop ( ) { < - end . c } } ( subscription ) } } 
func ( f * fakeclient ) ismember ( org , user string ) ( bool , error ) { for , m : = range f . orgmembers [ org ] { if m == user { return true , nil } } return false , nil } 
func ( f * fakeclient ) listissuecomments ( owner , repo string , number int ) ( [ ] github . issuecomment , error ) { return append ( [ ] github . issuecomment { } , f . issuecomments [ number ] ... ) , nil } 
func ( f * fakeclient ) listpullrequestcomments ( owner , repo string , number int ) ( [ ] github . reviewcomment , error ) { return append ( [ ] github . reviewcomment { } , f . pullrequestcomments [ number ] ... ) , nil } 
func ( f * fakeclient ) listreviews ( owner , repo string , number int ) ( [ ] github . review , error ) { return append ( [ ] github . review { } , f . reviews [ number ] ... ) , nil } 
func ( f * fakeclient ) listissueevents ( owner , repo string , number int ) ( [ ] github . listedissueevent , error ) { return append ( [ ] github . listedissueevent { } , f . issueevents [ number ] ... ) , nil } 
func ( f * fakeclient ) createcomment ( owner , repo string , number int , comment string ) error { f . issuecommentsadded = append ( f . issuecommentsadded , fmt . sprintf ( " " , owner , repo , number , comment ) ) f . issuecomments [ number ] = append ( f . issuecomments [ number ] , github . issuecomment { id : f . issuecommentid , body : comment , user : github . user { login : botname } , } ) f . issuecommentid ++ return nil } 
func ( f * fakeclient ) createreview ( org , repo string , number int , r github . draftreview ) error { f . reviews [ number ] = append ( f . reviews [ number ] , github . review { id : f . reviewid , user : github . user { login : botname } , body : r . body , } ) f . reviewid ++ return nil } 
func ( f * fakeclient ) createcommentreaction ( org , repo string , id int , reaction string ) error { f . commentreactionsadded = append ( f . commentreactionsadded , fmt . sprintf ( " " , org , repo , id , reaction ) ) return nil } 
func ( f * fakeclient ) createissuereaction ( org , repo string , id int , reaction string ) error { f . issuereactionsadded = append ( f . issuereactionsadded , fmt . sprintf ( " " , org , repo , id , reaction ) ) return nil } 
func ( f * fakeclient ) deletecomment ( owner , repo string , id int ) error { f . issuecommentsdeleted = append ( f . issuecommentsdeleted , fmt . sprintf ( " " , owner , repo , id ) ) for num , ics : = range f . issuecomments { for i , ic : = range ics { if ic . id == id { f . issuecomments [ num ] = append ( ics [ : i ] , ics [ i + 1 : ] ... ) return nil } } } return fmt . errorf ( " " , id ) } 
func ( f * fakeclient ) deletestalecomments ( org , repo string , number int , comments [ ] github . issuecomment , isstale func ( github . issuecomment ) bool ) error { if comments == nil { comments , = f . listissuecomments ( org , repo , number ) } for , comment : = range comments { if isstale ( comment ) { if err : = f . deletecomment ( org , repo , comment . id ) ; err ! = nil { return fmt . errorf ( " " , comment . id ) } } } return nil } 
func ( f * fakeclient ) getpullrequest ( owner , repo string , number int ) ( * github . pullrequest , error ) { val , exists : = f . pullrequests [ number ] if ! exists { return nil , fmt . errorf ( " " , number ) } return val , nil } 
func ( f * fakeclient ) getpullrequestchanges ( org , repo string , number int ) ( [ ] github . pullrequestchange , error ) { return f . pullrequestchanges [ number ] , nil } 
func ( f * fakeclient ) getref ( owner , repo , ref string ) ( string , error ) { return testref , nil } 
func ( f * fakeclient ) deleteref ( owner , repo , ref string ) error { f . refsdeleted = append ( f . refsdeleted , struct { org , repo , ref string } { org : owner , repo : repo , ref : ref } ) return nil } 
func ( f * fakeclient ) getsinglecommit ( org , repo , sha string ) ( github . singlecommit , error ) { return f . commits [ sha ] , nil } 
func ( f * fakeclient ) createstatus ( owner , repo , sha string , s github . status ) error { if f . createdstatuses == nil { f . createdstatuses = make ( map [ string ] [ ] github . status ) } statuses : = f . createdstatuses [ sha ] var updated bool for i : = range statuses { if statuses [ i ] . context == s . context { statuses [ i ] = s updated = true } } if ! updated { statuses = append ( statuses , s ) } f . createdstatuses [ sha ] = statuses return nil } 
func ( f * fakeclient ) liststatuses ( org , repo , ref string ) ( [ ] github . status , error ) { return f . createdstatuses [ ref ] , nil } 
func ( f * fakeclient ) getcombinedstatus ( owner , repo , ref string ) ( * github . combinedstatus , error ) { return f . combinedstatuses [ ref ] , nil } 
func ( f * fakeclient ) getrepolabels ( owner , repo string ) ( [ ] github . label , error ) { la : = [ ] github . label { } for , l : = range f . repolabelsexisting { la = append ( la , github . label { name : l } ) } return la , nil } 
func ( f * fakeclient ) getissuelabels ( owner , repo string , number int ) ( [ ] github . label , error ) { re : = regexp . mustcompile ( fmt . sprintf ( , owner , repo , number ) ) la : = [ ] github . label { } alllabels : = sets . newstring ( f . issuelabelsexisting ... ) alllabels . insert ( f . issuelabelsadded ... ) alllabels . delete ( f . issuelabelsremoved ... ) for , l : = range alllabels . list ( ) { groups : = re . findstringsubmatch ( l ) if groups ! = nil { la = append ( la , github . label { name : groups [ 1 ] } ) } } return la , nil } 
func ( f * fakeclient ) addlabel ( owner , repo string , number int , label string ) error { labelstring : = fmt . sprintf ( " " , owner , repo , number , label ) if sets . newstring ( f . issuelabelsadded ... ) . has ( labelstring ) { return fmt . errorf ( " " , label , owner , repo , number ) } if f . repolabelsexisting == nil { f . issuelabelsadded = append ( f . issuelabelsadded , labelstring ) return nil } for , l : = range f . repolabelsexisting { if label == l { f . issuelabelsadded = append ( f . issuelabelsadded , labelstring ) return nil } } return fmt . errorf ( " " , label , owner , repo , number ) } 
func ( f * fakeclient ) removelabel ( owner , repo string , number int , label string ) error { labelstring : = fmt . sprintf ( " " , owner , repo , number , label ) if ! sets . newstring ( f . issuelabelsremoved ... ) . has ( labelstring ) { f . issuelabelsremoved = append ( f . issuelabelsremoved , labelstring ) return nil } return fmt . errorf ( " " , label , owner , repo , number ) } 
func ( f * fakeclient ) findissues ( query , sort string , asc bool ) ( [ ] github . issue , error ) { return f . issues , nil } 
func ( f * fakeclient ) assignissue ( owner , repo string , number int , assignees [ ] string ) error { var m github . missingusers for , a : = range assignees { if a == " " { m . users = append ( m . users , a ) continue } f . assigneesadded = append ( f . assigneesadded , fmt . sprintf ( " " , owner , repo , number , a ) ) } if m . users == nil { return nil } return m } 
func ( f * fakeclient ) getfile ( org , repo , file , commit string ) ( [ ] byte , error ) { contents , ok : = f . remotefiles [ file ] if ! ok { return nil , fmt . errorf ( " " , file ) } if commit == " " { if master , ok : = contents [ " " ] ; ok { return [ ] byte ( master ) , nil } return nil , fmt . errorf ( " " , file ) } if content , ok : = contents [ commit ] ; ok { return [ ] byte ( content ) , nil } return nil , fmt . errorf ( " " , file , commit ) } 
func ( f * fakeclient ) listteams ( org string ) ( [ ] github . team , error ) { return [ ] github . team { { id : 0 , name : " " , } , { id : 42 , name : " " , } , } , nil } 
func ( f * fakeclient ) listteammembers ( teamid int , role string ) ( [ ] github . teammember , error ) { if role ! = github . roleall { return nil , fmt . errorf ( " " , role ) } teams : = map [ int ] [ ] github . teammember { 0 : { { login : " " } } , 42 : { { login : " " } } , } members , ok : = teams [ teamid ] if ! ok { return [ ] github . teammember { } , nil } return members , nil } 
func ( f * fakeclient ) iscollaborator ( org , repo , login string ) ( bool , error ) { normed : = github . normlogin ( login ) for , collab : = range f . collaborators { if github . normlogin ( collab ) == normed { return true , nil } } return false , nil } 
func ( f * fakeclient ) listcollaborators ( org , repo string ) ( [ ] github . user , error ) { result : = make ( [ ] github . user , 0 , len ( f . collaborators ) ) for , login : = range f . collaborators { result = append ( result , github . user { login : login } ) } return result , nil } 
func ( f * fakeclient ) clearmilestone ( org , repo string , issuenum int ) error { f . milestone = 0 return nil } 
func ( f * fakeclient ) setmilestone ( org , repo string , issuenum , milestonenum int ) error { if milestonenum < 0 { return fmt . errorf ( " " ) } f . milestone = milestonenum return nil } 
func ( f * fakeclient ) listmilestones ( org , repo string ) ( [ ] github . milestone , error ) { milestones : = [ ] github . milestone { } for k , v : = range f . milestonemap { milestones = append ( milestones , github . milestone { title : k , number : v } ) } return milestones , nil } 
func ( f * fakeclient ) listprcommits ( org , repo string , prnumber int ) ( [ ] github . repositorycommit , error ) { k : = fmt . sprintf ( " " , org , repo , prnumber ) return f . commitmap [ k ] , nil } 
func ( f * fakeclient ) getrepoprojects ( owner , repo string ) ( [ ] github . project , error ) { return f . repoprojects [ fmt . sprintf ( " " , owner , repo ) ] , nil } 
func ( f * fakeclient ) getorgprojects ( org string ) ( [ ] github . project , error ) { return f . repoprojects [ fmt . sprintf ( " " , org ) ] , nil } 
func ( f * fakeclient ) getprojectcolumns ( projectid int ) ( [ ] github . projectcolumn , error ) { for , projects : = range f . repoprojects { for , project : = range projects { if projectid == project . id { return f . projectcolumnsmap [ project . name ] , nil } } } return nil , fmt . errorf ( " " ) } 
func ( f * fakeclient ) createprojectcard ( columnid int , projectcard github . projectcard ) ( * github . projectcard , error ) { if f . columncardsmap == nil { f . columncardsmap = make ( map [ int ] [ ] github . projectcard ) } for project , columnidmap : = range f . columnidmap { columnname , exists : = columnidmap [ columnid ] if exists { f . columncardsmap [ columnid ] = append ( f . columncardsmap [ columnid ] , projectcard , ) f . column = columnname f . project = project return & projectcard , nil } } return nil , fmt . errorf ( " " , columnid , f . columnidmap ) } 
func ( f * fakeclient ) deleteprojectcard ( projectcardid int ) error { if f . columncardsmap == nil { return fmt . errorf ( " " ) } f . project = " " f . column = " " newcards : = [ ] github . projectcard { } oldcolumnid : = - 1 for column , cards : = range f . columncardsmap { removalindex : = - 1 for i , existingcard : = range cards { if existingcard . contentid == projectcardid { oldcolumnid = column removalindex = i break } } if removalindex ! = - 1 { newcards = cards newcards [ removalindex ] = newcards [ len ( newcards ) - 1 ] newcards = newcards [ : len ( newcards ) - 1 ] break } } if oldcolumnid ! = - 1 { f . columncardsmap [ oldcolumnid ] = newcards } return nil } 
func ( f * fakeclient ) moveprojectcard ( projectcardid int , newcolumnid int ) error { newcards : = [ ] github . projectcard { } oldcolumnid : = - 1 projectcard : = github . projectcard { } for column , cards : = range f . columncardsmap { removalindex : = - 1 for i , existingcard : = range cards { if existingcard . contentid == projectcardid { oldcolumnid = column removalindex = i projectcard = existingcard break } } if removalindex ! = - 1 { newcards = cards newcards [ removalindex ] = newcards [ len ( newcards ) - 1 ] newcards = newcards [ : len ( newcards ) - 1 ] } } if oldcolumnid ! = - 1 { f . columncardsmap [ oldcolumnid ] = newcards } for project , columnidmap : = range f . columnidmap { if columnname , exists : = columnidmap [ newcolumnid ] ; exists { f . columncardsmap [ newcolumnid ] = append ( f . columncardsmap [ newcolumnid ] , projectcard , ) f . column = columnname f . project = project break } } return nil } 
func ( f * fakeclient ) teamhasmember ( teamid int , memberlogin string ) ( bool , error ) { teammembers , : = f . listteammembers ( teamid , github . roleall ) for , member : = range teammembers { if member . login == memberlogin { return true , nil } } return false , nil } 
func ( config * influxconfig ) addflags ( cmd * cobra . command ) { cmd . persistentflags ( ) . stringvar ( & config . user , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & config . password , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & config . host , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & config . db , " " , " " , " " ) } 
func ( config * influxconfig ) createdatabaseclient ( ) ( * influxdb , error ) { client , err : = influxdb . newhttpclient ( influxdb . httpconfig { addr : config . host , username : config . user , password : config . password , } ) if err ! = nil { return nil , err } return & influxdb { client : client , database : config . db , } , nil } 
func ( i * influxdb ) push ( measurement string , tags map [ string ] string , fields map [ string ] interface { } , date time . time ) error { batch , err : = influxdb . newbatchpoints ( influxdb . batchpointsconfig { database : i . database , precision : " " , } ) if err ! = nil { return err } pt , err : = influxdb . newpoint ( measurement , tags , fields , date ) if err ! = nil { return err } batch . addpoint ( pt ) err = i . client . write ( batch ) if err ! = nil { return err } glog . infof ( " " , measurement , tags , fields , date ) return nil } 
func newprowjobwithannotation ( spec prowapi . prowjobspec , labels , annotations map [ string ] string ) prowapi . prowjob { return newprowjob ( spec , labels , annotations ) } 
func newprowjob ( spec prowapi . prowjobspec , labels map [ string ] string ) prowapi . prowjob { return newprowjob ( spec , labels , nil ) } 
func newpresubmit ( pr github . pullrequest , basesha string , job config . presubmit , eventguid string ) prowapi . prowjob { refs : = createrefs ( pr , basesha ) labels : = make ( map [ string ] string ) for k , v : = range job . labels { labels [ k ] = v } labels [ github . eventguid ] = eventguid return newprowjob ( presubmitspec ( job , refs ) , labels ) } 
func presubmitspec ( p config . presubmit , refs prowapi . refs ) prowapi . prowjobspec { pjs : = specfromjobbase ( p . jobbase ) pjs . type = prowapi . presubmitjob pjs . context = p . context pjs . report = ! p . skipreport pjs . reruncommand = p . reruncommand if p . jenkinsspec ! = nil { pjs . jenkinsspec = & prowapi . jenkinsspec { githubbranchsourcejob : p . jenkinsspec . githubbranchsourcejob , } } pjs . refs = completeprimaryrefs ( refs , p . jobbase ) return pjs } 
func postsubmitspec ( p config . postsubmit , refs prowapi . refs ) prowapi . prowjobspec { pjs : = specfromjobbase ( p . jobbase ) pjs . type = prowapi . postsubmitjob pjs . context = p . context pjs . report = ! p . skipreport pjs . refs = completeprimaryrefs ( refs , p . jobbase ) if p . jenkinsspec ! = nil { pjs . jenkinsspec = & prowapi . jenkinsspec { githubbranchsourcejob : p . jenkinsspec . githubbranchsourcejob , } } return pjs } 
func periodicspec ( p config . periodic ) prowapi . prowjobspec { pjs : = specfromjobbase ( p . jobbase ) pjs . type = prowapi . periodicjob return pjs } 
func batchspec ( p config . presubmit , refs prowapi . refs ) prowapi . prowjobspec { pjs : = specfromjobbase ( p . jobbase ) pjs . type = prowapi . batchjob pjs . context = p . context pjs . refs = completeprimaryrefs ( refs , p . jobbase ) return pjs } 
func partitionactive ( pjs [ ] prowapi . prowjob ) ( pending , triggered chan prowapi . prowjob ) { pendingcount , triggeredcount : = 0 , 0 for , pj : = range pjs { switch pj . status . state { case prowapi . pendingstate : pendingcount ++ case prowapi . triggeredstate : triggeredcount ++ } } pending = make ( chan prowapi . prowjob , pendingcount ) triggered = make ( chan prowapi . prowjob , triggeredcount ) for , pj : = range pjs { switch pj . status . state { case prowapi . pendingstate : pending < - pj case prowapi . triggeredstate : triggered < - pj } } close ( pending ) close ( triggered ) return pending , triggered } 
func prowjobfields ( pj * prowapi . prowjob ) logrus . fields { fields : = make ( logrus . fields ) fields [ " " ] = pj . objectmeta . name fields [ " " ] = pj . spec . job fields [ " " ] = pj . spec . type if len ( pj . objectmeta . labels [ github . eventguid ] ) > 0 { fields [ github . eventguid ] = pj . objectmeta . labels [ github . eventguid ] } if pj . spec . refs ! = nil && len ( pj . spec . refs . pulls ) == 1 { fields [ github . prlogfield ] = pj . spec . refs . pulls [ 0 ] . number fields [ github . repologfield ] = pj . spec . refs . repo fields [ github . orglogfield ] = pj . spec . refs . org } if pj . spec . jenkinsspec ! = nil { fields [ " " ] = pj . spec . jenkinsspec . githubbranchsourcejob } return fields } 
func joburl ( plank config . plank , pj prowapi . prowjob , log * logrus . entry ) string { if pj . spec . decorationconfig ! = nil && plank . getjoburlprefix ( pj . spec . refs ) ! = " " { spec : = downwardapi . newjobspec ( pj . spec , pj . status . buildid , pj . name ) gcsconfig : = pj . spec . decorationconfig . gcsconfiguration , gcspath , : = gcsupload . pathsforjob ( gcsconfig , & spec , " " ) prefix , : = url . parse ( plank . getjoburlprefix ( pj . spec . refs ) ) prefix . path = path . join ( prefix . path , gcsconfig . bucket , gcspath ) return prefix . string ( ) } var b bytes . buffer if err : = plank . joburltemplate . execute ( & b , & pj ) ; err ! = nil { log . withfields ( prowjobfields ( & pj ) ) . errorf ( " " , err ) } else { return b . string ( ) } return " " } 
func clustertoctx ( cluster string ) string { if cluster == kube . inclustercontext { return kube . defaultclusteralias } return cluster } 
func ( pluginhelp * pluginhelp ) addcommand ( command command ) { pluginhelp . commands = append ( pluginhelp . commands , command ) } 
func ( c * fakeprowjobs ) get ( name string , options v1 . getoptions ) ( result * prowjobsv1 . prowjob , err error ) { obj , err : = c . fake . invokes ( testing . newgetaction ( prowjobsresource , c . ns , name ) , & prowjobsv1 . prowjob { } ) if obj == nil { return nil , err } return obj . ( * prowjobsv1 . prowjob ) , err } 
func ( c * fakeprowjobs ) list ( opts v1 . listoptions ) ( result * prowjobsv1 . prowjoblist , err error ) { obj , err : = c . fake . invokes ( testing . newlistaction ( prowjobsresource , prowjobskind , c . ns , opts ) , & prowjobsv1 . prowjoblist { } ) if obj == nil { return nil , err } label , , : = testing . extractfromlistoptions ( opts ) if label == nil { label = labels . everything ( ) } list : = & prowjobsv1 . prowjoblist { listmeta : obj . ( * prowjobsv1 . prowjoblist ) . listmeta } for , item : = range obj . ( * prowjobsv1 . prowjoblist ) . items { if label . matches ( labels . set ( item . labels ) ) { list . items = append ( list . items , item ) } } return list , err } 
func ( c * fakeprowjobs ) watch ( opts v1 . listoptions ) ( watch . interface , error ) { return c . fake . invokeswatch ( testing . newwatchaction ( prowjobsresource , c . ns , opts ) ) } 
func ( c * fakeprowjobs ) create ( prowjob * prowjobsv1 . prowjob ) ( result * prowjobsv1 . prowjob , err error ) { obj , err : = c . fake . invokes ( testing . newcreateaction ( prowjobsresource , c . ns , prowjob ) , & prowjobsv1 . prowjob { } ) if obj == nil { return nil , err } return obj . ( * prowjobsv1 . prowjob ) , err } 
func ( c * fakeprowjobs ) update ( prowjob * prowjobsv1 . prowjob ) ( result * prowjobsv1 . prowjob , err error ) { obj , err : = c . fake . invokes ( testing . newupdateaction ( prowjobsresource , c . ns , prowjob ) , & prowjobsv1 . prowjob { } ) if obj == nil { return nil , err } return obj . ( * prowjobsv1 . prowjob ) , err } 
func ( c * fakeprowjobs ) updatestatus ( prowjob * prowjobsv1 . prowjob ) ( * prowjobsv1 . prowjob , error ) { obj , err : = c . fake . invokes ( testing . newupdatesubresourceaction ( prowjobsresource , " " , c . ns , prowjob ) , & prowjobsv1 . prowjob { } ) if obj == nil { return nil , err } return obj . ( * prowjobsv1 . prowjob ) , err } 
func ( c * fakeprowjobs ) delete ( name string , options * v1 . deleteoptions ) error { , err : = c . fake . invokes ( testing . newdeleteaction ( prowjobsresource , c . ns , name ) , & prowjobsv1 . prowjob { } ) return err } 
func ( c * fakeprowjobs ) deletecollection ( options * v1 . deleteoptions , listoptions v1 . listoptions ) error { action : = testing . newdeletecollectionaction ( prowjobsresource , c . ns , listoptions ) , err : = c . fake . invokes ( action , & prowjobsv1 . prowjoblist { } ) return err } 
func ( c * fakeprowjobs ) patch ( name string , pt types . patchtype , data [ ] byte , subresources ... string ) ( result * prowjobsv1 . prowjob , err error ) { obj , err : = c . fake . invokes ( testing . newpatchsubresourceaction ( prowjobsresource , c . ns , name , data , subresources ... ) , & prowjobsv1 . prowjob { } ) if obj == nil { return nil , err } return obj . ( * prowjobsv1 . prowjob ) , err } 
func ( t * tide ) mergemethod ( org , repo string ) github . pullrequestmergetype { name : = org + " " + repo v , ok : = t . mergetype [ name ] if ! ok { if ov , found : = t . mergetype [ org ] ; found { return ov } return github . mergemerge } return v } 
func ( t * tide ) mergecommittemplate ( org , repo string ) tidemergecommittemplate { name : = org + " " + repo v , ok : = t . mergetemplate [ name ] if ! ok { return t . mergetemplate [ org ] } return v } 
func ( tq * tidequery ) query ( ) string { toks : = [ ] string { " " , " " } for , o : = range tq . orgs { toks = append ( toks , fmt . sprintf ( " " " " , o ) ) } for , r : = range tq . repos { toks = append ( toks , fmt . sprintf ( " " " " , r ) ) } for , r : = range tq . excludedrepos { toks = append ( toks , fmt . sprintf ( " " " " , r ) ) } for , b : = range tq . excludedbranches { toks = append ( toks , fmt . sprintf ( " " " " , b ) ) } for , b : = range tq . includedbranches { toks = append ( toks , fmt . sprintf ( " " " " , b ) ) } for , l : = range tq . labels { toks = append ( toks , fmt . sprintf ( " " " " , l ) ) } for , l : = range tq . missinglabels { toks = append ( toks , fmt . sprintf ( " " " " , l ) ) } if tq . milestone ! = " " { toks = append ( toks , fmt . sprintf ( " " " " , tq . milestone ) ) } if tq . reviewapprovedrequired { toks = append ( toks , " " ) } return strings . join ( toks , " " ) } 
func ( tq tidequery ) forrepo ( org , repo string ) bool { fullname : = fmt . sprintf ( " " , org , repo ) for , queryorg : = range tq . orgs { if queryorg ! = org { continue } for , excludedrepo : = range tq . excludedrepos { if excludedrepo == fullname { return false } } return true } for , queryrepo : = range tq . repos { if queryrepo == fullname { return true } } return false } 
func ( tqs tidequeries ) orgexceptionsandrepos ( ) ( map [ string ] sets . string , sets . string ) { orgs : = make ( map [ string ] sets . string ) for i : = range tqs { for , org : = range tqs [ i ] . orgs { applicablerepos : = sets . newstring ( reposinorg ( org , tqs [ i ] . excludedrepos ) ... ) if excepts , ok : = orgs [ org ] ; ! ok { orgs [ org ] = applicablerepos } else { orgs [ org ] = excepts . intersection ( applicablerepos ) } } } repos : = sets . newstring ( ) for i : = range tqs { repos . insert ( tqs [ i ] . repos ... ) } reposlist : = repos . unsortedlist ( ) for , excepts : = range orgs { excepts . delete ( reposlist ... ) } return orgs , repos } 
func ( tqs tidequeries ) querymap ( ) * querymap { return & querymap { queries : tqs , cache : make ( map [ string ] tidequeries ) , } } 
func ( qm * querymap ) forrepo ( org , repo string ) tidequeries { res : = tidequeries ( nil ) fullname : = fmt . sprintf ( " " , org , repo ) qm . lock ( ) defer qm . unlock ( ) if qs , ok : = qm . cache [ fullname ] ; ok { return append ( res , qs ... ) } for , query : = range qm . queries { if query . forrepo ( org , repo ) { res = append ( res , query ) } } qm . cache [ fullname ] = res return res } 
func ( cp * tidecontextpolicy ) validate ( ) error { if inter : = sets . newstring ( cp . requiredcontexts ... ) . intersection ( sets . newstring ( cp . optionalcontexts ... ) ) ; inter . len ( ) > 0 { return fmt . errorf ( " " , strings . join ( inter . list ( ) , " " ) ) } if inter : = sets . newstring ( cp . requiredcontexts ... ) . intersection ( sets . newstring ( cp . requiredifpresentcontexts ... ) ) ; inter . len ( ) > 0 { return fmt . errorf ( " " , strings . join ( inter . list ( ) , " " ) ) } if inter : = sets . newstring ( cp . optionalcontexts ... ) . intersection ( sets . newstring ( cp . requiredifpresentcontexts ... ) ) ; inter . len ( ) > 0 { return fmt . errorf ( " " , strings . join ( inter . list ( ) , " " ) ) } return nil } 
func ( c config ) gettidecontextpolicy ( org , repo , branch string ) ( * tidecontextpolicy , error ) { options : = parsetidecontextpolicyoptions ( org , repo , branch , c . tide . contextoptions ) required : = sets . newstring ( options . requiredcontexts ... ) requiredifpresent : = sets . newstring ( options . requiredifpresentcontexts ... ) optional : = sets . newstring ( options . optionalcontexts ... ) prowrequired , prowrequiredifpresent , prowoptional : = branchrequirements ( org , repo , branch , c . presubmits ) required . insert ( prowrequired ... ) requiredifpresent . insert ( prowrequiredifpresent ... ) optional . insert ( prowoptional ... ) if options . frombranchprotection ! = nil && * options . frombranchprotection { bp , err : = c . getbranchprotection ( org , repo , branch ) if err ! = nil { logrus . witherror ( err ) . warningf ( " " , org , repo , branch ) } else if bp ! = nil && bp . protect ! = nil && * bp . protect && bp . requiredstatuschecks ! = nil { required . insert ( bp . requiredstatuschecks . contexts ... ) } } t : = & tidecontextpolicy { requiredcontexts : required . list ( ) , requiredifpresentcontexts : requiredifpresent . list ( ) , optionalcontexts : optional . list ( ) , skipunknowncontexts : options . skipunknowncontexts , } if err : = t . validate ( ) ; err ! = nil { return t , err } return t , nil } 
func ( cp * tidecontextpolicy ) isoptional ( c string ) bool { if sets . newstring ( cp . optionalcontexts ... ) . has ( c ) { return true } if sets . newstring ( cp . requiredcontexts ... ) . has ( c ) { return false } if sets . newstring ( cp . requiredifpresentcontexts ... ) . has ( c ) { return false } if cp . skipunknowncontexts ! = nil && * cp . skipunknowncontexts { return true } return false } 
func ( cp * tidecontextpolicy ) missingrequiredcontexts ( contexts [ ] string ) [ ] string { if len ( cp . requiredcontexts ) == 0 { return nil } existingcontexts : = sets . newstring ( ) for , c : = range contexts { existingcontexts . insert ( c ) } var missingcontexts [ ] string for c : = range sets . newstring ( cp . requiredcontexts ... ) . difference ( existingcontexts ) { missingcontexts = append ( missingcontexts , c ) } return missingcontexts } 
func newforconfigordie ( c * rest . config ) * clientset { var cs clientset cs . prowv1 = prowv1 . newforconfigordie ( c ) cs . discoveryclient = discovery . newdiscoveryclientforconfigordie ( c ) return & cs } 
func new ( c rest . interface ) * clientset { var cs clientset cs . prowv1 = prowv1 . new ( c ) cs . discoveryclient = discovery . newdiscoveryclient ( c ) return & cs } 
func matches ( repo string , repos [ ] string ) bool { org : = strings . split ( repo , " " ) [ 0 ] for , r : = range repos { if r == repo | | r == org { return true } } return false } 
func helpprovider ( enabledrepos [ ] string ) ( * pluginhelp . pluginhelp , error ) { return & pluginhelp . pluginhelp { description : ' the needs - rebase plugin manages the ' ' + labels . needsrebase + , } , nil } 
func handleevent ( log * logrus . entry , ghc githubclient , pre * github . pullrequestevent ) error { if pre . action ! = github . pullrequestactionopened && pre . action ! = github . pullrequestactionsynchronize && pre . action ! = github . pullrequestactionreopened { return nil } sleep ( time . second * 5 ) org : = pre . repo . owner . login repo : = pre . repo . name number : = pre . number sha : = pre . pullrequest . head . sha mergeable , err : = ghc . ismergeable ( org , repo , number , sha ) if err ! = nil { return err } issuelabels , err : = ghc . getissuelabels ( org , repo , number ) if err ! = nil { return err } haslabel : = github . haslabel ( labels . needsrebase , issuelabels ) return takeaction ( log , ghc , org , repo , number , pre . pullrequest . user . login , haslabel , mergeable ) } 
func takeaction ( log * logrus . entry , ghc githubclient , org , repo string , num int , author string , haslabel , mergeable bool ) error { if ! mergeable && ! haslabel { if err : = ghc . addlabel ( org , repo , num , labels . needsrebase ) ; err ! = nil { log . witherror ( err ) . errorf ( " " , labels . needsrebase ) } msg : = plugins . formatsimpleresponse ( author , needsrebasemessage ) return ghc . createcomment ( org , repo , num , msg ) } else if mergeable && haslabel { if err : = ghc . removelabel ( org , repo , num , labels . needsrebase ) ; err ! = nil { log . witherror ( err ) . errorf ( " " , labels . needsrebase ) } botname , err : = ghc . botname ( ) if err ! = nil { return err } return ghc . deletestalecomments ( org , repo , num , nil , shouldprune ( botname ) ) } return nil } 
func newdryrunprowjobclient ( deckurl string ) prowv1 . prowjobinterface { return & dryrunprowjobclient { deckurl : deckurl , client : & http . client { } , } } 
func ( c * dryrunprowjobclient ) create ( * prowapi . prowjob ) ( * prowapi . prowjob , error ) { return nil , nil } 
func ( c * dryrunprowjobclient ) update ( * prowapi . prowjob ) ( * prowapi . prowjob , error ) { return nil , nil } 
func ( c * dryrunprowjobclient ) updatestatus ( * prowapi . prowjob ) ( * prowapi . prowjob , error ) { return nil , nil } 
func ( c * dryrunprowjobclient ) delete ( name string , options * metav1 . deleteoptions ) error { return nil } 
func ( c * dryrunprowjobclient ) deletecollection ( options * metav1 . deleteoptions , listoptions metav1 . listoptions ) error { return nil } 
func ( c * dryrunprowjobclient ) get ( name string , options metav1 . getoptions ) ( * prowapi . prowjob , error ) { return nil , nil } 
func ( c * dryrunprowjobclient ) list ( opts metav1 . listoptions ) ( * prowapi . prowjoblist , error ) { var jl prowapi . prowjoblist err : = c . request ( " " , map [ string ] string { " " : opts . labelselector } , & jl ) return & jl , err } 
func ( c * dryrunprowjobclient ) requestretry ( path string , query map [ string ] string ) ( [ ] byte , error ) { resp , err : = c . retry ( path , query ) if err ! = nil { return nil , err } defer resp . body . close ( ) rb , err : = ioutil . readall ( resp . body ) if err ! = nil { return nil , err } if resp . statuscode == 404 { return nil , & kapierrors . statuserror { errstatus : metav1 . status { status : metav1 . statusfailure , code : http . statusnotfound , reason : metav1 . statusreasonnotfound , } } } else if resp . statuscode == 409 { return nil , & kapierrors . statuserror { errstatus : metav1 . status { status : metav1 . statusfailure , code : http . statusconflict , reason : metav1 . statusreasonalreadyexists , } } } else if resp . statuscode == 422 { return nil , & kapierrors . statuserror { errstatus : metav1 . status { status : metav1 . statusfailure , code : http . statusunprocessableentity , reason : metav1 . statusreasoninvalid , } } } else if resp . statuscode < 200 | | resp . statuscode > 299 { return nil , fmt . errorf ( " " " " " " , resp . status , string ( rb ) ) } return rb , nil } 
func ( c * dryrunprowjobclient ) watch ( opts metav1 . listoptions ) ( watch . interface , error ) { return nil , nil } 
func ( c * dryrunprowjobclient ) patch ( name string , pt types . patchtype , data [ ] byte , subresources ... string ) ( result * prowapi . prowjob , err error ) { return nil , nil } 
func ( c * controller ) hassynced ( ) bool { if ! c . pjinformer . hassynced ( ) { if c . wait ! = " " { c . wait = " " ns : = c . pjnamespace ( ) if ns == " " { ns = " " } logrus . infof ( " " , ns ) } return false } if ! c . prowjobsdone { c . prowjobsdone = true logrus . info ( " " ) } if c . pipelinesdone == nil { c . pipelinesdone = map [ string ] bool { } } for n , cfg : = range c . pipelines { if ! cfg . informer . informer ( ) . hassynced ( ) { if c . wait ! = n { c . wait = n logrus . infof ( " " , n ) } return false } else if ! c . pipelinesdone [ n ] { c . pipelinesdone [ n ] = true logrus . infof ( " " , n ) } } return true } 
func ( c * controller ) run ( threads int , stop < - chan struct { } ) error { defer runtime . handlecrash ( ) defer c . workqueue . shutdown ( ) logrus . info ( " " ) logrus . info ( " " ) if ok : = cache . waitforcachesync ( stop , c . hassynced ) ; ! ok { return fmt . errorf ( " " ) } logrus . info ( " " ) for i : = 0 ; i < threads ; i ++ { go wait . until ( c . runworker , time . second , stop ) } logrus . info ( " " ) < - stop logrus . info ( " " ) return nil } 
func ( c * controller ) runworker ( ) { for { key , shutdown : = c . workqueue . get ( ) if shutdown { return } func ( ) { defer c . workqueue . done ( key ) if err : = reconcile ( c , key . ( string ) ) ; err ! = nil { runtime . handleerror ( fmt . errorf ( " " , key , err ) ) return } c . workqueue . forget ( key ) } ( ) } } 
func tokey ( ctx , namespace , name string ) string { return strings . join ( [ ] string { ctx , namespace , name } , " " ) } 
func fromkey ( key string ) ( string , string , string , error ) { parts : = strings . split ( key , " " ) if len ( parts ) ! = 3 { return " " , " " , " " , fmt . errorf ( " " , key ) } return parts [ 0 ] , parts [ 1 ] , parts [ 2 ] , nil } 
func ( c * controller ) enqueuekey ( ctx string , obj interface { } ) { switch o : = obj . ( type ) { case * prowjobv1 . prowjob : ns : = o . spec . namespace if ns == " " { ns = o . namespace } c . workqueue . addratelimited ( tokey ( ctx , ns , o . name ) ) case * pipelinev1alpha1 . pipelinerun : c . workqueue . addratelimited ( tokey ( ctx , o . namespace , o . name ) ) default : logrus . warnf ( " " , o , obj ) return } } 
func finalstate ( status prowjobv1 . prowjobstate ) bool { switch status { case " " , prowjobv1 . pendingstate , prowjobv1 . triggeredstate : return false } return true } 
func description ( cond duckv1alpha1 . condition , fallback string ) string { switch { case cond . message ! = " " : return cond . message case cond . reason ! = " " : return cond . reason } return fallback } 
func prowjobstatus ( ps pipelinev1alpha1 . pipelinerunstatus ) ( prowjobv1 . prowjobstate , string ) { started : = ps . starttime finished : = ps . completiontime pcond : = ps . getcondition ( duckv1alpha1 . conditionsucceeded ) if pcond == nil { if ! finished . iszero ( ) { return prowjobv1 . errorstate , descmissingcondition } return prowjobv1 . triggeredstate , descscheduling } cond : = * pcond switch { case cond . status == untypedcorev1 . conditiontrue : return prowjobv1 . successstate , description ( cond , descsucceeded ) case cond . status == untypedcorev1 . conditionfalse : return prowjobv1 . failurestate , description ( cond , descfailed ) case started . iszero ( ) : return prowjobv1 . triggeredstate , description ( cond , descinitializing ) case cond . status == untypedcorev1 . conditionunknown , finished . iszero ( ) : return prowjobv1 . pendingstate , description ( cond , descrunning ) } logrus . warnf ( " " , cond ) return prowjobv1 . errorstate , description ( cond , descunknown ) } 
func pipelinemeta ( pj prowjobv1 . prowjob ) metav1 . objectmeta { labels , annotations : = decorate . labelsandannotationsforjob ( pj ) return metav1 . objectmeta { annotations : annotations , name : pj . name , namespace : pj . spec . namespace , labels : labels , } } 
func sourceurl ( pj prowjobv1 . prowjob ) string { if pj . spec . refs == nil { return " " } sourceurl : = pj . spec . refs . cloneuri if sourceurl == " " { sourceurl = fmt . sprintf ( " " , pj . spec . refs . repolink ) } return sourceurl } 
func makepipelinegitresource ( pj prowjobv1 . prowjob ) * pipelinev1alpha1 . pipelineresource { var revision string if pj . spec . refs ! = nil { if len ( pj . spec . refs . pulls ) > 0 { revision = pj . spec . refs . pulls [ 0 ] . sha } else { revision = pj . spec . refs . basesha } } pr : = pipelinev1alpha1 . pipelineresource { objectmeta : pipelinemeta ( pj ) , spec : pipelinev1alpha1 . pipelineresourcespec { type : pipelinev1alpha1 . pipelineresourcetypegit , params : [ ] pipelinev1alpha1 . param { { name : " " , value : sourceurl ( pj ) , } , { name : " " , value : revision , } , } , } , } return & pr } 
func makepipelinerun ( pj prowjobv1 . prowjob , pr * pipelinev1alpha1 . pipelineresource ) ( * pipelinev1alpha1 . pipelinerun , error ) { if pj . spec . pipelinerunspec == nil { return nil , errors . new ( " " ) } p : = pipelinev1alpha1 . pipelinerun { objectmeta : pipelinemeta ( pj ) , spec : * pj . spec . pipelinerunspec . deepcopy ( ) , } buildid : = pj . status . buildid if buildid == " " { return nil , errors . new ( " " ) } p . spec . params = append ( p . spec . params , pipelinev1alpha1 . param { name : " " , value : buildid , } ) rb : = pipelinev1alpha1 . pipelineresourcebinding { name : pr . name , resourceref : pipelinev1alpha1 . pipelineresourceref { name : pr . name , apiversion : pr . apiversion , } , } p . spec . resources = append ( p . spec . resources , rb ) return & p , nil } 
func diskmonitor ( interval time . duration , diskroot string ) { logger : = logrus . withfield ( " " , " " ) ticker : = time . newticker ( interval ) for ; true ; < - ticker . c { logger . info ( " " ) , bytesfree , bytesused , err : = diskutil . getdiskusage ( diskroot ) if err ! = nil { logger . witherror ( err ) . error ( " " ) } else { diskfree . set ( float64 ( bytesfree ) / 1e9 ) diskused . set ( float64 ( bytesused ) / 1e9 ) disktotal . set ( float64 ( bytesfree + bytesused ) / 1e9 ) } } } 
func ( m * multiplexerpluginwrapper ) receiveissue ( issue sql . issue ) [ ] point { points : = [ ] point { } for , plugin : = range m . plugins { points = append ( points , plugin . receiveissue ( issue ) ... ) } return points } 
func ( m * multiplexerpluginwrapper ) receiveissueevent ( event sql . issueevent ) [ ] point { points : = [ ] point { } for , plugin : = range m . plugins { points = append ( points , plugin . receiveissueevent ( event ) ... ) } return points } 
func ( m * multiplexerpluginwrapper ) receivecomment ( comment sql . comment ) [ ] point { points : = [ ] point { } for , plugin : = range m . plugins { points = append ( points , plugin . receivecomment ( comment ) ... ) } return points } 
func matchingconfigs ( org , repo , branch , label string , allconfigs [ ] plugins . requirematchinglabel ) [ ] plugins . requirematchinglabel { var filtered [ ] plugins . requirematchinglabel for , cfg : = range allconfigs { if ( branch == " " && ! cfg . issues ) | | ( branch ! = " " && ! cfg . prs ) { continue } if org ! = cfg . org | | ( cfg . repo ! = " " && cfg . repo ! = repo ) | | ( cfg . branch ! = " " && branch ! = " " && cfg . branch ! = branch ) { continue } if label ! = " " && ! cfg . re . matchstring ( label ) { continue } filtered = append ( filtered , cfg ) } return filtered } 
func suggestcodechange ( p lint . problem ) string { var suggestion = " " for regex , handler : = range linthandlersmap { matches : = regex . findstringsubmatch ( p . text ) suggestion = handler ( p , matches ) if suggestion ! = " " && suggestion ! = p . linetext { return formatsuggestion ( suggestion ) } } return " " } 
func serveexternalpluginhelp ( mux * http . servemux , log * logrus . entry , provider externalpluginhelpprovider ) { mux . handlefunc ( " " , func ( w http . responsewriter , r * http . request ) { w . header ( ) . set ( " " , " " ) servererror : = func ( action string , err error ) { log . witherror ( err ) . errorf ( " " , action ) msg : = fmt . sprintf ( " " , action , err ) http . error ( w , msg , http . statusinternalservererror ) } if r . method ! = http . methodpost { log . errorf ( " " , r . method ) http . error ( w , " " , http . statusmethodnotallowed ) return } b , err : = ioutil . readall ( r . body ) if err ! = nil { servererror ( " " , err ) return } var enabledrepos [ ] string if err : = json . unmarshal ( b , & enabledrepos ) ; err ! = nil { servererror ( " " , err ) return } if provider == nil { servererror ( " " , errors . new ( " " ) ) return } help , err : = provider ( enabledrepos ) if err ! = nil { servererror ( " " , err ) return } b , err = json . marshal ( help ) if err ! = nil { servererror ( " " , err ) return } fmt . fprint ( w , string ( b ) ) } , ) } 
func ( p * protector ) protect ( ) { bp : = p . cfg . branchprotection for orgname : = range bp . orgs { org : = bp . getorg ( orgname ) if err : = p . updateorg ( orgname , * org ) ; err ! = nil { p . errors . add ( fmt . errorf ( " " , orgname , err ) ) } } if ! bp . protecttested { return } for repo : = range p . cfg . presubmits { if p . completedrepos [ repo ] == true { continue } parts : = strings . split ( repo , " " ) if len ( parts ) ! = 2 { p . errors . add ( fmt . errorf ( " " , repo ) ) continue } orgname : = parts [ 0 ] reponame : = parts [ 1 ] repo : = bp . getorg ( orgname ) . getrepo ( reponame ) if err : = p . updaterepo ( orgname , reponame , * repo ) ; err ! = nil { p . errors . add ( fmt . errorf ( " " , orgname , reponame , err ) ) } } } 
func ( p * protector ) updateorg ( orgname string , org config . org ) error { var repos [ ] string if org . protect ! = nil { rs , err : = p . client . getrepos ( orgname , false ) if err ! = nil { return fmt . errorf ( " " , err ) } for , r : = range rs { if ! r . archived { repos = append ( repos , r . name ) } } } else { for r : = range org . repos { repos = append ( repos , r ) } } for , reponame : = range repos { repo : = org . getrepo ( reponame ) if err : = p . updaterepo ( orgname , reponame , * repo ) ; err ! = nil { return fmt . errorf ( " " , reponame , err ) } } return nil } 
func ( p * protector ) updaterepo ( orgname string , reponame string , repo config . repo ) error { p . completedrepos [ orgname + " " + reponame ] = true githubrepo , err : = p . client . getrepo ( orgname , reponame ) if err ! = nil { return fmt . errorf ( " " , err ) } if githubrepo . archived { return nil } branches : = map [ string ] github . branch { } for , onlyprotected : = range [ ] bool { false , true } { bs , err : = p . client . getbranches ( orgname , reponame , onlyprotected ) if err ! = nil { return fmt . errorf ( " " , err ) } for , b : = range bs { branches [ b . name ] = b } } for bn , githubbranch : = range branches { if branch , err : = repo . getbranch ( bn ) ; err ! = nil { return fmt . errorf ( " " , bn , err ) } else if err = p . updatebranch ( orgname , reponame , bn , * branch , githubbranch . protected ) ; err ! = nil { return fmt . errorf ( " " , bn , githubbranch . protected , err ) } } return nil } 
func ( p * protector ) updatebranch ( orgname , repo string , branchname string , branch config . branch , protected bool ) error { bp , err : = p . cfg . getpolicy ( orgname , repo , branchname , branch ) if err ! = nil { return fmt . errorf ( " " , err ) } if bp == nil | | bp . protect == nil { return nil } if ! protected && ! * bp . protect { logrus . infof ( " " , orgname , repo , branchname ) return nil } var req * github . branchprotectionrequest if * bp . protect { r : = makerequest ( * bp ) req = & r } p . updates < - requirements { org : orgname , repo : repo , branch : branchname , request : req , } return nil } 
func ( o * options ) validate ( ) error { if o . numworkers == 0 { return errors . new ( " " ) } if o . prowjobnamespace == " " { return errors . new ( " " ) } return o . options . validate ( ) } 
func ( o * options ) loadconfig ( config string ) error { return json . unmarshal ( [ ] byte ( config ) , o ) } 
func ( o * options ) addflags ( flags * flag . flagset ) { flags . intvar ( & o . numworkers , " " , 25 , " " ) flags . stringvar ( & o . prowjobnamespace , " " , " " , " " ) o . options . addflags ( flags ) } 
func loadclusterconfig ( ) ( * rest . config , error ) { clusterconfig , err : = rest . inclusterconfig ( ) if err == nil { return clusterconfig , nil } credentials , err : = clientcmd . newdefaultclientconfigloadingrules ( ) . load ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } clusterconfig , err = clientcmd . newdefaultclientconfig ( * credentials , & clientcmd . configoverrides { } ) . clientconfig ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return clusterconfig , nil } 
func ( o * options ) run ( ) error { clusterconfig , err : = loadclusterconfig ( ) if err ! = nil { return fmt . errorf ( " " , err ) } client , err : = kubernetes . newforconfig ( clusterconfig ) if err ! = nil { return err } prowjobclient , err : = kube . newclientincluster ( o . prowjobnamespace ) if err ! = nil { return err } controller : = artifact uploader . newcontroller ( client . corev1 ( ) , prowjobclient , o . options ) stop : = make ( chan struct { } ) defer close ( stop ) go controller . run ( o . numworkers , stop ) select { } } 
func ( a * agent ) start ( paths [ ] string ) error { secretsmap , err : = loadsecrets ( paths ) if err ! = nil { return err } a . secretsmap = secretsmap for secretpath : = range secretsmap { go a . reloadsecret ( secretpath ) } return nil } 
func ( a * agent ) reloadsecret ( secretpath string ) { var lastmodtime time . time logger : = logrus . newentry ( logrus . standardlogger ( ) ) skips : = 0 for range time . tick ( 1 * time . second ) { if skips < 600 { secretstat , err : = os . stat ( secretpath ) if err ! = nil { logger . withfield ( " " , secretpath ) . witherror ( err ) . error ( " " ) continue } recentmodtime : = secretstat . modtime ( ) if ! recentmodtime . after ( lastmodtime ) { skips ++ continue } lastmodtime = recentmodtime } if secretvalue , err : = loadsinglesecret ( secretpath ) ; err ! = nil { logger . withfield ( " " , secretpath ) . witherror ( err ) . error ( " " ) } else { a . setsecret ( secretpath , secretvalue ) skips = 0 } } } 
func ( a * agent ) getsecret ( secretpath string ) [ ] byte { a . rlock ( ) defer a . runlock ( ) return a . secretsmap [ secretpath ] } 
func ( a * agent ) setsecret ( secretpath string , secretvalue [ ] byte ) { a . lock ( ) defer a . unlock ( ) a . secretsmap [ secretpath ] = secretvalue } 
func ( a * agent ) gettokengenerator ( secretpath string ) func ( ) [ ] byte { return func ( ) [ ] byte { return a . getsecret ( secretpath ) } } 
func new ( maxrecordsperkey int , opener io . opener , path string ) ( * history , error ) { hist : = & history { logs : map [ string ] * recordlog { } , logsizelimit : maxrecordsperkey , opener : opener , path : path , } if path ! = " " { var err error start : = time . now ( ) hist . logs , err = readhistory ( maxrecordsperkey , hist . opener , hist . path ) if err ! = nil { return nil , err } logrus . withfields ( logrus . fields { " " : time . since ( start ) . string ( ) , " " : hist . path , } ) . debugf ( " " , len ( hist . logs ) ) } return hist , nil } 
func ( h * history ) record ( poolkey , action , basesha , err string , targets [ ] prowapi . pull ) { t : = now ( ) sort . sort ( bynum ( targets ) ) h . addrecord ( poolkey , & record { time : t , action : action , basesha : basesha , target : targets , err : err , } , ) } 
func ( h * history ) flush ( ) { if h . path == " " { return } records : = h . allrecords ( ) start : = time . now ( ) err : = writehistory ( h . opener , h . path , records ) log : = logrus . withfields ( logrus . fields { " " : time . since ( start ) . string ( ) , " " : h . path , } ) if err ! = nil { log . witherror ( err ) . error ( " " ) } else { log . debugf ( " " , len ( h . logs ) ) } } 
func ( h * history ) allrecords ( ) map [ string ] [ ] * record { h . lock ( ) defer h . unlock ( ) res : = make ( map [ string ] [ ] * record , len ( h . logs ) ) for key , log : = range h . logs { res [ key ] = log . toslice ( ) } return res } 
func makecommand ( ) * cobra . command { flags : = & flags { } cmd : = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . flags ( ) . stringvarp ( & flags . outputfile , " " , " " , " " , " " ) cmd . flags ( ) . stringvarp ( & flags . artifactsdirname , " " , " " , " " , " " ) cmd . flags ( ) . stringvarp ( & flags . profilename , " " , " " , " " , " " ) return cmd } 
func ( c * commentcounterplugin ) addflags ( cmd * cobra . command ) { cmd . flags ( ) . stringslicevar ( & c . pattern , " " , [ ] string { } , " " ) } 
func ( c * commentcounterplugin ) checkflags ( ) error { for , pattern : = range c . pattern { matcher , err : = regexp . compile ( pattern ) if err ! = nil { return err } c . matcher = append ( c . matcher , matcher ) } return nil } 
func ( c * commentcounterplugin ) receivecomment ( comment sql . comment ) [ ] point { points : = [ ] point { } for , matcher : = range c . matcher { if matcher . matchstring ( comment . body ) { points = append ( points , point { values : map [ string ] interface { } { " " : 1 , } , date : comment . commentcreatedat , } ) } } return points } 
func newcontroller ( pjclientset clientset . interface , queue workqueue . ratelimitinginterface , informer pjinformers . prowjobinformer , reporter reportclient , numworkers int , wg * sync . waitgroup ) * controller { return & controller { pjclientset : pjclientset , queue : queue , informer : informer , reporter : reporter , numworkers : numworkers , wg : wg , } } 
func ( c * controller ) run ( stopch < - chan struct { } ) { defer utilruntime . handlecrash ( ) defer c . queue . shutdown ( ) logrus . info ( " " ) c . informer . informer ( ) . addeventhandler ( cache . resourceeventhandlerfuncs { addfunc : func ( obj interface { } ) { key , err : = cache . metanamespacekeyfunc ( obj ) logrus . withfield ( " " , key ) . infof ( " " ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) return } c . queue . addratelimited ( key ) } , updatefunc : func ( oldobj , newobj interface { } ) { key , err : = cache . metanamespacekeyfunc ( newobj ) logrus . withfield ( " " , key ) . infof ( " " ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) return } c . queue . addratelimited ( key ) } , } ) go c . informer . informer ( ) . run ( stopch ) if ! cache . waitforcachesync ( stopch , c . hassynced ) { utilruntime . handleerror ( fmt . errorf ( " " ) ) return } logrus . info ( " " ) for i : = 0 ; i < c . numworkers ; i ++ { go wait . until ( c . runworker , time . second , stopch ) } logrus . infof ( " " , c . numworkers ) < - stopch logrus . info ( " " ) } 
func ( c * controller ) runworker ( ) { c . wg . add ( 1 ) for c . processnextitem ( ) { } c . wg . done ( ) } 
func newaggregate ( errlist ... error ) aggregate { if len ( errlist ) == 0 { return nil } var errs [ ] error for , e : = range errlist { if e ! = nil { errs = append ( errs , e ) } } if len ( errs ) == 0 { return nil } return aggregate ( errs ) } 
func ( agg aggregate ) error ( ) string { if len ( agg ) == 0 { return " " } return fmt . sprintf ( " " , strings . join ( agg . strings ( ) , " " ) ) } 
func ( agg aggregate ) strings ( ) [ ] string { strs : = make ( [ ] string , 0 , len ( agg ) ) for , e : = range agg { if subagg , ok : = e . ( aggregate ) ; ok { strs = append ( strs , subagg . strings ( ) ... ) } else { strs = append ( strs , e . error ( ) ) } } return strs } 
func new ( ) ( * localgit , * git . client , error ) { g , err : = exec . lookpath ( " " ) if err ! = nil { return nil , nil , err } t , err : = ioutil . tempdir ( " " , " " ) if err ! = nil { return nil , nil , err } c , err : = git . newclient ( ) if err ! = nil { os . removeall ( t ) return nil , nil , err } getsecret : = func ( ) [ ] byte { return [ ] byte ( " " ) } c . setcredentials ( " " , getsecret ) c . setremote ( t ) return & localgit { dir : t , git : g , } , c , nil } 
func ( lg * localgit ) makefakerepo ( org , repo string ) error { rdir : = filepath . join ( lg . dir , org , repo ) if err : = os . mkdirall ( rdir , os . modeperm ) ; err ! = nil { return err } if err : = runcmd ( lg . git , rdir , " " ) ; err ! = nil { return err } if err : = runcmd ( lg . git , rdir , " " , " " , " " ) ; err ! = nil { return err } if err : = runcmd ( lg . git , rdir , " " , " " , " " ) ; err ! = nil { return err } if err : = runcmd ( lg . git , rdir , " " , " " , " " ) ; err ! = nil { return err } if err : = lg . addcommit ( org , repo , map [ string ] [ ] byte { " " : { } } ) ; err ! = nil { return err } return nil } 
func ( lg * localgit ) addcommit ( org , repo string , files map [ string ] [ ] byte ) error { rdir : = filepath . join ( lg . dir , org , repo ) for f , b : = range files { path : = filepath . join ( rdir , f ) if err : = os . mkdirall ( filepath . dir ( path ) , os . modeperm ) ; err ! = nil { return err } if err : = ioutil . writefile ( path , b , os . modeperm ) ; err ! = nil { return err } if err : = runcmd ( lg . git , rdir , " " , f ) ; err ! = nil { return err } } return runcmd ( lg . git , rdir , " " , " " , " " ) } 
func ( lg * localgit ) checkoutnewbranch ( org , repo , branch string ) error { rdir : = filepath . join ( lg . dir , org , repo ) return runcmd ( lg . git , rdir , " " , " " , branch ) } 
func ( lg * localgit ) checkout ( org , repo , commitlike string ) error { rdir : = filepath . join ( lg . dir , org , repo ) return runcmd ( lg . git , rdir , " " , commitlike ) } 
func ( lg * localgit ) revparse ( org , repo , commitlike string ) ( string , error ) { rdir : = filepath . join ( lg . dir , org , repo ) return runcmdoutput ( lg . git , rdir , " " , commitlike ) } 
func cleanall ( sess * session . session , region string ) error { acct , err : = account . getaccount ( sess , regions . default ) if err ! = nil { return errors . wrap ( err , " " ) } klog . v ( 1 ) . infof ( " " , acct ) var regionlist [ ] string if region == " " { regionlist , err = regions . getall ( sess ) if err ! = nil { return errors . wrap ( err , " " ) } } else { regionlist = [ ] string { region } } klog . infof ( " " , regionlist ) for , r : = range regionlist { for , typ : = range regionaltypelist { set , err : = typ . listall ( sess , acct , r ) if err ! = nil { return errors . wrapf ( err , " " , typ ) } if err : = typ . markandsweep ( sess , acct , r , set ) ; err ! = nil { return errors . wrapf ( err , " " , typ ) } } } for , typ : = range globaltypelist { set , err : = typ . listall ( sess , acct , regions . default ) if err ! = nil { return errors . wrapf ( err , " " , typ ) } if err : = typ . markandsweep ( sess , acct , regions . default , set ) ; err ! = nil { return errors . wrapf ( err , " " , typ ) } } return nil } 
func optionsforrepo ( config * plugins . configuration , org , repo string ) * plugins . lgtm { fullname : = fmt . sprintf ( " " , org , repo ) for i : = range config . lgtm { if ! strinslice ( org , config . lgtm [ i ] . repos ) && ! strinslice ( fullname , config . lgtm [ i ] . repos ) { continue } return & config . lgtm [ i ] } return & plugins . lgtm { } } 
func getchangedfiles ( gc githubclient , org , repo string , number int ) ( [ ] string , error ) { changes , err : = gc . getpullrequestchanges ( org , repo , number ) if err ! = nil { return nil , fmt . errorf ( " " , org , repo , number ) } var filenames [ ] string for , change : = range changes { filenames = append ( filenames , change . filename ) } return filenames , nil } 
func loadreviewers ( ro repoowners . repoowner , filenames [ ] string ) sets . string { reviewers : = sets . string { } for , filename : = range filenames { reviewers = reviewers . union ( ro . approvers ( filename ) ) . union ( ro . reviewers ( filename ) ) } return reviewers } 
func newcontroller ( lastsyncfallback , cookiefilepath string , projects map [ string ] [ ] string , kc * kube . client , cfg config . getter ) ( * controller , error ) { if lastsyncfallback == " " { return nil , errors . new ( " " ) } var lastupdate time . time if buf , err : = ioutil . readfile ( lastsyncfallback ) ; err == nil { unix , err : = strconv . parseint ( string ( buf ) , 10 , 64 ) if err ! = nil { return nil , err } lastupdate = time . unix ( unix , 0 ) } else if err ! = nil && ! os . isnotexist ( err ) { return nil , fmt . errorf ( " " , err ) } else { logrus . warnf ( " " , lastsyncfallback ) lastupdate = time . now ( ) } c , err : = client . newclient ( projects ) if err ! = nil { return nil , err } c . start ( cookiefilepath ) return & controller { kc : kc , config : cfg , gc : c , lastupdate : lastupdate , lastsyncfallback : lastsyncfallback , } , nil } 
func ( c * controller ) savelastsync ( lastsync time . time ) error { if c . lastsyncfallback == " " { return nil } lastsyncunix : = strconv . formatint ( lastsync . unix ( ) , 10 ) logrus . infof ( " " , lastsyncunix ) tempfile , err : = ioutil . tempfile ( filepath . dir ( c . lastsyncfallback ) , " " ) if err ! = nil { return err } defer os . remove ( tempfile . name ( ) ) err = ioutil . writefile ( tempfile . name ( ) , [ ] byte ( lastsyncunix ) , 0644 ) if err ! = nil { return err } err = os . rename ( tempfile . name ( ) , c . lastsyncfallback ) if err ! = nil { logrus . witherror ( err ) . info ( " " ) return copyfile ( tempfile . name ( ) , c . lastsyncfallback ) } return nil } 
func ( c * controller ) sync ( ) error { synctime : = c . lastupdate for instance , changes : = range c . gc . querychanges ( c . lastupdate , c . config ( ) . gerrit . ratelimit ) { for , change : = range changes { if err : = c . processchange ( instance , change ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , change . currentrevision ) } if synctime . before ( change . updated . time ) { synctime = change . updated . time } } logrus . infof ( " " , len ( changes ) , instance ) } c . lastupdate = synctime if err : = c . savelastsync ( synctime ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , synctime , c . lastsyncfallback ) } return nil } 
func listchangedfiles ( changeinfo client . changeinfo ) config . changedfilesprovider { return func ( ) ( [ ] string , error ) { var changed [ ] string revision : = changeinfo . revisions [ changeinfo . currentrevision ] for file : = range revision . files { changed = append ( changed , file ) } return changed , nil } } 
func ( e * eventcounterplugin ) addflags ( cmd * cobra . command ) { cmd . flags ( ) . stringvar ( & e . desc , " " , " " , " " ) } 
func ( e * eventcounterplugin ) checkflags ( ) error { e . matcher = neweventmatcher ( e . desc ) return nil } 
func ( e * eventcounterplugin ) receiveissueevent ( event sql . issueevent ) [ ] point { var label string if event . label ! = nil { label = * event . label } if ! e . matcher . match ( event . event , label ) { return nil } return [ ] point { { values : map [ string ] interface { } { " " : 1 } , date : event . eventcreatedat , } , } } 
func upload ( bucket * storage . buckethandle , uploadtargets map [ string ] uploadfunc ) error { errch : = make ( chan error , len ( uploadtargets ) ) group : = & sync . waitgroup { } group . add ( len ( uploadtargets ) ) for dest , upload : = range uploadtargets { obj : = bucket . object ( dest ) logrus . withfield ( " " , dest ) . info ( " " ) go func ( f uploadfunc , obj * storage . objecthandle , name string ) { defer group . done ( ) if err : = f ( obj ) ; err ! = nil { errch < - err } logrus . withfield ( " " , name ) . info ( " " ) } ( upload , obj , dest ) } group . wait ( ) close ( errch ) if len ( errch ) ! = 0 { var uploaderrors [ ] error for err : = range errch { uploaderrors = append ( uploaderrors , err ) } return fmt . errorf ( " " , uploaderrors ) } return nil } 
func fileuploadwithmetadata ( file string , metadata map [ string ] string ) uploadfunc { return func ( obj * storage . objecthandle ) error { reader , err : = os . open ( file ) if err ! = nil { return err } uploaderr : = datauploadwithmetadata ( reader , metadata ) ( obj ) closeerr : = reader . close ( ) return errorutil . newaggregate ( uploaderr , closeerr ) } } 
func datauploadwithmetadata ( src io . reader , metadata map [ string ] string ) uploadfunc { return func ( obj * storage . objecthandle ) error { writer : = obj . newwriter ( context . background ( ) ) writer . metadata = metadata , copyerr : = io . copy ( writer , src ) closeerr : = writer . close ( ) return errorutil . newaggregate ( copyerr , closeerr ) } } 
func haslabel ( label string , issuelabels [ ] label ) bool { for , l : = range issuelabels { if strings . tolower ( l . name ) == strings . tolower ( label ) { return true } } return false } 
func imagetoobig ( url string ) ( bool , error ) { limit : = 10000000 resp , err : = http . head ( url ) if err ! = nil { return true , fmt . errorf ( " " , err ) } if sc : = resp . statuscode ; sc ! = http . statusok { return true , fmt . errorf ( " " , sc ) } size , : = strconv . atoi ( resp . header . get ( " " ) ) if size > limit { return true , nil } return false , nil } 
func levelfrompermissions ( permissions repopermissions ) repopermissionlevel { if permissions . admin { return admin } else if permissions . push { return write } else if permissions . pull { return read } else { return none } } 
func permissionsfromlevel ( permission repopermissionlevel ) repopermissions { switch permission { case none : return repopermissions { } case read : return repopermissions { pull : true } case write : return repopermissions { pull : true , push : true } case admin : return repopermissions { pull : true , push : true , admin : true } default : return repopermissions { } } } 
func newprowjobs ( c * prowv1client , namespace string ) * prowjobs { return & prowjobs { client : c . restclient ( ) , ns : namespace , } } 
func ( c * prowjobs ) list ( opts metav1 . listoptions ) ( result * v1 . prowjoblist , err error ) { result = & v1 . prowjoblist { } err = c . client . get ( ) . namespace ( c . ns ) . resource ( " " ) . versionedparams ( & opts , scheme . parametercodec ) . do ( ) . into ( result ) return } 
func ( c * prowjobs ) create ( prowjob * v1 . prowjob ) ( result * v1 . prowjob , err error ) { result = & v1 . prowjob { } err = c . client . post ( ) . namespace ( c . ns ) . resource ( " " ) . body ( prowjob ) . do ( ) . into ( result ) return } 
func ( c * prowjobs ) update ( prowjob * v1 . prowjob ) ( result * v1 . prowjob , err error ) { result = & v1 . prowjob { } err = c . client . put ( ) . namespace ( c . ns ) . resource ( " " ) . name ( prowjob . name ) . body ( prowjob ) . do ( ) . into ( result ) return } 
func ( b blockers ) getapplicable ( org , repo , branch string ) [ ] blocker { var res [ ] blocker res = append ( res , b . repo [ orgrepo { org : org , repo : repo } ] ... ) res = append ( res , b . branch [ orgrepobranch { org : org , repo : repo , branch : branch } ] ... ) sort . slice ( res , func ( i , j int ) bool { return res [ i ] . number < res [ j ] . number } ) return res } 
func findall ( ghc githubclient , log * logrus . entry , label , orgrepotokens string ) ( blockers , error ) { issues , err : = search ( context . background ( ) , ghc , log , blockerquery ( label , orgrepotokens ) , ) if err ! = nil { return blockers { } , fmt . errorf ( " " , err ) } return fromissues ( issues ) , nil } 
func newcountplugin ( runner func ( plugin ) error ) * cobra . command { statecounter : = & stateplugin { } eventcounter : = & eventcounterplugin { } commentsasevents : = newfakecommentpluginwrapper ( eventcounter ) commentcounter : = & commentcounterplugin { } authorloggable : = newmultiplexerpluginwrapper ( commentsasevents , commentcounter , ) authorlogged : = newauthorloggerpluginwrapper ( authorloggable ) fullmultiplex : = newmultiplexerpluginwrapper ( authorlogged , statecounter ) fakeopen : = newfakeopenpluginwrapper ( fullmultiplex ) typefilter : = newtypefilterwrapperplugin ( fakeopen ) authorfilter : = newauthorfilterpluginwrapper ( typefilter ) cmd : = & cobra . command { use : " " , short : " " , rune : func ( cmd * cobra . command , args [ ] string ) error { if err : = eventcounter . checkflags ( ) ; err ! = nil { return err } if err : = statecounter . checkflags ( ) ; err ! = nil { return err } if err : = typefilter . checkflags ( ) ; err ! = nil { return err } if err : = commentcounter . checkflags ( ) ; err ! = nil { return err } return runner ( authorfilter ) } , } eventcounter . addflags ( cmd ) statecounter . addflags ( cmd ) commentcounter . addflags ( cmd ) typefilter . addflags ( cmd ) authorfilter . addflags ( cmd ) authorlogged . addflags ( cmd ) return cmd } 
func ( o * fakecommentpluginwrapper ) receiveissue ( issue sql . issue ) [ ] point { return o . plugin . receiveissue ( issue ) } 
func ( o * fakecommentpluginwrapper ) receiveissueevent ( event sql . issueevent ) [ ] point { return o . plugin . receiveissueevent ( event ) } 
func ( o * fakecommentpluginwrapper ) receivecomment ( comment sql . comment ) [ ] point { fakeevent : = sql . issueevent { issueid : comment . issueid , event : " " , eventcreatedat : comment . commentcreatedat , actor : & comment . user , } return append ( o . plugin . receivecomment ( comment ) , o . plugin . receiveissueevent ( fakeevent ) ... , ) } 
func updatemetrics ( interval time . duration , diskroot string ) { logger : = logrus . withfield ( " " , " " ) ticker : = time . newticker ( interval ) for ; true ; < - ticker . c { logger . info ( " " ) , bytesfree , bytesused , err : = diskutil . getdiskusage ( diskroot ) if err ! = nil { logger . witherror ( err ) . error ( " " ) } else { prommetrics . diskfree . set ( float64 ( bytesfree ) / 1e9 ) prommetrics . diskused . set ( float64 ( bytesused ) / 1e9 ) prommetrics . disktotal . set ( float64 ( bytesfree + bytesused ) / 1e9 ) } } } 
func newranch ( config string , s * storage ) ( * ranch , error ) { newranch : = & ranch { storage : s , updatetime : updatetime , } if config ! = " " { if err : = newranch . syncconfig ( config ) ; err ! = nil { return nil , err } } newranch . logstatus ( ) return newranch , nil } 
func ( r * ranch ) acquire ( rtype , state , dest , owner string ) ( * common . resource , error ) { r . resourceslock . lock ( ) defer r . resourceslock . unlock ( ) resources , err : = r . storage . getresources ( ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " ) return nil , & resourcenotfound { rtype } } foundtype : = false for idx : = range resources { res : = resources [ idx ] if rtype == res . type { foundtype = true if state == res . state && res . owner == " " { res . lastupdate = r . updatetime ( ) res . owner = owner res . state = dest if err : = r . storage . updateresource ( res ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , res . name ) return nil , err } return & res , nil } } } if foundtype { return nil , & resourcenotfound { rtype } } return nil , & resourcetypenotfound { rtype } } 
func ( r * ranch ) release ( name , dest , owner string ) error { r . resourceslock . lock ( ) defer r . resourceslock . unlock ( ) res , err : = r . storage . getresource ( name ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " , name ) return & resourcenotfound { name } } if owner ! = res . owner { return & ownernotmatch { owner : owner , request : res . owner } } res . lastupdate = r . updatetime ( ) res . owner = " " res . state = dest if err : = r . storage . updateresource ( res ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , res . name ) return err } return nil } 
func ( r * ranch ) update ( name , owner , state string , ud * common . userdata ) error { r . resourceslock . lock ( ) defer r . resourceslock . unlock ( ) res , err : = r . storage . getresource ( name ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " , name ) return & resourcenotfound { name } } if owner ! = res . owner { return & ownernotmatch { owner : owner , request : res . owner } } if state ! = res . state { return & statenotmatch { res . state , state } } if res . userdata == nil { res . userdata = & common . userdata { } } res . userdata . update ( ud ) res . lastupdate = r . updatetime ( ) if err : = r . storage . updateresource ( res ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , res . name ) return err } return nil } 
func ( r * ranch ) reset ( rtype , state string , expire time . duration , dest string ) ( map [ string ] string , error ) { r . resourceslock . lock ( ) defer r . resourceslock . unlock ( ) ret : = make ( map [ string ] string ) resources , err : = r . storage . getresources ( ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " ) return nil , err } for idx : = range resources { res : = resources [ idx ] if rtype == res . type && state == res . state && res . owner ! = " " { if time . since ( res . lastupdate ) > expire { res . lastupdate = r . updatetime ( ) ret [ res . name ] = res . owner res . owner = " " res . state = dest if err : = r . storage . updateresource ( res ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , res . name ) return ret , err } } } } return ret , nil } 
func ( r * ranch ) logstatus ( ) { resources , err : = r . storage . getresources ( ) if err ! = nil { return } resjson , err : = json . marshal ( resources ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " , resources ) } logrus . infof ( " " , string ( resjson ) ) } 
func ( r * ranch ) syncconfig ( config string ) error { resources , err : = parseconfig ( config ) if err ! = nil { return err } if err : = r . storage . syncresources ( resources ) ; err ! = nil { return err } return nil } 
func ( r * ranch ) metric ( rtype string ) ( common . metric , error ) { metric : = common . metric { type : rtype , current : map [ string ] int { } , owners : map [ string ] int { } , } resources , err : = r . storage . getresources ( ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) return metric , & resourcenotfound { rtype } } for , res : = range resources { if res . type ! = rtype { continue } if , ok : = metric . current [ res . state ] ; ! ok { metric . current [ res . state ] = 0 } if , ok : = metric . owners [ res . owner ] ; ! ok { metric . owners [ res . owner ] = 0 } metric . current [ res . state ] ++ metric . owners [ res . owner ] ++ } if len ( metric . current ) == 0 && len ( metric . owners ) == 0 { return metric , & resourcenotfound { rtype } } return metric , nil } 
func formaturl ( dogurl string ) ( string , error ) { if dogurl == " " { return " " , errors . new ( " " ) } src , err : = url . parserequesturi ( dogurl ) if err ! = nil { return " " , fmt . errorf ( " " , dogurl , err ) } return fmt . sprintf ( " " , src , src ) , nil } 
func trusteduser ( ghc trusteduserclient , trigger plugins . trigger , user , org , repo string ) ( bool , error ) { if ! trigger . onlyorgmembers { if ok , err : = ghc . iscollaborator ( org , repo , user ) ; err ! = nil { return false , fmt . errorf ( " " , err ) } else if ok { return true , nil } } if member , err : = ghc . ismember ( org , user ) ; err ! = nil { return false , fmt . errorf ( " " , org , err ) } else if member { return true , nil } if trigger . trustedorg == " " | | trigger . trustedorg == org { return false , nil } member , err : = ghc . ismember ( trigger . trustedorg , user ) if err ! = nil { return false , fmt . errorf ( " " , trigger . trustedorg , err ) } return member , nil } 
func runandskipjobs ( c client , pr * github . pullrequest , requestedjobs [ ] config . presubmit , skippedjobs [ ] config . presubmit , eventguid string , elideskippedcontexts bool ) error { if err : = validatecontextoverlap ( requestedjobs , skippedjobs ) ; err ! = nil { c . logger . witherror ( err ) . warn ( " " ) return err } runerr : = runrequested ( c , pr , requestedjobs , eventguid ) var skiperr error if ! elideskippedcontexts { skiperr = skiprequested ( c , pr , skippedjobs ) } return errorutil . newaggregate ( runerr , skiperr ) } 
func validatecontextoverlap ( torun , toskip [ ] config . presubmit ) error { requestedcontexts : = sets . newstring ( ) for , job : = range torun { requestedcontexts . insert ( job . context ) } skippedcontexts : = sets . newstring ( ) for , job : = range toskip { skippedcontexts . insert ( job . context ) } if overlap : = requestedcontexts . intersection ( skippedcontexts ) . list ( ) ; len ( overlap ) > 0 { return fmt . errorf ( " " , strings . join ( overlap , " " ) ) } return nil } 
func runrequested ( c client , pr * github . pullrequest , requestedjobs [ ] config . presubmit , eventguid string ) error { basesha , err : = c . githubclient . getref ( pr . base . repo . owner . login , pr . base . repo . name , " " + pr . base . ref ) if err ! = nil { return err } var errors [ ] error for , job : = range requestedjobs { c . logger . infof ( " " , job . name ) pj : = pjutil . newpresubmit ( * pr , basesha , job , eventguid ) c . logger . withfields ( pjutil . prowjobfields ( & pj ) ) . info ( " " ) if , err : = c . prowjobclient . create ( & pj ) ; err ! = nil { c . logger . witherror ( err ) . error ( " " ) errors = append ( errors , err ) } } return errorutil . newaggregate ( errors ... ) } 
func skiprequested ( c client , pr * github . pullrequest , skippedjobs [ ] config . presubmit ) error { var errors [ ] error for , job : = range skippedjobs { if job . skipreport { continue } c . logger . infof ( " " , job . name ) if err : = c . githubclient . createstatus ( pr . base . repo . owner . login , pr . base . repo . name , pr . head . sha , skippedstatusfor ( job . context ) ) ; err ! = nil { errors = append ( errors , err ) } } return errorutil . newaggregate ( errors ... ) } 
func ( l labelevent ) match ( eventname , label string ) bool { return eventname == " " && label == l . label } 
func ( u unlabelevent ) match ( eventname , label string ) bool { return eventname == " " && label == u . label } 
func neweventmatcher ( eventdescription string ) eventmatcher { split : = strings . splitn ( eventdescription , " " , 2 ) switch split [ 0 ] { case " " : return falseevent { } case " " : return commentevent { } case " " : return openevent { } case " " : return reopenevent { } case " " : return mergeevent { } case " " : return closeevent { } case " " : if len ( split ) ! = 2 { panic ( fmt . errorf ( " " ) ) } return labelevent { split [ 1 ] } case " " : if len ( split ) ! = 2 { panic ( fmt . errorf ( " " ) ) } return unlabelevent { split [ 1 ] } default : panic ( fmt . errorf ( " " , split [ 0 ] ) ) } } 
func ( o * githuboptions ) addflags ( fs * flag . flagset ) { o . addflags ( true , fs ) } 
func ( o * githuboptions ) addflagswithoutdefaultgithubtokenpath ( fs * flag . flagset ) { o . addflags ( false , fs ) } 
func ( o * githuboptions ) validate ( dryrun bool ) error { for , uri : = range o . endpoint . strings ( ) { if uri == " " { uri = github . defaultapiendpoint } else if , err : = url . parserequesturi ( uri ) ; err ! = nil { return fmt . errorf ( " " , uri ) } } if o . graphqlendpoint == " " { o . graphqlendpoint = github . defaultgraphqlendpoint } else if , err : = url . parse ( o . graphqlendpoint ) ; err ! = nil { return fmt . errorf ( " " , o . graphqlendpoint ) } if o . deprecatedtokenfile ! = " " { o . tokenpath = o . deprecatedtokenfile logrus . error ( " " ) } if o . tokenpath == " " { logrus . warn ( " " ) } return nil } 
func ( o * githuboptions ) githubclientwithlogfields ( secretagent * secret . agent , dryrun bool , fields logrus . fields ) ( client * github . client , err error ) { var generator * func ( ) [ ] byte if o . tokenpath == " " { generatorfunc : = func ( ) [ ] byte { return [ ] byte { } } generator = & generatorfunc } else { if secretagent == nil { return nil , fmt . errorf ( " " , o . tokenpath ) } generatorfunc : = secretagent . gettokengenerator ( o . tokenpath ) generator = & generatorfunc } if dryrun { return github . newdryrunclientwithfields ( fields , * generator , o . graphqlendpoint , o . endpoint . strings ( ) ... ) , nil } return github . newclientwithfields ( fields , * generator , o . graphqlendpoint , o . endpoint . strings ( ) ... ) , nil } 
func ( o * githuboptions ) githubclient ( secretagent * secret . agent , dryrun bool ) ( client * github . client , err error ) { return o . githubclientwithlogfields ( secretagent , dryrun , logrus . fields { } ) } 
func ( o * githuboptions ) gitclient ( secretagent * secret . agent , dryrun bool ) ( client * git . client , err error ) { client , err = git . newclient ( ) if err ! = nil { return nil , err } defer func ( client * git . client ) { if err ! = nil { client . clean ( ) } } ( client ) githubclient , err : = o . githubclient ( secretagent , dryrun ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } botname , err : = githubclient . botname ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } client . setcredentials ( botname , secretagent . gettokengenerator ( o . tokenpath ) ) return client , nil } 
func tomap ( g * calculation . coveragelist ) map [ string ] calculation . coverage { m : = make ( map [ string ] calculation . coverage ) for , cov : = range g . group { m [ cov . name ] = cov } return m } 
func findchanges ( baselist * calculation . coveragelist , newlist * calculation . coveragelist ) [ ] * coveragechange { var changes [ ] * coveragechange basefilesmap : = tomap ( baselist ) for , newcov : = range newlist . group { basecov , ok : = basefilesmap [ newcov . name ] var baseratio float32 if ! ok { baseratio = - 1 } else { baseratio = basecov . ratio ( ) } newratio : = newcov . ratio ( ) if ischangesignificant ( baseratio , newratio ) { changes = append ( changes , & coveragechange { name : newcov . name , baseratio : baseratio , newratio : newratio , } ) } } return changes } 
func ( config * mysqlconfig ) createdatabase ( ) ( * gorm . db , error ) { db , err : = gorm . open ( " " , config . getdsn ( " " ) ) if err ! = nil { return nil , err } db . exec ( fmt . sprintf ( " " , config . db ) ) db . close ( ) db , err = gorm . open ( " " , config . getdsn ( config . db ) ) err = db . automigrate ( & assignee { } , & issue { } , & issueevent { } , & label { } , & comment { } ) . error if err ! = nil { return nil , err } return db , nil } 
func ( config * mysqlconfig ) addflags ( cmd * cobra . command ) { cmd . persistentflags ( ) . stringvar ( & config . user , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & config . password , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & config . host , " " , " " , " " ) cmd . persistentflags ( ) . intvar ( & config . port , " " , 3306 , " " ) cmd . persistentflags ( ) . stringvar ( & config . db , " " , " " , " " ) } 
func newreporter ( gc report . githubclient , cfg config . getter , reportagent v1 . prowjobagent ) * client { return & client { gc : gc , config : cfg , reportagent : reportagent , } } 
func ( c * client ) shouldreport ( pj * v1 . prowjob ) bool { if ! pj . spec . report { return false } if pj . spec . type ! = v1 . presubmitjob && pj . spec . type ! = v1 . postsubmitjob { return false } if c . reportagent ! = " " && pj . spec . agent ! = c . reportagent { return false } return true } 
func ( c * client ) report ( pj * v1 . prowjob ) ( [ ] * v1 . prowjob , error ) { return [ ] * v1 . prowjob { pj } , report . report ( c . gc , c . config ( ) . plank . reporttemplate , * pj , c . config ( ) . githubreporter . jobtypestoreport ) } 
func ( s * set ) mark ( r interface ) bool { key : = r . resourcekey ( ) now : = time . now ( ) s . marked [ key ] = true if t , ok : = s . firstseen [ key ] ; ok { since : = now . sub ( t ) if since > s . ttl { s . swept = append ( s . swept , key ) return true } klog . v ( 1 ) . infof ( " " , key , since ) return false } s . firstseen [ key ] = now klog . v ( 1 ) . infof ( " " , key ) if s . ttl == 0 { s . swept = append ( s . swept , key ) return true } return false } 
func ( s * set ) markcomplete ( ) int { var gone [ ] string for key : = range s . firstseen { if ! s . marked [ key ] { gone = append ( gone , key ) } } for , key : = range gone { klog . v ( 1 ) . infof ( " " , key ) delete ( s . firstseen , key ) } if len ( s . swept ) > 0 { klog . errorf ( " " , len ( s . swept ) , s . swept ) } return len ( s . swept ) } 
func newjobagent ( kc serviceclusterclient , plclients map [ string ] podlogclient , cfg config . getter ) * jobagent { return & jobagent { kc : kc , pkcs : plclients , config : cfg , } } 
func ( ja * jobagent ) start ( ) { ja . tryupdate ( ) go func ( ) { t : = time . tick ( period ) for range t { ja . tryupdate ( ) } } ( ) } 
func ( ja * jobagent ) jobs ( ) [ ] job { ja . mut . lock ( ) defer ja . mut . unlock ( ) res : = make ( [ ] job , len ( ja . jobs ) ) copy ( res , ja . jobs ) return res } 
func ( ja * jobagent ) prowjobs ( ) [ ] prowapi . prowjob { ja . mut . lock ( ) defer ja . mut . unlock ( ) res : = make ( [ ] prowapi . prowjob , len ( ja . prowjobs ) ) copy ( res , ja . prowjobs ) return res } 
func ( ja * jobagent ) getprowjob ( job , id string ) ( prowapi . prowjob , error ) { if ja == nil { return prowapi . prowjob { } , fmt . errorf ( " " ) } var j prowapi . prowjob ja . mut . lock ( ) idmap , ok : = ja . jobsidmap [ job ] if ok { j , ok = idmap [ id ] } ja . mut . unlock ( ) if ! ok { return prowapi . prowjob { } , errprowjobnotfound } return j , nil } 
func unionstrings ( parent , child [ ] string ) [ ] string { if child == nil { return parent } if parent == nil { return child } s : = sets . newstring ( parent ... ) s . insert ( child ... ) return s . list ( ) } 
func ( p policy ) apply ( child policy ) policy { return policy { protect : selectbool ( p . protect , child . protect ) , requiredstatuschecks : mergecontextpolicy ( p . requiredstatuschecks , child . requiredstatuschecks ) , admins : selectbool ( p . admins , child . admins ) , restrictions : mergerestrictions ( p . restrictions , child . restrictions ) , requiredpullrequestreviews : mergereviewpolicy ( p . requiredpullrequestreviews , child . requiredpullrequestreviews ) , } } 
func ( bp branchprotection ) getorg ( name string ) * org { o , ok : = bp . orgs [ name ] if ok { o . policy = bp . apply ( o . policy ) } else { o . policy = bp . policy } return & o } 
func ( o org ) getrepo ( name string ) * repo { r , ok : = o . repos [ name ] if ok { r . policy = o . apply ( r . policy ) } else { r . policy = o . policy } return & r } 
func ( r repo ) getbranch ( name string ) ( * branch , error ) { b , ok : = r . branches [ name ] if ok { b . policy = r . apply ( b . policy ) if b . protect == nil { return nil , errors . new ( " " ) } } else { b . policy = r . policy } return & b , nil } 
func ( c * config ) getbranchprotection ( org , repo , branch string ) ( * policy , error ) { if , present : = c . branchprotection . orgs [ org ] ; ! present { return nil , nil } b , err : = c . branchprotection . getorg ( org ) . getrepo ( repo ) . getbranch ( branch ) if err ! = nil { return nil , err } return c . getpolicy ( org , repo , branch , * b ) } 
func ( c * config ) getpolicy ( org , repo , branch string , b branch ) ( * policy , error ) { policy : = b . policy if prowcontexts , , : = branchrequirements ( org , repo , branch , c . presubmits ) ; len ( prowcontexts ) > 0 { if policy . protect ! = nil && ! * policy . protect { return nil , fmt . errorf ( " " ) } ps : = policy { requiredstatuschecks : & contextpolicy { contexts : prowcontexts , } , } if c . branchprotection . protecttested { yes : = true ps . protect = & yes } policy = policy . apply ( ps ) } if policy . protect ! = nil && ! * policy . protect { var old * bool old , policy . protect = policy . protect , old switch { case policy . defined ( ) && c . branchprotection . allowdisabledpolicies : logrus . warnf ( " " , org , repo , branch ) policy = policy { protect : policy . protect , } case policy . defined ( ) : return nil , fmt . errorf ( " " , org , repo , branch ) } policy . protect = old } if ! policy . defined ( ) { return nil , nil } return & policy , nil } 
func branchrequirements ( org , repo , branch string , presubmits map [ string ] [ ] presubmit ) ( [ ] string , [ ] string , [ ] string ) { jobs , ok : = presubmits [ org + " " + repo ] if ! ok { return nil , nil , nil } var required , requiredifpresent , optional [ ] string for , j : = range jobs { if ! j . couldrun ( branch ) { continue } if j . contextrequired ( ) { if j . triggersconditionally ( ) { requiredifpresent = append ( requiredifpresent , j . context ) } else { required = append ( required , j . context ) } } else { optional = append ( optional , j . context ) } } return required , requiredifpresent , optional } 
func updateissueevents ( issueid int , db * gorm . db , client clientinterface ) { latest , err : = findlatestevent ( issueid , db , client . repositoryname ( ) ) if err ! = nil { glog . error ( " " , err ) return } c : = make ( chan * github . issueevent , 500 ) go client . fetchissueevents ( issueid , latest , c ) for event : = range c { eventorm , err : = newissueevent ( event , issueid , client . repositoryname ( ) ) if err ! = nil { glog . error ( " " , err ) } db . create ( eventorm ) } } 
func ( c * controller ) enqueuekey ( ctx string , obj interface { } ) { switch o : = obj . ( type ) { case * prowjobv1 . prowjob : c . workqueue . addratelimited ( tokey ( ctx , o . spec . namespace , o . name ) ) case * buildv1alpha1 . build : c . workqueue . addratelimited ( tokey ( ctx , o . namespace , o . name ) ) default : logrus . warnf ( " " , o , obj ) return } } 
func prowjobstatus ( bs buildv1alpha1 . buildstatus ) ( prowjobv1 . prowjobstate , string ) { started : = bs . starttime finished : = bs . completiontime pcond : = bs . getcondition ( buildv1alpha1 . buildsucceeded ) if pcond == nil { if ! finished . iszero ( ) { return prowjobv1 . errorstate , descmissingcondition } return prowjobv1 . triggeredstate , descscheduling } cond : = * pcond switch { case cond . status == coreapi . conditiontrue : return prowjobv1 . successstate , description ( cond , descsucceeded ) case cond . status == coreapi . conditionfalse : return prowjobv1 . failurestate , description ( cond , descfailed ) case started . iszero ( ) : return prowjobv1 . triggeredstate , description ( cond , descinitializing ) case cond . status == coreapi . conditionunknown , finished . iszero ( ) : return prowjobv1 . pendingstate , description ( cond , descrunning ) } logrus . warnf ( " " , cond ) return prowjobv1 . errorstate , description ( cond , descunknown ) } 
func buildenv ( pj prowjobv1 . prowjob , buildid string ) ( map [ string ] string , error ) { return downwardapi . envforspec ( downwardapi . newjobspec ( pj . spec , buildid , pj . name ) ) } 
func defaultarguments ( t * buildv1alpha1 . templateinstantiationspec , rawenv map [ string ] string ) { keys : = sets . string { } for , arg : = range t . arguments { keys . insert ( arg . name ) } for , k : = range sets . stringkeyset ( rawenv ) . list ( ) { if keys . has ( k ) { continue } t . arguments = append ( t . arguments , buildv1alpha1 . argumentspec { name : k , value : rawenv [ k ] } ) } } 
func defaultenv ( c * coreapi . container , rawenv map [ string ] string ) { keys : = sets . string { } for , arg : = range c . env { keys . insert ( arg . name ) } for , k : = range sets . stringkeyset ( rawenv ) . list ( ) { if keys . has ( k ) { continue } c . env = append ( c . env , coreapi . envvar { name : k , value : rawenv [ k ] } ) } } 
func injectenvironment ( b * buildv1alpha1 . build , rawenv map [ string ] string ) { for i : = range b . spec . steps { defaultenv ( & b . spec . steps [ i ] , rawenv ) } if b . spec . template ! = nil { defaultarguments ( b . spec . template , rawenv ) } } 
func injectsource ( b * buildv1alpha1 . build , pj prowjobv1 . prowjob ) ( bool , error ) { if b . spec . source ! = nil { return false , nil } srccontainer , refs , clonevolumes , err : = decorate . clonerefs ( pj , codemount , logmount ) if err ! = nil { return false , fmt . errorf ( " " , err ) } if srccontainer == nil { return false , nil } else { srccontainer . name = " " } b . spec . source = & buildv1alpha1 . sourcespec { custom : srccontainer , } b . spec . volumes = append ( b . spec . volumes , clonevolumes ... ) wd : = workdir ( refs [ 0 ] ) for i : = range b . spec . steps { if b . spec . steps [ i ] . workingdir ! = " " { continue } b . spec . steps [ i ] . workingdir = wd . value } if b . spec . template ! = nil { b . spec . template . arguments = append ( b . spec . template . arguments , wd ) } return true , nil } 
func injectedsteps ( encodedjobspec string , dc prowjobv1 . decorationconfig , injectedsource bool , toolsmount coreapi . volumemount , entries [ ] wrapper . options ) ( [ ] coreapi . container , * coreapi . container , * coreapi . volume , error ) { gcsvol , gcsmount , gcsoptions : = decorate . gcsoptions ( dc ) sidecar , err : = decorate . sidecar ( dc . utilityimages . sidecar , gcsoptions , gcsmount , logmount , encodedjobspec , decorate . requirepassingentries , entries ... ) if err ! = nil { return nil , nil , nil , fmt . errorf ( " " , err ) } var clonelogmount * coreapi . volumemount if injectedsource { clonelogmount = & logmount } initupload , err : = decorate . initupload ( dc . utilityimages . initupload , gcsoptions , gcsmount , clonelogmount , encodedjobspec ) if err ! = nil { return nil , nil , nil , fmt . errorf ( " " , err ) } placer : = decorate . placeentrypoint ( dc . utilityimages . entrypoint , toolsmount ) return [ ] coreapi . container { placer , * initupload } , sidecar , & gcsvol , nil } 
func determinetimeout ( spec * buildv1alpha1 . buildspec , dc * prowjobv1 . decorationconfig , defaulttimeout time . duration ) time . duration { switch { case spec . timeout ! = nil : return spec . timeout . duration case dc ! = nil && dc . timeout . duration > 0 : return dc . timeout . duration default : return defaulttimeout } } 
func makebuild ( pj prowjobv1 . prowjob , defaulttimeout time . duration ) ( * buildv1alpha1 . build , error ) { if pj . spec . buildspec == nil { return nil , errors . new ( " " ) } buildid : = pj . status . buildid if buildid == " " { return nil , errors . new ( " " ) } b : = buildv1alpha1 . build { objectmeta : buildmeta ( pj ) , spec : * pj . spec . buildspec . deepcopy ( ) , } rawenv , err : = buildenv ( pj , buildid ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } injectenvironment ( & b , rawenv ) injectedsource , err : = injectsource ( & b , pj ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } injecttimeout ( & b . spec , pj . spec . decorationconfig , defaulttimeout ) if pj . spec . decorationconfig ! = nil { encodedjobspec : = rawenv [ downwardapi . jobspecenv ] err = decoratebuild ( & b . spec , encodedjobspec , * pj . spec . decorationconfig , injectedsource ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } } return & b , nil } 
func newissue ( gissue * github . issue , repository string ) ( * sql . issue , error ) { if gissue . number == nil | | gissue . title == nil | | gissue . user == nil | | gissue . user . login == nil | | gissue . state == nil | | gissue . comments == nil | | gissue . createdat == nil | | gissue . updatedat == nil { return nil , fmt . errorf ( " " , gissue ) } var closedat * time . time if gissue . closedat ! = nil { closedat = gissue . closedat } assignees , err : = newassignees ( * gissue . number , gissue . assignees , repository ) if err ! = nil { return nil , err } var body string if gissue . body ! = nil { body = * gissue . body } ispr : = ( gissue . pullrequestlinks ! = nil && gissue . pullrequestlinks . url ! = nil ) labels , err : = newlabels ( * gissue . number , gissue . labels , repository ) if err ! = nil { return nil , err } return & sql . issue { id : strconv . itoa ( * gissue . number ) , labels : labels , title : * gissue . title , body : body , user : * gissue . user . login , assignees : assignees , state : * gissue . state , comments : * gissue . comments , ispr : ispr , issueclosedat : closedat , issuecreatedat : * gissue . createdat , issueupdatedat : * gissue . updatedat , repository : strings . tolower ( repository ) , } , nil } 
func newissueevent ( gissueevent * github . issueevent , issueid int , repository string ) ( * sql . issueevent , error ) { if gissueevent . id == nil | | gissueevent . event == nil | | gissueevent . createdat == nil { return nil , fmt . errorf ( " " , gissueevent ) } var label * string if gissueevent . label ! = nil { label = gissueevent . label . name } var assignee * string if gissueevent . assignee ! = nil { assignee = gissueevent . assignee . login } var actor * string if gissueevent . actor ! = nil { actor = gissueevent . actor . login } return & sql . issueevent { id : itoa ( * gissueevent . id ) , label : label , event : * gissueevent . event , eventcreatedat : * gissueevent . createdat , issueid : strconv . itoa ( issueid ) , assignee : assignee , actor : actor , repository : strings . tolower ( repository ) , } , nil } 
func newlabels ( issueid int , glabels [ ] github . label , repository string ) ( [ ] sql . label , error ) { labels : = [ ] sql . label { } repository = strings . tolower ( repository ) for , label : = range glabels { if label . name == nil { return nil , fmt . errorf ( " " ) } labels = append ( labels , sql . label { issueid : strconv . itoa ( issueid ) , name : * label . name , repository : repository , } ) } return labels , nil } 
func newassignees ( issueid int , gassignees [ ] * github . user , repository string ) ( [ ] sql . assignee , error ) { assignees : = [ ] sql . assignee { } repository = strings . tolower ( repository ) for , assignee : = range gassignees { if assignee ! = nil && assignee . login == nil { return nil , fmt . errorf ( " " ) } assignees = append ( assignees , sql . assignee { issueid : strconv . itoa ( issueid ) , name : * assignee . login , repository : repository , } ) } return assignees , nil } 
func newissuecomment ( issueid int , gcomment * github . issuecomment , repository string ) ( * sql . comment , error ) { if gcomment . id == nil | | gcomment . body == nil | | gcomment . createdat == nil | | gcomment . updatedat == nil { return nil , fmt . errorf ( " " , gcomment ) } var login string if gcomment . user ! = nil && gcomment . user . login ! = nil { login = * gcomment . user . login } return & sql . comment { id : itoa ( * gcomment . id ) , issueid : strconv . itoa ( issueid ) , body : * gcomment . body , user : login , commentcreatedat : * gcomment . createdat , commentupdatedat : * gcomment . updatedat , pullrequest : false , repository : strings . tolower ( repository ) , } , nil } 
func messagefilter ( lastupdate time . time , change client . changeinfo , presubmits [ ] config . presubmit ) ( pjutil . filter , error ) { var filters [ ] pjutil . filter currentrevision : = change . revisions [ change . currentrevision ] . number for , message : = range change . messages { messagetime : = message . date . time if message . revisionnumber ! = currentrevision | | ! messagetime . after ( lastupdate ) { continue } if ! pjutil . testallre . matchstring ( message . message ) { for , presubmit : = range presubmits { if presubmit . triggermatches ( message . message ) { logrus . infof ( " " , change . number , message . message , presubmit . name ) filters = append ( filters , pjutil . commandfilter ( message . message ) ) } } } else { filters = append ( filters , pjutil . testallfilter ( ) ) } } return pjutil . aggregatefilter ( filters ) , nil } 
func ( jb * build ) issuccess ( ) bool { return jb . result ! = nil && * jb . result == success } 
func ( jb * build ) isfailure ( ) bool { return jb . result ! = nil && ( * jb . result == failure | | * jb . result == unstable ) } 
func ( jb * build ) isaborted ( ) bool { return jb . result ! = nil && * jb . result == aborted } 
func ( jb * build ) prowjobid ( ) string { for , action : = range jb . actions { for , p : = range action . parameters { if p . name == prowjobid { value , ok : = p . value . ( string ) if ! ok { logrus . errorf ( " " , p . name , jb ) continue } return value } } } return " " } 
func ( jb * build ) buildid ( ) string { var buildid string hasprowjobid : = false for , action : = range jb . actions { for , p : = range action . parameters { hasprowjobid = hasprowjobid | | p . name == prowjobid if p . name == statusbuildid { value , ok : = p . value . ( string ) if ! ok { logrus . errorf ( " " , p . name , jb ) continue } buildid = value } } } if ! hasprowjobid { return " " } return buildid } 
func newclient ( url string , dryrun bool , tlsconfig * tls . config , authconfig * authconfig , logger * logrus . entry , metrics * clientmetrics , ) ( * client , error ) { if logger == nil { logger = logrus . newentry ( logrus . standardlogger ( ) ) } c : = & client { logger : logger . withfield ( " " , " " ) , dryrun : dryrun , baseurl : url , authconfig : authconfig , client : & http . client { timeout : 30 * time . second , } , metrics : metrics , } if tlsconfig ! = nil { c . client . transport = & http . transport { tlsclientconfig : tlsconfig } } if c . authconfig . csrfprotect { if err : = c . crumbrequest ( ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } } return c , nil } 
func ( c * client ) crumbrequest ( ) error { if c . authconfig . csrftoken ! = " " && c . authconfig . csrfrequestfield ! = " " { return nil } c . logger . debug ( " " ) data , err : = c . getskipmetrics ( " " ) if err ! = nil { return err } crumbresp : = struct { crumb string ' json : " crumb " ' crumbrequestfield string ' json : " crumbrequestfield " ' } { } if err : = json . unmarshal ( data , & crumbresp ) ; err ! = nil { return fmt . errorf ( " " , err ) } c . authconfig . csrftoken = crumbresp . crumb c . authconfig . csrfrequestfield = crumbresp . crumbrequestfield return nil } 
func ( c * client ) measure ( method , path string , code int , start time . time ) { if c . metrics == nil { return } c . metrics . requestlatency . withlabelvalues ( method , path ) . observe ( time . since ( start ) . seconds ( ) ) c . metrics . requests . withlabelvalues ( method , path , fmt . sprintf ( " " , code ) ) . inc ( ) } 
func ( c * client ) request ( method , path string , params url . values , measure bool ) ( * http . response , error ) { var resp * http . response var err error backoff : = retrydelay urlpath : = fmt . sprintf ( " " , c . baseurl , path ) if params ! = nil { urlpath = fmt . sprintf ( " " , urlpath , params . encode ( ) ) } start : = time . now ( ) for retries : = 0 ; retries < maxretries ; retries ++ { resp , err = c . dorequest ( method , urlpath ) if err == nil && resp . statuscode < 500 { break } else if err == nil && retries + 1 < maxretries { resp . body . close ( ) } if measure && c . metrics ! = nil { c . metrics . requestretries . inc ( ) } time . sleep ( backoff ) backoff * = 2 } if measure && resp ! = nil { c . measure ( method , path , resp . statuscode , start ) } return resp , err } 
func ( c * client ) dorequest ( method , path string ) ( * http . response , error ) { req , err : = http . newrequest ( method , path , nil ) if err ! = nil { return nil , err } if c . authconfig ! = nil { if c . authconfig . basic ! = nil { req . setbasicauth ( c . authconfig . basic . user , string ( c . authconfig . basic . gettoken ( ) ) ) } if c . authconfig . bearertoken ! = nil { req . header . set ( " " , fmt . sprintf ( " " , c . authconfig . bearertoken . gettoken ( ) ) ) } if c . authconfig . csrfprotect && c . authconfig . csrfrequestfield ! = " " && c . authconfig . csrftoken ! = " " { req . header . set ( c . authconfig . csrfrequestfield , c . authconfig . csrftoken ) } } return c . client . do ( req ) } 
func getjobname ( spec * prowapi . prowjobspec ) string { if spec . jenkinsspec ! = nil && spec . jenkinsspec . githubbranchsourcejob && spec . refs ! = nil { if len ( spec . refs . pulls ) > 0 { return fmt . sprintf ( " " , spec . job , spec . refs . pulls [ 0 ] . number ) } return fmt . sprintf ( " " , spec . job , spec . refs . baseref ) } return spec . job } 
func getbuildpath ( spec * prowapi . prowjobspec ) string { jenkinsjobname : = getjobname ( spec ) jenkinspath : = fmt . sprintf ( " " , jenkinsjobname ) return jenkinspath } 
func ( c * client ) getjobinfo ( spec * prowapi . prowjobspec ) ( * jobinfo , error ) { path : = getjobinfopath ( spec ) c . logger . debugf ( " " , path ) data , err : = c . get ( path ) if err ! = nil { c . logger . errorf ( " " , err ) return nil , err } var jobinfo jobinfo if err : = json . unmarshal ( data , & jobinfo ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } c . logger . tracef ( " " , jobinfo ) return & jobinfo , nil } 
func ( c * client ) jobparameterized ( jobinfo * jobinfo ) bool { for , prop : = range jobinfo . property { if prop . parameterdefinitions ! = nil && len ( prop . parameterdefinitions ) > 0 { return true } } return false } 
func ( c * client ) launchbuild ( spec * prowapi . prowjobspec , params url . values ) error { var path string if params ! = nil { path = getbuildwithparameterspath ( spec ) } else { path = getbuildpath ( spec ) } c . logger . debugf ( " " , path ) resp , err : = c . request ( http . methodpost , path , params , true ) if err ! = nil { return err } defer resp . body . close ( ) if resp . statuscode ! = 201 { return fmt . errorf ( " " , resp . status ) } return nil } 
func ( c * client ) build ( pj * prowapi . prowjob , buildid string ) error { c . logger . withfields ( pjutil . prowjobfields ( pj ) ) . info ( " " ) return c . buildfromspec ( & pj . spec , buildid , pj . objectmeta . name ) } 
func ( c * client ) buildfromspec ( spec * prowapi . prowjobspec , buildid , prowjobid string ) error { if c . dryrun { return nil } env , err : = downwardapi . envforspec ( downwardapi . newjobspec ( * spec , buildid , prowjobid ) ) if err ! = nil { return err } params : = url . values { } for key , value : = range env { params . set ( key , value ) } if err : = c . ensurebuildablejob ( spec ) ; err ! = nil { return fmt . errorf ( " " , spec . job , err ) } return c . launchbuild ( spec , params ) } 
func ( c * client ) listbuilds ( jobs [ ] buildqueryparams ) ( map [ string ] build , error ) { jenkinsbuilds , err : = c . getenqueuedbuilds ( jobs ) if err ! = nil { return nil , err } buildchan : = make ( chan map [ string ] build , len ( jobs ) ) errchan : = make ( chan error , len ( jobs ) ) wg : = & sync . waitgroup { } wg . add ( len ( jobs ) ) for , job : = range jobs { go func ( job string ) { defer wg . done ( ) builds , err : = c . getbuilds ( job ) if err ! = nil { errchan < - err } else { buildchan < - builds } } ( job . jobname ) } wg . wait ( ) close ( buildchan ) close ( errchan ) for err : = range errchan { if err ! = nil { return nil , err } } for builds : = range buildchan { for id , build : = range builds { jenkinsbuilds [ id ] = build } } return jenkinsbuilds , nil } 
func ( c * client ) getenqueuedbuilds ( jobs [ ] buildqueryparams ) ( map [ string ] build , error ) { c . logger . debug ( " " ) data , err : = c . get ( " " ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } page : = struct { queuedbuilds [ ] build ' json : " items " ' } { } if err : = json . unmarshal ( data , & page ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } jenkinsbuilds : = make ( map [ string ] build ) for , jb : = range page . queuedbuilds { prowjobid : = jb . prowjobid ( ) if prowjobid == " " { continue } var exists bool for , job : = range jobs { if prowjobid == job . prowjobid { exists = true break } } if ! exists { continue } jb . enqueued = true jenkinsbuilds [ prowjobid ] = jb } return jenkinsbuilds , nil } 
func ( c * client ) getbuilds ( job string ) ( map [ string ] build , error ) { c . logger . debugf ( " " , job ) data , err : = c . get ( fmt . sprintf ( " " , job ) ) if err ! = nil { if , isnotfound : = err . ( notfounderror ) ; isnotfound { c . logger . witherror ( err ) . warnf ( " " , job ) return nil , nil } return nil , fmt . errorf ( " " , job , err ) } page : = struct { builds [ ] build ' json : " builds " ' } { } if err : = json . unmarshal ( data , & page ) ; err ! = nil { return nil , fmt . errorf ( " " , job , err ) } jenkinsbuilds : = make ( map [ string ] build ) for , jb : = range page . builds { prowjobid : = jb . prowjobid ( ) if prowjobid == " " { continue } jenkinsbuilds [ prowjobid ] = jb } return jenkinsbuilds , nil } 
func ( c * client ) abort ( job string , build * build ) error { c . logger . debugf ( " " , job , build . number ) if c . dryrun { return nil } resp , err : = c . request ( http . methodpost , fmt . sprintf ( " " , job , build . number ) , nil , false ) if err ! = nil { return err } defer resp . body . close ( ) if resp . statuscode < 200 | | resp . statuscode >= 300 { return fmt . errorf ( " " , resp . status ) } return nil } 
func presubmittojobspec ( pre config . presubmit ) * downwardapi . jobspec { return & downwardapi . jobspec { type : prowapi . presubmitjob , job : pre . name , } } 
func postsubmittojobspec ( post config . postsubmit ) * downwardapi . jobspec { return & downwardapi . jobspec { type : prowapi . postsubmitjob , job : post . name , } } 
func periodictojobspec ( periodic config . periodic ) * downwardapi . jobspec { return & downwardapi . jobspec { type : prowapi . periodicjob , job : periodic . name , } } 
func getbuildid ( name , toturl string ) ( string , error ) { if toturl == " " { return node . generate ( ) . string ( ) , nil } var err error url , err : = url . parse ( toturl ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } url . path = path . join ( url . path , " " , name ) sleepduration : = 100 * time . millisecond for retries : = 0 ; retries < 10 ; retries ++ { if retries > 0 { sleep ( sleepduration ) sleepduration = sleepduration * 2 } var resp * http . response resp , err = http . get ( url . string ( ) ) if err ! = nil { continue } defer resp . body . close ( ) if resp . statuscode ! = 200 { err = fmt . errorf ( " " , resp . status ) continue } var buf [ ] byte buf , err = ioutil . readall ( resp . body ) if err == nil { return string ( buf ) , nil } return " " , err } return " " , err } 
func listgcsobjects ( ctx context . context , client * storage . client , bucketname , prefix , delim string ) ( [ ] string , error ) { var objects [ ] string it : = client . bucket ( bucketname ) . objects ( ctx , & storage . query { prefix : prefix , delimiter : delim , } ) for { attrs , err : = it . next ( ) if err == iterator . done { break } if err ! = nil { return objects , fmt . errorf ( " " , err ) } if attrs . prefix ! = " " { objects = append ( objects , path . base ( attrs . prefix ) ) } } logrus . info ( " " ) return objects , nil } 
func findbaseprofile ( ctx context . context , client * storage . client , bucket , prowjobname , artifactsdirname , covprofilename string ) ( [ ] byte , error ) { dirofjob : = path . join ( " " , prowjobname ) strbuilds , err : = listgcsobjects ( ctx , client , bucket , dirofjob + " " , " " ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } builds : = sortbuilds ( strbuilds ) profilepath : = " " for , build : = range builds { builddirpath : = path . join ( dirofjob , strconv . itoa ( build ) ) dirofstatusjson : = path . join ( builddirpath , statusjson ) statustext , err : = readgcsobject ( ctx , client , bucket , dirofstatusjson ) if err ! = nil { logrus . infof ( " " , dirofstatusjson , bucket ) } else if isbuildsucceeded ( statustext ) { artifactsdirpath : = path . join ( builddirpath , artifactsdirname ) profilepath = path . join ( artifactsdirpath , covprofilename ) break } } if profilepath == " " { return nil , fmt . errorf ( " " , dirofjob , bucket , len ( builds ) ) } return readgcsobject ( ctx , client , bucket , profilepath ) } 
func sortbuilds ( strbuilds [ ] string ) [ ] int { var res [ ] int for , buildstr : = range strbuilds { num , err : = strconv . atoi ( buildstr ) if err ! = nil { logrus . infof ( " " , buildstr ) } else { res = append ( res , num ) } } sort . sort ( sort . reverse ( sort . intslice ( res ) ) ) return res } 
func getall ( sess * session . session ) ( [ ] string , error ) { var regions [ ] string svc : = ec2 . new ( sess , & aws . config { region : aws . string ( default ) } ) resp , err : = svc . describeregions ( nil ) if err ! = nil { return nil , err } for , region : = range resp . regions { regions = append ( regions , * region . regionname ) } return regions , nil } 
func neweventclient ( ghc githubclient , log * logrus . entry , org , repo string , number int ) * eventclient { return & eventclient { org : org , repo : repo , number : number , ghc : ghc , log : log , } } 
func ( c * eventclient ) prunecomments ( shouldprune func ( github . issuecomment ) bool ) { c . once . do ( func ( ) { botname , err : = c . ghc . botname ( ) if err ! = nil { c . log . witherror ( err ) . error ( " " ) } comments , err : = c . ghc . listissuecomments ( c . org , c . repo , c . number ) if err ! = nil { c . log . witherror ( err ) . errorf ( " " , c . org , c . repo , c . number ) } if botname ! = " " { for , comment : = range comments { if comment . user . login == botname { c . comments = append ( c . comments , comment ) } } } } ) c . lock . lock ( ) defer c . lock . unlock ( ) var remaining [ ] github . issuecomment for , comment : = range c . comments { removed : = false if shouldprune ( comment ) { if err : = c . ghc . deletecomment ( c . org , c . repo , comment . id ) ; err ! = nil { c . log . witherror ( err ) . errorf ( " " , comment . id ) } else { removed = true } } if ! removed { remaining = append ( remaining , comment ) } } c . comments = remaining } 
func makeshield ( subject , status , color string ) [ ] byte { p : = struct { width , rightstart , rightwidth int xposleft , xposright float64 subject , status string color string } { subject : subject , status : status , rightstart : 13 + 6 * len ( subject ) , rightwidth : 13 + 6 * len ( status ) , } p . width = p . rightstart + p . rightwidth p . xposleft = float64 ( p . rightstart ) * 0 . 5 p . xposright = float64 ( p . rightstart ) + float64 ( p . rightwidth - 2 ) * 0 . 5 switch color { case " " : p . color = " " case " " : p . color = " " default : p . color = color } var buf bytes . buffer svgtemplate . execute ( & buf , p ) return buf . bytes ( ) } 
func formatresponse ( to , message , reason string ) string { format : = return fmt . sprintf ( format , to , message , reason , aboutthisbotwithoutcommands ) } 
func formatsimpleresponse ( to , message string ) string { format : = return fmt . sprintf ( format , to , message , aboutthisbotwithoutcommands ) } 
func formaticresponse ( ic github . issuecomment , s string ) string { return formatresponseraw ( ic . body , ic . htmlurl , ic . user . login , s ) } 
func formatresponseraw ( body , bodyurl , login , reply string ) string { format : = var quoted [ ] string for , l : = range strings . split ( body , " \n " ) { quoted = append ( quoted , " " + l ) } return formatresponse ( login , reply , fmt . sprintf ( format , bodyurl , strings . join ( quoted , " \n " ) ) ) } 
func ( o * options ) validate ( ) error { if o . gcspath . string ( ) ! = " " { o . bucket = o . gcspath . bucket ( ) o . pathprefix = o . gcspath . object ( ) } if ! o . dryrun { if o . bucket == " " { return errors . new ( " " ) } if o . gcscredentialsfile == " " { return errors . new ( " " ) } } return o . gcsconfiguration . validate ( ) } 
func ( o * options ) addflags ( fs * flag . flagset ) { fs . stringvar ( & o . subdir , " " , " " , " " ) fs . stringvar ( & o . pathstrategy , " " , prowapi . pathstrategyexplicit , " " ) fs . stringvar ( & o . defaultorg , " " , " " , " " ) fs . stringvar ( & o . defaultrepo , " " , " " , " " ) fs . var ( & o . gcspath , " " , " " ) fs . stringvar ( & o . gcscredentialsfile , " " , " " , " " ) fs . boolvar ( & o . dryrun , " " , true , " " ) } 
func encode ( options options ) ( string , error ) { encoded , err : = json . marshal ( options ) return string ( encoded ) , err } 
func registerissuehandler ( name string , fn issuehandler , help helpprovider ) { pluginhelp [ name ] = help issuehandlers [ name ] = fn } 
func registerissuecommenthandler ( name string , fn issuecommenthandler , help helpprovider ) { pluginhelp [ name ] = help issuecommenthandlers [ name ] = fn } 
func registerpullrequesthandler ( name string , fn pullrequesthandler , help helpprovider ) { pluginhelp [ name ] = help pullrequesthandlers [ name ] = fn } 
func registerstatuseventhandler ( name string , fn statuseventhandler , help helpprovider ) { pluginhelp [ name ] = help statuseventhandlers [ name ] = fn } 
func registerpusheventhandler ( name string , fn pusheventhandler , help helpprovider ) { pluginhelp [ name ] = help pusheventhandlers [ name ] = fn } 
func registerrevieweventhandler ( name string , fn revieweventhandler , help helpprovider ) { pluginhelp [ name ] = help revieweventhandlers [ name ] = fn } 
func registerreviewcommenteventhandler ( name string , fn reviewcommenteventhandler , help helpprovider ) { pluginhelp [ name ] = help reviewcommenteventhandlers [ name ] = fn } 
func registergenericcommenthandler ( name string , fn genericcommenthandler , help helpprovider ) { pluginhelp [ name ] = help genericcommenthandlers [ name ] = fn } 
func newagent ( configagent * config . agent , pluginconfigagent * configagent , clientagent * clientagent , logger * logrus . entry ) agent { prowconfig : = configagent . config ( ) pluginconfig : = pluginconfigagent . config ( ) return agent { githubclient : clientagent . githubclient , kubernetesclient : clientagent . kubernetesclient , prowjobclient : clientagent . prowjobclient , gitclient : clientagent . gitclient , slackclient : clientagent . slackclient , ownersclient : clientagent . ownersclient , config : prowconfig , pluginconfig : pluginconfig , logger : logger , } } 
func ( a * agent ) initializecommentpruner ( org , repo string , pr int ) { a . commentpruner = commentpruner . neweventclient ( a . githubclient , a . logger . withfield ( " " , " " ) , org , repo , pr , ) } 
func ( a * agent ) commentpruner ( ) ( * commentpruner . eventclient , error ) { if a . commentpruner == nil { return nil , errors . new ( " " ) } return a . commentpruner , nil } 
func ( pa * configagent ) load ( path string ) error { b , err : = ioutil . readfile ( path ) if err ! = nil { return err } np : = & configuration { } if err : = yaml . unmarshal ( b , np ) ; err ! = nil { return err } if err : = np . validate ( ) ; err ! = nil { return err } pa . set ( np ) return nil } 
func ( pa * configagent ) config ( ) * configuration { pa . mut . lock ( ) defer pa . mut . unlock ( ) return pa . configuration } 
func ( pa * configagent ) set ( pc * configuration ) { pa . mut . lock ( ) defer pa . mut . unlock ( ) pa . configuration = pc } 
func ( pa * configagent ) start ( path string ) error { if err : = pa . load ( path ) ; err ! = nil { return err } ticker : = time . tick ( 1 * time . minute ) go func ( ) { for range ticker { if err : = pa . load ( path ) ; err ! = nil { logrus . withfield ( " " , path ) . witherror ( err ) . error ( " " ) } } } ( ) return nil } 
func ( pa * configagent ) genericcommenthandlers ( owner , repo string ) map [ string ] genericcommenthandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] genericcommenthandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = genericcommenthandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) issuehandlers ( owner , repo string ) map [ string ] issuehandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] issuehandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = issuehandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) issuecommenthandlers ( owner , repo string ) map [ string ] issuecommenthandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] issuecommenthandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = issuecommenthandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) pullrequesthandlers ( owner , repo string ) map [ string ] pullrequesthandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] pullrequesthandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = pullrequesthandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) revieweventhandlers ( owner , repo string ) map [ string ] revieweventhandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] revieweventhandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = revieweventhandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) reviewcommenteventhandlers ( owner , repo string ) map [ string ] reviewcommenteventhandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] reviewcommenteventhandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = reviewcommenteventhandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) statuseventhandlers ( owner , repo string ) map [ string ] statuseventhandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] statuseventhandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = statuseventhandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) pusheventhandlers ( owner , repo string ) map [ string ] pusheventhandler { pa . mut . lock ( ) defer pa . mut . unlock ( ) hs : = map [ string ] pusheventhandler { } for , p : = range pa . getplugins ( owner , repo ) { if h , ok : = pusheventhandlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * configagent ) getplugins ( owner , repo string ) [ ] string { var plugins [ ] string fullname : = fmt . sprintf ( " " , owner , repo ) plugins = append ( plugins , pa . configuration . plugins [ owner ] ... ) plugins = append ( plugins , pa . configuration . plugins [ fullname ] ... ) return plugins } 
func eventsforplugin ( name string ) [ ] string { var events [ ] string if , ok : = issuehandlers [ name ] ; ok { events = append ( events , " " ) } if , ok : = issuecommenthandlers [ name ] ; ok { events = append ( events , " " ) } if , ok : = pullrequesthandlers [ name ] ; ok { events = append ( events , " " ) } if , ok : = pusheventhandlers [ name ] ; ok { events = append ( events , " " ) } if , ok : = revieweventhandlers [ name ] ; ok { events = append ( events , " " ) } if , ok : = reviewcommenteventhandlers [ name ] ; ok { events = append ( events , " " ) } if , ok : = statuseventhandlers [ name ] ; ok { events = append ( events , " " ) } if , ok : = genericcommenthandlers [ name ] ; ok { events = append ( events , " " ) } return events } 
func striptags ( str string ) ( string , [ ] string ) { tags : = re . findallstring ( str , - 1 ) for i , w : = range tags { w = strings . trimspace ( w ) tags [ i ] = w [ 1 : len ( w ) - 1 ] } var reals [ ] string for , p : = range re . split ( str , - 1 ) { if p == " " { continue } reals = append ( reals , p ) } return strings . join ( reals , " " ) , tags } 
func insertlink ( started * gcs . started , viewurl string ) ( bool , error ) { if started . metadata == nil { started . metadata = metadata . metadata { } } meta : = started . metadata var changed bool top , present : = meta . string ( resultstorekey ) if ! present | | top == nil | | * top ! = viewurl { changed = true meta [ resultstorekey ] = viewurl } links , present : = meta . meta ( linkskey ) if present && links == nil { return false , fmt . errorf ( " " , meta [ linkskey ] ) } if links == nil { links = & metadata . metadata { } changed = true } resultstoremeta , present : = links . meta ( resultstorekey ) if present && resultstoremeta == nil { return false , fmt . errorf ( " " , ( * links ) [ resultstorekey ] ) } if resultstoremeta == nil { resultstoremeta = & metadata . metadata { } changed = true } val , present : = resultstoremeta . string ( urlkey ) if present && val == nil { return false , fmt . errorf ( " " , ( * resultstoremeta ) [ urlkey ] ) } if ! changed && val ! = nil && * val == viewurl { return false , nil } ( * resultstoremeta ) [ urlkey ] = viewurl ( * links ) [ resultstorekey ] = * resultstoremeta meta [ linkskey ] = * links return true , nil } 
func parseconfig ( configpath string ) ( [ ] common . resourcesconfig , error ) { if , err : = os . stat ( configpath ) ; os . isnotexist ( err ) { return nil , err } file , err : = ioutil . readfile ( configpath ) if err ! = nil { return nil , err } var data common . masonconfig err = yaml . unmarshal ( file , & data ) if err ! = nil { return nil , err } return data . configs , nil } 
func validateconfig ( configs [ ] common . resourcesconfig , resources [ ] common . resource ) error { resourcesneeds : = map [ string ] int { } actualresources : = map [ string ] int { } confignames : = map [ string ] map [ string ] int { } for , c : = range configs { , alreadyexists : = confignames [ c . name ] if alreadyexists { return fmt . errorf ( " " , c . name ) } confignames [ c . name ] = c . needs } for , res : = range resources { , useconfig : = confignames [ res . type ] if useconfig { c , ok : = confignames [ res . type ] if ! ok { err : = fmt . errorf ( " " , res . type ) logrus . witherror ( err ) . error ( " " ) return err } for k , v : = range c { resourcesneeds [ k ] += v } } actualresources [ res . type ] ++ } for rtype , needs : = range resourcesneeds { actual , ok : = actualresources [ rtype ] if ! ok { err : = fmt . errorf ( " " , rtype ) logrus . witherror ( err ) . errorf ( " " ) return err } if needs > actual { err : = fmt . errorf ( " " , rtype ) logrus . witherror ( err ) . errorf ( " " ) return err } } return nil } 
func newmason ( cleanercount int , client boskosclient , waitperiod , syncperiod time . duration ) * mason { return & mason { client : client , cleanercount : cleanercount , storage : * newstorage ( storage . newmemorystorage ( ) ) , pending : make ( chan requirements ) , cleaned : make ( chan requirements , cleanercount + 1 ) , fulfilled : make ( chan requirements , cleanercount + 1 ) , boskoswaitperiod : waitperiod , boskossyncperiod : syncperiod , configconverters : map [ string ] configconverter { } , } } 
func ( m * mason ) registerconfigconverter ( name string , fn configconverter ) error { , ok : = m . configconverters [ name ] if ok { return fmt . errorf ( " " , name ) } m . configconverters [ name ] = fn return nil } 
func ( m * mason ) updateconfigs ( storagepath string ) error { configs , err : = parseconfig ( storagepath ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) return err } return m . storage . syncconfigs ( configs ) } 
func helpprovider ( enabledrepos [ ] string ) ( * pluginhelp . pluginhelp , error ) { pluginhelp : = & pluginhelp . pluginhelp { description : ' the cherrypick plugin is used for cherrypicking prs across branches . for every successful cherrypick invocation a new pr is opened against the target branch and assigned to the requester . if the parent pr contains a release note , it is copied to the cherrypick pr . ' , } pluginhelp . addcommand ( pluginhelp . command { usage : " " , description : " " , featured : true , whocanuse : " " , examples : [ ] string { " " } , } ) return pluginhelp , nil } 
func ( s * server ) ensureforkexists ( org , repo string ) error { s . repolock . lock ( ) defer s . repolock . unlock ( ) fork : = s . botname + " " + repo if ! repoexists ( fork , s . repos ) { if err : = s . ghc . createfork ( org , repo ) ; err ! = nil { return fmt . errorf ( " " , org , repo , err ) } if err : = waitforrepo ( s . botname , repo , s . ghc ) ; err ! = nil { return fmt . errorf ( " " , org , repo , err ) } s . repos = append ( s . repos , github . repo { fullname : fork , fork : true } ) } return nil } 
func ( s * server ) getpatch ( org , repo , targetbranch string , num int ) ( string , error ) { patch , err : = s . ghc . getpullrequestpatch ( org , repo , num ) if err ! = nil { return " " , err } localpath : = fmt . sprintf ( " " , org , repo , num , normalize ( targetbranch ) ) out , err : = os . create ( localpath ) if err ! = nil { return " " , err } defer out . close ( ) if , err : = io . copy ( out , bytes . newbuffer ( patch ) ) ; err ! = nil { return " " , err } return localpath , nil } 
func validatepayload ( payload [ ] byte , sig string , key [ ] byte ) bool { if ! strings . hasprefix ( sig , " " ) { return false } sig = sig [ 5 : ] sb , err : = hex . decodestring ( sig ) if err ! = nil { return false } mac : = hmac . new ( sha1 . new , key ) mac . write ( payload ) expected : = mac . sum ( nil ) return hmac . equal ( sb , expected ) } 
func payloadsignature ( payload [ ] byte , key [ ] byte ) string { mac : = hmac . new ( sha1 . new , key ) mac . write ( payload ) sum : = mac . sum ( nil ) return " " + hex . encodetostring ( sum ) } 
func findteam ( teams map [ string ] github . team , name string , previousnames ... string ) * github . team { if t , ok : = teams [ name ] ; ok { return & t } for , p : = range previousnames { if t , ok : = teams [ p ] ; ok { return & t } } return nil } 
func validateteamnames ( orgconfig org . config ) error { used : = sets . string { } dups : = sets . string { } for name , orgteam : = range orgconfig . teams { if used . has ( name ) { dups . insert ( name ) } else { used . insert ( name ) } for , n : = range orgteam . previously { if used . has ( n ) { dups . insert ( n ) } else { used . insert ( n ) } } } if n : = len ( dups ) ; n > 0 { return fmt . errorf ( " " , n , strings . join ( dups . list ( ) , " " ) ) } return nil } 
func updatestring ( have , want * string ) bool { switch { case have == nil : panic ( " " ) case want == nil : return false case * have == * want : return false } * have = * want return true } 
func updatebool ( have , want * bool ) bool { switch { case have == nil : panic ( " " ) case want == nil : return false case * have == * want : return false } * have = * want return true } 
func configureorgmeta ( client orgmetadataclient , orgname string , want org . metadata ) error { cur , err : = client . getorg ( orgname ) if err ! = nil { return fmt . errorf ( " " , orgname , err ) } change : = false change = updatestring ( & cur . billingemail , want . billingemail ) | | change change = updatestring ( & cur . company , want . company ) | | change change = updatestring ( & cur . email , want . email ) | | change change = updatestring ( & cur . name , want . name ) | | change change = updatestring ( & cur . description , want . description ) | | change change = updatestring ( & cur . location , want . location ) | | change if want . defaultrepositorypermission ! = nil { w : = string ( * want . defaultrepositorypermission ) change = updatestring ( & cur . defaultrepositorypermission , & w ) } change = updatebool ( & cur . hasorganizationprojects , want . hasorganizationprojects ) | | change change = updatebool ( & cur . hasrepositoryprojects , want . hasrepositoryprojects ) | | change change = updatebool ( & cur . memberscancreaterepositories , want . memberscancreaterepositories ) | | change if change { if , err : = client . editorg ( orgname , * cur ) ; err ! = nil { return fmt . errorf ( " " , orgname , err ) } } return nil } 
func configureteam ( client editteamclient , orgname , teamname string , team org . team , gt github . team , parent * int ) error { patch : = false if gt . name ! = teamname { patch = true } gt . name = teamname if team . description ! = nil && gt . description ! = * team . description { patch = true gt . description = * team . description } else { gt . description = " " } if gt . parent == nil && parent ! = nil { patch = true gt . parentteamid = parent } if gt . parent ! = nil { if parent == nil { patch = true gt . parent = nil gt . parentteamid = parent } else if gt . parent . id ! = * parent { patch = true gt . parent = nil gt . parentteamid = parent } } if team . privacy ! = nil && gt . privacy ! = string ( * team . privacy ) { patch = true gt . privacy = string ( * team . privacy ) } else if team . privacy == nil && ( parent ! = nil | | len ( team . children ) > 0 ) && gt . privacy ! = " " { patch = true gt . privacy = github . privacyclosed } if patch { if , err : = client . editteam ( gt ) ; err ! = nil { return fmt . errorf ( " " , orgname , gt . id , gt . name , err ) } } return nil } 
func configureteamrepos ( client teamrepoclient , githubteams map [ string ] github . team , name , orgname string , team org . team ) error { gt , ok : = githubteams [ name ] if ! ok { return fmt . errorf ( " " , name ) } want : = team . repos have : = map [ string ] github . repopermissionlevel { } repos , err : = client . listteamrepos ( gt . id ) if err ! = nil { return fmt . errorf ( " " , gt . id , name , err ) } for , repo : = range repos { have [ repo . name ] = github . levelfrompermissions ( repo . permissions ) } actions : = map [ string ] github . repopermissionlevel { } for wantrepo , wantpermission : = range want { if havepermission , haverepo : = have [ wantrepo ] ; haverepo && havepermission == wantpermission { continue } actions [ wantrepo ] = wantpermission } for haverepo : = range have { if , wantrepo : = want [ haverepo ] ; ! wantrepo { actions [ haverepo ] = github . none } } var updateerrors [ ] error for repo , permission : = range actions { var err error if permission == github . none { err = client . removeteamrepo ( gt . id , orgname , repo ) } else { err = client . updateteamrepo ( gt . id , orgname , repo , permission ) } if err ! = nil { updateerrors = append ( updateerrors , fmt . errorf ( " " , gt . id , name , repo , permission , err ) ) } } return errorutil . newaggregate ( updateerrors ... ) } 
func ( c * client ) shouldreport ( pj * prowapi . prowjob ) bool { pubsubmap : = findlabels ( pj , pubsubprojectlabel , pubsubtopiclabel ) return pubsubmap [ pubsubprojectlabel ] ! = " " && pubsubmap [ pubsubtopiclabel ] ! = " " } 
func ( c * client ) report ( pj * prowapi . prowjob ) ( [ ] * prowapi . prowjob , error ) { message : = c . generatemessagefrompj ( pj ) ctx : = context . background ( ) client , err : = pubsub . newclient ( ctx , message . project ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } topic : = client . topic ( message . topic ) d , err : = json . marshal ( message ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } res : = topic . publish ( ctx , & pubsub . message { data : d , } ) , err = res . get ( ctx ) if err ! = nil { return nil , fmt . errorf ( " " " " , message . runid , message . project , message . topic , err ) } return [ ] * prowapi . prowjob { pj } , nil } 
func ( o options ) run ( spec * downwardapi . jobspec , extra map [ string ] gcs . uploadfunc ) error { uploadtargets : = o . assembletargets ( spec , extra ) if ! o . dryrun { ctx : = context . background ( ) gcsclient , err : = storage . newclient ( ctx , option . withcredentialsfile ( o . gcscredentialsfile ) ) if err ! = nil { return fmt . errorf ( " " , err ) } if err : = gcs . upload ( gcsclient . bucket ( o . bucket ) , uploadtargets ) ; err ! = nil { return fmt . errorf ( " " , err ) } } else { for destination : = range uploadtargets { logrus . withfield ( " " , destination ) . info ( " " ) } } logrus . info ( " " ) return nil } 
func pathsforjob ( options * prowapi . gcsconfiguration , spec * downwardapi . jobspec , subdir string ) ( string , string , gcs . repopathbuilder ) { builder : = builderforstrategy ( options . pathstrategy , options . defaultorg , options . defaultrepo ) jobbasepath : = gcs . pathforspec ( spec , builder ) if options . pathprefix ! = " " { jobbasepath = path . join ( options . pathprefix , jobbasepath ) } var gcspath string if subdir == " " { gcspath = jobbasepath } else { gcspath = path . join ( jobbasepath , subdir ) } return jobbasepath , gcspath , builder } 
func newdefaultfieldsformatter ( wrappedformatter logrus . formatter , defaultfields logrus . fields , ) * defaultfieldsformatter { res : = & defaultfieldsformatter { wrappedformatter : wrappedformatter , defaultfields : defaultfields , } if res . wrappedformatter == nil { res . wrappedformatter = & logrus . jsonformatter { } } return res } 
func ( d * defaultfieldsformatter ) format ( entry * logrus . entry ) ( [ ] byte , error ) { data : = make ( logrus . fields , len ( entry . data ) + len ( d . defaultfields ) ) for k , v : = range d . defaultfields { data [ k ] = v } for k , v : = range entry . data { data [ k ] = v } return d . wrappedformatter . format ( & logrus . entry { logger : entry . logger , data : data , time : entry . time , level : entry . level , message : entry . message , } ) } 
func ( issue * issue ) findlabels ( regex * regexp . regexp ) [ ] label { labels : = [ ] label { } for , label : = range issue . labels { if regex . matchstring ( label . name ) { labels = append ( labels , label ) } } return labels } 
func ( o * options ) addflags ( flags * flag . flagset ) { flags . stringvar ( & o . log , " " , " " , " " ) o . options . addflags ( flags ) } 
func newagent ( config * config . githuboauthconfig , logger * logrus . entry ) * agent { return & agent { gc : config , logger : logger , } } 
func ( ga * agent ) handlelogin ( client oauthclient ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { statetoken : = xsrftoken . generate ( ga . gc . clientsecret , " " , " " ) state : = hex . encodetostring ( [ ] byte ( statetoken ) ) oauthsession , err : = ga . gc . cookiestore . new ( r , oauthsessioncookie ) oauthsession . options . secure = true oauthsession . options . httponly = true if err ! = nil { ga . servererror ( w , " " , err ) return } oauthsession . options . maxage = 10 * 60 oauthsession . values [ statekey ] = state if err : = oauthsession . save ( r , w ) ; err ! = nil { ga . servererror ( w , " " , err ) return } redirecturl : = client . authcodeurl ( state , oauth2 . approvalforce , oauth2 . accesstypeonline ) http . redirect ( w , r , redirecturl , http . statusfound ) } } 
func ( ga * agent ) handlelogout ( client oauthclient ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { accesstokensession , err : = ga . gc . cookiestore . get ( r , tokensession ) if err ! = nil { ga . servererror ( w , " " , err ) return } accesstokensession . options . maxage = - 1 if err : = accesstokensession . save ( r , w ) ; err ! = nil { ga . servererror ( w , " " , err ) return } logincookie , err : = r . cookie ( loginsession ) if err == nil { logincookie . maxage = - 1 logincookie . expires = time . now ( ) . add ( - time . hour * 24 ) http . setcookie ( w , logincookie ) } http . redirect ( w , r , ga . gc . finalredirecturl , http . statusfound ) } } 
func ( ga * agent ) servererror ( w http . responsewriter , action string , err error ) { ga . logger . witherror ( err ) . errorf ( " " , action ) msg : = fmt . sprintf ( " " , action , err ) http . error ( w , msg , http . statusinternalservererror ) } 
func ( in * resourcesconfigobject ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func ( in * resourcesconfigobject ) fromitem ( i common . item ) { c , err : = common . itemtoresourcesconfig ( i ) if err == nil { in . fromconfig ( c ) } } 
func ( in * resourcesconfigcollection ) getitems ( ) [ ] object { var items [ ] object for , i : = range in . items { items = append ( items , i ) } return items } 
func ( in * resourcesconfigcollection ) setitems ( objects [ ] object ) { var items [ ] * resourcesconfigobject for , b : = range objects { items = append ( items , b . ( * resourcesconfigobject ) ) } in . items = items } 
func ( in * resourcesconfigcollection ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func ( l * repopermissionlevel ) unmarshaltext ( text [ ] byte ) error { v : = repopermissionlevel ( text ) if , ok : = repopermissionlevels [ v ] ; ! ok { return fmt . errorf ( " " , v , repopermissionlevels ) } * l = v return nil } 
func ( i issue ) isassignee ( login string ) bool { for , assignee : = range i . assignees { if normlogin ( login ) == normlogin ( assignee . login ) { return true } } return false } 
func ( i issue ) isauthor ( login string ) bool { return normlogin ( i . user . login ) == normlogin ( login ) } 
func ( i issue ) haslabel ( labeltofind string ) bool { for , label : = range i . labels { if strings . tolower ( label . name ) == strings . tolower ( labeltofind ) { return true } } return false } 
func ( pe pushevent ) branch ( ) string { ref : = strings . trimprefix ( pe . ref , " " ) ref = strings . trimprefix ( ref , " " ) return ref } 
func truncate ( in string ) string { const ( half = ( maxlen - len ( elide ) ) / 2 ) if len ( in ) <= maxlen { return in } return in [ : half ] + elide + in [ len ( in ) - half : ] } 
func reportstatus ( ghc githubclient , pj prowapi . prowjob ) error { refs : = pj . spec . refs if pj . spec . report { contextstate , err : = prowjobstatetogithubstatus ( pj . status . state ) if err ! = nil { return err } sha : = refs . basesha if len ( refs . pulls ) > 0 { sha = refs . pulls [ 0 ] . sha } if err : = ghc . createstatus ( refs . org , refs . repo , sha , github . status { state : contextstate , description : truncate ( pj . status . description ) , context : pj . spec . context , targeturl : pj . status . url , } ) ; err ! = nil { return err } } return nil } 
func shouldreport ( pj prowapi . prowjob , validtypes [ ] prowapi . prowjobtype ) bool { valid : = false for , t : = range validtypes { if pj . spec . type == t { valid = true } } if ! valid { return false } if ! pj . spec . report { return false } return true } 
func createcomment ( reporttemplate * template . template , pj prowapi . prowjob , entries [ ] string ) ( string , error ) { plural : = " " if len ( entries ) > 1 { plural = " " } var b bytes . buffer if reporttemplate ! = nil { if err : = reporttemplate . execute ( & b , & pj ) ; err ! = nil { return " " , err } } lines : = [ ] string { fmt . sprintf ( " " , pj . spec . refs . pulls [ 0 ] . author , plural ) , " " , " " , " " , } lines = append ( lines , entries ... ) if reporttemplate ! = nil { lines = append ( lines , " " , b . string ( ) ) } lines = append ( lines , [ ] string { " " , " " , " " , plugins . aboutthisbot , " " , commenttag , } ... ) return strings . join ( lines , " \n " ) , nil } 
func defaultlookingdhcpoptions ( dhcp * ec2 . dhcpoptions , region string ) bool { if len ( dhcp . tags ) ! = 0 { return false } for , conf : = range dhcp . dhcpconfigurations { switch * conf . key { case " " : var domain string if region == " " { domain = " " } else { domain = region + " " } if len ( conf . values ) ! = 1 | | * conf . values [ 0 ] . value ! = domain { return false } case " " : if len ( conf . values ) ! = 1 | | * conf . values [ 0 ] . value ! = " " { return false } default : return false } } return true } 
func genericcommentaction ( action string ) github . genericcommenteventaction { switch action { case " " , " " , " " : return github . genericcommentactioncreated case " " : return github . genericcommentactionedited case " " , " " : return github . genericcommentactiondeleted } return " " } 
func ( lens lens ) config ( ) lenses . lensconfig { return lenses . lensconfig { name : name , title : title , priority : priority , } } 
func ( lens lens ) header ( artifacts [ ] lenses . artifact , resourcedir string ) string { t , err : = template . parsefiles ( filepath . join ( resourcedir , " " ) ) if err ! = nil { return fmt . sprintf ( " " , err ) } var buf bytes . buffer if err : = t . executetemplate ( & buf , " " , nil ) ; err ! = nil { return fmt . sprintf ( " " , err ) } return buf . string ( ) } 
func ( lens lens ) callback ( artifacts [ ] lenses . artifact , resourcedir string , data string ) string { return " " } 
func formatrecord ( record record ) string { output : = bytes . buffer { } if record . failed { fmt . fprintln ( & output , " " ) } fmt . fprintf ( & output , " " , record . refs . org , record . refs . repo , record . refs . baseref ) if record . refs . basesha ! = " " { fmt . fprintf ( & output , " " , record . refs . basesha ) } output . writestring ( " \n " ) if len ( record . refs . pulls ) > 0 { output . writestring ( " \n " ) for , pull : = range record . refs . pulls { fmt . fprintf ( & output , " \ t " , pull . number ) if pull . sha ! = " " { fmt . fprintf ( & output , " " , pull . sha ) } fmt . fprint ( & output , " \n " ) } } for , command : = range record . commands { fmt . fprintf ( & output , " \n " , command . command ) fmt . fprint ( & output , command . output ) if command . error ! = " " { fmt . fprintf ( & output , " \n " , command . error ) } } return output . string ( ) } 
func ( c * client ) namespace ( ns string ) * client { nc : = * c nc . namespace = ns return & nc } 
func ( c * client ) requestretrystream ( r * request ) ( io . readcloser , error ) { if c . fake && r . deckpath == " " { return nil , nil } resp , err : = c . retry ( r ) if err ! = nil { return nil , err } if resp . statuscode == 409 { return nil , newconflicterror ( fmt . errorf ( " " ) ) } else if resp . statuscode < 200 | | resp . statuscode > 299 { return nil , fmt . errorf ( " " " " , resp . status ) } return resp . body , nil } 
func ( c * client ) requestretry ( r * request ) ( [ ] byte , error ) { if c . fake && r . deckpath == " " { return [ ] byte ( " " ) , nil } resp , err : = c . retry ( r ) if err ! = nil { return nil , err } defer resp . body . close ( ) rb , err : = ioutil . readall ( resp . body ) if err ! = nil { return nil , err } if resp . statuscode == 404 { return nil , newnotfounderror ( fmt . errorf ( " " , string ( rb ) ) ) } else if resp . statuscode == 409 { return nil , newconflicterror ( fmt . errorf ( " " , string ( rb ) ) ) } else if resp . statuscode == 422 { return nil , newunprocessableentityerror ( fmt . errorf ( " " , string ( rb ) ) ) } else if resp . statuscode == 404 { return nil , newnotfounderror ( fmt . errorf ( " " , string ( rb ) ) ) } else if resp . statuscode < 200 | | resp . statuscode > 299 { return nil , fmt . errorf ( " " " " " " , resp . status , string ( rb ) ) } return rb , nil } 
func newfakeclient ( deckurl string ) * client { return & client { namespace : " " , deckurl : deckurl , client : & http . client { } , fake : true , } } 
func newclientincluster ( namespace string ) ( * client , error ) { tokenfile : = " " token , err : = ioutil . readfile ( tokenfile ) if err ! = nil { return nil , err } rootcafile : = " " certdata , err : = ioutil . readfile ( rootcafile ) if err ! = nil { return nil , err } cp : = x509 . newcertpool ( ) cp . appendcertsfrompem ( certdata ) tr : = & http . transport { tlsclientconfig : & tls . config { minversion : tls . versiontls12 , rootcas : cp , } , } return & client { logger : logrus . withfield ( " " , " " ) , baseurl : inclusterbaseurl , client : & http . client { transport : tr , timeout : requesttimeout } , token : string ( token ) , namespace : namespace , } , nil } 
func newclientfromfile ( clusterpath , namespace string ) ( * client , error ) { data , err : = ioutil . readfile ( clusterpath ) if err ! = nil { return nil , err } var c cluster if err : = yaml . unmarshal ( data , & c ) ; err ! = nil { return nil , err } return newclient ( & c , namespace ) } 
func unmarshalclustermap ( data [ ] byte ) ( map [ string ] cluster , error ) { var raw map [ string ] cluster if err : = yaml . unmarshal ( data , & raw ) ; err ! = nil { var singleconfig cluster if err : = yaml . unmarshal ( data , & singleconfig ) ; err ! = nil { return nil , err } raw = map [ string ] cluster { defaultclusteralias : singleconfig } } return raw , nil } 
func clientmapfromfile ( clusterspath , namespace string ) ( map [ string ] * client , error ) { data , err : = ioutil . readfile ( clusterspath ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } raw , err : = unmarshalclustermap ( data ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } founddefault : = false result : = map [ string ] * client { } for alias , config : = range raw { client , err : = newclient ( & config , namespace ) if err ! = nil { return nil , fmt . errorf ( " " , alias , clusterspath , err ) } result [ alias ] = client if alias == defaultclusteralias { founddefault = true } } if ! founddefault { return nil , fmt . errorf ( " " , defaultclusteralias , clusterspath ) } return result , nil } 
func newclient ( c * cluster , namespace string ) ( * client , error ) { cc : = c . clientcertificate ck : = c . clientkey ca : = c . clustercacertificate cert , err : = tls . x509keypair ( cc , ck ) if err ! = nil { return nil , err } cp : = x509 . newcertpool ( ) cp . appendcertsfrompem ( ca ) tr : = & http . transport { tlsclientconfig : & tls . config { minversion : tls . versiontls12 , certificates : [ ] tls . certificate { cert } , rootcas : cp , } , } return & client { logger : logrus . withfield ( " " , " " ) , baseurl : c . endpoint , client : & http . client { transport : tr , timeout : requesttimeout } , namespace : namespace , } , nil } 
func ( c * client ) getpod ( name string ) ( pod , error ) { c . log ( " " , name ) var retpod pod err : = c . request ( & request { path : fmt . sprintf ( " " , c . namespace , name ) , } , & retpod ) return retpod , err } 
func ( c * client ) listpods ( selector string ) ( [ ] pod , error ) { c . log ( " " , selector ) var pl struct { items [ ] pod ' json : " items " ' } err : = c . request ( & request { path : fmt . sprintf ( " " , c . namespace ) , query : map [ string ] string { " " : selector } , } , & pl ) return pl . items , err } 
func ( c * client ) createprowjob ( j prowapi . prowjob ) ( prowapi . prowjob , error ) { var representation string if out , err : = json . marshal ( j ) ; err == nil { representation = string ( out [ : ] ) } else { representation = fmt . sprintf ( " " , j ) } c . log ( " " , representation ) var retjob prowapi . prowjob err : = c . request ( & request { method : http . methodpost , path : fmt . sprintf ( " " , c . namespace ) , requestbody : & j , } , & retjob ) return retjob , err } 
func ( c * client ) getprowjob ( name string ) ( prowapi . prowjob , error ) { c . log ( " " , name ) var pj prowapi . prowjob err : = c . request ( & request { path : fmt . sprintf ( " " , c . namespace , name ) , } , & pj ) return pj , err } 
func ( c * client ) listprowjobs ( selector string ) ( [ ] prowapi . prowjob , error ) { c . log ( " " , selector ) var jl struct { items [ ] prowapi . prowjob ' json : " items " ' } err : = c . request ( & request { path : fmt . sprintf ( " " , c . namespace ) , deckpath : " " , query : map [ string ] string { " " : selector } , } , & jl ) if err == nil { var pjs [ ] prowapi . prowjob for , pj : = range jl . items { pjs = append ( pjs , pj ) } jl . items = pjs } return jl . items , err } 
func ( c * client ) deleteprowjob ( name string ) error { c . log ( " " , name ) return c . request ( & request { method : http . methoddelete , path : fmt . sprintf ( " " , c . namespace , name ) , } , nil ) } 
func ( c * client ) replaceprowjob ( name string , job prowapi . prowjob ) ( prowapi . prowjob , error ) { c . log ( " " , name , job ) var retjob prowapi . prowjob err : = c . request ( & request { method : http . methodput , path : fmt . sprintf ( " " , c . namespace , name ) , requestbody : & job , } , & retjob ) return retjob , err } 
func ( c * client ) createpod ( p v1 . pod ) ( pod , error ) { c . log ( " " , p ) var retpod pod err : = c . request ( & request { method : http . methodpost , path : fmt . sprintf ( " " , c . namespace ) , requestbody : & p , } , & retpod ) return retpod , err } 
func ( c * client ) getlog ( pod string ) ( [ ] byte , error ) { c . log ( " " , pod ) return c . requestretry ( & request { path : fmt . sprintf ( " " , c . namespace , pod ) , } ) } 
func ( c * client ) getlogtail ( pod , container string , n int64 ) ( [ ] byte , error ) { c . log ( " " , pod , n ) return c . requestretry ( & request { path : fmt . sprintf ( " " , c . namespace , pod ) , query : map [ string ] string { " " : " " , " " : container , " " : strconv . formatint ( n , 10 ) , } , } ) } 
func ( c * client ) getcontainerlog ( pod , container string ) ( [ ] byte , error ) { c . log ( " " , pod ) return c . requestretry ( & request { path : fmt . sprintf ( " " , c . namespace , pod ) , query : map [ string ] string { " " : container } , } ) } 
func ( c * client ) createconfigmap ( content configmap ) ( configmap , error ) { c . log ( " " ) var retconfigmap configmap err : = c . request ( & request { method : http . methodpost , path : fmt . sprintf ( " " , c . namespace ) , requestbody : & content , } , & retconfigmap ) return retconfigmap , err } 
func ( c * client ) getconfigmap ( name , namespace string ) ( configmap , error ) { c . log ( " " , name ) if namespace == " " { namespace = c . namespace } var retconfigmap configmap err : = c . request ( & request { path : fmt . sprintf ( " " , namespace , name ) , } , & retconfigmap ) return retconfigmap , err } 
func ( c * client ) replaceconfigmap ( name string , config configmap ) ( configmap , error ) { c . log ( " " , name ) namespace : = c . namespace if config . namespace ! = " " { namespace = config . namespace } var retconfigmap configmap err : = c . request ( & request { method : http . methodput , path : fmt . sprintf ( " " , namespace , name ) , requestbody : & config , } , & retconfigmap ) return retconfigmap , err } 
func getdiskusage ( path string ) ( percentblocksfree float64 , bytesfree , bytesused uint64 , err error ) { var stat syscall . statfs t err = syscall . statfs ( path , & stat ) if err ! = nil { return 0 , 0 , 0 , err } percentblocksfree = float64 ( stat . bfree ) / float64 ( stat . blocks ) * 100 bytesfree = stat . bfree * uint64 ( stat . bsize ) bytesused = ( stat . blocks - stat . bfree ) * uint64 ( stat . bsize ) return percentblocksfree , bytesfree , bytesused , nil } 
func getatime ( path string , defaulttime time . time ) time . time { at , err : = atime . stat ( path ) if err ! = nil { log . witherror ( err ) . errorf ( " " , path ) return defaulttime } return at } 
func registerlens ( lens lens ) error { config : = lens . config ( ) , ok : = lensreg [ config . name ] if ok { return fmt . errorf ( " " , config . name ) } if config . title == " " { return errors . new ( " " ) } if config . priority < 0 { return errors . new ( " " ) } lensreg [ config . name ] = lens logrus . infof ( " " , config . name , config . title ) return nil } 
func getlens ( name string ) ( lens , error ) { lens , ok : = lensreg [ name ] if ! ok { return nil , errinvalidlensname } return lens , nil } 
func lastnlines ( a artifact , n int64 ) ( [ ] string , error ) { return lastnlineschunked ( a , n , 300 * n + 1 ) } 
func lastnlineschunked ( a artifact , n , chunksize int64 ) ( [ ] string , error ) { toread : = chunksize + 1 chunks : = int64 ( 1 ) var contents [ ] byte var linesincontents int64 artifactsize , err : = a . size ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } offset : = artifactsize - chunks * chunksize lastoffset : = offset var lastread int64 for linesincontents < n && offset ! = 0 { offset = lastoffset - lastread if offset < 0 { toread = offset + chunksize + 1 offset = 0 } bytesread : = make ( [ ] byte , toread ) numbytesread , err : = a . readat ( bytesread , offset ) if err ! = nil && err ! = io . eof { return nil , fmt . errorf ( " " , err ) } lastread = int64 ( numbytesread ) lastoffset = offset bytesread = bytes . trim ( bytesread , " \ x00 " ) linesincontents += int64 ( bytes . count ( bytesread , [ ] byte ( " \n " ) ) ) contents = append ( bytesread , contents ... ) chunks ++ } var lines [ ] string scanner : = bufio . newscanner ( bytes . newreader ( contents ) ) scanner . split ( bufio . scanlines ) for scanner . scan ( ) { line : = scanner . text ( ) lines = append ( lines , line ) } l : = int64 ( len ( lines ) ) if l < n { return lines , nil } return lines [ l - n : ] , nil } 
func newclient ( tokengenerator func ( ) [ ] byte ) * client { return & client { logger : logrus . withfield ( " " , " " ) , tokengenerator : tokengenerator , } } 
func ( sl * client ) writemessage ( text , channel string ) error { sl . log ( " " , text , channel ) if sl . fake { return nil } var uv = sl . urlvalues ( ) uv . add ( " " , channel ) uv . add ( " " , text ) , err : = sl . postmessage ( chatpostmessage , uv ) return err } 
func ( natgateway ) markandsweep ( sess * session . session , acct string , region string , set * set ) error { svc : = ec2 . new ( sess , & aws . config { region : aws . string ( region ) } ) inp : = & ec2 . describenatgatewaysinput { } if err : = svc . describenatgatewayspages ( inp , func ( page * ec2 . describenatgatewaysoutput , bool ) bool { for , gw : = range page . natgateways { g : = & natgateway { account : acct , region : region , id : * gw . natgatewayid , } if set . mark ( g ) { inp : = & ec2 . deletenatgatewayinput { natgatewayid : gw . natgatewayid } if , err : = svc . deletenatgateway ( inp ) ; err ! = nil { klog . warningf ( " " , g . arn ( ) , err ) } } } return true } ) ; err ! = nil { return err } return nil } 
func ( natgateway ) listall ( sess * session . session , acct , region string ) ( * set , error ) { svc : = ec2 . new ( sess , & aws . config { region : aws . string ( region ) } ) set : = newset ( 0 ) inp : = & ec2 . describenatgatewaysinput { } err : = svc . describenatgatewayspages ( inp , func ( page * ec2 . describenatgatewaysoutput , bool ) bool { for , gw : = range page . natgateways { now : = time . now ( ) arn : = natgateway { account : acct , region : region , id : * gw . natgatewayid , } . arn ( ) set . firstseen [ arn ] = now } return true } ) return set , errors . wrapf ( err , " " , acct , region ) } 
func ( c * prowv1client ) restclient ( ) rest . interface { if c == nil { return nil } return c . restclient } 
func newclient ( owner string , url string ) * client { client : = & client { url : url , owner : owner , storage : storage . newmemorystorage ( ) , } client . dialer . retrycount = 3 client . dialer . retrysleep = time . second * 10 client . dialer . timeout = 30 * time . second client . dialer . keepalive = 30 * time . second client . dialer . dualstack = true client . http . transport = & http . transport { proxy : http . proxyfromenvironment , dial : client . dialer . dial , dialcontext : client . dialer . dialcontext , maxidleconns : 100 , idleconntimeout : 90 * time . second , tlshandshaketimeout : 10 * time . second , expectcontinuetimeout : 1 * time . second , } return client } 
func ( c * client ) acquire ( rtype , state , dest string ) ( * common . resource , error ) { r , err : = c . acquire ( rtype , state , dest ) if err ! = nil { return nil , err } c . lock . lock ( ) defer c . lock . unlock ( ) if r ! = nil { c . storage . add ( * r ) } return r , nil } 
func ( c * client ) acquirewait ( ctx context . context , rtype , state , dest string ) ( * common . resource , error ) { if ctx == nil { return nil , errcontextrequired } for { r , err : = c . acquire ( rtype , state , dest ) if err ! = nil { if err == erralreadyinuse | | err == errnotfound { select { case < - ctx . done ( ) : return nil , err case < - time . after ( 3 * time . second ) : continue } } return nil , err } return r , nil } } 
func ( c * client ) acquirebystate ( state , dest string , names [ ] string ) ( [ ] common . resource , error ) { resources , err : = c . acquirebystate ( state , dest , names ) if err ! = nil { return nil , err } c . lock . lock ( ) defer c . lock . unlock ( ) for , r : = range resources { c . storage . add ( r ) } return resources , nil } 
func ( c * client ) acquirebystatewait ( ctx context . context , state , dest string , names [ ] string ) ( [ ] common . resource , error ) { if ctx == nil { return nil , errcontextrequired } for { r , err : = c . acquirebystate ( state , dest , names ) if err ! = nil { if err == erralreadyinuse | | err == errnotfound { select { case < - ctx . done ( ) : return nil , err case < - time . after ( 3 * time . second ) : continue } } return nil , err } return r , nil } } 
func ( c * client ) releaseall ( dest string ) error { c . lock . lock ( ) defer c . lock . unlock ( ) resources , err : = c . storage . list ( ) if err ! = nil { return err } if len ( resources ) == 0 { return fmt . errorf ( " " ) } var allerrors error for , r : = range resources { c . storage . delete ( r . getname ( ) ) err : = c . release ( r . getname ( ) , dest ) if err ! = nil { allerrors = multierror . append ( allerrors , err ) } } return allerrors } 
func ( c * client ) releaseone ( name , dest string ) error { c . lock . lock ( ) defer c . lock . unlock ( ) if , err : = c . storage . get ( name ) ; err ! = nil { return fmt . errorf ( " " , name ) } c . storage . delete ( name ) if err : = c . release ( name , dest ) ; err ! = nil { return err } return nil } 
func ( c * client ) updateall ( state string ) error { c . lock . lock ( ) defer c . lock . unlock ( ) resources , err : = c . storage . list ( ) if err ! = nil { return err } if len ( resources ) == 0 { return fmt . errorf ( " " ) } var allerrors error for , r : = range resources { if err : = c . update ( r . getname ( ) , state , nil ) ; err ! = nil { allerrors = multierror . append ( allerrors , err ) continue } if err : = c . updatelocalresource ( r , state , nil ) ; err ! = nil { allerrors = multierror . append ( allerrors , err ) } } return allerrors } 
func ( c * client ) syncall ( ) error { c . lock . lock ( ) defer c . lock . unlock ( ) resources , err : = c . storage . list ( ) if err ! = nil { return err } if len ( resources ) == 0 { logrus . info ( " " ) return nil } var allerrors error for , i : = range resources { r , err : = common . itemtoresource ( i ) if err ! = nil { allerrors = multierror . append ( allerrors , err ) continue } if err : = c . update ( r . name , r . state , nil ) ; err ! = nil { allerrors = multierror . append ( allerrors , err ) continue } if err : = c . storage . update ( r ) ; err ! = nil { allerrors = multierror . append ( allerrors , err ) } } return allerrors } 
func ( c * client ) updateone ( name , state string , userdata * common . userdata ) error { c . lock . lock ( ) defer c . lock . unlock ( ) r , err : = c . storage . get ( name ) if err ! = nil { return fmt . errorf ( " " , name ) } if err : = c . update ( r . getname ( ) , state , userdata ) ; err ! = nil { return err } return c . updatelocalresource ( r , state , userdata ) } 
func ( c * client ) reset ( rtype , state string , expire time . duration , dest string ) ( map [ string ] string , error ) { return c . reset ( rtype , state , expire , dest ) } 
func ( c * client ) metric ( rtype string ) ( common . metric , error ) { return c . metric ( rtype ) } 
func ( c * client ) hasresource ( ) bool { resources , : = c . storage . list ( ) return len ( resources ) > 0 } 
func ( d * dialerwithretry ) dialcontext ( ctx context . context , network , address string ) ( net . conn , error ) { count : = d . retrycount + 1 sleep : = d . retrysleep i : = uint ( 0 ) for { conn , err : = d . dialer . dialcontext ( ctx , network , address ) if err ! = nil { if isdialerrorretriable ( err ) { if i < count - 1 { select { case < - time . after ( sleep ) : i ++ continue case < - ctx . done ( ) : return nil , err } } } return nil , err } return conn , nil } } 
func isdialerrorretriable ( err error ) bool { operr , isoperr : = err . ( * net . operror ) if ! isoperr { return false } if operr . timeout ( ) | | operr . temporary ( ) { return true } syserr , issyserr : = operr . err . ( * os . syscallerror ) if ! issyserr { return false } switch syserr . err { case syscall . econnrefused , syscall . econnreset : return true } return false } 
func newdashboardagent ( repos [ ] string , config * config . githuboauthconfig , log * logrus . entry ) * dashboardagent { return & dashboardagent { repos : repos , goac : config , log : log , } } 
func ( da * dashboardagent ) querypullrequests ( ctx context . context , ghc githubclient , query string ) ( [ ] pullrequest , error ) { var prs [ ] pullrequest vars : = map [ string ] interface { } { " " : ( githubql . string ) ( query ) , " " : ( * githubql . string ) ( nil ) , } var totalcost int var remaining int for { sq : = searchquery { } if err : = ghc . query ( ctx , & sq , vars ) ; err ! = nil { return nil , err } totalcost += int ( sq . ratelimit . cost ) remaining = int ( sq . ratelimit . remaining ) for , n : = range sq . search . nodes { prs = append ( prs , n . pullrequest ) } if ! sq . search . pageinfo . hasnextpage { break } vars [ " " ] = githubql . newstring ( sq . search . pageinfo . endcursor ) } da . log . infof ( " " " " , query , totalcost , remaining ) return prs , nil } 
func ( da * dashboardagent ) getheadcontexts ( ghc githubclient , pr pullrequest ) ( [ ] context , error ) { org : = string ( pr . repository . owner . login ) repo : = string ( pr . repository . name ) combined , err : = ghc . getcombinedstatus ( org , repo , string ( pr . headrefoid ) ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } contexts : = make ( [ ] context , 0 , len ( combined . statuses ) ) for , status : = range combined . statuses { contexts = append ( contexts , context { context : status . context , description : status . description , state : strings . toupper ( status . state ) , } , ) } return contexts , nil } 
func ( da * dashboardagent ) constructsearchquery ( login string ) string { tokens : = [ ] string { " " , " " , " " + login } for i : = range da . repos { tokens = append ( tokens , fmt . sprintf ( " " " " , da . repos [ i ] ) ) } return strings . join ( tokens , " " ) } 
func loadclusterconfigs ( kubeconfig , buildcluster string ) ( map [ string ] rest . config , error ) { logrus . infof ( " " ) localcfg , err : = localconfig ( ) if err ! = nil { logrus . witherror ( err ) . warn ( " " ) } kubecfgs , currentcontext , err : = kubeconfigs ( kubeconfig ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } buildcfgs , err : = buildconfigs ( buildcluster ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return mergeconfigs ( localcfg , kubecfgs , currentcontext , buildcfgs ) } 
func newbundledstates ( description string ) bundledstates { return bundledstates { description : description , states : map [ string ] state { } , } } 
func ( b bundledstates ) receiveevent ( id string , eventname , label string , t time . time ) bool { state , ok : = b . states [ id ] if ! ok { state = newstate ( b . description ) } state , changed : = state . receiveevent ( eventname , label , t ) b . states [ id ] = state return changed } 
func ( b bundledstates ) ages ( t time . time ) map [ string ] time . duration { ages : = map [ string ] time . duration { } for id , state : = range b . states { if ! state . active ( ) { continue } ages [ id ] = state . age ( t ) } return ages } 
func ( b bundledstates ) total ( t time . time ) ( count int , sum int64 ) { for , age : = range b . ages ( t ) { count ++ sum += int64 ( age / time . minute ) } return } 
func ( b bundledstates ) percentile ( t time . time , percentile int ) time . duration { if percentile > 100 | | percentile <= 0 { panic ( fmt . errorf ( " " , percentile ) ) } ages : = [ ] time . duration { } for , age : = range b . ages ( t ) { ages = append ( ages , age ) } if len ( ages ) == 0 { return 0 } sort . sort ( byduration ( ages ) ) index : = int ( math . ceil ( float64 ( percentile ) * float64 ( len ( ages ) ) / 100 ) - 1 ) if index >= len ( ages ) { panic ( fmt . errorf ( " " , index , len ( ages ) ) ) } return ages [ index ] } 
func newmetrics ( ) * metrics { return & metrics { clientmetrics : & clientmetrics { requests : requests , requestretries : requestretries , requestlatency : requestlatency , } , resyncperiod : resyncperiod , } } 
func newgroup ( gitattributescontent func ( ) ( [ ] byte , error ) ) ( * group , error ) { g : = & group { linguistgeneratedpatterns : [ ] pattern { } , } bs , err : = gitattributescontent ( ) if err ! = nil { switch err . ( type ) { case * github . filenotfound : return g , nil default : return nil , fmt . errorf ( " " , err ) } } if err : = g . load ( bytes . newbuffer ( bs ) ) ; err ! = nil { return nil , err } return g , nil } 
func ( g * group ) load ( r io . reader ) error { s : = bufio . newscanner ( r ) for s . scan ( ) { l : = strings . trimspace ( s . text ( ) ) if l == " " | | l [ 0 ] == { continue } fs : = strings . fields ( l ) if len ( fs ) < 2 { continue } attributes : = sets . newstring ( fs [ 1 : ] ... ) if attributes . has ( " " ) { p , err : = parsepattern ( fs [ 0 ] ) if err ! = nil { return fmt . errorf ( " " , err ) } g . linguistgeneratedpatterns = append ( g . linguistgeneratedpatterns , p ) } } if err : = s . err ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func handle ( log * logrus . entry , ghc githubclient , cp commentpruner , ie * github . issueevent , mentionre * regexp . regexp ) error { if ! shouldreact ( mentionre , ie ) { return nil } org : = ie . repo . owner . login repo : = ie . repo . name number : = ie . issue . number hassiglabel : = hassiglabel ( ie . issue . labels ) hasneedssiglabel : = github . haslabel ( labels . needssig , ie . issue . labels ) if hassiglabel && hasneedssiglabel { if err : = ghc . removelabel ( org , repo , number , labels . needssig ) ; err ! = nil { log . witherror ( err ) . errorf ( " " , labels . needssig ) } botname , err : = ghc . botname ( ) if err ! = nil { return fmt . errorf ( " " , err ) } cp . prunecomments ( shouldprune ( log , botname ) ) } else if ! hassiglabel && ! hasneedssiglabel { if err : = ghc . addlabel ( org , repo , number , labels . needssig ) ; err ! = nil { log . witherror ( err ) . errorf ( " " , labels . needssig ) } msg : = plugins . formatresponse ( ie . issue . user . login , needssigmessage , needssigdetails ) if err : = ghc . createcomment ( org , repo , number , msg ) ; err ! = nil { log . witherror ( err ) . error ( " " ) } } return nil } 
func shouldprune ( log * logrus . entry , botname string ) func ( github . issuecomment ) bool { return func ( comment github . issuecomment ) bool { if comment . user . login ! = botname { return false } return strings . contains ( comment . body , needssigmessage ) } } 
func newdiskcache ( delegate http . roundtripper , cachedir string , cachesizegb , maxconcurrency int ) http . roundtripper { return newfromcache ( delegate , diskcache . newwithdiskv ( diskv . new ( diskv . options { basepath : path . join ( cachedir , " " ) , tempdir : path . join ( cachedir , " " ) , cachesizemax : uint64 ( cachesizegb ) * uint64 ( 1000000000 ) , } ) ) , maxconcurrency , ) } 
func newmemcache ( delegate http . roundtripper , maxconcurrency int ) http . roundtripper { return newfromcache ( delegate , httpcache . newmemorycache ( ) , maxconcurrency ) } 
func ( c * clientset ) prowv1 ( ) prowv1 . prowv1interface { return & fakeprowv1 . fakeprowv1 { fake : & c . fake } } 
func ( c * clientset ) prow ( ) prowv1 . prowv1interface { return & fakeprowv1 . fakeprowv1 { fake : & c . fake } } 
func newowners ( log * logrus . entry , filenames [ ] string , r repo , s int64 ) owners { return owners { filenames : filenames , repo : r , seed : s , log : log } } 
func ( o owners ) getapprovers ( ) map [ string ] sets . string { ownerstoapprovers : = map [ string ] sets . string { } for fn : = range o . getownersset ( ) { ownerstoapprovers [ fn ] = o . repo . approvers ( fn ) } return ownerstoapprovers } 
func ( o owners ) getleafapprovers ( ) map [ string ] sets . string { ownerstoapprovers : = map [ string ] sets . string { } for fn : = range o . getownersset ( ) { ownerstoapprovers [ fn ] = o . repo . leafapprovers ( fn ) } return ownerstoapprovers } 
func ( o owners ) getallpotentialapprovers ( ) [ ] string { approversonly : = [ ] string { } for , approverlist : = range o . getleafapprovers ( ) { for approver : = range approverlist { approversonly = append ( approversonly , approver ) } } sort . strings ( approversonly ) if len ( approversonly ) == 0 { o . log . debug ( " " ) } return approversonly } 
func ( o owners ) getreversemap ( approvers map [ string ] sets . string ) map [ string ] sets . string { approverownersfiles : = map [ string ] sets . string { } for ownersfile , approvers : = range approvers { for approver : = range approvers { if , ok : = approverownersfiles [ approver ] ; ok { approverownersfiles [ approver ] . insert ( ownersfile ) } else { approverownersfiles [ approver ] = sets . newstring ( ownersfile ) } } } return approverownersfiles } 
func ( o owners ) temporaryunapprovedfiles ( approvers sets . string ) sets . string { ap : = newapprovers ( o ) for approver : = range approvers { ap . addapprover ( approver , " " , false ) } return ap . unapprovedfiles ( ) } 
func ( o owners ) keepcoveringapprovers ( reversemap map [ string ] sets . string , knownapprovers sets . string , potentialapprovers [ ] string ) sets . string { if len ( potentialapprovers ) == 0 { o . log . debug ( " " ) } keptapprovers : = sets . newstring ( ) unapproved : = o . temporaryunapprovedfiles ( knownapprovers ) for , suggestedapprover : = range o . getsuggestedapprovers ( reversemap , potentialapprovers ) . list ( ) { if reversemap [ suggestedapprover ] . intersection ( unapproved ) . len ( ) ! = 0 { keptapprovers . insert ( suggestedapprover ) } } return keptapprovers } 
func ( o owners ) getsuggestedapprovers ( reversemap map [ string ] sets . string , potentialapprovers [ ] string ) sets . string { ap : = newapprovers ( o ) for ! ap . requirementsmet ( ) { newapprover : = findmostcoveringapprover ( potentialapprovers , reversemap , ap . unapprovedfiles ( ) ) if newapprover == " " { o . log . warnf ( " " , ap . unapprovedfiles ( ) . list ( ) ) return ap . getcurrentapproversset ( ) } ap . addapprover ( newapprover , " " , false ) } return ap . getcurrentapproversset ( ) } 
func ( o owners ) getownersset ( ) sets . string { owners : = sets . newstring ( ) for , fn : = range o . filenames { owners . insert ( o . repo . findapproverownersforfile ( fn ) ) } o . removesubdirs ( owners ) return owners } 
func ( o owners ) getshuffledapprovers ( ) [ ] string { approverslist : = o . getallpotentialapprovers ( ) order : = rand . new ( rand . newsource ( o . seed ) ) . perm ( len ( approverslist ) ) people : = make ( [ ] string , 0 , len ( approverslist ) ) for , i : = range order { people = append ( people , approverslist [ i ] ) } return people } 
func ( o owners ) removesubdirs ( dirs sets . string ) { canonicalize : = func ( p string ) string { if p == " " { return " " } return p } for , dir : = range dirs . list ( ) { path : = dir for { if o . repo . isnoparentowners ( path ) | | canonicalize ( path ) == " " { break } path = filepath . dir ( path ) if dirs . has ( canonicalize ( path ) ) { dirs . delete ( dir ) break } } } } 
func ( a approval ) string ( ) string { return fmt . sprintf ( ' * < a href= " %s " title= " %s " > %s < / a > * ' , a . reference , a . how , a . login , ) } 
func intersectsetscase ( one , other sets . string ) sets . string { lower : = sets . newstring ( ) for item : = range other { lower . insert ( strings . tolower ( item ) ) } intersection : = sets . newstring ( ) for item : = range one { if lower . has ( strings . tolower ( item ) ) { intersection . insert ( item ) } } return intersection } 
func newapprovers ( owners owners ) approvers { return approvers { owners : owners , approvers : map [ string ] approval { } , assignees : sets . newstring ( ) , manuallyapproved : func ( ) bool { return false } , } } 
func ( ap * approvers ) shouldnotoverrideapproval ( login string , noissue bool ) bool { login = strings . tolower ( login ) approval , alreadyapproved : = ap . approvers [ login ] return alreadyapproved && approval . noissue && ! noissue } 
func ( ap * approvers ) addlgtmer ( login , reference string , noissue bool ) { if ap . shouldnotoverrideapproval ( login , noissue ) { return } ap . approvers [ strings . tolower ( login ) ] = approval { login : login , how : " " , reference : reference , noissue : noissue , } } 
func ( ap * approvers ) removeapprover ( login string ) { delete ( ap . approvers , strings . tolower ( login ) ) } 
func ( ap * approvers ) addassignees ( logins ... string ) { for , login : = range logins { ap . assignees . insert ( strings . tolower ( login ) ) } } 
func ( ap approvers ) getcurrentapproversset ( ) sets . string { currentapprovers : = sets . newstring ( ) for approver : = range ap . approvers { currentapprovers . insert ( approver ) } return currentapprovers } 
func ( ap approvers ) getcurrentapproverssetcased ( ) sets . string { currentapprovers : = sets . newstring ( ) for , approval : = range ap . approvers { currentapprovers . insert ( approval . login ) } return currentapprovers } 
func ( ap approvers ) getnoissueapproversset ( ) sets . string { approvers : = sets . newstring ( ) for approver : = range ap . noissueapprovers ( ) { approvers . insert ( approver ) } return approvers } 
func ( ap approvers ) getfilesapprovers ( ) map [ string ] sets . string { filesapprovers : = map [ string ] sets . string { } currentapprovers : = ap . getcurrentapproverssetcased ( ) for fn , potentialapprovers : = range ap . owners . getapprovers ( ) { filesapprovers [ fn ] = intersectsetscase ( currentapprovers , potentialapprovers ) } return filesapprovers } 
func ( ap approvers ) noissueapprovers ( ) map [ string ] approval { nia : = map [ string ] approval { } reversemap : = ap . owners . getreversemap ( ap . owners . getapprovers ( ) ) for login , approver : = range ap . approvers { if ! approver . noissue { continue } if len ( reversemap [ login ] ) == 0 { continue } nia [ login ] = approver } return nia } 
func ( ap approvers ) unapprovedfiles ( ) sets . string { unapproved : = sets . newstring ( ) for fn , approvers : = range ap . getfilesapprovers ( ) { if len ( approvers ) == 0 { unapproved . insert ( fn ) } } return unapproved } 
func ( ap approvers ) getfiles ( baseurl * url . url , branch string ) [ ] file { allownersfiles : = [ ] file { } filesapprovers : = ap . getfilesapprovers ( ) for , file : = range ap . owners . getownersset ( ) . list ( ) { if len ( filesapprovers [ file ] ) == 0 { allownersfiles = append ( allownersfiles , unapprovedfile { baseurl : baseurl , filepath : file , branch : branch , } ) } else { allownersfiles = append ( allownersfiles , approvedfile { baseurl : baseurl , filepath : file , approvers : filesapprovers [ file ] , branch : branch , } ) } } return allownersfiles } 
func ( ap approvers ) getccs ( ) [ ] string { randomizedapprovers : = ap . owners . getshuffledapprovers ( ) currentapprovers : = ap . getcurrentapproversset ( ) approversandassignees : = currentapprovers . union ( ap . assignees ) leafreversemap : = ap . owners . getreversemap ( ap . owners . getleafapprovers ( ) ) suggested : = ap . owners . keepcoveringapprovers ( leafreversemap , approversandassignees , randomizedapprovers ) approversandsuggested : = currentapprovers . union ( suggested ) everyone : = approversandsuggested . union ( ap . assignees ) fullreversemap : = ap . owners . getreversemap ( ap . owners . getapprovers ( ) ) keepassignees : = ap . owners . keepcoveringapprovers ( fullreversemap , approversandsuggested , everyone . list ( ) ) return suggested . union ( keepassignees ) . list ( ) } 
func ( ap approvers ) requirementsmet ( ) bool { return ap . arefilesapproved ( ) && ( ! ap . requireissue | | ap . associatedissue ! = 0 | | len ( ap . noissueapprovers ( ) ) ! = 0 ) } 
func ( ap approvers ) isapproved ( ) bool { reqsmet : = ap . requirementsmet ( ) if ! reqsmet && ap . manuallyapproved ( ) { return true } return reqsmet } 
func ( ap approvers ) listapprovals ( ) [ ] approval { approvals : = [ ] approval { } for , approver : = range ap . getcurrentapproversset ( ) . list ( ) { approvals = append ( approvals , ap . approvers [ approver ] ) } return approvals } 
func ( ap approvers ) listnoissueapprovals ( ) [ ] approval { approvals : = [ ] approval { } for , approver : = range ap . getnoissueapproversset ( ) . list ( ) { approvals = append ( approvals , ap . approvers [ approver ] ) } return approvals } 
func generatetemplate ( templ , name string , data interface { } ) ( string , error ) { buf : = bytes . newbufferstring ( " " ) if messagetempl , err : = template . new ( name ) . parse ( templ ) ; err ! = nil { return " " , fmt . errorf ( " " , name , err ) } else if err : = messagetempl . execute ( buf , data ) ; err ! = nil { return " " , fmt . errorf ( " " , name , err ) } return buf . string ( ) , nil } 
func getmessage ( ap approvers , linkurl * url . url , org , repo , branch string ) * string { linkurl . path = org + " " + repo message , err : = generatetemplate ( + " " + + " " + + " " + + " " + , " " , map [ string ] interface { } { " " : ap , " " : linkurl , " " : org , " " : repo , " " : branch } ) if err ! = nil { ap . owners . log . witherror ( err ) . errorf ( " " ) return nil } message += getgubernatormetadata ( ap . getccs ( ) ) title , err : = generatetemplate ( " " , " " , ap ) if err ! = nil { ap . owners . log . witherror ( err ) . errorf ( " " ) return nil } return notification ( approvalnotificationname , title , message ) } 
func getgubernatormetadata ( tobeassigned [ ] string ) string { bytes , err : = json . marshal ( map [ string ] [ ] string { " " : tobeassigned } ) if err == nil { return fmt . sprintf ( " \n " , bytes ) } return " " } 
func writetemplate ( templatepath string , outputpath string , data interface { } ) error { funcmap : = template . funcmap { " " : func ( input string ) string { return strings . replace ( input , " " , " " , - 1 ) } , } t , err : = template . new ( filepath . base ( templatepath ) ) . funcs ( funcmap ) . parsefiles ( templatepath ) if err ! = nil { return err } if ! pathexists ( outputpath ) { , err = os . create ( outputpath ) if err ! = nil { return err } } f , err : = os . openfile ( outputpath , os . o rdwr , 0644 ) if err ! = nil { return err } defer f . close ( ) f . truncate ( 0 ) err = t . execute ( f , data ) if err ! = nil { return err } return nil } 
func validate ( labels [ ] label , parent string , seen map [ string ] string ) ( map [ string ] string , error ) { newseen : = copystringmap ( seen ) for , l : = range labels { name : = strings . tolower ( l . name ) path : = parent + " " + name if other , present : = newseen [ name ] ; present { return newseen , fmt . errorf ( " " , name , path , other ) } newseen [ name ] = path if newseen , err : = validate ( l . previously , path , newseen ) ; err ! = nil { return newseen , err } if len ( l . description ) > 100 { return newseen , fmt . errorf ( " " , name ) } } return newseen , nil } 
func ( c configuration ) labels ( ) [ ] label { var labelarrays [ ] [ ] label labelarrays = append ( labelarrays , c . default . labels ) for , repo : = range c . repos { labelarrays = append ( labelarrays , repo . labels ) } labelmap : = make ( map [ string ] label ) for , labels : = range labelarrays { for , l : = range labels { name : = strings . tolower ( l . name ) if , ok : = labelmap [ name ] ; ! ok { labelmap [ name ] = l } } } var labels [ ] label for , label : = range labelmap { labels = append ( labels , label ) } sort . slice ( labels , func ( i , j int ) bool { return labels [ i ] . name < labels [ j ] . name } ) return labels } 
func ( c configuration ) validate ( orgs string ) error { seen , err : = validate ( c . default . labels , " " , make ( map [ string ] string ) ) if err ! = nil { return fmt . errorf ( " " , err ) } sortedorgs : = strings . split ( orgs , " " ) sort . strings ( sortedorgs ) for repo , repoconfig : = range c . repos { if , err : = validate ( repoconfig . labels , repo , seen ) ; err ! = nil { return fmt . errorf ( " " , err ) } if len ( orgs ) ! = 0 { data : = strings . split ( repo , " " ) if len ( data ) == 2 { if ! stringinsortedslice ( data [ 0 ] , sortedorgs ) { logrus . withfield ( " " , orgs ) . withfield ( " " , data [ 0 ] ) . withfield ( " " , repo ) . warn ( " " ) } } } } return nil } 
func labelsfortarget ( labels [ ] label , target labeltarget ) ( filteredlabels [ ] label ) { for , label : = range labels { if target == label . target { filteredlabels = append ( filteredlabels , label ) } } sort . slice ( filteredlabels , func ( i , j int ) bool { return filteredlabels [ i ] . name < filteredlabels [ j ] . name } ) return } 
func loadconfig ( path string , orgs string ) ( * configuration , error ) { if path == " " { return nil , errors . new ( " " ) } var c configuration data , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } if err = yaml . unmarshal ( data , & c ) ; err ! = nil { return nil , err } if err = c . validate ( orgs ) ; err ! = nil { return nil , err } return & c , nil } 
func getorg ( org string ) ( string , bool ) { data : = strings . split ( org , " " ) if len ( data ) == 2 && data [ 0 ] == " " { return data [ 1 ] , true } return org , false } 
func loadrepos ( org string , gc client ) ( [ ] string , error ) { org , isuser : = getorg ( org ) repos , err : = gc . getrepos ( org , isuser ) if err ! = nil { return nil , err } var rl [ ] string for , r : = range repos { if r . archived { continue } rl = append ( rl , r . name ) } return rl , nil } 
func loadlabels ( gc client , org string , repos [ ] string ) ( * repolabels , error ) { repochan : = make ( chan string , len ( repos ) ) for , repo : = range repos { repochan < - repo } close ( repochan ) wg : = sync . waitgroup { } wg . add ( maxconcurrentworkers ) labels : = make ( chan repolabels , len ( repos ) ) errchan : = make ( chan error , len ( repos ) ) for i : = 0 ; i < maxconcurrentworkers ; i ++ { go func ( repositories < - chan string ) { defer wg . done ( ) for repository : = range repositories { logrus . withfield ( " " , org ) . withfield ( " " , repository ) . info ( " " ) repolabels , err : = gc . getrepolabels ( org , repository ) if err ! = nil { logrus . withfield ( " " , org ) . withfield ( " " , repository ) . error ( " " ) errchan < - err } labels < - repolabels { repository : repolabels } } } ( repochan ) } wg . wait ( ) close ( labels ) close ( errchan ) rl : = repolabels { } for data : = range labels { for repo , repolabels : = range data { rl [ repo ] = repolabels } } var overallerr error if len ( errchan ) > 0 { var listerrs [ ] error for listerr : = range errchan { listerrs = append ( listerrs , listerr ) } overallerr = fmt . errorf ( " " , listerrs ) } return & rl , overallerr } 
func rename ( repo string , previous , wanted label ) update { logrus . withfield ( " " , repo ) . withfield ( " " , previous . name ) . withfield ( " " , wanted . name ) . info ( " " ) return update { why : " " , current : & previous , wanted : & wanted , repo : repo } } 
func change ( repo string , label label ) update { logrus . withfield ( " " , repo ) . withfield ( " " , label . name ) . withfield ( " " , label . color ) . info ( " " ) return update { why : " " , current : & label , wanted : & label , repo : repo } } 
func classifylabels ( labels [ ] label , required , archaic , dead map [ string ] label , now time . time , parent * label ) ( map [ string ] label , map [ string ] label , map [ string ] label ) { newrequired : = copylabelmap ( required ) newarchaic : = copylabelmap ( archaic ) newdead : = copylabelmap ( dead ) for i , l : = range labels { first : = parent if first == nil { first = & labels [ i ] } lower : = strings . tolower ( l . name ) switch { case parent == nil && l . deleteafter == nil : newrequired [ lower ] = l case l . deleteafter ! = nil && now . after ( * l . deleteafter ) : newdead [ lower ] = l case parent ! = nil : l . parent = parent newarchaic [ lower ] = l } newrequired , newarchaic , newdead = classifylabels ( l . previously , newrequired , newarchaic , newdead , now , first ) } return newrequired , newarchaic , newdead } 
func parsecommadelimitedlist ( list string ) ( map [ string ] [ ] string , error ) { mapping : = map [ string ] [ ] string { } for , r : = range strings . split ( list , " " ) { value : = strings . trimspace ( r ) if strings . count ( value , " " ) ! = 1 { return nil , fmt . errorf ( " " , value ) } parts : = strings . splitn ( value , " " , 2 ) if others , exist : = mapping [ parts [ 0 ] ] ; ! exist { mapping [ parts [ 0 ] ] = [ ] string { parts [ 1 ] } } else { mapping [ parts [ 0 ] ] = append ( others , parts [ 1 ] ) } } return mapping , nil } 
func linkify ( text string ) string { link : = strings . replace ( text , " " , " " , - 1 ) discard , : = regexp . compile ( " " ) link = discard . replaceallstring ( link , " " ) return strings . tolower ( link ) } 
func newcache ( diskroot string ) * cache { return & cache { diskroot : strings . trimsuffix ( diskroot , string ( os . pathlistseparator ) ) , } } 
func ( c * cache ) keytopath ( key string ) string { return filepath . join ( c . diskroot , key ) } 
func ( c * cache ) pathtokey ( key string ) string { return strings . trimprefix ( key , c . diskroot + string ( os . pathseparator ) ) } 
func ( c * cache ) get ( key string , readhandler readhandler ) error { path : = c . keytopath ( key ) f , err : = os . open ( path ) if err ! = nil { if os . isnotexist ( err ) { return readhandler ( false , nil ) } return fmt . errorf ( " " , err ) } return readhandler ( true , f ) } 
func ( c * cache ) getentries ( ) [ ] entryinfo { entries : = [ ] entryinfo { } = filepath . walk ( c . diskroot , func ( path string , f os . fileinfo , err error ) error { if err ! = nil { logrus . witherror ( err ) . error ( " " ) return nil } if ! f . isdir ( ) { atime : = diskutil . getatime ( path , time . now ( ) ) entries = append ( entries , entryinfo { path : path , lastaccess : atime , } ) } return nil } ) return entries } 
func ( c * cache ) delete ( key string ) error { return os . remove ( c . keytopath ( key ) ) } 
func newgcsartifact ( ctx context . context , handle artifacthandle , link string , path string , sizelimit int64 ) * gcsartifact { return & gcsartifact { handle : handle , link : link , path : path , sizelimit : sizelimit , ctx : ctx , } } 
func ( a * gcsartifact ) size ( ) ( int64 , error ) { attrs , err : = a . handle . attrs ( a . ctx ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } return attrs . size , nil } 
func ( a * gcsartifact ) readat ( p [ ] byte , off int64 ) ( n int , err error ) { gzipped , err : = a . gzipped ( ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } if gzipped { return 0 , lenses . errgzipoffsetread } artifactsize , err : = a . size ( ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } if off >= artifactsize { return 0 , fmt . errorf ( " " ) } var goteof bool toread : = int64 ( len ( p ) ) if toread + off > artifactsize { return 0 , fmt . errorf ( " " ) } else if toread + off == artifactsize { goteof = true } reader , err : = a . handle . newrangereader ( a . ctx , off , toread ) defer reader . close ( ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } offset : = 0 for offset < len ( p ) { n , err = reader . read ( p [ offset : ] ) offset += n if err ! = nil { if err == io . eof && goteof { break } return 0 , fmt . errorf ( " " , err ) } } if goteof { return offset , io . eof } return offset , nil } 
func ( a * gcsartifact ) readatmost ( n int64 ) ( [ ] byte , error ) { var reader io . readcloser var p [ ] byte gzipped , err : = a . gzipped ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if gzipped { reader , err = a . handle . newreader ( a . ctx ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } defer reader . close ( ) p , err = ioutil . readall ( reader ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } artifactsize : = int64 ( len ( p ) ) readrange : = n if n > artifactsize { readrange = artifactsize return p [ : readrange ] , io . eof } return p [ : readrange ] , nil } artifactsize , err : = a . size ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } readrange : = n var goteof bool if n > artifactsize { goteof = true readrange = artifactsize } reader , err = a . handle . newrangereader ( a . ctx , 0 , readrange ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } defer reader . close ( ) p , err = ioutil . readall ( reader ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if goteof { return p , io . eof } return p , nil } 
func ( a * gcsartifact ) readall ( ) ( [ ] byte , error ) { size , err : = a . size ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if size > a . sizelimit { return nil , lenses . errfiletoolarge } reader , err : = a . handle . newreader ( a . ctx ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } defer reader . close ( ) p , err : = ioutil . readall ( reader ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return p , nil } 
func ( a * gcsartifact ) readtail ( n int64 ) ( [ ] byte , error ) { gzipped , err : = a . gzipped ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if gzipped { return nil , lenses . errgzipoffsetread } size , err : = a . size ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } var offset int64 if n >= size { offset = 0 } else { offset = size - n } reader , err : = a . handle . newrangereader ( a . ctx , offset , - 1 ) defer reader . close ( ) if err ! = nil && err ! = io . eof { return nil , fmt . errorf ( " " , err ) } read , err : = ioutil . readall ( reader ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return read , nil } 
func ( a * gcsartifact ) gzipped ( ) ( bool , error ) { attrs , err : = a . handle . attrs ( a . ctx ) if err ! = nil { return false , fmt . errorf ( " " , err ) } return attrs . contentencoding == " " , nil } 
func optionsforrepo ( config * plugins . configuration , org , repo string ) * plugins . welcome { fullname : = fmt . sprintf ( " " , org , repo ) for , c : = range config . welcome { if ! strinslice ( fullname , c . repos ) { continue } return & c } for , c : = range config . welcome { if ! strinslice ( org , c . repos ) { continue } return & c } return & plugins . welcome { } } 
func ( s * prowjoblister ) list ( selector labels . selector ) ( ret [ ] * v1 . prowjob , err error ) { err = cache . listall ( s . indexer , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . prowjob ) ) } ) return ret , err } 
func ( s * prowjoblister ) prowjobs ( namespace string ) prowjobnamespacelister { return prowjobnamespacelister { indexer : s . indexer , namespace : namespace } } 
func ( s prowjobnamespacelister ) list ( selector labels . selector ) ( ret [ ] * v1 . prowjob , err error ) { err = cache . listallbynamespace ( s . indexer , s . namespace , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . prowjob ) ) } ) return ret , err } 
func metadatafromfilename ( filename string ) ( string , map [ string ] string ) { metadata : = make ( map [ string ] string ) segments : = strings . split ( filename , " " ) index : = len ( segments ) - 1 segment : = segments [ index ] switch segment { case " " , " " : metadata [ " " ] = " " } if , ok : = metadata [ " " ] ; ok { if index == 0 { segment = " " } else { filename = filename [ : len ( filename ) - len ( segment ) - 1 ] index - = 1 segment = segments [ index ] } } if segment ! = " " { mediatype : = mime . typebyextension ( " " + segment ) if mediatype ! = " " { metadata [ " " ] = mediatype } } if , ok : = metadata [ " " ] ; ! ok { if , ok : = metadata [ " " ] ; ok { metadata [ " " ] = " " delete ( metadata , " " ) } } return filename , metadata } 
func ( br brancher ) runsagainstallbranch ( ) bool { return len ( br . skipbranches ) == 0 && len ( br . branches ) == 0 } 
func ( br brancher ) shouldrun ( branch string ) bool { if br . runsagainstallbranch ( ) { return true } if len ( br . skipbranches ) ! = 0 && br . reskip . matchstring ( branch ) { return false } if len ( br . branches ) == 0 | | br . re . matchstring ( branch ) { return true } return false } 
func ( br brancher ) intersects ( other brancher ) bool { if br . runsagainstallbranch ( ) | | other . runsagainstallbranch ( ) { return true } if len ( br . branches ) > 0 { basebranches : = sets . newstring ( br . branches ... ) if len ( other . branches ) > 0 { otherbranches : = sets . newstring ( other . branches ... ) if basebranches . intersection ( otherbranches ) . len ( ) > 0 { return true } return false } for , b : = range basebranches . list ( ) { if other . shouldrun ( b ) { return true } } return false } if len ( other . branches ) == 0 { return true } return other . intersects ( br ) } 
func ( cm regexpchangematcher ) shouldrun ( changes changedfilesprovider ) ( determined bool , shouldrun bool , err error ) { if cm . couldrun ( ) { changelist , err : = changes ( ) if err ! = nil { return true , false , err } return true , cm . runsagainstchanges ( changelist ) , nil } return false , false , nil } 
func ( cm regexpchangematcher ) runsagainstchanges ( changes [ ] string ) bool { for , change : = range changes { if cm . rechanges . matchstring ( change ) { return true } } return false } 
func ( ps postsubmit ) couldrun ( baseref string ) bool { return ps . brancher . shouldrun ( baseref ) } 
func ( ps postsubmit ) shouldrun ( baseref string , changes changedfilesprovider ) ( bool , error ) { if ! ps . couldrun ( baseref ) { return false , nil } if determined , shouldrun , err : = ps . regexpchangematcher . shouldrun ( changes ) ; err ! = nil { return false , err } else if determined { return shouldrun , nil } return true , nil } 
func ( ps presubmit ) couldrun ( baseref string ) bool { return ps . brancher . shouldrun ( baseref ) } 
func ( ps presubmit ) shouldrun ( baseref string , changes changedfilesprovider , forced , defaults bool ) ( bool , error ) { if ! ps . couldrun ( baseref ) { return false , nil } if ps . alwaysrun { return true , nil } if forced { return true , nil } if determined , shouldrun , err : = ps . regexpchangematcher . shouldrun ( changes ) ; err ! = nil { return false , err } else if determined { return shouldrun , nil } return defaults , nil } 
func ( ps presubmit ) triggermatches ( body string ) bool { return ps . trigger ! = " " && ps . re . matchstring ( body ) } 
func newgithubdeferredchangedfilesprovider ( client githubclient , org , repo string , num int ) changedfilesprovider { var changedfiles [ ] string return func ( ) ( [ ] string , error ) { if changedfiles == nil { changes , err : = client . getpullrequestchanges ( org , repo , num ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } for , change : = range changes { changedfiles = append ( changedfiles , change . filename ) } } return changedfiles , nil } } 
func ( c * jobconfig ) getpresubmit ( repo , jobname string ) * presubmit { presubmits : = c . allpresubmits ( [ ] string { repo } ) for i : = range presubmits { ps : = presubmits [ i ] if ps . name == jobname { return & ps } } return nil } 
func ( c * jobconfig ) setpresubmits ( jobs map [ string ] [ ] presubmit ) error { nj : = map [ string ] [ ] presubmit { } for k , v : = range jobs { nj [ k ] = make ( [ ] presubmit , len ( v ) ) copy ( nj [ k ] , v ) if err : = setpresubmitregexes ( nj [ k ] ) ; err ! = nil { return err } } c . presubmits = nj return nil } 
func ( c * jobconfig ) setpostsubmits ( jobs map [ string ] [ ] postsubmit ) error { nj : = map [ string ] [ ] postsubmit { } for k , v : = range jobs { nj [ k ] = make ( [ ] postsubmit , len ( v ) ) copy ( nj [ k ] , v ) if err : = setpostsubmitregexes ( nj [ k ] ) ; err ! = nil { return err } } c . postsubmits = nj return nil } 
func ( c * jobconfig ) allpresubmits ( repos [ ] string ) [ ] presubmit { var res [ ] presubmit for repo , v : = range c . presubmits { if len ( repos ) == 0 { res = append ( res , v ... ) } else { for , r : = range repos { if r == repo { res = append ( res , v ... ) break } } } } return res } 
func ( c * jobconfig ) allpostsubmits ( repos [ ] string ) [ ] postsubmit { var res [ ] postsubmit for repo , v : = range c . postsubmits { if len ( repos ) == 0 { res = append ( res , v ... ) } else { for , r : = range repos { if r == repo { res = append ( res , v ... ) break } } } } return res } 
func ( c * jobconfig ) allperiodics ( ) [ ] periodic { var listperiodic func ( ps [ ] periodic ) [ ] periodic listperiodic = func ( ps [ ] periodic ) [ ] periodic { var res [ ] periodic for , p : = range ps { res = append ( res , p ) } return res } return listperiodic ( c . periodics ) } 
func clearcompiledregexes ( presubmits [ ] presubmit ) { for i : = range presubmits { presubmits [ i ] . re = nil presubmits [ i ] . brancher . re = nil presubmits [ i ] . brancher . reskip = nil presubmits [ i ] . regexpchangematcher . rechanges = nil } } 
func ( s * simpleconfig ) empty ( ) bool { return len ( s . approvers ) == 0 && len ( s . reviewers ) == 0 && len ( s . requiredreviewers ) == 0 && len ( s . labels ) == 0 } 
func newclient ( gc * git . client , ghc * github . client , mdyamlenabled func ( org , repo string ) bool , skipcollaborators func ( org , repo string ) bool , ownersdirblacklist func ( ) prowconf . ownersdirblacklist , ) * client { return & client { git : gc , ghc : ghc , logger : logrus . withfield ( " " , " " ) , cache : make ( map [ string ] cacheentry ) , mdyamlenabled : mdyamlenabled , skipcollaborators : skipcollaborators , ownersdirblacklist : ownersdirblacklist , } } 
func ( c * client ) loadrepoaliases ( org , repo , base string ) ( repoaliases , error ) { log : = c . logger . withfields ( logrus . fields { " " : org , " " : repo , " " : base } ) cloneref : = fmt . sprintf ( " " , org , repo ) fullname : = fmt . sprintf ( " " , cloneref , base ) sha , err : = c . ghc . getref ( org , repo , fmt . sprintf ( " " , base ) ) if err ! = nil { return nil , fmt . errorf ( " " , fullname , err ) } c . lock . lock ( ) defer c . lock . unlock ( ) entry , ok : = c . cache [ fullname ] if ! ok | | entry . sha ! = sha { gitrepo , err : = c . git . clone ( cloneref ) if err ! = nil { return nil , fmt . errorf ( " " , cloneref , err ) } defer gitrepo . clean ( ) if err : = gitrepo . checkout ( base ) ; err ! = nil { return nil , err } entry . aliases = loadaliasesfrom ( gitrepo . dir , log ) entry . sha = sha c . cache [ fullname ] = entry } return entry . aliases , nil } 
func ( a repoaliases ) expandalias ( alias string ) sets . string { if a == nil { return nil } return a [ github . normlogin ( alias ) ] } 
func ( a repoaliases ) expandaliases ( logins sets . string ) sets . string { if a == nil { return logins } logins = logins . union ( nil ) for , login : = range logins . list ( ) { if expanded : = a . expandalias ( login ) ; len ( expanded ) > 0 { logins . delete ( login ) logins = logins . union ( expanded ) } } return logins } 
func parsefullconfig ( b [ ] byte ) ( fullconfig , error ) { full : = new ( fullconfig ) err : = yaml . unmarshal ( b , full ) return * full , err } 
func parsesimpleconfig ( b [ ] byte ) ( simpleconfig , error ) { simple : = new ( simpleconfig ) err : = yaml . unmarshal ( b , simple ) return * simple , err } 
func decodeownersmdconfig ( path string , config * simpleconfig ) error { filebytes , err : = ioutil . readfile ( path ) if err ! = nil { return err } meta : = mdstructuredheaderregex . findstring ( string ( filebytes ) ) return yaml . unmarshal ( [ ] byte ( meta ) , & config ) } 
func findownersforfile ( log * logrus . entry , path string , ownermap map [ string ] map [ * regexp . regexp ] sets . string ) string { d : = path for ; d ! = basedirconvention ; d = canonicalize ( filepath . dir ( d ) ) { relative , err : = filepath . rel ( d , path ) if err ! = nil { log . witherror ( err ) . withfield ( " " , path ) . errorf ( " " , d ) return " " } for re , n : = range ownermap [ d ] { if re ! = nil && ! re . matchstring ( relative ) { continue } if len ( n ) ! = 0 { return d } } } return " " } 
func ( o * repoowners ) findapproverownersforfile ( path string ) string { return findownersforfile ( o . log , path , o . approvers ) } 
func ( o * repoowners ) findreviewersownersforfile ( path string ) string { return findownersforfile ( o . log , path , o . reviewers ) } 
func ( o * repoowners ) findlabelsforfile ( path string ) sets . string { return o . entriesforfile ( path , o . labels , false ) } 
func ( o * repoowners ) isnoparentowners ( path string ) bool { return o . options [ path ] . noparentowners } 
func ( o * repoowners ) entriesforfile ( path string , people map [ string ] map [ * regexp . regexp ] sets . string , leafonly bool ) sets . string { d : = path if ! o . enablemdyaml | | ! strings . hassuffix ( path , " " ) { d = filepath . dir ( d ) d = canonicalize ( path ) } out : = sets . newstring ( ) for { relative , err : = filepath . rel ( d , path ) if err ! = nil { o . log . witherror ( err ) . withfield ( " " , path ) . errorf ( " " , d ) return nil } for re , s : = range people [ d ] { if re == nil | | re . matchstring ( relative ) { out . insert ( s . list ( ) ... ) } } if leafonly && out . len ( ) > 0 { break } if d == basedirconvention { break } if o . options [ d ] . noparentowners { break } d = filepath . dir ( d ) d = canonicalize ( d ) } return out } 
func ( o * repoowners ) leafapprovers ( path string ) sets . string { return o . entriesforfile ( path , o . approvers , true ) } 
func ( o * repoowners ) approvers ( path string ) sets . string { return o . entriesforfile ( path , o . approvers , false ) } 
func ( o * repoowners ) leafreviewers ( path string ) sets . string { return o . entriesforfile ( path , o . reviewers , true ) } 
func ( o * repoowners ) reviewers ( path string ) sets . string { return o . entriesforfile ( path , o . reviewers , false ) } 
func ( o * repoowners ) requiredreviewers ( path string ) sets . string { return o . entriesforfile ( path , o . requiredreviewers , false ) } 
func ( c * coverage ) ratio ( ) float32 { if c . numallstmts == 0 { return 1 } return float32 ( c . numcoveredstmts ) / float32 ( c . numallstmts ) } 
func ( pe * periodicprowjobevent ) frompayload ( data [ ] byte ) error { if err : = json . unmarshal ( data , pe ) ; err ! = nil { return err } return nil } 
func ( pe * periodicprowjobevent ) tomessage ( ) ( * pubsub . message , error ) { data , err : = json . marshal ( pe ) if err ! = nil { return nil , err } message : = pubsub . message { data : data , attributes : map [ string ] string { proweventtype : periodicprowjobevent , } , } return & message , nil } 
func ( p * privacy ) unmarshaltext ( text [ ] byte ) error { v : = privacy ( text ) if , ok : = privacysettings [ v ] ; ! ok { return fmt . errorf ( " " , v ) } * p = v return nil } 
func compileapplicableblockades ( org , repo string , log * logrus . entry , blockades [ ] plugins . blockade ) [ ] blockade { if len ( blockades ) == 0 { return nil } orgrepo : = fmt . sprintf ( " " , org , repo ) var compiled [ ] blockade for , raw : = range blockades { if ! stringinslice ( org , raw . repos ) && ! stringinslice ( orgrepo , raw . repos ) { continue } b : = blockade { } for , str : = range raw . blockregexps { if reg , err : = regexp . compile ( str ) ; err ! = nil { log . witherror ( err ) . errorf ( " " , str ) } else { b . blockregexps = append ( b . blockregexps , reg ) } } if len ( b . blockregexps ) == 0 { continue } if raw . explanation == " " { b . explanation = " " } else { b . explanation = raw . explanation } for , str : = range raw . exceptionregexps { if reg , err : = regexp . compile ( str ) ; err ! = nil { log . witherror ( err ) . errorf ( " " , str ) } else { b . exceptionregexps = append ( b . exceptionregexps , reg ) } } compiled = append ( compiled , b ) } return compiled } 
func calculateblocks ( changes [ ] github . pullrequestchange , blockades [ ] blockade ) summary { sum : = make ( summary ) for , change : = range changes { for , b : = range blockades { if b . isblocked ( change . filename ) { sum [ b . explanation ] = append ( sum [ b . explanation ] , change ) } } } return sum } 
func mergeprofiles ( a [ ] * cover . profile , b [ ] * cover . profile ) ( [ ] * cover . profile , error ) { var result [ ] * cover . profile files : = make ( map [ string ] * cover . profile , len ( a ) ) for , profile : = range a { np : = deepcopyprofile ( * profile ) result = append ( result , & np ) files [ np . filename ] = & np } needssort : = false for , profile : = range b { dest , ok : = files [ profile . filename ] if ok { if err : = ensureprofilesmatch ( profile , dest ) ; err ! = nil { return nil , fmt . errorf ( " " , profile . filename , err ) } for i , block : = range profile . blocks { db : = & dest . blocks [ i ] db . count += block . count } } else { np : = deepcopyprofile ( * profile ) files [ np . filename ] = & np result = append ( result , & np ) needssort = true } } if needssort { sort . slice ( result , func ( i , j int ) bool { return result [ i ] . filename < result [ j ] . filename } ) } return result , nil } 
func mergemultipleprofiles ( profiles [ ] [ ] * cover . profile ) ( [ ] * cover . profile , error ) { if len ( profiles ) < 1 { return nil , errors . new ( " " ) } result : = profiles [ 0 ] for , profile : = range profiles [ 1 : ] { var err error if result , err = mergeprofiles ( result , profile ) ; err ! = nil { return nil , err } } return result , nil } 
func ( a * authorloggerpluginwrapper ) addflags ( cmd * cobra . command ) { cmd . flags ( ) . boolvar ( & a . enabled , " " , false , " " ) } 
func ( a * authorloggerpluginwrapper ) receiveissue ( issue sql . issue ) [ ] point { points : = a . plugin . receiveissue ( issue ) if a . enabled { for i : = range points { if points [ i ] . values == nil { points [ i ] . values = map [ string ] interface { } { } } points [ i ] . values [ " " ] = issue . user } } return points } 
func ( a * authorloggerpluginwrapper ) receiveissueevent ( event sql . issueevent ) [ ] point { points : = a . plugin . receiveissueevent ( event ) if a . enabled { for i : = range points { if points [ i ] . values == nil { points [ i ] . values = map [ string ] interface { } { } } if event . actor ! = nil { points [ i ] . values [ " " ] = * event . actor } } } return points } 
func ( a * authorloggerpluginwrapper ) receivecomment ( comment sql . comment ) [ ] point { points : = a . plugin . receivecomment ( comment ) if a . enabled { for i : = range points { if points [ i ] . values == nil { points [ i ] . values = map [ string ] interface { } { } } points [ i ] . values [ " " ] = comment . user } } return points } 
func ( o * options ) addflags ( fs * flag . flagset ) { fs . stringvar ( & o . processlog , " " , " " , " " ) fs . stringvar ( & o . markerfile , " " , " " , " " ) fs . stringvar ( & o . metadatafile , " " , " " , " " ) } 
func ( o * options ) validate ( ) error { if o . processlog == " " { return errors . new ( " " ) } if o . markerfile == " " { return errors . new ( " " ) } return nil } 
func ( c * controller ) processnextitem ( ) bool { key , quit : = c . queue . get ( ) if quit { return false } defer c . queue . done ( key ) workitem : = key . ( item ) prowjob , err : = c . prowjobclient . getprowjob ( workitem . prowjobid ) if err ! = nil { c . handleerr ( err , workitem ) return true } spec : = downwardapi . newjobspec ( prowjob . spec , prowjob . status . buildid , prowjob . name ) result : = c . client . pods ( workitem . namespace ) . getlogs ( workitem . podname , & api . podlogoptions { container : workitem . containername } ) . do ( ) if err : = result . error ( ) ; err ! = nil { c . handleerr ( err , workitem ) return true } log , : = result . raw ( ) var target string if workitem . podname == workitem . prowjobid { target = path . join ( containerlogdir , fmt . sprintf ( " " , workitem . containername ) ) } else { target = path . join ( containerlogdir , workitem . podname , fmt . sprintf ( " " , workitem . containername ) ) } data : = gcs . dataupload ( bytes . newreader ( log ) ) if err : = c . gcsconfig . run ( & spec , map [ string ] gcs . uploadfunc { target : data } ) ; err ! = nil { c . handleerr ( err , workitem ) return true } c . queue . forget ( key ) return true } 
func ( c * controller ) handleerr ( err error , key item ) { if c . queue . numrequeues ( key ) < 5 { glog . infof ( " " , key . containername , key . podname , err ) c . queue . addratelimited ( key ) return } c . queue . forget ( key ) glog . infof ( " " , key . containername , key . podname , err ) } 
func commandfilter ( body string ) filter { return func ( p config . presubmit ) ( bool , bool , bool ) { return p . triggermatches ( body ) , p . triggermatches ( body ) , true } } 
func aggregatefilter ( filters [ ] filter ) filter { return func ( presubmit config . presubmit ) ( bool , bool , bool ) { for , filter : = range filters { if shouldrun , forced , defaults : = filter ( presubmit ) ; shouldrun { return shouldrun , forced , defaults } } return false , false , false } } 
func filterpresubmits ( filter filter , changes config . changedfilesprovider , branch string , presubmits [ ] config . presubmit , logger * logrus . entry ) ( [ ] config . presubmit , [ ] config . presubmit , error ) { var totrigger [ ] config . presubmit var toskip [ ] config . presubmit for , presubmit : = range presubmits { matches , forced , defaults : = filter ( presubmit ) if ! matches { continue } shouldrun , err : = presubmit . shouldrun ( branch , changes , forced , defaults ) if err ! = nil { return nil , nil , err } if shouldrun { totrigger = append ( totrigger , presubmit ) } else { toskip = append ( toskip , presubmit ) } } logger . withfields ( logrus . fields { " " : totrigger , " " : toskip } ) . debugf ( " " , len ( presubmits ) , len ( totrigger ) , len ( toskip ) ) return totrigger , toskip , nil } 
func makecommand ( ) * cobra . command { flags : = & flags { } cmd : = & cobra . command { use : " " , short : " " , long : ' filters a go coverage file , removing entries that do not match the given flags . ' , run : func ( cmd * cobra . command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . flags ( ) . stringvarp ( & flags . outputfile , " " , " " , " " , " " ) cmd . flags ( ) . stringslicevar ( & flags . includepaths , " " , nil , " " ) cmd . flags ( ) . stringslicevar ( & flags . excludepaths , " " , nil , " " ) return cmd } 
func ( t * eventtimeheap ) push ( x interface { } ) { * t = append ( * t , x . ( sql . issueevent ) ) } 
func ( t * eventtimeheap ) pop ( ) interface { } { old : = * t n : = len ( old ) x : = old [ n - 1 ] * t = old [ 0 : n - 1 ] return x } 
func newfakeopenpluginwrapper ( plugin plugin ) * fakeopenpluginwrapper { return & fakeopenpluginwrapper { plugin : plugin , alreadyopen : map [ string ] bool { } , } } 
func ( o * fakeopenpluginwrapper ) receiveissue ( issue sql . issue ) [ ] point { if , ok : = o . alreadyopen [ issue . id ] ; ! ok { heap . push ( & o . openevents , sql . issueevent { event : " " , issueid : issue . id , actor : & issue . user , eventcreatedat : issue . issuecreatedat , } ) o . alreadyopen [ issue . id ] = true } return o . plugin . receiveissue ( issue ) } 
func ( o * fakeopenpluginwrapper ) receiveissueevent ( event sql . issueevent ) [ ] point { points : = [ ] point { } for o . openevents . len ( ) > 0 && ! o . openevents [ 0 ] . eventcreatedat . after ( event . eventcreatedat ) { points = append ( points , o . plugin . receiveissueevent ( heap . pop ( & o . openevents ) . ( sql . issueevent ) ) ... ) } return append ( points , o . plugin . receiveissueevent ( event ) ... ) } 
func ( o * fakeopenpluginwrapper ) receivecomment ( comment sql . comment ) [ ] point { return o . plugin . receivecomment ( comment ) } 
func ( o * options ) validate ( ) error { if o . srcroot == " " { return errors . new ( " " ) } if o . log == " " { return errors . new ( " " ) } if len ( o . gitrefs ) == 0 { return errors . new ( " " ) } seen : = map [ string ] sets . string { } for , ref : = range o . gitrefs { if , seenorg : = seen [ ref . org ] ; seenorg { if seen [ ref . org ] . has ( ref . repo ) { return errors . new ( " " ) } seen [ ref . org ] . insert ( ref . repo ) } else { seen [ ref . org ] = sets . newstring ( ref . repo ) } } return nil } 
func ( o * options ) complete ( args [ ] string ) { o . gitrefs = o . refs . gitrefs o . keyfiles = o . keys . data for , ref : = range o . gitrefs { alias , err : = o . clonepath . execute ( orgrepo { org : ref . org , repo : ref . repo } ) if err ! = nil { panic ( err ) } ref . pathalias = alias alias , err = o . cloneuri . execute ( orgrepo { org : ref . org , repo : ref . repo } ) if err ! = nil { panic ( err ) } ref . cloneuri = alias } } 
func ( o * options ) addflags ( fs * flag . flagset ) { fs . stringvar ( & o . srcroot , " " , " " , " " ) fs . stringvar ( & o . log , " " , " " , " " ) fs . stringvar ( & o . gitusername , " " , defaultgitusername , " " ) fs . stringvar ( & o . gituseremail , " " , defaultgituseremail , " " ) fs . var ( & o . refs , " " , " " ) fs . var ( & o . keys , " " , " " ) fs . var ( & o . clonepath , " " , " " ) fs . var ( & o . cloneuri , " " , " " ) fs . intvar ( & o . maxparallelworkers , " " , 0 , " " ) fs . stringvar ( & o . cookiepath , " " , " " , " " ) } 
func ( r * gitrefs ) set ( value string ) error { gitref , err : = parserefs ( value ) if err ! = nil { return err } r . gitrefs = append ( r . gitrefs , * gitref ) return nil } 
func ( r * stringslice ) set ( value string ) error { r . data = append ( r . data , value ) return nil } 
func ( a * orgrepoformat ) set ( value string ) error { templ , err : = template . new ( " " ) . parse ( value ) if err ! = nil { return err } a . raw = value a . format = templ return nil } 
func ensure ( binary , install string ) error { if , err : = exec . lookpath ( binary ) ; err ! = nil { return fmt . errorf ( " " , binary , install ) } return nil } 
func output ( args ... string ) ( string , error ) { cmd : = exec . command ( args [ 0 ] , args [ 1 : ] ... ) cmd . stderr = os . stderr cmd . stdin = os . stdin b , err : = cmd . output ( ) return strings . trimspace ( string ( b ) ) , err } 
func projects ( max int ) ( [ ] string , error ) { out , err : = output ( " " , " " , " " , fmt . sprintf ( " " , max ) , " " ) if err ! = nil { return nil , err } return strings . split ( out , " \n " ) , nil } 
func currentclusters ( proj string ) ( map [ string ] cluster , error ) { clusters , err : = output ( " " , " " , " " , " " , " " + proj , " " ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } options : = map [ string ] cluster { } for , line : = range strings . split ( clusters , " \n " ) { if len ( line ) == 0 { continue } parts : = strings . split ( line , " \ t " ) if len ( parts ) ! = 2 { return nil , fmt . errorf ( " " , line ) } c : = cluster { name : parts [ 0 ] , zone : parts [ 1 ] , project : proj } options [ c . name ] = c } return options , nil } 
func createcluster ( proj , choice string ) ( * cluster , error ) { const def = " " if choice == " " { fmt . printf ( " " , def ) fmt . scanln ( & choice ) if choice == " " { choice = def } } cmd : = exec . command ( " " , " " , " " , " " , choice ) cmd . stdin = os . stdin cmd . stdout = os . stdout cmd . stderr = os . stderr if err : = cmd . run ( ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } out , err : = output ( " " , " " , " " , " " , choice , " " ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } parts : = strings . split ( out , " \ t " ) if len ( parts ) ! = 2 { return nil , fmt . errorf ( " " , out ) } return & cluster { name : parts [ 0 ] , zone : parts [ 1 ] , project : proj } , nil } 
func contextconfig ( ) ( clientcmd . clientconfigloader , * clientcmdapi . config , error ) { if err : = ensurekubectl ( ) ; err ! = nil { fmt . println ( " " ) fmt . println ( " " , err ) if gerr : = ensuregcloud ( ) ; gerr ! = nil { fmt . println ( " " , gerr ) } return nil , nil , errors . new ( " " ) } l : = clientcmd . newdefaultclientconfigloadingrules ( ) c , err : = l . load ( ) return l , c , err } 
func applycreate ( ctx string , args ... string ) error { create : = exec . command ( " " , append ( [ ] string { " " , " " , " " } , args ... ) ... ) create . stderr = os . stderr obj , err : = create . stdoutpipe ( ) if err ! = nil { return fmt . errorf ( " " , err ) } if err : = create . start ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } if err : = apply ( ctx , obj ) ; err ! = nil { return fmt . errorf ( " " , err ) } if err : = create . wait ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func filterpresubmits ( honoroktotest bool , githubclient githubclient , body string , pr * github . pullrequest , presubmits [ ] config . presubmit , logger * logrus . entry ) ( [ ] config . presubmit , [ ] config . presubmit , error ) { org , repo , sha : = pr . base . repo . owner . login , pr . base . repo . name , pr . head . sha filter , err : = presubmitfilter ( honoroktotest , githubclient , body , org , repo , sha , logger ) if err ! = nil { return nil , nil , err } number , branch : = pr . number , pr . base . ref changes : = config . newgithubdeferredchangedfilesprovider ( githubclient , org , repo , number ) totrigger , toskipsuperset , err : = pjutil . filterpresubmits ( filter , changes , branch , presubmits , logger ) if err ! = nil { return nil , nil , err } toskip : = determineskippedpresubmits ( totrigger , toskipsuperset , logger ) return totrigger , toskip , err } 
func determineskippedpresubmits ( totrigger , toskipsuperset [ ] config . presubmit , logger * logrus . entry ) [ ] config . presubmit { triggeredcontexts : = sets . newstring ( ) for , presubmit : = range totrigger { triggeredcontexts . insert ( presubmit . context ) } var toskip [ ] config . presubmit for , presubmit : = range toskipsuperset { if triggeredcontexts . has ( presubmit . context ) { logger . withfields ( logrus . fields { " " : presubmit . context , " " : presubmit . name } ) . debug ( " " ) continue } toskip = append ( toskip , presubmit ) } return toskip } 
func diffprofiles ( before [ ] * cover . profile , after [ ] * cover . profile ) ( [ ] * cover . profile , error ) { var diff [ ] * cover . profile if len ( before ) ! = len ( after ) { return nil , fmt . errorf ( " " , len ( before ) , len ( after ) ) } for i , beforeprofile : = range before { afterprofile : = after [ i ] if err : = ensureprofilesmatch ( beforeprofile , afterprofile ) ; err ! = nil { return nil , fmt . errorf ( " " , i , err ) } diffprofile : = cover . profile { filename : beforeprofile . filename , mode : beforeprofile . mode } for j , beforeblock : = range beforeprofile . blocks { afterblock : = afterprofile . blocks [ j ] diffblock : = cover . profileblock { startline : beforeblock . startline , startcol : beforeblock . startcol , endline : beforeblock . endline , endcol : beforeblock . endcol , numstmt : beforeblock . numstmt , count : afterblock . count - beforeblock . count , } diffprofile . blocks = append ( diffprofile . blocks , diffblock ) } diff = append ( diff , & diffprofile ) } return diff , nil } 
func dispatch ( plugin plugins . plugin , db * influxdb , issues chan sql . issue , eventscommentschannel chan interface { } ) { for { var points [ ] plugins . point select { case issue , ok : = < - issues : if ! ok { return } points = plugin . receiveissue ( issue ) case event , ok : = < - eventscommentschannel : if ! ok { return } switch event : = event . ( type ) { case sql . issueevent : points = plugin . receiveissueevent ( event ) case sql . comment : points = plugin . receivecomment ( event ) default : glog . fatal ( " " , event ) } } for , point : = range points { if err : = db . push ( point . tags , point . values , point . date ) ; err ! = nil { glog . fatal ( " " , err ) } } } } 
func ( config * transformconfig ) run ( plugin plugins . plugin ) error { if err : = config . checkrootflags ( ) ; err ! = nil { return err } mysqldb , err : = config . mysqlconfig . createdatabase ( ) if err ! = nil { return err } influxdb , err : = config . influxconfig . createdatabase ( map [ string ] string { " " : config . repository } , config . metricname ) if err ! = nil { return err } fetcher : = newfetcher ( config . repository ) go dispatch ( plugin , influxdb , fetcher . issueschannel , fetcher . eventscommentschannel ) ticker : = time . tick ( time . hour / time . duration ( config . frequency ) ) for { if err : = fetcher . fetch ( mysqldb ) ; err ! = nil { return err } if err : = influxdb . pushbatchpoints ( ) ; err ! = nil { return err } if config . once { break } < - ticker } return nil } 
func ( a * authorfilterpluginwrapper ) addflags ( cmd * cobra . command ) { cmd . flags ( ) . stringslicevar ( & a . ignoredauthors , " " , [ ] string { } , " " ) } 
func ( a * authorfilterpluginwrapper ) receiveissue ( issue sql . issue ) [ ] point { if a . match ( issue . user ) { return nil } return a . plugin . receiveissue ( issue ) } 
func ( a * authorfilterpluginwrapper ) receiveissueevent ( event sql . issueevent ) [ ] point { if event . actor ! = nil && a . match ( * event . actor ) { return nil } return a . plugin . receiveissueevent ( event ) } 
func ( a * authorfilterpluginwrapper ) receivecomment ( comment sql . comment ) [ ] point { if a . match ( comment . user ) { return nil } return a . plugin . receivecomment ( comment ) } 
func ( c * client ) createissue ( org , repo , title , body string , labels , assignees [ ] string ) ( * github . issue , error ) { glog . infof ( " \n " , c . dryrun , title , labels , assignees ) if c . dryrun { return nil , nil } issue : = & github . issuerequest { title : & title , body : & body , } if len ( labels ) > 0 { issue . labels = & labels } if len ( assignees ) > 0 { issue . assignees = & assignees } var result * github . issue , err : = c . retry ( fmt . sprintf ( " " , title ) , func ( ) ( * github . response , error ) { var resp * github . response var err error result , resp , err = c . issueservice . create ( context . background ( ) , org , repo , issue ) return resp , err } , ) return result , err } 
func ( c * client ) createstatus ( owner , repo , ref string , status * github . repostatus ) ( * github . repostatus , error ) { glog . infof ( " " , c . dryrun , ref , * status . context , * status . state ) if c . dryrun { return nil , nil } var result * github . repostatus msg : = fmt . sprintf ( " " , ref ) , err : = c . retry ( msg , func ( ) ( * github . response , error ) { var resp * github . response var err error result , resp , err = c . reposervice . createstatus ( context . background ( ) , owner , repo , ref , status ) return resp , err } ) return result , err } 
func ( c * client ) foreachpr ( owner , repo string , opts * github . pullrequestlistoptions , continueonerror bool , mungepr prmungefunc ) error { var lastpage int , err : = c . depaginate ( " " , & opts . listoptions , func ( ) ( [ ] interface { } , * github . response , error ) { list , resp , err : = c . prservice . list ( context . background ( ) , owner , repo , opts ) if err == nil { for , pr : = range list { if pr == nil { glog . errorln ( " " ) } if mungeerr : = mungepr ( pr ) ; mungeerr ! = nil { if pr . number == nil { mungeerr = fmt . errorf ( " " , mungeerr ) } else { mungeerr = fmt . errorf ( " " , * pr . number , mungeerr ) } if ! continueonerror { return nil , resp , & retryabort { mungeerr } } glog . errorf ( " \n " , mungeerr ) } } if resp . lastpage > 0 { lastpage = resp . lastpage } glog . infof ( " \n " , opts . listoptions . page , lastpage ) } return nil , resp , err } , ) return err } 
func ( c * client ) getcollaborators ( org , repo string ) ( [ ] * github . user , error ) { opts : = & github . listcollaboratorsoptions { } collaborators , err : = c . depaginate ( fmt . sprintf ( " " , org , repo ) , & opts . listoptions , func ( ) ( [ ] interface { } , * github . response , error ) { page , resp , err : = c . reposervice . listcollaborators ( context . background ( ) , org , repo , opts ) var interfacelist [ ] interface { } if err == nil { interfacelist = make ( [ ] interface { } , 0 , len ( page ) ) for , user : = range page { interfacelist = append ( interfacelist , user ) } } return interfacelist , resp , err } , ) result : = make ( [ ] * github . user , 0 , len ( collaborators ) ) for , user : = range collaborators { result = append ( result , user . ( * github . user ) ) } return result , err } 
func ( c * client ) getcombinedstatus ( owner , repo , ref string ) ( * github . combinedstatus , error ) { var result * github . combinedstatus listopts : = & github . listoptions { } statuses , err : = c . depaginate ( fmt . sprintf ( " " , ref ) , listopts , func ( ) ( [ ] interface { } , * github . response , error ) { combined , resp , err : = c . reposervice . getcombinedstatus ( context . background ( ) , owner , repo , ref , listopts , ) if result == nil { result = combined } var interfacelist [ ] interface { } if err == nil { interfacelist = make ( [ ] interface { } , 0 , len ( combined . statuses ) ) for , status : = range combined . statuses { interfacelist = append ( interfacelist , status ) } } return interfacelist , resp , err } , ) if result ! = nil { result . statuses = make ( [ ] github . repostatus , 0 , len ( statuses ) ) for , status : = range statuses { result . statuses = append ( result . statuses , status . ( github . repostatus ) ) } } return result , err } 
func ( c * client ) getissues ( org , repo string , opts * github . issuelistbyrepooptions ) ( [ ] * github . issue , error ) { issues , err : = c . depaginate ( fmt . sprintf ( " " , org , repo ) , & opts . listoptions , func ( ) ( [ ] interface { } , * github . response , error ) { page , resp , err : = c . issueservice . listbyrepo ( context . background ( ) , org , repo , opts ) var interfacelist [ ] interface { } if err == nil { interfacelist = make ( [ ] interface { } , 0 , len ( page ) ) for , issue : = range page { interfacelist = append ( interfacelist , issue ) } } return interfacelist , resp , err } , ) result : = make ( [ ] * github . issue , 0 , len ( issues ) ) for , issue : = range issues { result = append ( result , issue . ( * github . issue ) ) } return result , err } 
func ( c * client ) getrepolabels ( org , repo string ) ( [ ] * github . label , error ) { opts : = & github . listoptions { } labels , err : = c . depaginate ( fmt . sprintf ( " " , org , repo ) , opts , func ( ) ( [ ] interface { } , * github . response , error ) { page , resp , err : = c . issueservice . listlabels ( context . background ( ) , org , repo , opts ) var interfacelist [ ] interface { } if err == nil { interfacelist = make ( [ ] interface { } , 0 , len ( page ) ) for , label : = range page { interfacelist = append ( interfacelist , label ) } } return interfacelist , resp , err } , ) result : = make ( [ ] * github . label , 0 , len ( labels ) ) for , label : = range labels { result = append ( result , label . ( * github . label ) ) } return result , err } 
func ( c * client ) getuser ( login string ) ( * github . user , error ) { var result * github . user , err : = c . retry ( fmt . sprintf ( " " , login ) , func ( ) ( * github . response , error ) { var resp * github . response var err error result , resp , err = c . userservice . get ( context . background ( ) , login ) return resp , err } , ) return result , err } 
func checkconfigvalidity ( ) error { glog . info ( " " ) if * nodename == " " { return fmt . errorf ( " " ) } if * gcspath == " " { return fmt . errorf ( " " ) } if , err : = os . stat ( * gcloudauthfilepath ) ; err ! = nil { return fmt . errorf ( " " , err ) } else { glog . infof ( " \n " , * gcloudauthfilepath ) cmd : = exec . command ( " " , " " , " " , " " + * gcloudauthfilepath ) var stderr , stdout bytes . buffer cmd . stderr , cmd . stdout = & stderr , & stdout err = cmd . run ( ) glog . infof ( " \n \n " , stdout . string ( ) ) glog . infof ( " \n \n " , stderr . string ( ) ) if err ! = nil { return fmt . errorf ( " " , err ) } } return nil } 
func createsystemdlogfile ( service string , outputmode string , outputdir string ) error { journalcmdargs : = [ ] string { fmt . sprintf ( " " , outputmode ) , " " , * journalpath } if service == " " { journalcmdargs = append ( journalcmdargs , " " ) } else { journalcmdargs = append ( journalcmdargs , " " , fmt . sprintf ( " " , service ) ) } cmd : = exec . command ( " " , journalcmdargs ... ) output , err : = cmd . output ( ) if err ! = nil { return fmt . errorf ( " " , service , err ) } logfile : = filepath . join ( outputdir , service + " " ) if err : = ioutil . writefile ( logfile , output , 0444 ) ; err ! = nil { return fmt . errorf ( " " , service , err ) } return nil } 
func createfullsystemdlogfile ( outputdir string ) error { cmd : = exec . command ( " " , " " , " " , * journalpath ) output , err : = cmd . output ( ) if err ! = nil { return fmt . errorf ( " " , err ) } logfile : = filepath . join ( outputdir , " " ) if err : = ioutil . writefile ( logfile , output , 0444 ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func createsystemdlogfiles ( outputdir string ) { services : = append ( systemdservices , nodesystemdservices ... ) for , service : = range services { if err : = createsystemdlogfile ( service , " " , outputdir ) ; err ! = nil { glog . warningf ( " " , err ) } } for , service : = range systemdsetupservices { if err : = createsystemdlogfile ( service , " " , outputdir ) ; err ! = nil { glog . warningf ( " " , err ) } } if * dumpsystemdjournal { if err : = createfullsystemdlogfile ( outputdir ) ; err ! = nil { glog . warningf ( " " , err ) } } } 
func preparelogfiles ( logdir string ) { glog . info ( " " ) logfiles : = nodelogs [ : ] switch * cloudprovider { case " " , " " : logfiles = append ( logfiles , gcelogs ... ) case " " : logfiles = append ( logfiles , awslogs ... ) default : glog . errorf ( " " , * cloudprovider ) } if * enablehollownodelogs { logfiles = append ( logfiles , kubemarklogs ... ) } if , err : = os . stat ( " " ) ; err == nil { glog . info ( " " ) createsystemdlogfiles ( logdir ) } else { glog . infof ( " " , err ) logfiles = append ( logfiles , kernellog ) logfiles = append ( logfiles , initdlogs ... ) logfiles = append ( logfiles , supervisordlogs ... ) } for , logfile : = range logfiles { logfilefullpath : = filepath . join ( locallogpath , logfile + " " ) cmd : = exec . command ( " " , " " , fmt . sprintf ( " " , logfilefullpath , logdir ) ) if err : = cmd . run ( ) ; err ! = nil { glog . warningf ( " " , logfilefullpath , err ) } } } 
func writesuccessmarkerfile ( ) error { markerfilepath : = * gcspath + " " + * nodename + " " cmd : = exec . command ( " " , " " , " " , " " , " " , " " , markerfilepath ) stdin , err : = cmd . stdinpipe ( ) if err ! = nil { return fmt . errorf ( " " , err ) } io . writestring ( stdin , " " ) stdin . close ( ) if err = cmd . run ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func makecommand ( ) * cobra . command { flags : = & flags { } cmd : = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . flags ( ) . stringvarp ( & flags . outputfile , " " , " " , " " , " " ) cmd . flags ( ) . float32varp ( & flags . threshold , " " , " " , . 8 , " " ) return cmd } 
func ( c * configuration ) mdyamlenabled ( org , repo string ) bool { full : = fmt . sprintf ( " " , org , repo ) for , elem : = range c . owners . mdyamlrepos { if elem == org | | elem == full { return true } } return false } 
func ( r requirematchinglabel ) validate ( ) error { if r . org == " " { return errors . new ( " " ) } if strings . contains ( r . repo , " " ) { return errors . new ( " " ) } if r . regexp == " " { return errors . new ( " " ) } if r . missinglabel == " " { return errors . new ( " " ) } if r . graceperiod == " " { return errors . new ( " " ) } if ! r . prs && ! r . issues { return errors . new ( " " ) } if ! r . prs && r . branch ! = " " { return errors . new ( " " ) } if r . re . matchstring ( r . missinglabel ) { return errors . new ( " " ) } return nil } 
func warndeprecated ( last * time . time , freq time . duration , msg string ) { warnlock . rlock ( ) fresh : = time . now ( ) . sub ( * last ) <= freq warnlock . runlock ( ) if fresh { return } warnlock . lock ( ) defer warnlock . unlock ( ) now : = time . now ( ) if now . sub ( * last ) <= freq { return } * last = now logrus . warn ( msg ) } 
func ( r requirematchinglabel ) describe ( ) string { str : = & strings . builder { } fmt . fprintf ( str , " " , r . missinglabel ) if r . missingcomment == " " { fmt . fprint ( str , " " ) } else { fmt . fprint ( str , " " ) } if r . issues { fmt . fprint ( str , " " ) if r . prs { fmt . fprint ( str , " " ) } } if r . prs { if r . branch ! = " " { fmt . fprintf ( str , " " , r . branch ) } fmt . fprint ( str , " " ) } if r . repo == " " { fmt . fprintf ( str , " " , r . org ) } else { fmt . fprintf ( str , " " , r . org , r . repo ) } fmt . fprintf ( str , " " , r . regexp ) return str . string ( ) } 
func ( c * configuration ) triggerfor ( org , repo string ) trigger { for , tr : = range c . triggers { for , r : = range tr . repos { if r == org | | r == fmt . sprintf ( " " , org , repo ) { return tr } } } return trigger { } } 
func ( c * configuration ) enabledreposforplugin ( plugin string ) ( orgs , repos [ ] string ) { for repo , plugins : = range c . plugins { found : = false for , candidate : = range plugins { if candidate == plugin { found = true break } } if found { if strings . contains ( repo , " " ) { repos = append ( repos , repo ) } else { orgs = append ( orgs , repo ) } } } return } 
func ( c * configuration ) enabledreposforexternalplugin ( plugin string ) ( orgs , repos [ ] string ) { for repo , plugins : = range c . externalplugins { found : = false for , candidate : = range plugins { if candidate . name == plugin { found = true break } } if found { if strings . contains ( repo , " " ) { repos = append ( repos , repo ) } else { orgs = append ( orgs , repo ) } } } return } 
func ( c * configupdater ) setdefaults ( ) { if len ( c . maps ) == 0 { cf : = c . configfile if cf == " " { cf = " " } else { logrus . warnf ( ' config file is deprecated , please switch to " maps " : { " %s " : " config " } before july 2018 ' , cf ) } pf : = c . pluginfile if pf == " " { pf = " " } else { logrus . warnf ( ' plugin file is deprecated , please switch to " maps " : { " %s " : " plugins " } before july 2018 ' , pf ) } c . maps = map [ string ] configmapspec { cf : { name : " " , } , pf : { name : " " , } , } } for name , spec : = range c . maps { spec . namespaces = append ( [ ] string { spec . namespace } , spec . additionalnamespaces ... ) c . maps [ name ] = spec } } 
func validateplugins ( plugins map [ string ] [ ] string ) error { var errors [ ] string for , configuration : = range plugins { for , plugin : = range configuration { if , ok : = pluginhelp [ plugin ] ; ! ok { errors = append ( errors , fmt . sprintf ( " " , plugin ) ) } } } for repo , repoconfig : = range plugins { if strings . contains ( repo , " " ) { org : = strings . split ( repo , " " ) [ 0 ] if dupes : = findduplicatedpluginconfig ( repoconfig , plugins [ org ] ) ; len ( dupes ) > 0 { errors = append ( errors , fmt . sprintf ( " " , dupes , repo , org ) ) } } } if len ( errors ) > 0 { return fmt . errorf ( " \n \ t " , strings . join ( errors , " \n \ t " ) ) } return nil } 
func newreporter ( cookiefilepath string , projects map [ string ] [ ] string , lister pjlister . prowjoblister ) ( * client , error ) { gc , err : = client . newclient ( projects ) if err ! = nil { return nil , err } gc . start ( cookiefilepath ) return & client { gc : gc , lister : lister , } , nil } 
func run ( refs prowapi . refs , dir , gitusername , gituseremail , cookiepath string , env [ ] string ) record { logrus . withfields ( logrus . fields { " " : refs } ) . info ( " " ) record : = record { refs : refs } runcommands : = func ( commands [ ] clonecommand ) error { for , command : = range commands { formattedcommand , output , err : = command . run ( ) logrus . withfields ( logrus . fields { " " : formattedcommand , " " : output , " " : err } ) . info ( " " ) message : = " " if err ! = nil { message = err . error ( ) record . failed = true } record . commands = append ( record . commands , command { command : formattedcommand , output : output , error : message } ) if err ! = nil { return err } } return nil } g : = gitctxforrefs ( refs , dir , env ) if err : = runcommands ( g . commandsforbaseref ( refs , gitusername , gituseremail , cookiepath ) ) ; err ! = nil { return record } timestamp , err : = g . githeadtimestamp ( ) if err ! = nil { timestamp = int ( time . now ( ) . unix ( ) ) } if err : = runcommands ( g . commandsforpullrefs ( refs , timestamp ) ) ; err ! = nil { return record } finalsha , err : = g . gitrevparse ( ) if err ! = nil { logrus . witherror ( err ) . warnf ( " " , refs ) } else { record . finalsha = finalsha } return record } 
func pathforrefs ( basedir string , refs prowapi . refs ) string { var clonepath string if refs . pathalias ! = " " { clonepath = refs . pathalias } else { clonepath = fmt . sprintf ( " " , refs . org , refs . repo ) } return fmt . sprintf ( " " , basedir , clonepath ) } 
func gitctxforrefs ( refs prowapi . refs , basedir string , env [ ] string ) gitctx { g : = gitctx { clonedir : pathforrefs ( basedir , refs ) , env : env , repositoryuri : fmt . sprintf ( " " , refs . org , refs . repo ) , } if refs . cloneuri ! = " " { g . repositoryuri = refs . cloneuri } return g } 
func ( g * gitctx ) commandsforbaseref ( refs prowapi . refs , gitusername , gituseremail , cookiepath string ) [ ] clonecommand { commands : = [ ] clonecommand { { dir : " " , env : g . env , command : " " , args : [ ] string { " " , g . clonedir } } } commands = append ( commands , g . gitcommand ( " " ) ) if gitusername ! = " " { commands = append ( commands , g . gitcommand ( " " , " " , gitusername ) ) } if gituseremail ! = " " { commands = append ( commands , g . gitcommand ( " " , " " , gituseremail ) ) } if cookiepath ! = " " { commands = append ( commands , g . gitcommand ( " " , " " , cookiepath ) ) } commands = append ( commands , g . gitcommand ( " " , g . repositoryuri , " " , " " ) ) commands = append ( commands , g . gitcommand ( " " , g . repositoryuri , refs . baseref ) ) var target string if refs . basesha ! = " " { target = refs . basesha } else { target = " " } commands = append ( commands , g . gitcommand ( " " , target ) ) commands = append ( commands , g . gitcommand ( " " , " " , refs . baseref , target ) ) commands = append ( commands , g . gitcommand ( " " , refs . baseref ) ) return commands } 
func ( g * gitctx ) githeadtimestamp ( ) ( int , error ) { gitshowcommand : = g . gitcommand ( " " , " " , " " , " " ) , gitoutput , err : = gitshowcommand . run ( ) if err ! = nil { logrus . witherror ( err ) . debug ( " " ) return 0 , err } timestamp , converr : = strconv . atoi ( string ( gitoutput ) ) if converr ! = nil { logrus . witherror ( converr ) . errorf ( " " , gitoutput ) return 0 , converr } return timestamp , nil } 
func gittimestampenvs ( timestamp int ) [ ] string { return [ ] string { fmt . sprintf ( " " , timestamp ) , fmt . sprintf ( " " , timestamp ) , } } 
func ( g * gitctx ) gitrevparse ( ) ( string , error ) { gitrevparsecommand : = g . gitcommand ( " " , " " ) , commit , err : = gitrevparsecommand . run ( ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) return " " , err } return strings . trimspace ( commit ) , nil } 
func ( g * gitctx ) commandsforpullrefs ( refs prowapi . refs , faketimestamp int ) [ ] clonecommand { var commands [ ] clonecommand for , prref : = range refs . pulls { ref : = fmt . sprintf ( " " , prref . number ) if prref . ref ! = " " { ref = prref . ref } commands = append ( commands , g . gitcommand ( " " , g . repositoryuri , ref ) ) var prcheckout string if prref . sha ! = " " { prcheckout = prref . sha } else { prcheckout = " " } faketimestamp ++ gitmergecommand : = g . gitcommand ( " " , " " , prcheckout ) gitmergecommand . env = append ( gitmergecommand . env , gittimestampenvs ( faketimestamp ) ... ) commands = append ( commands , gitmergecommand ) } if ! refs . skipsubmodules { commands = append ( commands , g . gitcommand ( " " , " " , " " , " " ) ) } return commands } 
func producecovlist ( profiles [ ] * cover . profile ) * coveragelist { covlist : = newcoveragelist ( " " ) for , prof : = range profiles { covlist . group = append ( covlist . group , summarizeblocks ( prof ) ) } return covlist } 
func poprandom ( set sets . string ) string { list : = set . list ( ) sort . strings ( list ) sel : = list [ rand . intn ( len ( list ) ) ] set . delete ( sel ) return sel } 
func ( o * experimentalkubernetesoptions ) addflags ( fs * flag . flagset ) { fs . stringvar ( & o . buildcluster , " " , " " , " " ) fs . stringvar ( & o . kubeconfig , " " , " " , " " ) fs . stringvar ( & o . deckuri , " " , " " , " " ) } 
func ( o * experimentalkubernetesoptions ) validate ( dryrun bool ) error { if dryrun && o . deckuri == " " { return errors . new ( " " ) } if o . deckuri ! = " " { if , err : = url . parserequesturi ( o . deckuri ) ; err ! = nil { return fmt . errorf ( " " , o . deckuri ) } } if o . kubeconfig ! = " " { if , err : = os . stat ( o . kubeconfig ) ; err ! = nil { return fmt . errorf ( " " , err ) } } if o . kubeconfig ! = " " && o . buildcluster ! = " " { return errors . new ( " " ) } return nil } 
func ( o * experimentalkubernetesoptions ) resolve ( dryrun bool ) ( err error ) { if o . resolved { return nil } o . dryrun = dryrun if dryrun { return nil } clusterconfigs , err : = kube . loadclusterconfigs ( o . kubeconfig , o . buildcluster ) if err ! = nil { return fmt . errorf ( " " , o . kubeconfig , o . buildcluster , err ) } clients : = map [ string ] kubernetes . interface { } for context , config : = range clusterconfigs { client , err : = kubernetes . newforconfig ( & config ) if err ! = nil { return fmt . errorf ( " " , context , err ) } clients [ context ] = client } localcfg : = clusterconfigs [ kube . inclustercontext ] pjclient , err : = prow . newforconfig ( & localcfg ) if err ! = nil { return err } o . prowjobclientset = pjclient o . kubernetesclientsbycontext = clients o . resolved = true return nil } 
func ( o * experimentalkubernetesoptions ) prowjobclientset ( namespace string , dryrun bool ) ( prowjobclientset prow . interface , err error ) { if err : = o . resolve ( dryrun ) ; err ! = nil { return nil , err } if o . dryrun { return nil , errors . new ( " " ) } return o . prowjobclientset , nil } 
func ( o * experimentalkubernetesoptions ) prowjobclient ( namespace string , dryrun bool ) ( prowjobclient prowv1 . prowjobinterface , err error ) { if err : = o . resolve ( dryrun ) ; err ! = nil { return nil , err } if o . dryrun { return kube . newdryrunprowjobclient ( o . deckuri ) , nil } return o . prowjobclientset . prowv1 ( ) . prowjobs ( namespace ) , nil } 
func ( o * experimentalkubernetesoptions ) infrastructureclusterclient ( dryrun bool ) ( kubernetesclient kubernetes . interface , err error ) { if err : = o . resolve ( dryrun ) ; err ! = nil { return nil , err } if o . dryrun { return nil , errors . new ( " " ) } return o . kubernetesclientsbycontext [ kube . inclustercontext ] , nil } 
func ( o * experimentalkubernetesoptions ) buildclusterclients ( namespace string , dryrun bool ) ( buildclusterclients map [ string ] corev1 . podinterface , err error ) { if err : = o . resolve ( dryrun ) ; err ! = nil { return nil , err } if o . dryrun { return nil , errors . new ( " " ) } buildclients : = map [ string ] corev1 . podinterface { } for context , client : = range o . kubernetesclientsbycontext { buildclients [ context ] = client . corev1 ( ) . pods ( namespace ) } return buildclients , nil } 
func ( a * activestate ) age ( t time . time ) time . duration { return t . sub ( a . starttime ) } 
func ( a * activestate ) receiveevent ( eventname , label string , t time . time ) ( state , bool ) { if a . exit . match ( eventname , label ) { return & inactivestate { entry : a . exit . opposite ( ) , } , true } return a , false } 
func ( i * inactivestate ) receiveevent ( eventname , label string , t time . time ) ( state , bool ) { if i . entry . match ( eventname , label ) { return & activestate { starttime : t , exit : i . entry . opposite ( ) , } , true } return i , false } 
func ( m * multistate ) active ( ) bool { for , state : = range m . states { if ! state . active ( ) { return false } } return true } 
func ( m * multistate ) age ( t time . time ) time . duration { minage : = time . duration ( 1 < < 63 - 1 ) for , state : = range m . states { stateage : = state . age ( t ) if stateage < minage { minage = stateage } } return minage } 
func ( m * multistate ) receiveevent ( eventname , label string , t time . time ) ( state , bool ) { onechanged : = false for i : = range m . states { state , changed : = m . states [ i ] . receiveevent ( eventname , label , t ) if changed { onechanged = true } m . states [ i ] = state } return m , onechanged } 
func newstate ( statesdescription string ) state { states : = [ ] state { } if statesdescription == " " { return & inactivestate { entry : falseevent { } , } } splitdescription : = strings . split ( statesdescription , " " ) for , description : = range splitdescription { description = strings . trimspace ( description ) if strings . hasprefix ( description , " " ) { states = append ( states , & activestate { starttime : time . time { } , exit : neweventmatcher ( description [ 1 : ] ) , } ) } else { states = append ( states , & inactivestate { entry : neweventmatcher ( description ) , } ) } } return & multistate { states : states } } 
func ( f * sharedinformerfactory ) forresource ( resource schema . groupversionresource ) ( genericinformer , error ) { switch resource { case v1 . schemegroupversion . withresource ( " " ) : return & genericinformer { resource : resource . groupresource ( ) , informer : f . prow ( ) . v1 ( ) . prowjobs ( ) . informer ( ) } , nil } return nil , fmt . errorf ( " " , resource ) } 
func ( v * version ) prowjobs ( ) prowjobinformer { return & prowjobinformer { factory : v . factory , namespace : v . namespace , tweaklistoptions : v . tweaklistoptions } } 
func itemtoresourcesconfig ( i item ) ( resourcesconfig , error ) { conf , ok : = i . ( resourcesconfig ) if ! ok { return resourcesconfig { } , fmt . errorf ( " " , i ) } return conf , nil } 
func ( t typetoresources ) copy ( ) typetoresources { n : = typetoresources { } for k , v : = range t { n [ k ] = v } return n } 
func makecommand ( ) * cobra . command { flags : = & flags { } cmd : = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . flags ( ) . stringvarp ( & flags . outputfile , " " , " " , " " , " " ) return cmd } 
func newcontroller ( kc * kube . client , pkcs map [ string ] * kube . client , ghc githubclient , logger * logrus . entry , cfg config . getter , toturl , selector string , skipreport bool ) ( * controller , error ) { if logger == nil { logger = logrus . newentry ( logrus . standardlogger ( ) ) } buildclusters : = map [ string ] kubeclient { } for alias , client : = range pkcs { buildclusters [ alias ] = kubeclient ( client ) } return & controller { kc : kc , pkcs : buildclusters , ghc : ghc , log : logger , config : cfg , pendingjobs : make ( map [ string ] int ) , toturl : toturl , selector : selector , skipreport : skipreport , } , nil } 
func ( c * controller ) incrementnumpendingjobs ( job string ) { c . lock . lock ( ) defer c . lock . unlock ( ) c . pendingjobs [ job ] ++ } 
func ( c * controller ) setpreviousreportstate ( pj prowapi . prowjob ) error { latestpj , err : = c . kc . getprowjob ( pj . objectmeta . name ) if err ! = nil { return err } if latestpj . status . prevreportstates == nil { latestpj . status . prevreportstates = map [ string ] prowapi . prowjobstate { } } latestpj . status . prevreportstates [ reporter . githubreportername ] = latestpj . status . state , err = c . kc . replaceprowjob ( latestpj . objectmeta . name , latestpj ) return err } 
func ( c * controller ) syncmetrics ( ) { c . pjlock . rlock ( ) defer c . pjlock . runlock ( ) kube . gatherprowjobmetrics ( c . pjs ) } 
func ( c * controller ) terminatedupes ( pjs [ ] prowapi . prowjob , pm map [ string ] coreapi . pod ) error { log : = c . log . withfield ( " " , " " ) return pjutil . terminateolderpresubmitjobs ( c . kc , log , pjs , func ( tocancel prowapi . prowjob ) error { if c . config ( ) . plank . allowcancellations { if pod , exists : = pm [ tocancel . objectmeta . name ] ; exists { if client , ok : = c . pkcs [ tocancel . clusteralias ( ) ] ; ! ok { return fmt . errorf ( " " , tocancel . clusteralias ( ) ) } else if err : = client . deletepod ( pod . objectmeta . name ) ; err ! = nil { return fmt . errorf ( " " , err ) } } } return nil } ) } 
func syncprowjobs ( l * logrus . entry , syncfn syncfn , maxsyncroutines int , jobs < - chan prowapi . prowjob , reports chan < - prowapi . prowjob , syncerrors chan < - error , pm map [ string ] coreapi . pod , ) { goroutines : = maxsyncroutines if goroutines > len ( jobs ) { goroutines = len ( jobs ) } wg : = & sync . waitgroup { } wg . add ( goroutines ) l . debugf ( " " , goroutines ) for i : = 0 ; i < goroutines ; i ++ { go func ( ) { defer wg . done ( ) for pj : = range jobs { if err : = syncfn ( pj , pm , reports ) ; err ! = nil { syncerrors < - err } } } ( ) } wg . wait ( ) } 
func ( c * controller ) startpod ( pj prowapi . prowjob ) ( string , string , error ) { buildid , err : = c . getbuildid ( pj . spec . job ) if err ! = nil { return " " , " " , fmt . errorf ( " " , err ) } pod , err : = decorate . prowjobtopod ( pj , buildid ) if err ! = nil { return " " , " " , err } client , ok : = c . pkcs [ pj . clusteralias ( ) ] if ! ok { return " " , " " , fmt . errorf ( " " , pj . clusteralias ( ) ) } actual , err : = client . createpod ( * pod ) if err ! = nil { return " " , " " , err } return buildid , actual . objectmeta . name , nil } 
func dumpprofile ( profiles [ ] * cover . profile , writer io . writer ) error { if len ( profiles ) == 0 { return errors . new ( " " ) } if , err : = io . writestring ( writer , " " + profiles [ 0 ] . mode + " \n " ) ; err ! = nil { return err } for , profile : = range profiles { for , block : = range profile . blocks { if , err : = fmt . fprintf ( writer , " \n " , profile . filename , block . startline , block . startcol , block . endline , block . endcol , block . numstmt , block . count ) ; err ! = nil { return err } } } return nil } 
func blocksequal ( a cover . profileblock , b cover . profileblock ) bool { return a . startcol == b . startcol && a . startline == b . startline && a . endcol == b . endcol && a . endline == b . endline && a . numstmt == b . numstmt } 
func newprowjobinformer ( client versioned . interface , namespace string , resyncperiod time . duration , indexers cache . indexers ) cache . sharedindexinformer { return newfilteredprowjobinformer ( client , namespace , resyncperiod , indexers , nil ) } 
func newfilteredprowjobinformer ( client versioned . interface , namespace string , resyncperiod time . duration , indexers cache . indexers , tweaklistoptions internalinterfaces . tweaklistoptionsfunc ) cache . sharedindexinformer { return cache . newsharedindexinformer ( & cache . listwatch { listfunc : func ( options metav1 . listoptions ) ( runtime . object , error ) { if tweaklistoptions ! = nil { tweaklistoptions ( & options ) } return client . prowv1 ( ) . prowjobs ( namespace ) . list ( options ) } , watchfunc : func ( options metav1 . listoptions ) ( watch . interface , error ) { if tweaklistoptions ! = nil { tweaklistoptions ( & options ) } return client . prowv1 ( ) . prowjobs ( namespace ) . watch ( options ) } , } , & prowjobsv1 . prowjob { } , resyncperiod , indexers , ) } 
func new ( ja * jobs . jobagent , cfg config . getter , c * storage . client , ctx context . context ) * spyglass { return & spyglass { jobagent : ja , config : cfg , podlogartifactfetcher : newpodlogartifactfetcher ( ja ) , gcsartifactfetcher : newgcsartifactfetcher ( c ) , testgrid : & testgrid { conf : cfg , client : c , ctx : ctx , } , } } 
func ( s * spyglass ) lenses ( matchcache map [ string ] [ ] string ) [ ] lenses . lens { ls : = [ ] lenses . lens { } for lensname , matches : = range matchcache { if len ( matches ) == 0 { continue } lens , err : = lenses . getlens ( lensname ) if err ! = nil { logrus . withfield ( " " , lens ) . witherror ( err ) . error ( " " ) } else { ls = append ( ls , lens ) } } sort . slice ( ls , func ( i , j int ) bool { iconf : = ls [ i ] . config ( ) jconf : = ls [ j ] . config ( ) iname : = iconf . name jname : = jconf . name pi : = iconf . priority pj : = jconf . priority if pi == pj { return iname < jname } return pi < pj } ) return ls } 
func ( s * spyglass ) runpath ( src string ) ( string , error ) { src = strings . trimsuffix ( src , " " ) keytype , key , err : = splitsrc ( src ) if err ! = nil { return " " , fmt . errorf ( " " , src ) } switch keytype { case gcskeytype : return key , nil case prowkeytype : return s . prowtogcs ( key ) default : return " " , fmt . errorf ( " " , src ) } } 
func ( sg * spyglass ) extralinks ( src string ) ( [ ] extralink , error ) { artifacts , err : = sg . fetchartifacts ( src , " " , 1000000 , [ ] string { " " } ) if err ! = nil | | len ( artifacts ) == 0 { logrus . witherror ( err ) . debugf ( " " ) return nil , nil } content , err : = artifacts [ 0 ] . readall ( ) if err ! = nil { return nil , err } started : = metadata . started { } if err : = json . unmarshal ( content , & started ) ; err ! = nil { return nil , err } links , ok : = started . metadata . meta ( " " ) if ! ok { return nil , nil } extralinks : = make ( [ ] extralink , 0 , len ( * links ) ) for , name : = range links . keys ( ) { m , ok : = links . meta ( name ) if ! ok { logrus . debugf ( " " , name , artifacts [ 0 ] . canonicallink ( ) ) continue } s : = m . strings ( ) link : = extralink { name : name , url : s [ " " ] , description : s [ " " ] , } if link . url == " " | | link . name == " " { continue } extralinks = append ( extralinks , link ) } return extralinks , nil } 
func ( s * server ) needdemux ( eventtype , srcrepo string ) [ ] plugins . externalplugin { var matching [ ] plugins . externalplugin srcorg : = strings . split ( srcrepo , " " ) [ 0 ] for repo , plugins : = range s . plugins . config ( ) . externalplugins { if repo ! = srcrepo && repo ! = srcorg { continue } for , p : = range plugins { if len ( p . events ) == 0 { matching = append ( matching , p ) } else { for , et : = range p . events { if et ! = eventtype { continue } matching = append ( matching , p ) break } } } } return matching } 
func ( s * server ) demuxexternal ( l * logrus . entry , externalplugins [ ] plugins . externalplugin , payload [ ] byte , h http . header ) { h . set ( " " , " " ) for , p : = range externalplugins { s . wg . add ( 1 ) go func ( p plugins . externalplugin ) { defer s . wg . done ( ) if err : = s . dispatch ( p . endpoint , payload , h ) ; err ! = nil { l . witherror ( err ) . withfield ( " " , p . name ) . error ( " " ) } else { l . withfield ( " " , p . name ) . info ( " " ) } } ( p ) } } 
func ( s * server ) dispatch ( endpoint string , payload [ ] byte , h http . header ) error { req , err : = http . newrequest ( http . methodpost , endpoint , bytes . newbuffer ( payload ) ) if err ! = nil { return err } req . header = h resp , err : = s . do ( req ) if err ! = nil { return err } defer resp . body . close ( ) rb , err : = ioutil . readall ( resp . body ) if err ! = nil { return err } if resp . statuscode < 200 | | resp . statuscode > 299 { return fmt . errorf ( " " , resp . status , string ( rb ) ) } return nil } 
func ( s * stateplugin ) addflags ( cmd * cobra . command ) { cmd . flags ( ) . stringvar ( & s . desc , " " , " " , " " ) cmd . flags ( ) . intslicevar ( & s . percentiles , " " , [ ] int { } , " " ) } 
func ( s * stateplugin ) checkflags ( ) error { s . states = newbundledstates ( s . desc ) return nil } 
func ( s * stateplugin ) receiveissueevent ( event sql . issueevent ) [ ] point { label : = " " if event . label ! = nil { label = * event . label } if ! s . states . receiveevent ( event . issueid , event . event , label , event . eventcreatedat ) { return nil } total , sum : = s . states . total ( event . eventcreatedat ) values : = map [ string ] interface { } { " " : total , " " : int ( sum ) , } for , percentile : = range s . percentiles { values [ fmt . sprintf ( " " , percentile ) ] = int ( s . states . percentile ( event . eventcreatedat , percentile ) ) } return [ ] point { { values : values , date : event . eventcreatedat , } , } } 
func ( ownersdirblacklist ownersdirblacklist ) dirblacklist ( org , repo string ) ( blacklist [ ] string ) { blacklist = append ( blacklist , ownersdirblacklist . default ... ) if bl , ok : = ownersdirblacklist . repos [ org ] ; ok { blacklist = append ( blacklist , bl ... ) } if bl , ok : = ownersdirblacklist . repos [ org + " " + repo ] ; ok { blacklist = append ( blacklist , bl ... ) } return } 
func load ( prowconfig , jobconfig string ) ( c * config , err error ) { defer func ( ) { if r : = recover ( ) ; r ! = nil { c , err = nil , fmt . errorf ( " " , r ) } } ( ) c , err = loadconfig ( prowconfig , jobconfig ) if err ! = nil { return nil , err } if err : = c . finalizejobconfig ( ) ; err ! = nil { return nil , err } if err : = c . validatecomponentconfig ( ) ; err ! = nil { return nil , err } if err : = c . validatejobconfig ( ) ; err ! = nil { return nil , err } return c , nil } 
func yamltoconfig ( path string , nc interface { } ) error { b , err : = readfilemaybegzip ( path ) if err ! = nil { return fmt . errorf ( " " , path , err ) } if err : = yaml . unmarshal ( b , nc ) ; err ! = nil { return fmt . errorf ( " " , path , err ) } var jc * jobconfig switch v : = nc . ( type ) { case * jobconfig : jc = v case * config : jc = & v . jobconfig } for rep : = range jc . presubmits { var fix func ( * presubmit ) fix = func ( job * presubmit ) { job . sourcepath = path } for i : = range jc . presubmits [ rep ] { fix ( & jc . presubmits [ rep ] [ i ] ) } } for rep : = range jc . postsubmits { var fix func ( * postsubmit ) fix = func ( job * postsubmit ) { job . sourcepath = path } for i : = range jc . postsubmits [ rep ] { fix ( & jc . postsubmits [ rep ] [ i ] ) } } var fix func ( * periodic ) fix = func ( job * periodic ) { job . sourcepath = path } for i : = range jc . periodics { fix ( & jc . periodics [ i ] ) } return nil } 
func readfilemaybegzip ( path string ) ( [ ] byte , error ) { b , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } if ! bytes . hasprefix ( b , [ ] byte ( " \ x1f \ x8b " ) ) { return b , nil } gzipreader , err : = gzip . newreader ( bytes . newbuffer ( b ) ) if err ! = nil { return nil , err } return ioutil . readall ( gzipreader ) } 
func ( c * config ) mergejobconfig ( jc jobconfig ) error { c . presets = append ( c . presets , jc . presets ... ) validlabels : = map [ string ] bool { } for , preset : = range c . presets { for label , val : = range preset . labels { pair : = label + " " + val if , ok : = validlabels [ pair ] ; ok { return fmt . errorf ( " " , pair ) } validlabels [ pair ] = true } } c . periodics = append ( c . periodics , jc . periodics ... ) if c . presubmits == nil { c . presubmits = make ( map [ string ] [ ] presubmit ) } for repo , jobs : = range jc . presubmits { c . presubmits [ repo ] = append ( c . presubmits [ repo ] , jobs ... ) } if c . postsubmits == nil { c . postsubmits = make ( map [ string ] [ ] postsubmit ) } for repo , jobs : = range jc . postsubmits { c . postsubmits [ repo ] = append ( c . postsubmits [ repo ] , jobs ... ) } return nil } 
func ( c * config ) validatecomponentconfig ( ) error { if c . plank . joburlprefix ! = " " && c . plank . joburlprefixconfig [ " " ] ! = " " { return errors . new ( ' planks job url prefix must be unset when job url prefix config [ " * " ] is set . the former is deprecated , use the latter ' ) } for k , v : = range c . plank . joburlprefixconfig { if , err : = url . parse ( v ) ; err ! = nil { return fmt . errorf ( ' invalid value for planks job url prefix config [ " %s " ] : % v ' , k , err ) } } if c . slackreporter ! = nil { if err : = c . slackreporter . defaultandvalidate ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } } return nil } 
func configpath ( value string ) string { if value ! = " " { return value } logrus . warningf ( " " , defaultconfigpath ) return defaultconfigpath } 
func validatecontroller ( c * controller ) error { urltmpl , err : = template . new ( " " ) . parse ( c . joburltemplatestring ) if err ! = nil { return fmt . errorf ( " " , err ) } c . joburltemplate = urltmpl reporttmpl , err : = template . new ( " " ) . parse ( c . reporttemplatestring ) if err ! = nil { return fmt . errorf ( " " , err ) } c . reporttemplate = reporttmpl if c . maxconcurrency < 0 { return fmt . errorf ( " " , c . maxconcurrency ) } if c . maxgoroutines == 0 { c . maxgoroutines = 20 } if c . maxgoroutines <= 0 { return fmt . errorf ( " " , c . maxgoroutines ) } return nil } 
func ( c * prowconfig ) defaultjobbase ( base * jobbase ) { if base . agent == " " { base . agent = string ( prowapi . kubernetesagent ) } if base . namespace == nil | | * base . namespace == " " { s : = c . podnamespace base . namespace = & s } if base . cluster == " " { base . cluster = kube . defaultclusteralias } } 
func setpresubmitregexes ( js [ ] presubmit ) error { for i , j : = range js { if re , err : = regexp . compile ( j . trigger ) ; err == nil { js [ i ] . re = re } else { return fmt . errorf ( " " , j . name , err ) } if ! js [ i ] . re . matchstring ( j . reruncommand ) { return fmt . errorf ( " " " " " " , j . name , j . reruncommand , j . trigger ) } b , err : = setbrancherregexes ( j . brancher ) if err ! = nil { return fmt . errorf ( " " , j . name , err ) } js [ i ] . brancher = b c , err : = setchangeregexes ( j . regexpchangematcher ) if err ! = nil { return fmt . errorf ( " " , j . name , err ) } js [ i ] . regexpchangematcher = c } return nil } 
func setbrancherregexes ( br brancher ) ( brancher , error ) { if len ( br . branches ) > 0 { if re , err : = regexp . compile ( strings . join ( br . branches , ' | ' ) ) ; err == nil { br . re = re } else { return br , fmt . errorf ( " " , err ) } } if len ( br . skipbranches ) > 0 { if re , err : = regexp . compile ( strings . join ( br . skipbranches , ' | ' ) ) ; err == nil { br . reskip = re } else { return br , fmt . errorf ( " " , err ) } } return br , nil } 
func setpostsubmitregexes ( ps [ ] postsubmit ) error { for i , j : = range ps { b , err : = setbrancherregexes ( j . brancher ) if err ! = nil { return fmt . errorf ( " " , j . name , err ) } ps [ i ] . brancher = b c , err : = setchangeregexes ( j . regexpchangematcher ) if err ! = nil { return fmt . errorf ( " " , j . name , err ) } ps [ i ] . regexpchangematcher = c } return nil } 
func newboskoshandler ( r * ranch . ranch ) * http . servemux { mux : = http . newservemux ( ) mux . handle ( " " , handledefault ( r ) ) mux . handle ( " " , handleacquire ( r ) ) mux . handle ( " " , handleacquirebystate ( r ) ) mux . handle ( " " , handlerelease ( r ) ) mux . handle ( " " , handlereset ( r ) ) mux . handle ( " " , handleupdate ( r ) ) mux . handle ( " " , handlemetric ( r ) ) return mux } 
func handledefault ( r * ranch . ranch ) http . handlerfunc { return func ( res http . responsewriter , req * http . request ) { logrus . withfield ( " " , " " ) . infof ( " " , req . remoteaddr ) } } 
func handlerelease ( r * ranch . ranch ) http . handlerfunc { return func ( res http . responsewriter , req * http . request ) { logrus . withfield ( " " , " " ) . infof ( " " , req . remoteaddr ) if req . method ! = http . methodpost { msg : = fmt . sprintf ( " " , req . method ) logrus . warning ( msg ) http . error ( res , msg , http . statusmethodnotallowed ) return } name : = req . url . query ( ) . get ( " " ) dest : = req . url . query ( ) . get ( " " ) owner : = req . url . query ( ) . get ( " " ) if name == " " | | dest == " " | | owner == " " { msg : = fmt . sprintf ( " " , name , dest , owner ) logrus . warning ( msg ) http . error ( res , msg , http . statusbadrequest ) return } if err : = r . release ( name , dest , owner ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , name , dest , owner ) http . error ( res , err . error ( ) , errortostatus ( err ) ) return } logrus . infof ( " " , name , dest ) } } 
func handlemetric ( r * ranch . ranch ) http . handlerfunc { return func ( res http . responsewriter , req * http . request ) { logrus . withfield ( " " , " " ) . infof ( " " , req . remoteaddr ) if req . method ! = http . methodget { logrus . warningf ( " " , req . method ) http . error ( res , " " , http . statusmethodnotallowed ) return } rtype : = req . url . query ( ) . get ( " " ) if rtype == " " { msg : = " " logrus . warning ( msg ) http . error ( res , msg , http . statusbadrequest ) return } metric , err : = r . metric ( rtype ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " , rtype ) http . error ( res , err . error ( ) , errortostatus ( err ) ) return } js , err : = json . marshal ( metric ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) http . error ( res , err . error ( ) , errortostatus ( err ) ) return } res . header ( ) . set ( " " , " " ) res . write ( js ) } } 
func dumpprofile ( destination string , profile [ ] * cover . profile ) error { var output io . writer if destination == " " { output = os . stdout } else { f , err : = os . create ( destination ) if err ! = nil { return fmt . errorf ( " " , destination , err ) } defer f . close ( ) output = f } err : = cov . dumpprofile ( profile , output ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func loadprofile ( origin string ) ( [ ] * cover . profile , error ) { filename : = origin if origin == " " { tf , err : = ioutil . tempfile ( " " , " " ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } defer tf . close ( ) defer os . remove ( tf . name ( ) ) if , err : = io . copy ( tf , os . stdin ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } filename = tf . name ( ) } return cover . parseprofiles ( filename ) } 
func newclient ( ) ( * client , error ) { g , err : = exec . lookpath ( " " ) if err ! = nil { return nil , err } t , err : = ioutil . tempdir ( " " , " " ) if err ! = nil { return nil , err } return & client { logger : logrus . withfield ( " " , " " ) , dir : t , git : g , base : fmt . sprintf ( " " , github ) , repolocks : make ( map [ string ] * sync . mutex ) , } , nil } 
func ( c * client ) setcredentials ( user string , tokengenerator func ( ) [ ] byte ) { c . credlock . lock ( ) defer c . credlock . unlock ( ) c . user = user c . tokengenerator = tokengenerator } 
func ( r * repo ) checkout ( commitlike string ) error { r . logger . infof ( " " , commitlike ) co : = r . gitcommand ( " " , commitlike ) if b , err : = co . combinedoutput ( ) ; err ! = nil { return fmt . errorf ( " " , commitlike , err , string ( b ) ) } return nil } 
func ( r * repo ) checkoutnewbranch ( branch string ) error { r . logger . infof ( " " , branch ) co : = r . gitcommand ( " " , " " , branch ) if b , err : = co . combinedoutput ( ) ; err ! = nil { return fmt . errorf ( " " , branch , err , string ( b ) ) } return nil } 
func ( r * repo ) merge ( commitlike string ) ( bool , error ) { r . logger . infof ( " " , commitlike ) co : = r . gitcommand ( " " , " " , " " , " " , commitlike ) b , err : = co . combinedoutput ( ) if err == nil { return true , nil } r . logger . witherror ( err ) . infof ( " " , string ( b ) ) if b , err : = r . gitcommand ( " " , " " ) . combinedoutput ( ) ; err ! = nil { return false , fmt . errorf ( " " , commitlike , err , string ( b ) ) } return false , nil } 
func ( r * repo ) am ( path string ) error { r . logger . infof ( " " , path ) co : = r . gitcommand ( " " , " " , path ) b , err : = co . combinedoutput ( ) if err == nil { return nil } output : = string ( b ) r . logger . witherror ( err ) . infof ( " " , output ) if b , aborterr : = r . gitcommand ( " " , " " ) . combinedoutput ( ) ; err ! = nil { r . logger . witherror ( aborterr ) . warningf ( " " , string ( b ) ) } applymsg : = " " if strings . contains ( output , applymsg ) { i : = strings . index ( output , applymsg ) err = fmt . errorf ( " " , output [ : i ] ) } return err } 
func ( r * repo ) checkoutpullrequest ( number int ) error { r . logger . infof ( " " , r . repo , number ) if b , err : = retrycmd ( r . logger , r . dir , r . git , " " , r . base + " " + r . repo , fmt . sprintf ( " " , number , number ) ) ; err ! = nil { return fmt . errorf ( " " , number , err , string ( b ) ) } co : = r . gitcommand ( " " , fmt . sprintf ( " " , number ) ) if b , err : = co . combinedoutput ( ) ; err ! = nil { return fmt . errorf ( " " , number , err , string ( b ) ) } return nil } 
func ( r * repo ) config ( key , value string ) error { r . logger . infof ( " " , key , value ) if b , err : = r . gitcommand ( " " , key , value ) . combinedoutput ( ) ; err ! = nil { return fmt . errorf ( " " , key , value , err , string ( b ) ) } return nil } 
func retrycmd ( l * logrus . entry , dir , cmd string , arg ... string ) ( [ ] byte , error ) { var b [ ] byte var err error sleepytime : = time . second for i : = 0 ; i < 3 ; i ++ { c : = exec . command ( cmd , arg ... ) c . dir = dir b , err = c . combinedoutput ( ) if err ! = nil { l . warningf ( " " , cmd , arg , err , string ( b ) ) time . sleep ( sleepytime ) sleepytime * = 2 continue } break } return b , err } 
func ( r * repo ) mergecommitsexistbetween ( target , head string ) ( bool , error ) { r . logger . infof ( " " , target , head ) b , err : = r . gitcommand ( " " , fmt . sprintf ( " " , target , head ) , " " , " " ) . combinedoutput ( ) if err ! = nil { return false , fmt . errorf ( " " , target , head , err , string ( b ) ) } return len ( b ) ! = 0 , nil } 
func labelsandannotationsforjob ( pj prowapi . prowjob ) ( map [ string ] string , map [ string ] string ) { var extralabels map [ string ] string if extralabels = pj . objectmeta . labels ; extralabels == nil { extralabels = map [ string ] string { } } extralabels [ kube . prowjobidlabel ] = pj . objectmeta . name return labelsandannotationsforspec ( pj . spec , extralabels , nil ) } 
func prowjobtopod ( pj prowapi . prowjob , buildid string ) ( * coreapi . pod , error ) { if pj . spec . podspec == nil { return nil , fmt . errorf ( " " , pj . name ) } rawenv , err : = downwardapi . envforspec ( downwardapi . newjobspec ( pj . spec , buildid , pj . name ) ) if err ! = nil { return nil , err } spec : = pj . spec . podspec . deepcopy ( ) spec . restartpolicy = " " spec . containers [ 0 ] . name = kube . testcontainername if spec . automountserviceaccounttoken == nil && spec . serviceaccountname == " " { myfalse : = false spec . automountserviceaccounttoken = & myfalse } if pj . spec . decorationconfig == nil { spec . containers [ 0 ] . env = append ( spec . containers [ 0 ] . env , kubeenv ( rawenv ) ... ) } else { if err : = decorate ( spec , & pj , rawenv ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } } podlabels , annotations : = labelsandannotationsforjob ( pj ) return & coreapi . pod { objectmeta : metav1 . objectmeta { name : pj . objectmeta . name , labels : podlabels , annotations : annotations , } , spec : * spec , } , nil } 
func clonelogpath ( logmount coreapi . volumemount ) string { return filepath . join ( logmount . mountpath , clonelogpath ) } 
func cloneenv ( opt clonerefs . options ) ( [ ] coreapi . envvar , error ) { cloneconfigenv , err : = clonerefs . encode ( opt ) if err ! = nil { return nil , err } return kubeenv ( map [ string ] string { clonerefs . jsonconfigenvvar : cloneconfigenv } ) , nil } 
func sshvolume ( secret string ) ( coreapi . volume , coreapi . volumemount ) { var sshkeymode int32 = 0400 name : = strings . join ( [ ] string { " " , secret } , " " ) mountpath : = path . join ( " " , secret ) v : = coreapi . volume { name : name , volumesource : coreapi . volumesource { secret : & coreapi . secretvolumesource { secretname : secret , defaultmode : & sshkeymode , } , } , } vm : = coreapi . volumemount { name : name , mountpath : mountpath , readonly : true , } return v , vm } 
func cookiefilevolume ( secret string ) ( coreapi . volume , coreapi . volumemount , string ) { parts : = strings . splitn ( secret , " " , 2 ) cookiesecret : = parts [ 0 ] var base string if len ( parts ) == 1 { base = parts [ 0 ] } else { base = parts [ 1 ] } var cookiefilemode int32 = 0400 vol : = coreapi . volume { name : " " , volumesource : coreapi . volumesource { secret : & coreapi . secretvolumesource { secretname : cookiesecret , defaultmode : & cookiefilemode , } , } , } mount : = coreapi . volumemount { name : vol . name , mountpath : " " , readonly : true , } return vol , mount , path . join ( mount . mountpath , base ) } 
func injectentrypoint ( c * coreapi . container , timeout , graceperiod time . duration , prefix , previousmarker string , exitzero bool , log , tools coreapi . volumemount ) ( * wrapper . options , error ) { wrapperoptions : = & wrapper . options { args : append ( c . command , c . args ... ) , processlog : processlog ( log , prefix ) , markerfile : markerfile ( log , prefix ) , metadatafile : metadatafile ( log , prefix ) , } entrypointconfigenv , err : = entrypoint . encode ( entrypoint . options { artifactdir : artifactsdir ( log ) , graceperiod : graceperiod , options : wrapperoptions , timeout : timeout , alwayszero : exitzero , previousmarker : previousmarker , } ) if err ! = nil { return nil , err } c . command = [ ] string { entrypointlocation ( tools ) } c . args = nil c . env = append ( c . env , kubeenv ( map [ string ] string { entrypoint . jsonconfigenvvar : entrypointconfigenv } ) ... ) c . volumemounts = append ( c . volumemounts , log , tools ) return wrapperoptions , nil } 
func placeentrypoint ( image string , toolsmount coreapi . volumemount ) coreapi . container { return coreapi . container { name : " " , image : image , command : [ ] string { " " } , args : [ ] string { " " , entrypointlocation ( toolsmount ) } , volumemounts : [ ] coreapi . volumemount { toolsmount } , } } 
func kubeenv ( environment map [ string ] string ) [ ] coreapi . envvar { var keys [ ] string for key : = range environment { keys = append ( keys , key ) } sort . strings ( keys ) var kubeenvironment [ ] coreapi . envvar for , key : = range keys { kubeenvironment = append ( kubeenvironment , coreapi . envvar { name : key , value : environment [ key ] , } ) } return kubeenvironment } 
func ( o * kubernetesoptions ) addflags ( fs * flag . flagset ) { fs . stringvar ( & o . cluster , " " , " " , " " ) fs . stringvar ( & o . kubeconfig , " " , " " , " " ) fs . stringvar ( & o . deckuri , " " , " " , " " ) } 
func ( o * kubernetesoptions ) validate ( dryrun bool ) error { if dryrun && o . deckuri == " " { return errors . new ( " " ) } if o . deckuri ! = " " { if , err : = url . parserequesturi ( o . deckuri ) ; err ! = nil { return fmt . errorf ( " " , o . deckuri ) } } return nil } 
func ( o * kubernetesoptions ) client ( namespace string , dryrun bool ) ( * kube . client , error ) { if dryrun { return kube . newfakeclient ( o . deckuri ) , nil } if o . cluster == " " { return kube . newclientincluster ( namespace ) } return kube . newclientfromfile ( o . cluster , namespace ) } 
func handle ( gc githubclient , le * logrus . entry , e * event ) error { needslabel : = e . draft | | titleregex . matchstring ( e . title ) if needslabel && ! e . haslabel { if err : = gc . addlabel ( e . org , e . repo , e . number , labels . workinprogress ) ; err ! = nil { le . warnf ( " " , labels . workinprogress , err ) return err } } else if ! needslabel && e . haslabel { if err : = gc . removelabel ( e . org , e . repo , e . number , labels . workinprogress ) ; err ! = nil { le . warnf ( " " , labels . workinprogress , err ) return err } } return nil } 
func sendhook ( address , eventtype string , payload , hmac [ ] byte ) error { req , err : = http . newrequest ( http . methodpost , address , bytes . newbuffer ( payload ) ) if err ! = nil { return err } req . header . set ( " " , eventtype ) req . header . set ( " " , " " ) req . header . set ( " " , github . payloadsignature ( payload , hmac ) ) req . header . set ( " " , " " ) c : = & http . client { } resp , err : = c . do ( req ) if err ! = nil { return err } defer resp . body . close ( ) rb , err : = ioutil . readall ( resp . body ) if err ! = nil { return err } if resp . statuscode ! = 200 { return fmt . errorf ( " " , resp . statuscode , string ( bytes . trimspace ( rb ) ) ) } return nil } 
func format ( rtype string ) string { splits : = strings . split ( rtype , " " ) return splits [ len ( splits ) - 1 ] } 
func janitorclean ( resource * common . resource , flags [ ] string ) error { args : = append ( [ ] string { fmt . sprintf ( " " , format ( resource . type ) , resource . name ) } , flags ... ) logrus . infof ( " " , * janitorpath , strings . join ( args , " " ) ) cmd : = exec . command ( * janitorpath , args ... ) b , err : = cmd . combinedoutput ( ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " , resource . name , string ( b ) ) } else { logrus . tracef ( " " , string ( b ) ) logrus . infof ( " " , resource . name ) } return err } 
func janitor ( c boskosclient , buffer < - chan * common . resource , fn clean , flags [ ] string ) { for { resource : = < - buffer dest : = common . free if err : = fn ( resource , flags ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , * janitorpath ) dest = common . dirty } if err : = c . releaseone ( resource . name , dest ) ; err ! = nil { logrus . witherror ( err ) . error ( " " ) } } } 
func ( c * pubsubclient ) new ( ctx context . context , project string ) ( pubsubclientinterface , error ) { client , err : = pubsub . newclient ( ctx , project ) if err ! = nil { return nil , err } c . client = client return c , nil } 
func ( c * pubsubclient ) subscription ( id string ) subscriptioninterface { return & pubsubsubscription { sub : c . client . subscription ( id ) , } } 
func ( s * pullserver ) handlepulls ( ctx context . context , projectsubscriptions config . pubsubsubscriptions ) ( * errgroup . group , context . context , error ) { errgroup , derivedctx : = errgroup . withcontext ( ctx ) for project , subscriptions : = range projectsubscriptions { client , err : = s . client . new ( ctx , project ) if err ! = nil { return errgroup , derivedctx , err } for , subname : = range subscriptions { sub : = client . subscription ( subname ) errgroup . go ( func ( ) error { logrus . infof ( " " , sub . string ( ) , project ) defer logrus . warnf ( " " , sub . string ( ) , project ) err : = sub . receive ( derivedctx , func ( ctx context . context , msg messageinterface ) { if err = s . subscriber . handlemessage ( msg , sub . string ( ) ) ; err ! = nil { s . subscriber . metrics . ackmessagecounter . with ( prometheus . labels { subscriptionlabel : sub . string ( ) } ) . inc ( ) } else { s . subscriber . metrics . nackmessagecounter . with ( prometheus . labels { subscriptionlabel : sub . string ( ) } ) . inc ( ) } msg . ack ( ) } ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " , sub . string ( ) , project ) return err } return nil } ) } } return errgroup , derivedctx , nil } 
func ( s * pullserver ) run ( ctx context . context ) error { configevent : = make ( chan config . delta , 2 ) s . subscriber . configagent . subscribe ( configevent ) var err error defer func ( ) { if err ! = nil { logrus . witherror ( ctx . err ( ) ) . error ( " " ) } logrus . warn ( " " ) } ( ) currentconfig : = s . subscriber . configagent . config ( ) . pubsubsubscriptions errgroup , derivedctx , err : = s . handlepulls ( ctx , currentconfig ) if err ! = nil { return err } for { select { case < - ctx . done ( ) : return ctx . err ( ) case < - derivedctx . done ( ) : err = errgroup . wait ( ) return err case event : = < - configevent : newconfig : = event . after . pubsubsubscriptions logrus . info ( " " ) if ! reflect . deepequal ( currentconfig , newconfig ) { logrus . warn ( " " ) errgroup . wait ( ) errgroup , derivedctx , err = s . handlepulls ( ctx , newconfig ) if err ! = nil { return err } currentconfig = newconfig } } } } 
func spectostarted ( spec * downwardapi . jobspec , mainrefsha string ) gcs . started { started : = gcs . started { timestamp : time . now ( ) . unix ( ) , repoversion : downwardapi . getrevisionfromspec ( spec ) , } if mainrefsha ! = " " { started . repoversion = mainrefsha } if spec . refs ! = nil && len ( spec . refs . pulls ) > 0 { started . pull = strconv . itoa ( spec . refs . pulls [ 0 ] . number ) } started . repos = map [ string ] string { } if spec . refs ! = nil { started . repos [ spec . refs . org + " " + spec . refs . repo ] = spec . refs . string ( ) } for , ref : = range spec . extrarefs { started . repos [ ref . org + " " + ref . repo ] = ref . string ( ) } return started } 
func ( o options ) run ( ) error { spec , err : = downwardapi . resolvespecfromenv ( ) if err ! = nil { return fmt . errorf ( " " , err ) } uploadtargets : = map [ string ] gcs . uploadfunc { } var failed bool var mainrefsha string if o . log ! = " " { if failed , mainrefsha , err = processclonelog ( o . log , uploadtargets ) ; err ! = nil { return err } } started : = spectostarted ( spec , mainrefsha ) starteddata , err : = json . marshal ( & started ) if err ! = nil { return fmt . errorf ( " " , err ) } uploadtargets [ " " ] = gcs . dataupload ( bytes . newreader ( starteddata ) ) if err : = o . options . run ( spec , uploadtargets ) ; err ! = nil { return fmt . errorf ( " " , err ) } if failed { return errors . new ( " " ) } return nil } 
func processclonelog ( logfile string , uploadtargets map [ string ] gcs . uploadfunc ) ( bool , string , error ) { var clonerecords [ ] clone . record data , err : = ioutil . readfile ( logfile ) if err ! = nil { return true , " " , fmt . errorf ( " " , err ) } if err = json . unmarshal ( data , & clonerecords ) ; err ! = nil { return true , " " , fmt . errorf ( " " , err ) } clonelog : = bytes . buffer { } var failed bool var mainrefsha string for idx , record : = range clonerecords { clonelog . writestring ( clone . formatrecord ( record ) ) failed = failed | | record . failed if idx == 0 { mainrefsha = record . finalsha } } uploadtargets [ " " ] = gcs . dataupload ( bytes . newreader ( clonelog . bytes ( ) ) ) uploadtargets [ " " ] = gcs . fileupload ( logfile ) if failed { uploadtargets [ " " ] = gcs . dataupload ( bytes . newreader ( clonelog . bytes ( ) ) ) passed : = ! failed now : = time . now ( ) . unix ( ) finished : = gcs . finished { timestamp : & now , passed : & passed , result : " " , } finisheddata , err : = json . marshal ( & finished ) if err ! = nil { return true , mainrefsha , fmt . errorf ( " " , err ) } uploadtargets [ " " ] = gcs . dataupload ( bytes . newreader ( finisheddata ) ) } return failed , mainrefsha , nil } 
func hasprchanged ( pr github . pullrequestevent ) bool { switch pr . action { case github . pullrequestactionopened : return true case github . pullrequestactionreopened : return true case github . pullrequestactionsynchronize : return true default : return false } } 
func updateissues ( db * gorm . db , client clientinterface ) { latest , err : = findlatestissueupdate ( db , client . repositoryname ( ) ) if err ! = nil { glog . error ( " " , err ) return } c : = make ( chan * github . issue , 200 ) go client . fetchissues ( latest , c ) for issue : = range c { issueorm , err : = newissue ( issue , client . repositoryname ( ) ) if err ! = nil { glog . error ( " " , err ) continue } if db . create ( issueorm ) . error ! = nil { db . delete ( sql . label { } , " " , issueorm . id , client . repositoryname ( ) ) db . delete ( sql . assignee { } , " " , issueorm . id , client . repositoryname ( ) ) if err : = db . save ( issueorm ) . error ; err ! = nil { glog . error ( " " , err ) } } updatecomments ( * issue . number , issueorm . ispr , db , client ) updateissueevents ( * issue . number , db , client ) } } 
func handlereviewevent ( pc plugins . agent , re github . reviewevent ) error { return handlereview ( pc . logger , pc . githubclient , pc . ownersclient , pc . config . githuboptions , pc . pluginconfig , & re , ) } 
func findassociatedissue ( body , org string ) ( int , error ) { associatedissueregex , err : = regexp . compile ( fmt . sprintf ( associatedissueregexformat , org ) ) if err ! = nil { return 0 , err } match : = associatedissueregex . findstringsubmatch ( body ) if len ( match ) == 0 { return 0 , nil } v , err : = strconv . atoi ( match [ 1 ] ) if err ! = nil { return 0 , err } return v , nil } 
func addapprovers ( approvershandler * approvers . approvers , approvecomments [ ] * comment , author string , reviewactsasapprove bool ) { for , c : = range approvecomments { if c . author == " " { continue } if reviewactsasapprove && c . reviewstate == github . reviewstateapproved { approvershandler . addapprover ( c . author , c . htmlurl , false , ) } if reviewactsasapprove && c . reviewstate == github . reviewstatechangesrequested { approvershandler . removeapprover ( c . author ) } for , match : = range commandregex . findallstringsubmatch ( c . body , - 1 ) { name : = strings . toupper ( match [ 1 ] ) if name ! = approvecommand && name ! = lgtmcommand { continue } args : = strings . tolower ( strings . trimspace ( match [ 2 ] ) ) if strings . contains ( args , cancelargument ) { approvershandler . removeapprover ( c . author ) continue } if c . author == author { approvershandler . addauthorselfapprover ( c . author , c . htmlurl , args == noissueargument , ) } if name == approvecommand { approvershandler . addapprover ( c . author , c . htmlurl , args == noissueargument , ) } else { approvershandler . addlgtmer ( c . author , c . htmlurl , args == noissueargument , ) } } } } 
func optionsforrepo ( config * plugins . configuration , org , repo string ) * plugins . approve { fullname : = fmt . sprintf ( " " , org , repo ) a : = func ( ) * plugins . approve { for , c : = range config . approve { if ! strinslice ( fullname , c . repos ) { continue } return & c } for , c : = range config . approve { if ! strinslice ( org , c . repos ) { continue } return & c } return & plugins . approve { } } ( ) if a . deprecatedimplicitselfapprove == nil && a . requireselfapproval == nil && config . usedeprecatedselfapprove { no : = false a . deprecatedimplicitselfapprove = & no } if a . deprecatedreviewactsasapprove == nil && a . ignorereviewstate == nil && config . usedeprecatedreviewapprove { no : = false a . deprecatedreviewactsasapprove = & no } return a } 
func localonlymain ( cfg config . getter , o options , mux * http . servemux ) * http . servemux { mux . handle ( " " , gziphandler . gziphandler ( handlesimpletemplate ( o , cfg , " " , nil ) ) ) if o . spyglass { initspyglass ( cfg , o , mux , nil ) } return mux } 
func handlebadge ( ja * jobs . jobagent ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { setheadersnocaching ( w ) wantjobs : = r . url . query ( ) . get ( " " ) if wantjobs == " " { http . error ( w , " " , http . statusbadrequest ) return } w . header ( ) . set ( " " , " " ) alljobs : = ja . prowjobs ( ) , , svg : = renderbadge ( picklatestjobs ( alljobs , wantjobs ) ) w . write ( svg ) } } 
func handlejobhistory ( o options , cfg config . getter , gcsclient * storage . client ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { setheadersnocaching ( w ) tmpl , err : = getjobhistory ( r . url , cfg ( ) , gcsclient ) if err ! = nil { msg : = fmt . sprintf ( " " , err ) logrus . withfield ( " " , r . url ) . error ( msg ) http . error ( w , msg , http . statusinternalservererror ) return } handlesimpletemplate ( o , cfg , " " , tmpl ) ( w , r ) } } 
func handlerequestjobviews ( sg * spyglass . spyglass , cfg config . getter , o options ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { start : = time . now ( ) setheadersnocaching ( w ) src : = strings . trimprefix ( r . url . path , " " ) page , err : = renderspyglass ( sg , cfg , src , o ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) message : = fmt . sprintf ( " " , err ) http . error ( w , message , http . statusinternalservererror ) return } fmt . fprint ( w , page ) elapsed : = time . since ( start ) logrus . withfields ( logrus . fields { " " : elapsed . string ( ) , " " : r . url . path , " " : src , } ) . info ( " " ) } } 
func handlelog ( lc logclient ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { setheadersnocaching ( w ) w . header ( ) . set ( " " , " " ) job : = r . url . query ( ) . get ( " " ) id : = r . url . query ( ) . get ( " " ) logger : = logrus . withfields ( logrus . fields { " " : job , " " : id } ) if err : = validatelogrequest ( r ) ; err ! = nil { http . error ( w , err . error ( ) , http . statusbadrequest ) return } log , err : = lc . getjoblog ( job , id ) if err ! = nil { http . error ( w , fmt . sprintf ( " " , err ) , http . statusnotfound ) logger : = logger . witherror ( err ) msg : = " " if strings . contains ( err . error ( ) , " " ) { logger . info ( msg ) } else { logger . warning ( msg ) } return } if , err = w . write ( log ) ; err ! = nil { logger . witherror ( err ) . warning ( " " ) } } } 
func newcoveragelist ( name string ) * coveragelist { return & coveragelist { coverage : & coverage { name : name } , group : [ ] coverage { } , } } 
func ( covlist * coveragelist ) summarize ( ) { covlist . numcoveredstmts = 0 covlist . numallstmts = 0 for , item : = range covlist . group { covlist . numcoveredstmts += item . numcoveredstmts covlist . numallstmts += item . numallstmts } } 
func ( covlist * coveragelist ) subset ( prefix string ) * coveragelist { s : = newcoveragelist ( " " ) for , c : = range covlist . group { if strings . hasprefix ( c . name , prefix ) { covlist . group = append ( covlist . group , c ) } } return s } 
func ( covlist coveragelist ) listdirectories ( ) [ ] string { dirset : = map [ string ] bool { } for , cov : = range covlist . group { dirset [ path . dir ( cov . name ) ] = true } var result [ ] string for key : = range dirset { result = append ( result , key ) } return result } 
func readrequest ( r io . reader , contenttype string ) ( * admissionapi . admissionrequest , error ) { if contenttype ! = contenttypejson { return nil , fmt . errorf ( " " , contenttype , contenttypejson ) } if r == nil { return nil , fmt . errorf ( " " ) } body , err : = ioutil . readall ( r ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } var ar admissionapi . admissionreview deserializer : = codecs . universaldeserializer ( ) if , , err : = deserializer . decode ( body , nil , & ar ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } return ar . request , nil } 
func handle ( w http . responsewriter , r * http . request ) { req , err : = readrequest ( r . body , r . header . get ( " " ) ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) } if err : = writeresponse ( * req , w , onlyupdatestatus ) ; err ! = nil { logrus . witherror ( err ) . error ( " " ) } } 
func writeresponse ( ar admissionapi . admissionrequest , w io . writer , decide decider ) error { response , err : = decide ( ar ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) response = & admissionapi . admissionresponse { result : & meta . status { message : err . error ( ) , } , } } var result admissionapi . admissionreview result . response = response result . response . uid = ar . uid out , err : = json . marshal ( result ) if err ! = nil { return fmt . errorf ( " " , err ) } if , err : = w . write ( out ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func onlyupdatestatus ( req admissionapi . admissionrequest ) ( * admissionapi . admissionresponse , error ) { logger : = logrus . withfields ( logrus . fields { " " : req . resource , " " : req . subresource , " " : req . name , " " : req . namespace , " " : req . operation , } ) if req . subresource == " " { logrus . info ( " " ) return & allow , nil } var new prowjobv1 . prowjob if , , err : = codecs . universaldeserializer ( ) . decode ( req . object . raw , nil , & new ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } var old prowjobv1 . prowjob if , , err : = codecs . universaldeserializer ( ) . decode ( req . oldobject . raw , nil , & old ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } if equality . semantic . deepequal ( old . spec , new . spec ) { logrus . info ( " " ) return & allow , nil } logger . info ( " " ) return & reject , nil } 
func newhealth ( ) * health { healthmux : = http . newservemux ( ) healthmux . handlefunc ( " " , func ( w http . responsewriter , r * http . request ) { fmt . fprint ( w , " " ) } ) go func ( ) { logrus . witherror ( http . listenandserve ( " " + strconv . itoa ( healthport ) , healthmux ) ) . fatal ( " " ) } ( ) return & health { healthmux : healthmux , } } 
func ( h * health ) serveready ( ) { h . healthmux . handlefunc ( " " , func ( w http . responsewriter , r * http . request ) { fmt . fprint ( w , " " ) } ) } 
func newcontroller ( ghcsync , ghcstatus * github . client , prowjobclient prowv1 . prowjobinterface , cfg config . getter , gc * git . client , maxrecordsperpool int , opener io . opener , historyuri , statusuri string , logger * logrus . entry ) ( * controller , error ) { if logger == nil { logger = logrus . newentry ( logrus . standardlogger ( ) ) } hist , err : = history . new ( maxrecordsperpool , opener , historyuri ) if err ! = nil { return nil , fmt . errorf ( " " , historyuri , err ) } sc : = & statuscontroller { logger : logger . withfield ( " " , " " ) , ghc : ghcstatus , config : cfg , newpoolpending : make ( chan bool , 1 ) , shutdown : make ( chan bool ) , opener : opener , path : statusuri , } go sc . run ( ) return & controller { logger : logger . withfield ( " " , " " ) , ghc : ghcsync , prowjobclient : prowjobclient , config : cfg , gc : gc , sc : sc , changedfiles : & changedfilesagent { ghc : ghcsync , nextchangecache : make ( map [ changecachekey ] [ ] string ) , } , history : hist , } , nil } 
func byrepoandnumber ( prs [ ] pullrequest ) map [ string ] pullrequest { m : = make ( map [ string ] pullrequest ) for , pr : = range prs { key : = prkey ( & pr ) m [ key ] = pr } return m } 
func newexpectedcontext ( c string ) context { return context { context : githubql . string ( c ) , state : githubql . statusstateexpected , description : githubql . string ( " " ) , } } 
func contextstostrings ( contexts [ ] context ) [ ] string { var names [ ] string for , c : = range contexts { names = append ( names , string ( c . context ) ) } return names } 
func ( c * controller ) filtersubpools ( goroutines int , raw map [ string ] * subpool ) map [ string ] * subpool { filtered : = make ( map [ string ] * subpool ) var lock sync . mutex subpoolsinparallel ( goroutines , raw , func ( sp * subpool ) { if err : = c . initsubpooldata ( sp ) ; err ! = nil { sp . log . witherror ( err ) . error ( " " ) return } key : = poolkey ( sp . org , sp . repo , sp . branch ) if spfiltered : = filtersubpool ( c . ghc , sp ) ; spfiltered ! = nil { sp . log . withfield ( " " , key ) . withfield ( " " , spfiltered ) . debug ( " " ) lock . lock ( ) filtered [ key ] = spfiltered lock . unlock ( ) } else { sp . log . withfield ( " " , key ) . withfield ( " " , spfiltered ) . debug ( " " ) } } , ) return filtered } 
func filtersubpool ( ghc githubclient , sp * subpool ) * subpool { var tokeep [ ] pullrequest for , pr : = range sp . prs { if ! filterpr ( ghc , sp , & pr ) { tokeep = append ( tokeep , pr ) } } if len ( tokeep ) == 0 { return nil } sp . prs = tokeep return sp } 
func filterpr ( ghc githubclient , sp * subpool , pr * pullrequest ) bool { log : = sp . log . withfields ( pr . logfields ( ) ) if pr . mergeable == githubql . mergeablestateconflicting { log . debug ( " " ) return true } contexts , err : = headcontexts ( log , ghc , pr ) if err ! = nil { log . witherror ( err ) . error ( " " ) return true } presubmitshavecontext : = func ( context string ) bool { for , job : = range sp . presubmits [ int ( pr . number ) ] { if job . context == context { return true } } return false } for , ctx : = range unsuccessfulcontexts ( contexts , sp . cc , log ) { if ctx . state ! = githubql . statusstatepending { log . withfield ( " " , ctx . context ) . debug ( " " ) return true } if ! presubmitshavecontext ( string ( ctx . context ) ) { log . withfield ( " " , ctx . context ) . debug ( " " ) return true } } return false } 
func poolprmap ( subpoolmap map [ string ] * subpool ) map [ string ] pullrequest { prs : = make ( map [ string ] pullrequest ) for , sp : = range subpoolmap { for , pr : = range sp . prs { prs [ prkey ( & pr ) ] = pr } } return prs } 
func unsuccessfulcontexts ( contexts [ ] context , cc contextchecker , log * logrus . entry ) [ ] context { var failed [ ] context for , ctx : = range contexts { if string ( ctx . context ) == statuscontext { continue } if cc . isoptional ( string ( ctx . context ) ) { continue } if ctx . state ! = githubql . statusstatesuccess { failed = append ( failed , ctx ) } } for , c : = range cc . missingrequiredcontexts ( contextstostrings ( contexts ) ) { failed = append ( failed , newexpectedcontext ( c ) ) } log . debugf ( " " , len ( contexts ) , contextstostrings ( contexts ) , len ( failed ) , contextstostrings ( failed ) ) return failed } 
func trymerge ( mergefunc func ( ) error ) ( bool , error ) { var err error const maxretries = 3 backoff : = time . second * 4 for retry : = 0 ; retry < maxretries ; retry ++ { if err = mergefunc ( ) ; err == nil { return true , nil } if , ok : = err . ( github . modifiedheaderror ) ; ok { return true , fmt . errorf ( " " , err ) } else if , ok = err . ( github . unmergableprbasechangederror ) ; ok { err = fmt . errorf ( " " , err ) if retry + 1 < maxretries { sleep ( backoff ) backoff * = 2 } } else if , ok = err . ( github . unauthorizedtopusherror ) ; ok { return false , fmt . errorf ( " " , err ) } else if , ok = err . ( github . mergecommitsforbiddenerror ) ; ok { return false , fmt . errorf ( " " , err ) } else if , ok = err . ( github . unmergableprerror ) ; ok { return true , fmt . errorf ( " " , err ) } else { return true , err } } return true , err } 
func ( c * changedfilesagent ) prchanges ( pr * pullrequest ) config . changedfilesprovider { return func ( ) ( [ ] string , error ) { cachekey : = changecachekey { org : string ( pr . repository . owner . login ) , repo : string ( pr . repository . name ) , number : int ( pr . number ) , sha : string ( pr . headrefoid ) , } c . rlock ( ) changedfiles , ok : = c . changecache [ cachekey ] if ok { c . runlock ( ) c . lock ( ) c . nextchangecache [ cachekey ] = changedfiles c . unlock ( ) return changedfiles , nil } if changedfiles , ok = c . nextchangecache [ cachekey ] ; ok { c . runlock ( ) return changedfiles , nil } c . runlock ( ) changes , err : = c . ghc . getpullrequestchanges ( string ( pr . repository . owner . login ) , string ( pr . repository . name ) , int ( pr . number ) , ) if err ! = nil { return nil , fmt . errorf ( " " , int ( pr . number ) , err ) } changedfiles = make ( [ ] string , 0 , len ( changes ) ) for , change : = range changes { changedfiles = append ( changedfiles , change . filename ) } c . lock ( ) c . nextchangecache [ cachekey ] = changedfiles c . unlock ( ) return changedfiles , nil } } 
func ( c * changedfilesagent ) prune ( ) { c . lock ( ) defer c . unlock ( ) c . changecache = c . nextchangecache c . nextchangecache = make ( map [ changecachekey ] [ ] string ) } 
func headcontexts ( log * logrus . entry , ghc githubclient , pr * pullrequest ) ( [ ] context , error ) { for , node : = range pr . commits . nodes { if node . commit . oid == pr . headrefoid { return node . commit . status . contexts , nil } } org : = string ( pr . repository . owner . login ) repo : = string ( pr . repository . name ) log . warnf ( " " , len ( pr . commits . nodes ) ) combined , err : = ghc . getcombinedstatus ( org , repo , string ( pr . headrefoid ) ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } contexts : = make ( [ ] context , 0 , len ( combined . statuses ) ) for , status : = range combined . statuses { contexts = append ( contexts , context { context : githubql . string ( status . context ) , description : githubql . string ( status . description ) , state : githubql . statusstate ( strings . toupper ( status . state ) ) , } , ) } pr . commits . nodes = append ( pr . commits . nodes , struct { commit commit } { commit : commit { oid : pr . headrefoid , status : struct { contexts [ ] context } { contexts : contexts } , } , } , ) return contexts , nil } 
func aggregateprofiles ( profiles [ ] [ ] * cover . profile ) ( [ ] * cover . profile , error ) { setprofiles : = make ( [ ] [ ] * cover . profile , 0 , len ( profiles ) ) for , p : = range profiles { c : = counttoboolean ( p ) setprofiles = append ( setprofiles , c ) } aggregateprofiles , err : = mergemultipleprofiles ( setprofiles ) if err ! = nil { return nil , err } return aggregateprofiles , nil } 
func counttoboolean ( profile [ ] * cover . profile ) [ ] * cover . profile { setprofile : = make ( [ ] * cover . profile , 0 , len ( profile ) ) for , p : = range profile { pc : = deepcopyprofile ( * p ) for i : = range pc . blocks { if pc . blocks [ i ] . count > 0 { pc . blocks [ i ] . count = 1 } } setprofile = append ( setprofile , & pc ) } return setprofile } 
func newstorage ( r storage . persistencelayer , storage string ) ( * storage , error ) { s : = & storage { resources : r , } if storage ! = " " { var data struct { resources [ ] common . resource } buf , err : = ioutil . readfile ( storage ) if err == nil { logrus . infof ( " " , string ( buf ) ) err = json . unmarshal ( buf , & data ) if err ! = nil { return nil , err } } else if ! os . isnotexist ( err ) { return nil , err } logrus . info ( " " ) for , res : = range data . resources { if err : = s . addresource ( res ) ; err ! = nil { logrus . witherror ( err ) . errorf ( " " , res . name , res . state ) } logrus . infof ( " " , res . name , res . state ) } } return s , nil } 
func ( s * storage ) addresource ( resource common . resource ) error { return s . resources . add ( resource ) } 
func ( s * storage ) deleteresource ( name string ) error { return s . resources . delete ( name ) } 
func ( s * storage ) updateresource ( resource common . resource ) error { return s . resources . update ( resource ) } 
func ( s * storage ) getresource ( name string ) ( common . resource , error ) { i , err : = s . resources . get ( name ) if err ! = nil { return common . resource { } , err } var res common . resource res , err = common . itemtoresource ( i ) if err ! = nil { return common . resource { } , err } return res , nil } 
func ( s * storage ) getresources ( ) ( [ ] common . resource , error ) { var resources [ ] common . resource items , err : = s . resources . list ( ) if err ! = nil { return resources , err } for , i : = range items { var res common . resource res , err = common . itemtoresource ( i ) if err ! = nil { return nil , err } resources = append ( resources , res ) } sort . stable ( common . resourcebyupdatetime ( resources ) ) return resources , nil } 
func parseconfig ( configpath string ) ( [ ] common . resource , error ) { file , err : = ioutil . readfile ( configpath ) if err ! = nil { return nil , err } var data common . boskosconfig err = yaml . unmarshal ( file , & data ) if err ! = nil { return nil , err } var resources [ ] common . resource for , entry : = range data . resources { resources = append ( resources , common . newresourcesfromconfig ( entry ) ... ) } return resources , nil } 
func problemsinfiles ( r * git . repo , files map [ string ] string ) ( map [ string ] [ ] string , error ) { problems : = make ( map [ string ] [ ] string ) for f : = range files { src , err : = ioutil . readfile ( filepath . join ( r . dir , f ) ) if err ! = nil { return nil , err } content , err : = build . parse ( f , src ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } beforerewrite : = build . format ( content ) var info build . rewriteinfo build . rewrite ( content , & info ) ndata : = build . format ( content ) if ! bytes . equal ( src , ndata ) && ! bytes . equal ( src , beforerewrite ) { problems [ f ] = uniqproblems ( info . log ) } } return problems , nil } 
func newpodlogartifact ( jobname string , buildid string , sizelimit int64 , ja jobagent ) ( * podlogartifact , error ) { if jobname == " " { return nil , errinsufficientjobinfo } if buildid == " " { return nil , errinsufficientjobinfo } if sizelimit < 0 { return nil , errinvalidsizelimit } return & podlogartifact { name : jobname , buildid : buildid , sizelimit : sizelimit , jobagent : ja , } , nil } 
func ( a * podlogartifact ) canonicallink ( ) string { q : = url . values { " " : [ ] string { a . name } , " " : [ ] string { a . buildid } , } u : = url . url { path : " " , rawquery : q . encode ( ) , } return u . string ( ) } 
func ( a * podlogartifact ) readat ( p [ ] byte , off int64 ) ( n int , err error ) { logs , err : = a . jobagent . getjoblog ( a . name , a . buildid ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } r : = bytes . newreader ( logs ) readbytes , err : = r . readat ( p , off ) if err == io . eof { return readbytes , io . eof } if err ! = nil { return 0 , fmt . errorf ( " " , err ) } return readbytes , nil } 
func ( a * podlogartifact ) readall ( ) ( [ ] byte , error ) { size , err : = a . size ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if size > a . sizelimit { return nil , lenses . errfiletoolarge } logs , err : = a . jobagent . getjoblog ( a . name , a . buildid ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return logs , nil } 
func ( a * podlogartifact ) readatmost ( n int64 ) ( [ ] byte , error ) { logs , err : = a . jobagent . getjoblog ( a . name , a . buildid ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } reader : = bytes . newreader ( logs ) var bytecount int64 var p [ ] byte for bytecount < n { b , err : = reader . readbyte ( ) if err == io . eof { return p , io . eof } if err ! = nil { return nil , fmt . errorf ( " " , err ) } p = append ( p , b ) bytecount ++ } return p , nil } 
func ( a * podlogartifact ) readtail ( n int64 ) ( [ ] byte , error ) { logs , err : = a . jobagent . getjoblog ( a . name , a . buildid ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } size : = int64 ( len ( logs ) ) var off int64 if n > size { off = 0 } else { off = size - n } p : = make ( [ ] byte , n ) readbytes , err : = bytes . newreader ( logs ) . readat ( p , off ) if err ! = nil && err ! = io . eof { return nil , fmt . errorf ( " " , err ) } return p [ : readbytes ] , nil } 
func ( a * podlogartifact ) size ( ) ( int64 , error ) { logs , err : = a . jobagent . getjoblog ( a . name , a . buildid ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } return int64 ( len ( logs ) ) , nil } 
func modifiedgofiles ( ghc githubclient , org , repo string , number int , sha string ) ( map [ string ] string , error ) { changes , err : = ghc . getpullrequestchanges ( org , repo , number ) if err ! = nil { return nil , err } gfg , err : = genfiles . newgroup ( ghc , org , repo , sha ) if err ! = nil { return nil , err } modifiedfiles : = make ( map [ string ] string ) for , change : = range changes { switch { case strings . hasprefix ( change . filename , " " ) : continue case filepath . ext ( change . filename ) ! = " " : continue case gfg . match ( change . filename ) : continue case change . status == github . pullrequestfileremoved | | change . status == github . pullrequestfilerenamed : continue } modifiedfiles [ change . filename ] = change . patch } return modifiedfiles , nil } 
func newproblems ( cs [ ] github . reviewcomment , ps map [ string ] map [ int ] lint . problem ) map [ string ] map [ int ] lint . problem { res : = make ( map [ string ] map [ int ] lint . problem ) for f , ls : = range ps { res [ f ] = make ( map [ int ] lint . problem ) for l , p : = range ls { res [ f ] [ l ] = p } } for , c : = range cs { if c . position == nil { continue } if ! strings . contains ( c . body , commenttag ) { continue } delete ( res [ c . path ] , * c . position ) } return res } 
func undopreset ( preset * config . preset , labels map [ string ] string , pod * coreapi . podspec ) { for l , v : = range preset . labels { if v2 , ok : = labels [ l ] ; ! ok | | v2 ! = v { return } } removeenvnames : = sets . newstring ( ) for , e1 : = range preset . env { removeenvnames . insert ( e1 . name ) } removevolumenames : = sets . newstring ( ) for , volume : = range preset . volumes { removevolumenames . insert ( volume . name ) } removevolumemountnames : = sets . newstring ( ) for , volumemount : = range preset . volumemounts { removevolumemountnames . insert ( volumemount . name ) } filteredvolumes : = [ ] coreapi . volume { } for , volume : = range pod . volumes { if ! removevolumenames . has ( volume . name ) { filteredvolumes = append ( filteredvolumes , volume ) } } pod . volumes = filteredvolumes for i : = range pod . containers { filteredenv : = [ ] coreapi . envvar { } for , env : = range pod . containers [ i ] . env { if ! removeenvnames . has ( env . name ) { filteredenv = append ( filteredenv , env ) } } pod . containers [ i ] . env = filteredenv filteredvolumemounts : = [ ] coreapi . volumemount { } for , mount : = range pod . containers [ i ] . volumemounts { if ! removevolumemountnames . has ( mount . name ) { filteredvolumemounts = append ( filteredvolumemounts , mount ) } } pod . containers [ i ] . volumemounts = filteredvolumemounts } } 
func undopresubmitpresets ( presets [ ] config . preset , presubmit * config . presubmit ) { if presubmit . spec == nil { return } for , preset : = range presets { undopreset ( & preset , presubmit . labels , presubmit . spec ) } } 
func yamlbytesstripnulls ( yamlbytes [ ] byte ) [ ] byte { nullre : = regexp . mustcompile ( " \n \n " ) return nullre . replaceall ( yamlbytes , [ ] byte { } ) } 
func ( c * orgrepoconfig ) difference ( c2 * orgrepoconfig ) * orgrepoconfig { res : = & orgrepoconfig { orgexceptions : make ( map [ string ] sets . string ) , repos : sets . newstring ( ) . union ( c . repos ) , } for org , excepts1 : = range c . orgexceptions { if excepts2 , ok : = c2 . orgexceptions [ org ] ; ok { res . repos . insert ( excepts2 . difference ( excepts1 ) . unsortedlist ( ) ... ) } else { excepts : = sets . newstring ( ) . union ( excepts1 ) for , repo : = range c2 . repos . unsortedlist ( ) { if parts : = strings . splitn ( repo , " " , 2 ) ; len ( parts ) == 2 && parts [ 0 ] == org { excepts . insert ( repo ) } } res . orgexceptions [ org ] = excepts } } res . repos = res . repos . difference ( c2 . repos ) for , repo : = range res . repos . unsortedlist ( ) { if parts : = strings . splitn ( repo , " " , 2 ) ; len ( parts ) == 2 { if excepts2 , ok : = c2 . orgexceptions [ parts [ 0 ] ] ; ok && ! excepts2 . has ( repo ) { res . repos . delete ( repo ) } } } return res } 
func ( c * orgrepoconfig ) union ( c2 * orgrepoconfig ) * orgrepoconfig { res : = & orgrepoconfig { orgexceptions : make ( map [ string ] sets . string ) , repos : sets . newstring ( ) , } for org , excepts1 : = range c . orgexceptions { pruned : = excepts1 . difference ( c2 . repos ) if excepts2 , ok : = c2 . orgexceptions [ org ] ; ok { res . orgexceptions [ org ] = pruned . intersection ( excepts2 . difference ( c . repos ) ) } else { res . orgexceptions [ org ] = pruned } } for org , excepts2 : = range c2 . orgexceptions { if , exists : = res . orgexceptions [ org ] ; ! exists { res . orgexceptions [ org ] = excepts2 . difference ( c . repos ) } } for , repo : = range c . repos . union ( c2 . repos ) . unsortedlist ( ) { parts : = strings . splitn ( repo , " " , 2 ) if len ( parts ) ! = 2 { logrus . warnf ( " " , repo ) continue } if , exists : = res . orgexceptions [ parts [ 0 ] ] ; ! exists { res . repos . insert ( repo ) } } return res } 
func ensurevalidconfiguration ( plugin , label , verb string , tidesubset , tidesuperset , pluginssubset * orgrepoconfig ) error { notenabled : = tidesubset . difference ( pluginssubset ) . items ( ) notrequired : = pluginssubset . intersection ( tidesuperset ) . difference ( tidesubset ) . items ( ) var configerrors [ ] error if len ( notenabled ) > 0 { configerrors = append ( configerrors , fmt . errorf ( " " , verb , label , plugin , notenabled ) ) } if len ( notrequired ) > 0 { configerrors = append ( configerrors , fmt . errorf ( " " , plugin , verb , label , notrequired ) ) } return errorutil . newaggregate ( configerrors ... ) } 
func ( s * strings ) set ( value string ) error { if ! s . beenset { s . beenset = true s . vals = nil } s . vals = append ( s . vals , value ) return nil } 
func clearstalecomments ( gc githubclient , log * logrus . entry , pr * github . pullrequestevent , prlabels sets . string , comments [ ] github . issuecomment ) error { if prmustfollowrelnoteprocess ( gc , log , pr , prlabels , false ) && ! releasenotealreadyadded ( prlabels ) { return nil } botname , err : = gc . botname ( ) if err ! = nil { return err } return gc . deletestalecomments ( pr . repo . owner . login , pr . repo . name , pr . number , comments , func ( c github . issuecomment ) bool { return c . user . login == botname && ( strings . contains ( c . body , releasenotebody ) | | strings . contains ( c . body , parentreleasenotebody ) ) } , ) } 
func newclient ( boskosclient boskosclient ) * client { return & client { basic : boskosclient , resources : map [ string ] common . resource { } , } } 
func ( c * client ) acquire ( rtype , state , dest string ) ( * common . resource , error ) { var resourcestorelease [ ] common . resource releaseonfailure : = func ( ) { for , r : = range resourcestorelease { if err : = c . basic . releaseone ( r . name , common . dirty ) ; err ! = nil { logrus . witherror ( err ) . warningf ( " " , r . name ) } } } res , err : = c . basic . acquire ( rtype , state , dest ) if err ! = nil { return nil , err } var leasedresources common . leasedresources if err = res . userdata . extract ( leasedresources , & leasedresources ) ; err ! = nil { if , ok : = err . ( * common . userdatanotfound ) ; ! ok { logrus . witherror ( err ) . errorf ( " " , leasedresources ) return nil , err } } resourcestorelease = append ( resourcestorelease , * res ) resources , err : = c . basic . acquirebystate ( res . name , dest , leasedresources ) if err ! = nil { releaseonfailure ( ) return nil , err } resourcestorelease = append ( resourcestorelease , resources ... ) c . updateresource ( * res ) return res , nil } 
func ( c * client ) releaseone ( name , dest string ) ( allerrors error ) { res , err : = c . getresource ( name ) if err ! = nil { allerrors = err return } resourcenames : = [ ] string { name } var leasedresources common . leasedresources if err : = res . userdata . extract ( leasedresources , & leasedresources ) ; err ! = nil { if , ok : = err . ( * common . userdatanotfound ) ; ! ok { logrus . witherror ( err ) . errorf ( " " , leasedresources ) allerrors = multierror . append ( allerrors , err ) if err : = c . basic . releaseone ( name , dest ) ; err ! = nil { logrus . witherror ( err ) . warningf ( " " , name ) allerrors = multierror . append ( allerrors , err ) } return } } resourcenames = append ( resourcenames , leasedresources ... ) for , n : = range resourcenames { if err : = c . basic . releaseone ( n , dest ) ; err ! = nil { logrus . witherror ( err ) . warningf ( " " , n ) allerrors = multierror . append ( allerrors , err ) } } c . deleteresource ( name ) return } 
func ( c * client ) updateall ( state string ) error { return c . basic . updateall ( state ) } 
func getgithubclient ( token string ) * github . client { return github . newclient ( oauth2 . newclient ( oauth2 . nocontext , oauth2 . statictokensource ( & oauth2 . token { accesstoken : token } ) , ) , ) } 
func getusername ( client * github . client ) ( string , error ) { user , , err : = client . users . get ( context . background ( ) , " " ) if err ! = nil { return " " , err } if user . login == nil { return " " , errors . new ( " " " " ) } return * user . login , nil } 
func createtokenhandler ( tokenstream io . reader , influxdb * influxdb ) ( * tokenhandler , error ) { token , err : = ioutil . readall ( tokenstream ) if err ! = nil { return nil , err } client : = getgithubclient ( strings . trimspace ( string ( token ) ) ) login , err : = getusername ( client ) if err ! = nil { return nil , err } return & tokenhandler { gclient : client , login : login , influxdb : influxdb , } , nil } 
func createtokenhandlers ( tokenfiles [ ] string , influxdb * influxdb ) ( [ ] tokenhandler , error ) { tokens : = [ ] tokenhandler { } for , tokenfile : = range tokenfiles { f , err : = os . open ( tokenfile ) if err ! = nil { return nil , fmt . errorf ( " " , tokenfile , err ) } token , err : = createtokenhandler ( f , influxdb ) if err ! = nil { return nil , fmt . errorf ( " " , tokenfile , err ) } tokens = append ( tokens , * token ) } return tokens , nil } 
func ( t tokenhandler ) process ( ) { lastrate , err : = t . getcorerate ( ) if err ! = nil { glog . fatalf ( " " , t . login , err ) } for { halfperiod : = lastrate . reset . time . sub ( time . now ( ) ) / 2 time . sleep ( halfperiod ) newrate , err : = t . getcorerate ( ) if err ! = nil { glog . error ( " " , err ) continue } if ! newrate . reset . time . equal ( lastrate . reset . time ) | | newrate . remaining > lastrate . remaining { if err : = t . influxdb . push ( " " , map [ string ] string { " " : t . login } , map [ string ] interface { } { " " : lastrate . limit - lastrate . remaining } , lastrate . reset . time , ) ; err ! = nil { glog . error ( " " , err ) } time . sleep ( 30 * time . minute ) for { newrate , err = t . getcorerate ( ) if err == nil { break } glog . error ( " " , err ) time . sleep ( time . minute ) } } lastrate = newrate } } 
func ( i * jobindentifier ) string ( ) string { return fmt . sprintf ( " " , i . job , i . organization , i . repository , i . pullrequest ) } 
func terminateolderpresubmitjobs ( pjc prowclient , log * logrus . entry , pjs [ ] prowapi . prowjob , cleanup prowjobresourcescleanup ) error { dupes : = map [ jobindentifier ] int { } for i , pj : = range pjs { if pj . complete ( ) | | pj . spec . type ! = prowapi . presubmitjob { continue } ji : = jobindentifier { job : pj . spec . job , organization : pj . spec . refs . org , repository : pj . spec . refs . repo , pullrequest : pj . spec . refs . pulls [ 0 ] . number , } prev , ok : = dupes [ ji ] if ! ok { dupes [ ji ] = i continue } cancelindex : = i if ( & pjs [ prev ] . status . starttime ) . before ( & pj . status . starttime ) { cancelindex = prev dupes [ ji ] = i } tocancel : = pjs [ cancelindex ] if err : = cleanup ( tocancel ) ; err ! = nil { log . witherror ( err ) . withfields ( prowjobfields ( & tocancel ) ) . warn ( " " ) } tocancel . setcomplete ( ) prevstate : = tocancel . status . state tocancel . status . state = prowapi . abortedstate log . withfields ( prowjobfields ( & tocancel ) ) . withfield ( " " , prevstate ) . withfield ( " " , tocancel . status . state ) . info ( " " ) npj , err : = pjc . replaceprowjob ( tocancel . objectmeta . name , tocancel ) if err ! = nil { return err } pjs [ cancelindex ] = npj } return nil } 
func pushmetrics ( component , endpoint string , interval time . duration ) { sig : = make ( chan os . signal , 1 ) signal . notify ( sig , os . interrupt , syscall . sigterm ) for { select { case < - time . tick ( interval ) : if err : = push . fromgatherer ( component , push . hostnamegroupingkey ( ) , endpoint , prometheus . defaultgatherer ) ; err ! = nil { logrus . withfield ( " " , component ) . witherror ( err ) . error ( " " ) } case < - sig : logrus . withfield ( " " , component ) . infof ( " " ) return } } } 
func ratelimiter ( controllername string ) workqueue . ratelimitinginterface { rl : = workqueue . newmaxofratelimiter ( workqueue . newitemexponentialfailureratelimiter ( 5 * time . millisecond , 120 * time . second ) , & workqueue . bucketratelimiter { limiter : rate . newlimiter ( rate . limit ( 1000 ) , 50000 ) } , ) return workqueue . newnamedratelimitingqueue ( rl , controllername ) } 
func findrepo ( wd , path string ) ( string , error ) { opwd , err : = realpath ( wd ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } if strings . hasprefix ( path , " " ) { path = strings . replace ( path , " " , " " , 1 ) } var old string pwd : = opwd for old ! = pwd { old = pwd if strings . hassuffix ( pwd , " " + path ) { return pwd , nil } pwd = filepath . dir ( pwd ) } pwd = opwd for old ! = pwd { old = pwd check : = filepath . join ( pwd , path ) if info , err : = os . stat ( check ) ; err == nil && info . isdir ( ) { return check , nil } pwd = filepath . dir ( pwd ) } base : = filepath . base ( path ) pwd = opwd for old ! = pwd { old = pwd check : = filepath . join ( pwd , base ) if info , err : = os . stat ( check ) ; err == nil && info . isdir ( ) { return check , nil } pwd = filepath . dir ( pwd ) } return " " , errors . new ( " " ) } 
func checkcommitmessages ( gc githubclient , l * logrus . entry , org , repo string , number int ) ( [ ] github . gitcommit , error ) { allcommits , err : = gc . listprcommits ( org , repo , number ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } l . debugf ( " " , len ( allcommits ) ) var commitsmissingdco [ ] github . gitcommit for , commit : = range allcommits { if ! testre . matchstring ( commit . commit . message ) { c : = commit . commit c . sha = commit . sha commitsmissingdco = append ( commitsmissingdco , c ) } } l . debugf ( " " , len ( commitsmissingdco ) == 0 ) return commitsmissingdco , nil } 
func checkexistingstatus ( gc githubclient , l * logrus . entry , org , repo , sha string ) ( string , error ) { statuses , err : = gc . liststatuses ( org , repo , sha ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } existingstatus : = " " for , status : = range statuses { if status . context ! = dcocontextname { continue } existingstatus = status . state break } l . debugf ( " " , existingstatus ) return existingstatus , nil } 
func checkexistinglabels ( gc githubclient , l * logrus . entry , org , repo string , number int ) ( hasyeslabel , hasnolabel bool , err error ) { labels , err : = gc . getissuelabels ( org , repo , number ) if err ! = nil { return false , false , fmt . errorf ( " " , err ) } for , l : = range labels { if l . name == dcoyeslabel { hasyeslabel = true } if l . name == dconolabel { hasnolabel = true } } return hasyeslabel , hasnolabel , nil } 
func markdownshalist ( org , repo string , list [ ] github . gitcommit ) string { lines : = make ( [ ] string , len ( list ) ) linefmt : = " " for i , commit : = range list { if commit . sha == " " { continue } shortsha : = commit . sha if len ( shortsha ) > 7 { shortsha = shortsha [ : 7 ] } message : = strings . split ( commit . message , " \n " ) [ 0 ] lines [ i ] = fmt . sprintf ( linefmt , shortsha , org , repo , commit . sha , message ) } return strings . join ( lines , " \n " ) } 
func shouldprune ( log * logrus . entry ) func ( github . issuecomment ) bool { return func ( comment github . issuecomment ) bool { return strings . contains ( comment . body , dcomsgprunematch ) } } 
func pathforspec ( spec * downwardapi . jobspec , pathsegment repopathbuilder ) string { switch spec . type { case prowapi . periodicjob , prowapi . postsubmitjob : return path . join ( nonprlogs , spec . job , spec . buildid ) case prowapi . presubmitjob : return path . join ( prlogs , " " , pathsegment ( spec . refs . org , spec . refs . repo ) , strconv . itoa ( spec . refs . pulls [ 0 ] . number ) , spec . job , spec . buildid ) case prowapi . batchjob : return path . join ( prlogs , " " , " " , spec . job , spec . buildid ) default : logrus . fatalf ( " " , spec . type ) } return " " } 
func aliasforspec ( spec * downwardapi . jobspec ) string { switch spec . type { case prowapi . periodicjob , prowapi . postsubmitjob , prowapi . batchjob : return " " case prowapi . presubmitjob : return path . join ( prlogs , " " , spec . job , fmt . sprintf ( " " , spec . buildid ) ) default : logrus . fatalf ( " " , spec . type ) } return " " } 
func rootforspec ( spec * downwardapi . jobspec ) string { switch spec . type { case prowapi . periodicjob , prowapi . postsubmitjob : return path . join ( nonprlogs , spec . job ) case prowapi . presubmitjob , prowapi . batchjob : return path . join ( prlogs , " " , spec . job ) default : logrus . errorf ( " " , spec . type ) } return " " } 
func newsingledefaultrepopathbuilder ( defaultorg , defaultrepo string ) repopathbuilder { return func ( org , repo string ) string { if org == defaultorg && repo == defaultrepo { return " " } repo = strings . replace ( repo , " " , " " , - 1 ) return fmt . sprintf ( " " , org , repo ) } } 
func newexplicitrepopathbuilder ( ) repopathbuilder { return func ( org , repo string ) string { repo = strings . replace ( repo , " " , " " , - 1 ) return fmt . sprintf ( " " , org , repo ) } } 
func registersourceordie ( name string , src issuesource ) { if , ok : = sources [ name ] ; ok { glog . fatalf ( " " , name ) } sources [ name ] = src glog . infof ( " " , name ) } 
func ( c * issuecreator ) createandsync ( ) { var err error if err = c . initialize ( ) ; err ! = nil { glog . fatalf ( " " , err ) } glog . info ( " " ) for srcname , src : = range sources { glog . infof ( " " , srcname ) var issues [ ] issue if issues , err = src . issues ( c ) ; err ! = nil { glog . errorf ( " " , srcname , err ) continue } glog . infof ( " " , srcname ) created : = 0 for , issue : = range issues { if c . sync ( issue ) { created ++ } } glog . infof ( " " , created , len ( issues ) , srcname , ) } } 
func ( c * issuecreator ) registerflags ( ) { flag . stringvar ( & c . ownerpath , " " , " " , " " ) flag . intvar ( & c . maxsigcount , " " , 3 , " " ) flag . intvar ( & c . maxassignees , " " , 3 , " " ) flag . stringvar ( & c . tokenfile , " " , " " , " " ) flag . stringvar ( & c . project , " " , " " , " " ) flag . stringvar ( & c . org , " " , " " , " " ) flag . boolvar ( & c . dryrun , " " , true , " " ) for , src : = range sources { src . registerflags ( ) } } 
func setintersect ( a , b [ ] string ) ( filtered , removed [ ] string ) { for , elema : = range a { found : = false for , elemb : = range b { if elema == elemb { found = true break } } if found { filtered = append ( filtered , elema ) } else { removed = append ( removed , elema ) } } return } 
func getawscreds ( r * common . resource ) ( credentials . value , error ) { val : = credentials . value { } if r . type ! = resourcetype { return val , fmt . errorf ( " " , resourcetype , r . type ) } accesskey , ok : = r . userdata . map . load ( userdataaccessidkey ) if ! ok { return val , errors . new ( " " ) } secretkey , ok : = r . userdata . map . load ( userdatasecretaccesskey ) if ! ok { return val , errors . new ( " " ) } val . accesskeyid = accesskey . ( string ) val . secretaccesskey = secretkey . ( string ) return val , nil } 
func stopper ( ) chan struct { } { stop : = make ( chan struct { } ) c : = make ( chan os . signal , 2 ) signal . notify ( c , os . interrupt , syscall . sigterm ) go func ( ) { < - c logrus . warn ( " " ) close ( stop ) < - c logrus . error ( " " ) os . exit ( 1 ) } ( ) return stop } 
func newpipelineconfig ( cfg rest . config , stop chan struct { } ) ( * pipelineconfig , error ) { bc , err : = pipelineset . newforconfig ( & cfg ) if err ! = nil { return nil , err } if , err : = bc . tektonv1alpha1 ( ) . pipelineruns ( " " ) . list ( metav1 . listoptions { limit : 1 } ) ; err ! = nil { return nil , err } bif : = pipelineinfo . newsharedinformerfactory ( bc , 30 * time . minute ) bif . tekton ( ) . v1alpha1 ( ) . pipelineruns ( ) . lister ( ) go bif . start ( stop ) return & pipelineconfig { client : bc , informer : bif . tekton ( ) . v1alpha1 ( ) . pipelineruns ( ) , } , nil } 
func ( o * kubernetesclientoptions ) addflags ( fs * flag . flagset ) { fs . stringvar ( & o . masterurl , " " , " " , " " ) fs . stringvar ( & o . kubeconfig , " " , " " , " " ) } 
func ( o * kubernetesclientoptions ) validate ( dryrun bool ) error { if dryrun && o . masterurl == " " { return errors . new ( " " ) } if o . masterurl ! = " " { if , err : = url . parserequesturi ( o . masterurl ) ; err ! = nil { return fmt . errorf ( " " , o . masterurl ) } } if o . kubeconfig ! = " " { if , err : = os . stat ( o . kubeconfig ) ; err ! = nil { return err } } return nil } 
func ( o * kubernetesclientoptions ) kubeclient ( ) ( kubernetes . interface , error ) { return kube . getkubernetesclient ( o . masterurl , o . kubeconfig ) } 
func ( o * kubernetesclientoptions ) prowjobclient ( ) ( versioned . interface , error ) { return kube . getprowjobclient ( o . masterurl , o . kubeconfig ) } 
func ( bucket gcsbucket ) resolvesymlink ( symlink string ) ( string , error ) { data , err : = bucket . readobject ( symlink ) if err ! = nil { return " " , fmt . errorf ( " " , symlink , err ) } u : = string ( data ) return prefixre . replaceallstring ( u , " " ) , nil } 
func readjson ( bucket storagebucket , key string , data interface { } ) error { rawdata , err : = bucket . readobject ( key ) if err ! = nil { return fmt . errorf ( " " , key , err ) } err = json . unmarshal ( rawdata , & data ) if err ! = nil { return fmt . errorf ( " " , key , err ) } return nil } 
func ( bucket gcsbucket ) listsubdirs ( prefix string ) ( [ ] string , error ) { if ! strings . hassuffix ( prefix , " " ) { prefix += " " } dirs : = [ ] string { } it : = bucket . objects ( context . background ( ) , & storage . query { prefix : prefix , delimiter : " " , } ) for { attrs , err : = it . next ( ) if err == iterator . done { break } if err ! = nil { return dirs , err } if attrs . prefix ! = " " { dirs = append ( dirs , attrs . prefix ) } } return dirs , nil } 
func ( bucket gcsbucket ) listall ( prefix string ) ( [ ] string , error ) { keys : = [ ] string { } it : = bucket . objects ( context . background ( ) , & storage . query { prefix : prefix , } ) for { attrs , err : = it . next ( ) if err == iterator . done { break } if err ! = nil { return keys , err } keys = append ( keys , attrs . name ) } return keys , nil } 
func ( bucket gcsbucket ) listbuildids ( root string ) ( [ ] int64 , error ) { ids : = [ ] int64 { } if strings . hasprefix ( root , logsprefix ) { dirs , err : = bucket . listsubdirs ( root ) if err ! = nil { return ids , fmt . errorf ( " " , err ) } for , dir : = range dirs { i , err : = strconv . parseint ( path . base ( dir ) , 10 , 64 ) if err == nil { ids = append ( ids , i ) } else { logrus . warningf ( " " , dir ) } } } else { keys , err : = bucket . listall ( root ) if err ! = nil { return ids , fmt . errorf ( " " , err ) } for , key : = range keys { matches : = linkre . findstringsubmatch ( key ) if len ( matches ) == 2 { i , err : = strconv . parseint ( matches [ 1 ] , 10 , 64 ) if err == nil { ids = append ( ids , i ) } else { logrus . warningf ( " " , key ) } } } } return ids , nil } 
func cropresults ( a [ ] int64 , max int64 ) ( [ ] int64 , int , int ) { res : = [ ] int64 { } firstindex : = - 1 lastindex : = 0 for i , v : = range a { if v <= max { res = append ( res , v ) if firstindex == - 1 { firstindex = i } lastindex = i if len ( res ) >= resultsperpage { break } } } return res , firstindex , lastindex } 
func filterprofilepaths ( profile [ ] * cover . profile , paths [ ] string , include bool ) ( [ ] * cover . profile , error ) { parenpaths : = make ( [ ] string , len ( paths ) ) for i , path : = range paths { parenpaths [ i ] = " " + path + " " } joined : = strings . join ( parenpaths , " " ) re , err : = regexp . compile ( joined ) if err ! = nil { return nil , err } result : = make ( [ ] * cover . profile , 0 , len ( profile ) ) for , p : = range profile { if re . matchstring ( p . filename ) == include { result = append ( result , p ) } } return result , nil } 
func handle ( gc githubclient , log * logrus . entry , e * github . genericcommentevent , f haslabelfunc ) error { if e . action ! = github . genericcommentactioncreated { return nil } needslabel : = false if labelre . matchstring ( e . body ) { needslabel = true } else if labelcancelre . matchstring ( e . body ) { needslabel = false } else { return nil } org : = e . repo . owner . login repo : = e . repo . name issuelabels , err : = gc . getissuelabels ( org , repo , e . number ) if err ! = nil { return fmt . errorf ( " " , org , repo , e . number , err ) } haslabel : = f ( labels . hold , issuelabels ) if haslabel && ! needslabel { log . infof ( " " , labels . hold , org , repo , e . number ) return gc . removelabel ( org , repo , e . number , labels . hold ) } else if ! haslabel && needslabel { log . infof ( " " , labels . hold , org , repo , e . number ) return gc . addlabel ( org , repo , e . number , labels . hold ) } return nil } 
func loadsecrets ( paths [ ] string ) ( map [ string ] [ ] byte , error ) { secretsmap : = make ( map [ string ] [ ] byte , len ( paths ) ) for , path : = range paths { secretvalue , err : = loadsinglesecret ( path ) if err ! = nil { return nil , err } secretsmap [ path ] = secretvalue } return secretsmap , nil } 
func loadsinglesecret ( path string ) ( [ ] byte , error ) { b , err : = ioutil . readfile ( path ) if err ! = nil { return nil , fmt . errorf ( " " , path , err ) } return bytes . trimspace ( b ) , nil } 
func ( b * bool ) set ( s string ) error { v , err : = strconv . parsebool ( s ) if err ! = nil { return err } b . explicit = true b . value = v return nil } 
func newopener ( ctx context . context , creds string ) ( opener , error ) { var options [ ] option . clientoption if creds ! = " " { options = append ( options , option . withcredentialsfile ( creds ) ) } client , err : = storage . newclient ( ctx , options ... ) if err ! = nil { if creds ! = " " { return nil , err } logrus . witherror ( err ) . debug ( " " ) client = nil } return opener { gcs : client } , nil } 
func isnotexist ( err error ) bool { return os . isnotexist ( err ) | | err == storage . errobjectnotexist } 
func logclose ( c io . closer ) { if err : = c . close ( ) ; err ! = nil { logrus . witherror ( err ) . error ( " " ) } } 
func ( o opener ) reader ( ctx context . context , path string ) ( io . readcloser , error ) { g , err : = o . opengcs ( path ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if g == nil { return os . open ( path ) } return g . newreader ( ctx ) } 
func ( o opener ) writer ( ctx context . context , path string ) ( io . writecloser , error ) { g , err : = o . opengcs ( path ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if g == nil { return os . create ( path ) } return g . newwriter ( ctx ) , nil } 
func ( gac * githuboauthconfig ) initgithuboauthconfig ( cookie * sessions . cookiestore ) { gob . register ( & oauth2 . token { } ) gac . cookiestore = cookie } 
func deltadisplayed ( change * coveragechange ) string { if change . baseratio < 0 { return " " } return fmt . sprintf ( " " , ( change . newratio - change . baseratio ) * 100 ) } 
func maketable ( basecovlist , newcovlist * calculation . coveragelist , coveragethreshold float32 ) ( string , bool ) { var rows [ ] string iscoveragelow : = false for , change : = range findchanges ( basecovlist , newcovlist ) { filepath : = change . name rows = append ( rows , fmt . sprintf ( " " , filepath , formatpercentage ( change . baseratio ) , formatpercentage ( change . newratio ) , deltadisplayed ( change ) ) ) if change . newratio < coveragethreshold { iscoveragelow = true } } return strings . join ( rows , " \n " ) , iscoveragelow } 
func contentforgithubpost ( baseprofiles , newprofiles [ ] * cover . profile , jobname string , coveragethreshold float32 ) ( string , bool ) { rows : = [ ] string { " " , fmt . sprintf ( " " , jobname ) , " " , " " , " " , } table , iscoveragelow : = maketable ( calculation . producecovlist ( baseprofiles ) , calculation . producecovlist ( newprofiles ) , coveragethreshold ) if table == " " { return " " , false } rows = append ( rows , table ) rows = append ( rows , " " ) return strings . join ( rows , " \n " ) , iscoveragelow } 
func ( client * client ) addflags ( cmd * cobra . command ) { cmd . persistentflags ( ) . stringvar ( & client . token , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & client . tokenfile , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & client . org , " " , " " , " " ) cmd . persistentflags ( ) . stringvar ( & client . project , " " , " " , " " ) } 
func ( client * client ) checkflags ( ) error { if client . org == " " { return fmt . errorf ( " " ) } client . org = strings . tolower ( client . org ) if client . project == " " { return fmt . errorf ( " " ) } client . project = strings . tolower ( client . project ) return nil } 
func ( client * client ) getgithubclient ( ) ( * github . client , error ) { if client . githubclient ! = nil { return client . githubclient , nil } token : = client . token if len ( token ) == 0 && len ( client . tokenfile ) ! = 0 { data , err : = ioutil . readfile ( client . tokenfile ) if err ! = nil { return nil , err } token = strings . trimspace ( string ( data ) ) } if len ( token ) > 0 { ts : = oauth2 . statictokensource ( & oauth2 . token { accesstoken : token } ) tc : = oauth2 . newclient ( oauth2 . nocontext , ts ) client . githubclient = github . newclient ( tc ) } else { client . githubclient = github . newclient ( nil ) } return client . githubclient , nil } 
func ( client * client ) limitscheckandwait ( ) { var sleep time . duration githubclient , err : = client . getgithubclient ( ) if err ! = nil { glog . error ( " " , err ) sleep = time . minute } else { limits , , err : = githubclient . ratelimits ( context . background ( ) ) if err ! = nil { glog . error ( " " , err ) sleep = time . minute } if limits ! = nil && limits . core ! = nil && limits . core . remaining < tokenlimit { sleep = limits . core . reset . sub ( time . now ( ) ) glog . warning ( " " , sleep ) } } time . sleep ( sleep ) } 
func ( client * client ) repositoryname ( ) string { return fmt . sprintf ( " " , client . org , client . project ) } 
func ( client * client ) fetchissues ( latest time . time , c chan * github . issue ) { opt : = & github . issuelistbyrepooptions { since : latest , sort : " " , state : " " , direction : " " } githubclient , err : = client . getgithubclient ( ) if err ! = nil { close ( c ) glog . error ( err ) return } count : = 0 for { client . limitscheckandwait ( ) issues , resp , err : = githubclient . issues . listbyrepo ( context . background ( ) , client . org , client . project , opt , ) if err ! = nil { close ( c ) glog . error ( err ) return } for , issue : = range issues { c < - issue count ++ } if resp . nextpage == 0 { break } opt . listoptions . page = resp . nextpage } glog . infof ( " " , count , latest ) close ( c ) } 
func hasid ( events [ ] * github . issueevent , id int ) bool { for , event : = range events { if * event . id == int64 ( id ) { return true } } return false } 
func ( client * client ) fetchissueevents ( issueid int , latest * int , c chan * github . issueevent ) { opt : = & github . listoptions { perpage : 100 } githubclient , err : = client . getgithubclient ( ) if err ! = nil { close ( c ) glog . error ( err ) return } count : = 0 for { client . limitscheckandwait ( ) events , resp , err : = githubclient . issues . listissueevents ( context . background ( ) , client . org , client . project , issueid , opt , ) if err ! = nil { glog . errorf ( " " , err ) time . sleep ( time . second ) continue } for , event : = range events { c < - event count ++ } if resp . nextpage == 0 | | ( latest ! = nil && hasid ( events , * latest ) ) { break } opt . page = resp . nextpage } glog . infof ( " " , count ) close ( c ) } 
func ( client * client ) fetchissuecomments ( issueid int , latest time . time , c chan * github . issuecomment ) { opt : = & github . issuelistcommentsoptions { since : latest , sort : " " , direction : " " } githubclient , err : = client . getgithubclient ( ) if err ! = nil { close ( c ) glog . error ( err ) return } count : = 0 for { client . limitscheckandwait ( ) comments , resp , err : = githubclient . issues . listcomments ( context . background ( ) , client . org , client . project , issueid , opt , ) if err ! = nil { close ( c ) glog . error ( err ) return } for , comment : = range comments { c < - comment count ++ } if resp . nextpage == 0 { break } opt . listoptions . page = resp . nextpage } glog . infof ( " " , count , latest , issueid ) close ( c ) } 
func isprchanged ( pe github . pullrequestevent ) bool { switch pe . action { case github . pullrequestactionopened : return true case github . pullrequestactionreopened : return true case github . pullrequestactionsynchronize : return true case github . pullrequestactionedited : return true default : return false } } 
func newfetcher ( repository string ) * fetcher { return & fetcher { issueschannel : make ( chan sql . issue , 100 ) , eventscommentschannel : make ( chan interface { } , 100 ) , repository : repository , } } 
func ( f * fetcher ) fetchrecentissues ( db * gorm . db ) error { glog . infof ( " " , f . lastissue ) var issues [ ] sql . issue query : = db . where ( " " , f . lastissue ) . where ( " " , f . repository ) . order ( " " ) . preload ( " " ) . find ( & issues ) if query . error ! = nil { return query . error } count : = len ( issues ) for , issue : = range issues { f . issueschannel < - issue f . lastissue = issue . issueupdatedat } glog . infof ( " " , count ) return nil } 
func ( f * fetcher ) fetch ( db * gorm . db ) error { if err : = f . fetchrecentissues ( db ) ; err ! = nil { return err } if err : = f . fetchrecenteventsandcomments ( db ) ; err ! = nil { return err } return nil } 
func zoneismanaged ( z * route53 . hostedzone ) bool { name : = aws . stringvalue ( z . name ) if " " == name { return true } klog . infof ( " " , name ) return false } 
func resourcerecordsetismanaged ( rrs * route53 . resourcerecordset ) bool { if " " ! = aws . stringvalue ( rrs . type ) { return false } name : = aws . stringvalue ( rrs . name ) for , managednameregex : = range managednameregexes { if managednameregex . matchstring ( name ) { return true } } klog . infof ( " " , name ) return false } 
func ( fjr * flakyjobreporter ) registerflags ( ) { flag . stringvar ( & fjr . flakyjobdataurl , " " , " " , " " ) flag . intvar ( & fjr . synccount , " " , 3 , " " ) } 
func ( fjr * flakyjobreporter ) issues ( c * creator . issuecreator ) ( [ ] creator . issue , error ) { fjr . creator = c json , err : = readhttp ( fjr . flakyjobdataurl ) if err ! = nil { return nil , err } flakyjobs , err : = fjr . parseflakyjobs ( json ) if err ! = nil { return nil , err } count : = fjr . synccount if len ( flakyjobs ) < count { count = len ( flakyjobs ) } issues : = make ( [ ] creator . issue , 0 , count ) for , fj : = range flakyjobs [ 0 : count ] { issues = append ( issues , fj ) } return issues , nil } 
func ( fjr * flakyjobreporter ) parseflakyjobs ( jsonin [ ] byte ) ( [ ] * flakyjob , error ) { var flakemap map [ string ] * flakyjob err : = json . unmarshal ( jsonin , & flakemap ) if err ! = nil | | flakemap == nil { return nil , fmt . errorf ( " " , err ) } flakyjobs : = make ( [ ] * flakyjob , 0 , len ( flakemap ) ) for job , fj : = range flakemap { if job == " " { glog . errorf ( " \n " ) continue } if fj == nil { glog . errorf ( " \n " , job ) continue } if fj . consistency == nil { glog . errorf ( " \n " , job ) continue } if fj . flakecount == nil { glog . errorf ( " \n " , job ) continue } if fj . flakytests == nil { glog . errorf ( " \n " , job ) continue } fj . name = job fj . reporter = fjr flakyjobs = append ( flakyjobs , fj ) } sort . slicestable ( flakyjobs , func ( i , j int ) bool { if * flakyjobs [ i ] . flakecount == * flakyjobs [ j ] . flakecount { return * flakyjobs [ i ] . consistency < * flakyjobs [ j ] . consistency } return * flakyjobs [ i ] . flakecount > * flakyjobs [ j ] . flakecount } ) return flakyjobs , nil } 
func ( fj * flakyjob ) title ( ) string { return fmt . sprintf ( " " , fj . name , * fj . flakecount ) } 
func ( fj * flakyjob ) labels ( ) [ ] string { labels : = [ ] string { " " } for sig : = range fj . reporter . creator . testssigs ( fj . testssorted ( ) ) { labels = append ( labels , " " + sig ) } return labels } 
func ( l linesbytimestamp ) string ( ) string { sort . sort ( l ) var log string for i , line : = range l { switch i { case len ( l ) - 1 : log += string ( line . actual ) default : log += fmt . sprintf ( " \n " , strings . trimsuffix ( string ( line . actual ) , " \n " ) ) } } return fmt . sprintf ( " " , log ) } 
func handlemetric ( boskos * client . client ) http . handlerfunc { return func ( res http . responsewriter , req * http . request ) { log : = logrus . withfield ( " " , " " ) log . infof ( " " , req . remoteaddr ) if req . method ! = " " { log . warningf ( " " , req . method ) http . error ( res , " " , http . statusmethodnotallowed ) return } rtype : = req . url . query ( ) . get ( " " ) if rtype == " " { msg : = " " log . warning ( msg ) http . error ( res , msg , http . statusbadrequest ) return } log . infof ( " " , rtype ) metric , err : = boskos . metric ( rtype ) if err ! = nil { log . witherror ( err ) . errorf ( " " , rtype ) http . error ( res , err . error ( ) , http . statusnotfound ) return } metricjson , err : = json . marshal ( metric ) if err ! = nil { log . witherror ( err ) . errorf ( " " , metricjson ) http . error ( res , err . error ( ) , http . statusinternalservererror ) return } log . infof ( " " , rtype , string ( metricjson ) ) fmt . fprint ( res , string ( metricjson ) ) } } 
func loadclusterconfig ( masterurl , kubeconfig string ) ( * rest . config , error ) { clusterconfig , err : = clientcmd . buildconfigfromflags ( masterurl , kubeconfig ) if err == nil { return clusterconfig , nil } credentials , err : = clientcmd . newdefaultclientconfigloadingrules ( ) . load ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } clusterconfig , err = clientcmd . newdefaultclientconfig ( * credentials , & clientcmd . configoverrides { } ) . clientconfig ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return clusterconfig , nil } 
func getkubernetesclient ( masterurl , kubeconfig string ) ( kubernetes . interface , error ) { config , err : = loadclusterconfig ( masterurl , kubeconfig ) if err ! = nil { return nil , err } client , err : = kubernetes . newforconfig ( config ) if err ! = nil { return nil , err } logrus . info ( " " ) return client , nil } 
func getprowjobclient ( masterurl , kubeconfig string ) ( prowjobclientset . interface , error ) { config , err : = loadclusterconfig ( masterurl , kubeconfig ) if err ! = nil { return nil , err } prowjobclient , err : = prowjobclientset . newforconfig ( config ) if err ! = nil { return nil , err } logrus . info ( " " ) return prowjobclient , nil } 
func ( o * options ) validate ( ) error { ents : = o . entries ( ) if len ( ents ) == 0 { return errors . new ( " " ) } for i , e : = range ents { if err : = e . validate ( ) ; err ! = nil { return fmt . errorf ( " " , i , err ) } } return o . gcsoptions . validate ( ) } 
func ( o * options ) addflags ( flags * flag . flagset ) { o . gcsoptions . addflags ( flags ) } 
func newjobspec ( spec prowapi . prowjobspec , buildid , prowjobid string ) jobspec { return jobspec { type : spec . type , job : spec . job , buildid : buildid , prowjobid : prowjobid , refs : spec . refs , extrarefs : spec . extrarefs , agent : spec . agent , } } 
func resolvespecfromenv ( ) ( * jobspec , error ) { specenv , ok : = os . lookupenv ( jobspecenv ) if ! ok { return nil , fmt . errorf ( " " , jobspecenv ) } spec : = & jobspec { } if err : = json . unmarshal ( [ ] byte ( specenv ) , spec ) ; err ! = nil { return nil , fmt . errorf ( " " , jobspecenv , err ) } return spec , nil } 
func envforspec ( spec jobspec ) ( map [ string ] string , error ) { env : = map [ string ] string { jobnameenv : spec . job , buildidenv : spec . buildid , prowjobidenv : spec . prowjobid , jobtypeenv : string ( spec . type ) , } if spec . agent == prowapi . kubernetesagent { env [ prowbuildidenv ] = spec . buildid } raw , err : = json . marshal ( spec ) if err ! = nil { return env , fmt . errorf ( " " , err ) } env [ jobspecenv ] = string ( raw ) if spec . type == prowapi . periodicjob { return env , nil } env [ repoownerenv ] = spec . refs . org env [ reponameenv ] = spec . refs . repo env [ pullbaserefenv ] = spec . refs . baseref env [ pullbaseshaenv ] = spec . refs . basesha env [ pullrefsenv ] = spec . refs . string ( ) if spec . type == prowapi . postsubmitjob | | spec . type == prowapi . batchjob { return env , nil } env [ pullnumberenv ] = strconv . itoa ( spec . refs . pulls [ 0 ] . number ) env [ pullpullshaenv ] = spec . refs . pulls [ 0 ] . sha return env , nil } 
func envfortype ( jobtype prowapi . prowjobtype ) [ ] string { baseenv : = [ ] string { jobnameenv , jobspecenv , jobtypeenv , prowjobidenv , buildidenv , prowbuildidenv } refsenv : = [ ] string { repoownerenv , reponameenv , pullbaserefenv , pullbaseshaenv , pullrefsenv } pullenv : = [ ] string { pullnumberenv , pullpullshaenv } switch jobtype { case prowapi . periodicjob : return baseenv case prowapi . postsubmitjob , prowapi . batchjob : return append ( baseenv , refsenv ... ) case prowapi . presubmitjob : return append ( append ( baseenv , refsenv ... ) , pullenv ... ) default : return [ ] string { } } } 
func getrevisionfromref ( refs * prowapi . refs ) string { if len ( refs . pulls ) > 0 { return refs . pulls [ 0 ] . sha } if refs . basesha ! = " " { return refs . basesha } return refs . baseref } 
func getrevisionfromspec ( spec * jobspec ) string { if spec . refs ! = nil { return getrevisionfromref ( spec . refs ) } else if len ( spec . extrarefs ) > 0 { return getrevisionfromref ( & spec . extrarefs [ 0 ] ) } return " " } 
func helpprovider ( config * plugins . configuration , enabledrepos [ ] string ) ( * pluginhelp . pluginhelp , error ) { return & pluginhelp . pluginhelp { description : fmt . sprintf ( " " , labels . mergecommits ) , } , nil } 
func newgroup ( gc ghfileclient , owner , repo , sha string ) ( * group , error ) { g : = & group { paths : make ( map [ string ] bool ) , filenames : make ( map [ string ] bool ) , pathprefixes : make ( map [ string ] bool ) , fileprefixes : make ( map [ string ] bool ) , } bs , err : = gc . getfile ( owner , repo , genconfigfile , sha ) if err ! = nil { switch err . ( type ) { case * github . filenotfound : return g , nil default : return nil , fmt . errorf ( " " , err ) } } repofiles , err : = g . load ( bytes . newbuffer ( bs ) ) if err ! = nil { return nil , err } for , f : = range repofiles { bs , err = gc . getfile ( owner , repo , f , sha ) if err ! = nil { return nil , err } if err = g . loadpaths ( bytes . newbuffer ( bs ) ) ; err ! = nil { return nil , err } } return g , nil } 
func ( g * group ) load ( r io . reader ) ( [ ] string , error ) { var repopaths [ ] string s : = bufio . newscanner ( r ) for s . scan ( ) { l : = strings . trimspace ( s . text ( ) ) if l == " " | | l [ 0 ] == { continue } fs : = strings . fields ( l ) if len ( fs ) ! = 2 { return repopaths , & parseerror { line : l } } switch fs [ 0 ] { case " " , " " : g . pathprefixes [ fs [ 1 ] ] = true case " " : g . fileprefixes [ fs [ 1 ] ] = true case " " : g . filenames [ fs [ 1 ] ] = true case " " : g . filenames [ fs [ 1 ] ] = true case " " : repopaths = append ( repopaths , fs [ 1 ] ) default : return repopaths , & parseerror { line : l } } } if err : = s . err ( ) ; err ! = nil { return repopaths , err } return repopaths , nil } 
func ( g * group ) loadpaths ( r io . reader ) error { s : = bufio . newscanner ( r ) for s . scan ( ) { l : = strings . trimspace ( s . text ( ) ) if l == " " | | l [ 0 ] == { continue } g . paths [ l ] = true } if err : = s . err ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( g * group ) match ( path string ) bool { if g . paths [ path ] { return true } for prefix : = range g . pathprefixes { if strings . hasprefix ( path , prefix ) { return true } } base : = filepath . base ( path ) if g . filenames [ base ] { return true } for prefix : = range g . fileprefixes { if strings . hasprefix ( base , prefix ) { return true } } return false } 
func ( config * influxconfig ) createdatabase ( tags map [ string ] string , measurement string ) ( * influxdb , error ) { client , err : = influxdb . newhttpclient ( influxdb . httpconfig { addr : config . host , username : config . user , password : config . password , } ) if err ! = nil { return nil , err } err = dropseries ( client , measurement , config . db , tags ) if err ! = nil { return nil , err } bp , err : = influxdb . newbatchpoints ( influxdb . batchpointsconfig { database : config . db , precision : " " , } ) if err ! = nil { return nil , err } return & influxdb { client : client , database : config . db , batch : bp , tags : tags , measurement : measurement , } , err } 
func mergetags ( defaulttags , extratags map [ string ] string ) map [ string ] string { newtags : = map [ string ] string { } for k , v : = range defaulttags { newtags [ k ] = v } for k , v : = range extratags { newtags [ k ] = v } return newtags } 
func tagstowhere ( tags map [ string ] string ) string { if len ( tags ) == 0 { return " " } sortedkeys : = [ ] string { } for k : = range tags { sortedkeys = append ( sortedkeys , k ) } sort . strings ( sortedkeys ) conditions : = [ ] string { } for , key : = range sortedkeys { conditions = append ( conditions , fmt . sprintf ( ' " %s " = ' % v ' ' , key , tags [ key ] ) ) } return " " + strings . join ( conditions , " " ) } 
func ( i * influxdb ) push ( tags map [ string ] string , fields map [ string ] interface { } , date time . time ) error { pt , err : = influxdb . newpoint ( i . measurement , mergetags ( i . tags , tags ) , fields , date ) if err ! = nil { return err } i . batch . addpoint ( pt ) i . batchsize ++ return nil } 
func ( i * influxdb ) pushbatchpoints ( ) error { err : = i . client . write ( i . batch ) if err ! = nil { return err } glog . infof ( " " , i . batchsize ) i . batch , err = influxdb . newbatchpoints ( influxdb . batchpointsconfig { database : i . database , precision : " " , } ) i . batchsize = 0 if err ! = nil { return err } return nil } 
func ( af * podlogartifactfetcher ) artifact ( jobname , buildid string , sizelimit int64 ) ( lenses . artifact , error ) { podlog , err : = newpodlogartifact ( jobname , buildid , sizelimit , af . jobagent ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return podlog , nil } 
func roleismanaged ( role * iam . role ) bool { name : = aws . stringvalue ( role . rolename ) path : = aws . stringvalue ( role . path ) if strings . hasprefix ( path , " " ) { return false } if strings . hasprefix ( name , " " ) | | strings . hasprefix ( name , " " ) { return true } klog . infof ( " " , name , path ) return false } 
func gather ( c * plank . controller ) { tick : = time . tick ( 30 * time . second ) sig : = make ( chan os . signal , 1 ) signal . notify ( sig , os . interrupt , syscall . sigterm ) for { select { case < - tick : start : = time . now ( ) c . syncmetrics ( ) logrus . withfield ( " " , fmt . sprintf ( " " , time . since ( start ) ) ) . debug ( " " ) case < - sig : logrus . debug ( " " ) return } } } 
func makerequest ( policy branchprotection . policy ) github . branchprotectionrequest { return github . branchprotectionrequest { enforceadmins : makeadmins ( policy . admins ) , requiredpullrequestreviews : makereviews ( policy . requiredpullrequestreviews ) , requiredstatuschecks : makechecks ( policy . requiredstatuschecks ) , restrictions : makerestrictions ( policy . restrictions ) , } } 
func makeadmins ( val * bool ) * bool { if v : = makebool ( val ) ; v { return & v } return nil } 
func makechecks ( cp * branchprotection . contextpolicy ) * github . requiredstatuschecks { if cp == nil { return nil } return & github . requiredstatuschecks { contexts : append ( [ ] string { } , sets . newstring ( cp . contexts ... ) . list ( ) ... ) , strict : makebool ( cp . strict ) , } } 
func makerestrictions ( rp * branchprotection . restrictions ) * github . restrictions { if rp == nil { return nil } teams : = append ( [ ] string { } , sets . newstring ( rp . teams ... ) . list ( ) ... ) users : = append ( [ ] string { } , sets . newstring ( rp . users ... ) . list ( ) ... ) return & github . restrictions { teams : & teams , users : & users , } } 
func makereviews ( rp * branchprotection . reviewpolicy ) * github . requiredpullrequestreviews { switch { case rp == nil : return nil case rp . approvals == nil : logrus . warn ( " " ) return nil case * rp . approvals == 0 : return nil } rprr : = github . requiredpullrequestreviews { dismissstalereviews : makebool ( rp . dismissstale ) , requirecodeownerreviews : makebool ( rp . requireowners ) , requiredapprovingreviewcount : * rp . approvals , } if rp . dismissalrestrictions ! = nil { rprr . dismissalrestrictions = * makerestrictions ( rp . dismissalrestrictions ) } return & rprr } 
func ( lens lens ) header ( artifacts [ ] lenses . artifact , resourcedir string ) string { return executetemplate ( resourcedir , " " , buildlogsview { } ) } 
func ( lens lens ) body ( artifacts [ ] lenses . artifact , resourcedir string , data string ) string { buildlogsview : = buildlogsview { logviews : [ ] logartifactview { } , rawgetallrequests : make ( map [ string ] string ) , rawgetmorerequests : make ( map [ string ] string ) , } for , a : = range artifacts { av : = logartifactview { artifactname : a . jobpath ( ) , artifactlink : a . canonicallink ( ) , } lines , err : = loglinesall ( a ) if err ! = nil { logrus . witherror ( err ) . info ( " " ) continue } av . linegroups = grouplines ( highlightlines ( lines , 0 ) ) av . viewall = true buildlogsview . logviews = append ( buildlogsview . logviews , av ) } return executetemplate ( resourcedir , " " , buildlogsview ) } 
func ( lens lens ) callback ( artifacts [ ] lenses . artifact , resourcedir string , data string ) string { var request linerequest err : = json . unmarshal ( [ ] byte ( data ) , & request ) if err ! = nil { return " " } artifact , ok : = artifactbyname ( artifacts , request . artifact ) if ! ok { return " " + request . artifact } var lines [ ] string if request . offset == 0 && request . length == - 1 { lines , err = loglinesall ( artifact ) } else { lines , err = loglines ( artifact , request . offset , request . length ) } if err ! = nil { return fmt . sprintf ( " " , err ) } loglines : = highlightlines ( lines , request . startline ) return executetemplate ( resourcedir , " " , loglines ) } 
func loglinesall ( artifact lenses . artifact ) ( [ ] string , error ) { read , err : = artifact . readall ( ) if err ! = nil { return nil , fmt . errorf ( " " , artifact . jobpath ( ) , err ) } loglines : = strings . split ( string ( read ) , " \n " ) return loglines , nil } 
func grouplines ( loglines [ ] logline ) [ ] linegroup { for i , line : = range loglines { if line . highlighted { for d : = - neighborlines ; d <= neighborlines ; d ++ { if i + d < 0 { continue } if i + d >= len ( loglines ) { break } loglines [ i + d ] . skip = false } } } currentoffset : = 0 previousoffset : = 0 var linegroups [ ] linegroup curgroup : = linegroup { } for i , line : = range loglines { if line . skip == curgroup . skip { curgroup . loglines = append ( curgroup . loglines , line ) currentoffset += line . length } else { curgroup . end = i curgroup . bytelength = currentoffset - previousoffset - 1 previousoffset = currentoffset if curgroup . skip { if curgroup . linesskipped ( ) < minlinesskipped { curgroup . skip = false } } if len ( curgroup . loglines ) > 0 { linegroups = append ( linegroups , curgroup ) } curgroup = linegroup { skip : line . skip , start : i , loglines : [ ] logline { line } , byteoffset : currentoffset , } currentoffset += line . length } } curgroup . end = len ( loglines ) curgroup . bytelength = currentoffset - previousoffset - 1 if curgroup . skip { if curgroup . linesskipped ( ) < minlinesskipped { curgroup . skip = false } } if len ( curgroup . loglines ) > 0 { linegroups = append ( linegroups , curgroup ) } return linegroups } 
func executetemplate ( resourcedir , templatename string , data interface { } ) string { t : = template . new ( " " ) , err : = t . parsefiles ( filepath . join ( resourcedir , " " ) ) if err ! = nil { return fmt . sprintf ( " " , err ) } var buf bytes . buffer if err : = t . executetemplate ( & buf , templatename , data ) ; err ! = nil { logrus . witherror ( err ) . error ( " " ) } return buf . string ( ) } 
func ( in * resourceobject ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func ( in * resourceobject ) fromitem ( i common . item ) { r , err : = common . itemtoresource ( i ) if err == nil { in . fromresource ( r ) } } 
func ( in * resourcecollection ) setitems ( objects [ ] object ) { var items [ ] * resourceobject for , b : = range objects { items = append ( items , b . ( * resourceobject ) ) } in . items = items } 
func ( in * resourcecollection ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func usecontext ( o options , ctx string ) error { , cmd : = command ( " " , " " , " " , ctx ) return cmd . run ( ) } 
func currentcontext ( o options ) ( string , error ) { , cmd : = command ( " " , " " , " " ) b , err : = cmd . output ( ) return strings . trimspace ( string ( b ) ) , err } 
func getcredentials ( o options ) error { if ! o . changecontext { cur , err : = currentcontext ( o ) if err ! = nil { return fmt . errorf ( " " , err ) } defer usecontext ( o , cur ) } old , set : = os . lookupenv ( useclientcertenv ) if set { defer os . setenv ( useclientcertenv , old ) } if err : = os . setenv ( " " , " " ) ; err ! = nil { return fmt . errorf ( " " , useclientcertenv , err ) } args , cmd : = command ( " " , " " , " " , " " , o . cluster , " " , o . project , " " , o . zone , ) if err : = cmd . run ( ) ; err ! = nil { return fmt . errorf ( " " , strings . join ( args , " " ) , err ) } return nil } 
func command ( bin string , args ... string ) ( [ ] string , * exec . cmd ) { cmd : = exec . command ( bin , args ... ) cmd . stderr = os . stderr return append ( [ ] string { bin } , args ... ) , cmd } 
func getaccount ( ) ( string , error ) { args , cmd : = command ( " " , " " , " " , " " ) b , err : = cmd . output ( ) if err ! = nil { return " " , fmt . errorf ( " " , strings . join ( args , " " ) , err ) } return strings . trimspace ( string ( b ) ) , nil } 
func setaccount ( account string ) error { , cmd : = command ( " " , " " , " " , " " , account ) return cmd . run ( ) } 
func describecluster ( o options ) ( * describe , error ) { if o . account ! = " " { act , err : = getaccount ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } defer setaccount ( act ) if err = setaccount ( o . account ) ; err ! = nil { return nil , fmt . errorf ( " " , o . account , err ) } } args , cmd : = command ( " " , " " , " " , " " , o . cluster , " " , o . project , " " , o . zone , " " , ) data , err : = cmd . output ( ) if err ! = nil { return nil , fmt . errorf ( " " , strings . join ( args , " " ) , err ) } var d describe if yaml . unmarshal ( data , & d ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } if d . endpoint == " " { return nil , errors . new ( " " ) } if len ( d . auth . clustercacertificate ) == 0 { return nil , errors . new ( " " ) } if len ( d . auth . clientkey ) == 0 { return nil , errors . new ( " " ) } if len ( d . auth . clientcertificate ) == 0 { return nil , errors . new ( " " ) } return & d , nil } 
func ( ss * strslice ) set ( value string ) error { * ss = append ( * ss , value ) return nil } 
func splitbucketobject ( path string ) ( string , string ) { path = strings . trim ( path , " " ) parts : = strings . splitn ( path , " " , 2 ) if len ( parts ) == 0 { return " " , " " } if len ( parts ) == 1 { return parts [ 0 ] , " " } return parts [ 0 ] , parts [ 1 ] } 
func dirname ( path string ) string { leading : = " " if strings . hasprefix ( path , " " ) { leading = " " } parts : = strings . split ( strings . trim ( path , " " ) , " " ) if len ( parts ) > 1 { return leading + strings . join ( parts [ 0 : len ( parts ) - 1 ] , " " ) + " " } return leading } 
func parsexml ( body [ ] byte , object string ) ( * gcsdir , error ) { dir : = new ( gcsdir ) if err : = xml . unmarshal ( body , & dir ) ; err ! = nil { return nil , err } isdir : = object == " " | | len ( dir . contents ) + len ( dir . commonprefixes ) > 0 selfindex : = - 1 for i : = range dir . contents { rec : = & dir . contents [ i ] name : = strings . trimprefix ( rec . name , object ) if name == " " { selfindex = i continue } rec . name = name if strings . hassuffix ( name , " " ) { rec . isdir = true } } for i : = range dir . commonprefixes { cp : = & dir . commonprefixes [ i ] cp . prefix = strings . trimprefix ( cp . prefix , object ) } if ! isdir { return nil , nil } if selfindex >= 0 { dir . contents = append ( dir . contents [ : selfindex ] , dir . contents [ selfindex + 1 : ] ... ) } return dir , nil } 
func ( dir * gcsdir ) render ( out http . responsewriter , inpath string ) { htmlpageheader ( out , dir . name ) if ! strings . hassuffix ( inpath , " " ) { inpath += " " } htmlcontentheader ( out , dir . name , inpath ) if dir . nextmarker ! = " " { htmlnextbutton ( out , gcspath + inpath , dir . nextmarker ) } htmlgridheader ( out ) if parent : = dirname ( inpath ) ; parent ! = " " { url : = gcspath + parent htmlgriditem ( out , iconback , url , " " , " " , " " ) } for i : = range dir . commonprefixes { dir . commonprefixes [ i ] . render ( out , inpath ) } for i : = range dir . contents { dir . contents [ i ] . render ( out , inpath ) } if dir . nextmarker ! = " " { htmlnextbutton ( out , gcspath + inpath , dir . nextmarker ) } htmlcontentfooter ( out ) htmlpagefooter ( out ) } 
func ( rec * record ) render ( out http . responsewriter , inpath string ) { mtime : = " " ts , err : = time . parse ( time . rfc3339 , rec . mtime ) if err == nil { mtime = ts . format ( " " ) } var url , size string if rec . isdir { url = gcspath + inpath + rec . name size = " " } else { url = gcsbaseurl + inpath + rec . name size = fmt . sprintf ( " " , rec . size ) } htmlgriditem ( out , iconfile , url , rec . name , size , mtime ) } 
func ( pfx * prefix ) render ( out http . responsewriter , inpath string ) { url : = gcspath + inpath + pfx . prefix htmlgriditem ( out , icondir , url , pfx . prefix , " " , " " ) } 
func ( tl txnlogger ) printf ( fmt string , args ... interface { } ) { args = append ( [ ] interface { } { tl . nonce } , args ... ) log . printf ( " " + fmt , args ... ) } 
func processregexmatches ( matches [ ] string ) ( string , string , bool , string ) { var shouldclear = false proposedproject : = matches [ 1 ] proposedcolumnname : = " " if len ( matches ) > 1 && proposedproject ! = clearkeyword { proposedcolumnname = matches [ 2 ] } if proposedproject == clearkeyword { if len ( matches ) > 2 && matches [ 2 ] ! = " " { proposedproject = matches [ 2 ] shouldclear = true } else { msg : = invalidnumargs return " " , " " , false , msg } } return proposedproject , proposedcolumnname , shouldclear , " " } 
func ( p projectsflag ) set ( value string ) error { parts : = strings . splitn ( value , " " , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } host : = parts [ 0 ] if , ok : = p [ host ] ; ok { return fmt . errorf ( " " , host ) } repos : = strings . split ( parts [ 1 ] , " " ) p [ host ] = repos return nil } 
func newclient ( instances map [ string ] [ ] string ) ( * client , error ) { c : = & client { handlers : map [ string ] * gerritinstancehandler { } , } for instance : = range instances { gc , err : = gerrit . newclient ( instance , nil ) if err ! = nil { return nil , err } c . handlers [ instance ] = & gerritinstancehandler { instance : instance , projects : instances [ instance ] , authservice : gc . authentication , accountservice : gc . accounts , changeservice : gc . changes , projectservice : gc . projects , } } return c , nil } 
func ( c * client ) querychanges ( lastupdate time . time , ratelimit int ) map [ string ] [ ] changeinfo { result : = map [ string ] [ ] changeinfo { } for , h : = range c . handlers { changes : = h . queryallchanges ( lastupdate , ratelimit ) if len ( changes ) > 0 { result [ h . instance ] = [ ] changeinfo { } for , change : = range changes { result [ h . instance ] = append ( result [ h . instance ] , change ) } } } return result } 
func ( c * client ) setreview ( instance , id , revision , message string , labels map [ string ] string ) error { h , ok : = c . handlers [ instance ] if ! ok { return fmt . errorf ( " " , instance ) } if , , err : = h . changeservice . setreview ( id , revision , & gerrit . reviewinput { message : message , labels : labels , } ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( c * client ) getbranchrevision ( instance , project , branch string ) ( string , error ) { h , ok : = c . handlers [ instance ] if ! ok { return " " , fmt . errorf ( " " , instance ) } res , , err : = h . projectservice . getbranch ( project , branch ) if err ! = nil { return " " , err } return res . revision , nil } 
func ( h * gerritinstancehandler ) queryallchanges ( lastupdate time . time , ratelimit int ) [ ] gerrit . changeinfo { result : = [ ] gerrit . changeinfo { } for , project : = range h . projects { changes , err : = h . querychangesforproject ( project , lastupdate , ratelimit ) if err ! = nil { logrus . witherror ( err ) . errorf ( " " , project ) continue } result = append ( result , changes ... ) } return result } 
func newtypefilterwrapperplugin ( plugin plugin ) * typefilterwrapperplugin { return & typefilterwrapperplugin { plugin : plugin , pass : map [ string ] bool { } , } } 
func ( t * typefilterwrapperplugin ) addflags ( cmd * cobra . command ) { cmd . flags ( ) . boolvar ( & t . pullrequests , " " , false , " " ) cmd . flags ( ) . boolvar ( & t . issues , " " , false , " " ) } 
func ( t * typefilterwrapperplugin ) checkflags ( ) error { if t . pullrequests && t . issues { return fmt . errorf ( " " ) } return nil } 
func ( t * typefilterwrapperplugin ) receiveissue ( issue sql . issue ) [ ] point { if issue . ispr && t . pullrequests { return nil } else if ! issue . ispr && t . issues { return nil } else { t . pass [ issue . id ] = true return t . plugin . receiveissue ( issue ) } } 
func ( t * typefilterwrapperplugin ) receiveissueevent ( event sql . issueevent ) [ ] point { if ! t . pass [ event . issueid ] { return nil } return t . plugin . receiveissueevent ( event ) } 
func ( t * typefilterwrapperplugin ) receivecomment ( comment sql . comment ) [ ] point { if ! t . pass [ comment . issueid ] { return nil } return t . plugin . receivecomment ( comment ) } 
func ( o * kubernetesclientoptions ) addflags ( fs * flag . flagset ) { fs . stringvar ( & o . namespace , " " , v1 . namespacedefault , " " ) fs . stringvar ( & o . kubeconfig , " " , " " , " " ) fs . boolvar ( & o . inmemory , " " , false , " " ) } 
func ( o * kubernetesclientoptions ) validate ( ) error { if o . kubeconfig ! = " " { if , err : = os . stat ( o . kubeconfig ) ; err ! = nil { return err } } return nil } 
func ( o * kubernetesclientoptions ) client ( t type ) ( clientinterface , error ) { if o . inmemory { return newdummyclient ( t ) , nil } return o . newcrdclient ( t ) } 
func ( o * kubernetesclientoptions ) newcrdclient ( t type ) ( * client , error ) { config , scheme , err : = createrestconfig ( o . kubeconfig , t ) if err ! = nil { return nil , err } if err = registerresource ( config , t ) ; err ! = nil { return nil , err } var restclient * rest . restclient restclient , err = rest . restclientfor ( config ) if err ! = nil { return nil , err } rc : = client { cl : restclient , ns : o . namespace , t : t , codec : runtime . newparametercodec ( scheme ) } return & rc , nil } 
func createrestconfig ( kubeconfig string , t type ) ( config * rest . config , types * runtime . scheme , err error ) { if kubeconfig == " " { config , err = rest . inclusterconfig ( ) } else { config , err = clientcmd . buildconfigfromflags ( " " , kubeconfig ) } if err ! = nil { return } version : = schema . groupversion { group : group , version : version , } config . groupversion = & version config . apipath = " " config . contenttype = runtime . contenttypejson types = runtime . newscheme ( ) schemebuilder : = runtime . newschemebuilder ( func ( scheme * runtime . scheme ) error { scheme . addknowntypes ( version , t . object , t . collection ) v1 . addtogroupversion ( scheme , version ) return nil } ) err = schemebuilder . addtoscheme ( types ) config . negotiatedserializer = serializer . directcodecfactory { codecfactory : serializer . newcodecfactory ( types ) } return } 
func registerresource ( config * rest . config , t type ) error { c , err : = apiextensionsclient . newforconfig ( config ) if err ! = nil { return err } crd : = & apiextensionsv1beta1 . customresourcedefinition { objectmeta : v1 . objectmeta { name : fmt . sprintf ( " " , t . plural , group ) , } , spec : apiextensionsv1beta1 . customresourcedefinitionspec { group : group , version : version , scope : apiextensionsv1beta1 . namespacescoped , names : apiextensionsv1beta1 . customresourcedefinitionnames { singular : t . singular , plural : t . plural , kind : t . kind , listkind : t . listkind , } , } , } if , err : = c . apiextensionsv1beta1 ( ) . customresourcedefinitions ( ) . create ( crd ) ; err ! = nil && ! apierrors . isalreadyexists ( err ) { return err } return nil } 
func newdummyclient ( t type ) * dummyclient { c : = & dummyclient { t : t , objects : make ( map [ string ] object ) , } return c } 
func ( c * dummyclient ) create ( obj object ) ( object , error ) { c . objects [ obj . getname ( ) ] = obj return obj , nil } 
func ( c * dummyclient ) update ( obj object ) ( object , error ) { , ok : = c . objects [ obj . getname ( ) ] if ! ok { return nil , fmt . errorf ( " " , obj . getname ( ) ) } c . objects [ obj . getname ( ) ] = obj return obj , nil } 
func ( c * dummyclient ) delete ( name string , options * v1 . deleteoptions ) error { , ok : = c . objects [ name ] if ok { delete ( c . objects , name ) return nil } return fmt . errorf ( " " , name ) } 
func ( c * dummyclient ) get ( name string ) ( object , error ) { obj , ok : = c . objects [ name ] if ok { return obj , nil } return nil , fmt . errorf ( " " , name ) } 
func ( c * dummyclient ) list ( opts v1 . listoptions ) ( collection , error ) { var items [ ] object for , i : = range c . objects { items = append ( items , i ) } r : = c . newcollection ( ) r . setitems ( items ) return r , nil } 
func ( c * client ) create ( obj object ) ( object , error ) { result : = c . newobject ( ) err : = c . cl . post ( ) . namespace ( c . ns ) . resource ( c . t . plural ) . name ( obj . getname ( ) ) . body ( obj ) . do ( ) . into ( result ) return result , err } 
func ( c * client ) delete ( name string , options * v1 . deleteoptions ) error { return c . cl . delete ( ) . namespace ( c . ns ) . resource ( c . t . plural ) . name ( name ) . body ( options ) . do ( ) . error ( ) } 
func ( c * client ) get ( name string ) ( object , error ) { result : = c . newobject ( ) err : = c . cl . get ( ) . namespace ( c . ns ) . resource ( c . t . plural ) . name ( name ) . do ( ) . into ( result ) return result , err } 
func ( c * client ) list ( opts v1 . listoptions ) ( collection , error ) { result : = c . newcollection ( ) err : = c . cl . get ( ) . namespace ( c . ns ) . resource ( c . t . plural ) . versionedparams ( & opts , c . codec ) . do ( ) . into ( result ) return result , err } 
func trustedpullrequest ( ghc githubclient , trigger plugins . trigger , author , org , repo string , num int , l [ ] github . label ) ( [ ] github . label , bool , error ) { if orgmember , err : = trusteduser ( ghc , trigger , author , org , repo ) ; err ! = nil { return l , false , fmt . errorf ( " " , author , err ) } else if orgmember { return l , true , nil } if l == nil { var err error l , err = ghc . getissuelabels ( org , repo , num ) if err ! = nil { return l , false , err } } return l , github . haslabel ( labels . oktotest , l ) , nil } 
func buildall ( c client , pr * github . pullrequest , eventguid string , elideskippedcontexts bool ) error { org , repo , number , branch : = pr . base . repo . owner . login , pr . base . repo . name , pr . number , pr . base . ref changes : = config . newgithubdeferredchangedfilesprovider ( c . githubclient , org , repo , number ) totest , toskipsuperset , err : = pjutil . filterpresubmits ( pjutil . testallfilter ( ) , changes , branch , c . config . presubmits [ pr . base . repo . fullname ] , c . logger ) if err ! = nil { return err } toskip : = determineskippedpresubmits ( totest , toskipsuperset , c . logger ) return runandskipjobs ( c , pr , totest , toskip , eventguid , elideskippedcontexts ) } 
func ( o options ) run ( ctx context . context ) ( int , error ) { spec , err : = downwardapi . resolvespecfromenv ( ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } ctx , cancel : = context . withcancel ( ctx ) interrupt : = make ( chan os . signal ) signal . notify ( interrupt , os . interrupt , syscall . sigterm ) go func ( ) { select { case s : = < - interrupt : logrus . errorf ( " " , s ) cancel ( ) case < - ctx . done ( ) : } } ( ) if o . deprecatedwrapperoptions ! = nil { logrus . warnf ( " " ) } entries : = o . entries ( ) passed , aborted , failures : = wait ( ctx , entries ) cancel ( ) signal . ignore ( os . interrupt , syscall . sigterm ) buildlog : = logreader ( entries ) metadata : = combinemetadata ( entries ) return failures , o . doupload ( spec , passed , aborted , metadata , buildlog ) } 
func ( s * storage ) addconfig ( conf common . resourcesconfig ) error { return s . configs . add ( conf ) } 
func ( s * storage ) deleteconfig ( name string ) error { return s . configs . delete ( name ) } 
func ( s * storage ) updateconfig ( conf common . resourcesconfig ) error { return s . configs . update ( conf ) } 
func ( s * storage ) getconfig ( name string ) ( common . resourcesconfig , error ) { i , err : = s . configs . get ( name ) if err ! = nil { return common . resourcesconfig { } , err } var conf common . resourcesconfig conf , err = common . itemtoresourcesconfig ( i ) if err ! = nil { return common . resourcesconfig { } , err } return conf , nil } 
func ( s * storage ) getconfigs ( ) ( [ ] common . resourcesconfig , error ) { var configs [ ] common . resourcesconfig items , err : = s . configs . list ( ) if err ! = nil { return configs , err } for , i : = range items { var conf common . resourcesconfig conf , err = common . itemtoresourcesconfig ( i ) if err ! = nil { return nil , err } configs = append ( configs , conf ) } return configs , nil } 
func addknowntypes ( scheme * runtime . scheme ) error { scheme . addknowntypes ( schemegroupversion , & prowjob { } , & prowjoblist { } , ) metav1 . addtogroupversion ( scheme , schemegroupversion ) return nil } 
func newcontroller ( continueonerror bool , addedpresubmitblacklist sets . string , prowjobclient prowv1 . prowjobinterface , githubclient * github . client , configagent * config . agent , pluginagent * plugins . configagent ) * controller { return & controller { continueonerror : continueonerror , addedpresubmitblacklist : addedpresubmitblacklist , prowjobtriggerer : & kubeprowjobtriggerer { prowjobclient : prowjobclient , githubclient : githubclient , configagent : configagent , } , githubclient : githubclient , statusmigrator : & githubmigrator { githubclient : githubclient , continueonerror : continueonerror , } , trustedchecker : & githubtrustedchecker { githubclient : githubclient , pluginagent : pluginagent , } , } } 
func ( c * controller ) run ( stop < - chan os . signal , changes < - chan config . delta ) { for { select { case change : = < - changes : start : = time . now ( ) if err : = c . reconcile ( change ) ; err ! = nil { logrus . witherror ( err ) . error ( " " ) } logrus . withfield ( " " , fmt . sprintf ( " " , time . since ( start ) ) ) . info ( " " ) case < - stop : logrus . info ( " " ) return } } } 
func addedblockingpresubmits ( old , new map [ string ] [ ] config . presubmit ) map [ string ] [ ] config . presubmit { added : = map [ string ] [ ] config . presubmit { } for repo , oldpresubmits : = range old { added [ repo ] = [ ] config . presubmit { } for , newpresubmit : = range new [ repo ] { if ! newpresubmit . contextrequired ( ) | | newpresubmit . needsexplicittrigger ( ) { continue } var found bool for , oldpresubmit : = range oldpresubmits { if oldpresubmit . name == newpresubmit . name { if oldpresubmit . skipreport && ! newpresubmit . skipreport { added [ repo ] = append ( added [ repo ] , newpresubmit ) logrus . withfields ( logrus . fields { " " : repo , " " : oldpresubmit . name , } ) . debug ( " " ) } if oldpresubmit . runifchanged ! = newpresubmit . runifchanged { added [ repo ] = append ( added [ repo ] , newpresubmit ) logrus . withfields ( logrus . fields { " " : repo , " " : oldpresubmit . name , } ) . debug ( " " ) } found = true break } } if ! found { added [ repo ] = append ( added [ repo ] , newpresubmit ) logrus . withfields ( logrus . fields { " " : repo , " " : newpresubmit . name , } ) . debug ( " " ) } } } var numadded int for , presubmits : = range added { numadded += len ( presubmits ) } logrus . infof ( " " , numadded ) return added } 
func removedblockingpresubmits ( old , new map [ string ] [ ] config . presubmit ) map [ string ] [ ] config . presubmit { removed : = map [ string ] [ ] config . presubmit { } for repo , oldpresubmits : = range old { removed [ repo ] = [ ] config . presubmit { } for , oldpresubmit : = range oldpresubmits { if ! oldpresubmit . contextrequired ( ) { continue } var found bool for , newpresubmit : = range new [ repo ] { if oldpresubmit . name == newpresubmit . name { found = true break } } if ! found { removed [ repo ] = append ( removed [ repo ] , oldpresubmit ) logrus . withfields ( logrus . fields { " " : repo , " " : oldpresubmit . name , } ) . debug ( " " ) } } } var numremoved int for , presubmits : = range removed { numremoved += len ( presubmits ) } logrus . infof ( " " , numremoved ) return removed } 
func migratedblockingpresubmits ( old , new map [ string ] [ ] config . presubmit ) map [ string ] [ ] presubmitmigration { migrated : = map [ string ] [ ] presubmitmigration { } for repo , oldpresubmits : = range old { migrated [ repo ] = [ ] presubmitmigration { } for , newpresubmit : = range new [ repo ] { if ! newpresubmit . contextrequired ( ) { continue } for , oldpresubmit : = range oldpresubmits { if oldpresubmit . context ! = newpresubmit . context && oldpresubmit . name == newpresubmit . name { migrated [ repo ] = append ( migrated [ repo ] , presubmitmigration { from : oldpresubmit , to : newpresubmit } ) logrus . withfields ( logrus . fields { " " : repo , " " : oldpresubmit . name , " " : oldpresubmit . context , " " : newpresubmit . context , } ) . debug ( " " ) } } } } var nummigrated int for , presubmits : = range migrated { nummigrated += len ( presubmits ) } logrus . infof ( " " , nummigrated ) return migrated } 
func load ( loader optionloader ) error { if jsonconfig , provided : = os . lookupenv ( loader . configvar ( ) ) ; provided { if err : = loader . loadconfig ( jsonconfig ) ; err ! = nil { return fmt . errorf ( " " , loader . configvar ( ) , err ) } return nil } fs : = flag . newflagset ( os . args [ 0 ] , flag . exitonerror ) loader . addflags ( fs ) fs . parse ( os . args [ 1 : ] ) loader . complete ( fs . args ( ) ) return nil } 
func newcontroller ( prowjobclient prowv1 . prowjobinterface , jc * client , ghc * github . client , logger * logrus . entry , cfg config . getter , toturl , selector string ) ( * controller , error ) { n , err : = snowflake . newnode ( 1 ) if err ! = nil { return nil , err } if logger == nil { logger = logrus . newentry ( logrus . standardlogger ( ) ) } return & controller { prowjobclient : prowjobclient , jc : jc , ghc : ghc , log : logger , cfg : cfg , selector : selector , node : n , toturl : toturl , pendingjobs : make ( map [ string ] int ) , } , nil } 
func ( c * controller ) canexecuteconcurrently ( pj * prowapi . prowjob ) bool { c . lock . lock ( ) defer c . lock . unlock ( ) if max : = c . config ( ) . maxconcurrency ; max > 0 { var running int for , num : = range c . pendingjobs { running += num } if running >= max { c . log . withfields ( pjutil . prowjobfields ( pj ) ) . debugf ( " " , running ) return false } } if pj . spec . maxconcurrency == 0 { c . pendingjobs [ pj . spec . job ] ++ return true } numpending : = c . pendingjobs [ pj . spec . job ] if numpending >= pj . spec . maxconcurrency { c . log . withfields ( pjutil . prowjobfields ( pj ) ) . debugf ( " " , pj . spec . job , numpending ) return false } c . pendingjobs [ pj . spec . job ] ++ return true } 
func getjenkinsjobs ( pjs [ ] prowapi . prowjob ) [ ] buildqueryparams { jenkinsjobs : = [ ] buildqueryparams { } for , pj : = range pjs { if pj . complete ( ) { continue } jenkinsjobs = append ( jenkinsjobs , buildqueryparams { jobname : getjobname ( & pj . spec ) , prowjobid : pj . name , } ) } return jenkinsjobs } 
func ( c * client ) throttle ( hourlytokens , burst int ) { c . log ( " " , hourlytokens , burst ) c . throttle . lock . lock ( ) defer c . throttle . lock . unlock ( ) previouslythrottled : = c . throttle . ticker ! = nil if hourlytokens <= 0 | | burst <= 0 { if previouslythrottled { c . client = c . throttle . http c . gqlc = c . throttle . graph c . throttle . ticker . stop ( ) c . throttle . ticker = nil } return } rate : = time . hour / time . duration ( hourlytokens ) ticker : = time . newticker ( rate ) throttle : = make ( chan time . time , burst ) for i : = 0 ; i < burst ; i ++ { throttle < - time . now ( ) } go func ( ) { for t : = range ticker . c { select { case throttle < - t : default : } } } ( ) if ! previouslythrottled { c . throttle . http = c . client c . throttle . graph = c . gqlc c . client = & c . throttle c . gqlc = & c . throttle } c . throttle . ticker = ticker c . throttle . throttle = throttle } 
func newclientwithfields ( fields logrus . fields , gettoken func ( ) [ ] byte , graphqlendpoint string , bases ... string ) * client { return & client { logger : logrus . withfields ( fields ) . withfield ( " " , " " ) , time : & standardtime { } , gqlc : githubql . newenterpriseclient ( graphqlendpoint , & http . client { timeout : maxrequesttime , transport : & oauth2 . transport { source : newreloadingtokensource ( gettoken ) } , } ) , client : & http . client { timeout : maxrequesttime } , bases : bases , gettoken : gettoken , dry : false , } } 
func newclient ( gettoken func ( ) [ ] byte , graphqlendpoint string , bases ... string ) * client { return newclientwithfields ( logrus . fields { } , gettoken , graphqlendpoint , bases ... ) } 
func newdryrunclient ( gettoken func ( ) [ ] byte , graphqlendpoint string , bases ... string ) * client { return newdryrunclientwithfields ( logrus . fields { } , gettoken , graphqlendpoint , bases ... ) } 
func newfakeclient ( ) * client { return & client { logger : logrus . withfield ( " " , " " ) , time : & standardtime { } , fake : true , dry : true , } } 
func ( c * client ) request ( r * request , ret interface { } ) ( int , error ) { statuscode , b , err : = c . requestraw ( r ) if err ! = nil { return statuscode , err } if ret ! = nil { if err : = json . unmarshal ( b , ret ) ; err ! = nil { return statuscode , err } } return statuscode , nil } 
func ( c * client ) requestraw ( r * request ) ( int , [ ] byte , error ) { if c . fake | | ( c . dry && r . method ! = http . methodget ) { return r . exitcodes [ 0 ] , nil , nil } resp , err : = c . requestretry ( r . method , r . path , r . accept , r . requestbody ) if err ! = nil { return 0 , nil , err } defer resp . body . close ( ) b , err : = ioutil . readall ( resp . body ) if err ! = nil { return 0 , nil , err } var okcode bool for , code : = range r . exitcodes { if code == resp . statuscode { okcode = true break } } if ! okcode { clienterror : = unmarshalclienterror ( b ) err = requesterror { clienterror : clienterror , errorstring : fmt . sprintf ( " " , resp . statuscode , r . exitcodes , string ( b ) ) , } } return resp . statuscode , b , err } 
func ( c * client ) getuserdata ( ) error { c . log ( " " ) var u user , err : = c . request ( & request { method : http . methodget , path : " " , exitcodes : [ ] int { 200 } , } , & u ) if err ! = nil { return err } c . botname = u . login c . email = u . email return nil } 
func ( c * client ) haspermission ( org , repo , user string , roles ... string ) ( bool , error ) { perm , err : = c . getuserpermission ( org , repo , user ) if err ! = nil { return false , err } for , r : = range roles { if r == perm { return true , nil } } return false , nil } 
func ( c * client ) deletestalecomments ( org , repo string , number int , comments [ ] issuecomment , isstale func ( issuecomment ) bool ) error { var err error if comments == nil { comments , err = c . listissuecomments ( org , repo , number ) if err ! = nil { return fmt . errorf ( " " , err ) } } for , comment : = range comments { if isstale ( comment ) { if err : = c . deletecomment ( org , repo , comment . id ) ; err ! = nil { return fmt . errorf ( " " , comment . id ) } } } return nil } 
func ( c * client ) readpaginatedresults ( path , accept string , newobj func ( ) interface { } , accumulate func ( interface { } ) ) error { values : = url . values { " " : [ ] string { " " } , } return c . readpaginatedresultswithvalues ( path , values , accept , newobj , accumulate ) } 
func ( c * client ) readpaginatedresultswithvalues ( path string , values url . values , accept string , newobj func ( ) interface { } , accumulate func ( interface { } ) ) error { pagedpath : = path if len ( values ) > 0 { pagedpath += " " + values . encode ( ) } for { resp , err : = c . requestretry ( http . methodget , pagedpath , accept , nil ) if err ! = nil { return err } defer resp . body . close ( ) if resp . statuscode < 200 | | resp . statuscode > 299 { return fmt . errorf ( " " , resp . status ) } b , err : = ioutil . readall ( resp . body ) if err ! = nil { return err } obj : = newobj ( ) if err : = json . unmarshal ( b , obj ) ; err ! = nil { return err } accumulate ( obj ) link : = parselinks ( resp . header . get ( " " ) ) [ " " ] if link == " " { break } u , err : = url . parse ( link ) if err ! = nil { return fmt . errorf ( " " , err ) } pagedpath = u . requesturi ( ) } return nil } 
func ( c * client ) updatepullrequest ( org , repo string , number int , title , body * string , open * bool , branch * string , canmodify * bool ) error { c . log ( " " , org , repo , title ) data : = struct { state * string ' json : " state , omitempty " ' title * string ' json : " title , omitempty " ' body * string ' json : " body , omitempty " ' base * string ' json : " base , omitempty " ' maintainercanmodify * bool ' json : " maintainer can modify , omitempty " ' } { title : title , body : body , base : branch , maintainercanmodify : canmodify , } if open ! = nil && * open { op : = " " data . state = & op } else if open ! = nil { cl : = " " data . state = & cl } , err : = c . request ( & request { accept : " " , method : http . methodpatch , path : fmt . sprintf ( " " , org , repo , number ) , requestbody : & data , exitcodes : [ ] int { 200 } , } , nil ) return err } 
func ( c * client ) getlabels ( path string ) ( [ ] label , error ) { var labels [ ] label if c . fake { return labels , nil } err : = c . readpaginatedresults ( path , " " , func ( ) interface { } { return & [ ] label { } } , func ( obj interface { } ) { labels = append ( labels , * ( obj . ( * [ ] label ) ) ... ) } , ) if err ! = nil { return nil , err } return labels , nil } 
func statecannotbechangedororiginalerror ( err error ) error { requesterr , ok : = err . ( requesterror ) if ok { for , errormsg : = range requesterr . errormessages ( ) { if strings . contains ( errormsg , statecannotbechangedmessageprefix ) { return statecannotbechanged { message : errormsg , } } } } return err } 
func ( c * client ) query ( ctx context . context , q interface { } , vars map [ string ] interface { } ) error { return c . gqlc . query ( ctx , q , vars ) } 
func ( c * client ) ismergeable ( org , repo string , number int , sha string ) ( bool , error ) { backoff : = time . second * 3 maxtries : = 3 for try : = 0 ; try < maxtries ; try ++ { pr , err : = c . getpullrequest ( org , repo , number ) if err ! = nil { return false , err } if pr . head . sha ! = sha { return false , fmt . errorf ( " " , sha , pr . head . sha ) } if pr . merged { return false , errors . new ( " " ) } if pr . mergable ! = nil { return * pr . mergable , nil } if try + 1 < maxtries { c . time . sleep ( backoff ) backoff * = 2 } } return false , fmt . errorf ( " " , maxtries ) } 
func ( s * reloadingtokensource ) token ( ) ( * oauth2 . token , error ) { return & oauth2 . token { accesstoken : string ( s . gettoken ( ) ) , } , nil } 
func ( c * client ) teamhasmember ( teamid int , memberlogin string ) ( bool , error ) { c . log ( " " , teamid , memberlogin ) projectmaintainers , err : = c . listteammembers ( teamid , roleall ) if err ! = nil { return false , err } for , person : = range projectmaintainers { if normlogin ( person . login ) == normlogin ( memberlogin ) { return true , nil } } return false , nil } 
func ( s * spyglass ) listartifacts ( src string ) ( [ ] string , error ) { keytype , key , err : = splitsrc ( src ) if err ! = nil { return [ ] string { } , fmt . errorf ( " " , err ) } gcskey : = " " switch keytype { case gcskeytype : gcskey = key case prowkeytype : if gcskey , err = s . prowtogcs ( key ) ; err ! = nil { logrus . warningf ( " " , err ) } default : return nil , fmt . errorf ( " " , src ) } artifactnames , err : = s . gcsartifactfetcher . artifacts ( gcskey ) logfound : = false for , name : = range artifactnames { if name == " " { logfound = true break } } if err ! = nil | | ! logfound { artifactnames = append ( artifactnames , " " ) } return artifactnames , nil } 
func ( * spyglass ) keytojob ( src string ) ( jobname string , buildid string , err error ) { src = strings . trim ( src , " " ) parsed : = strings . split ( src , " " ) if len ( parsed ) < 2 { return " " , " " , fmt . errorf ( " " , src ) } jobname = parsed [ len ( parsed ) - 2 ] buildid = parsed [ len ( parsed ) - 1 ] return jobname , buildid , nil } 
func ( s * spyglass ) prowtogcs ( prowkey string ) ( string , error ) { jobname , buildid , err : = s . keytojob ( prowkey ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } job , err : = s . jobagent . getprowjob ( jobname , buildid ) if err ! = nil { return " " , fmt . errorf ( " " , prowkey , err ) } url : = job . status . url prefix : = s . config ( ) . plank . getjoburlprefix ( job . spec . refs ) if ! strings . hasprefix ( url , prefix ) { return " " , fmt . errorf ( " " , url , prefix ) } return url [ len ( prefix ) : ] , nil } 
func ( in * decorationconfig ) deepcopyinto ( out * decorationconfig ) { * out = * in out . timeout = in . timeout out . graceperiod = in . graceperiod if in . utilityimages ! = nil { in , out : = & in . utilityimages , & out . utilityimages * out = new ( utilityimages ) * * out = * * in } if in . gcsconfiguration ! = nil { in , out : = & in . gcsconfiguration , & out . gcsconfiguration * out = new ( gcsconfiguration ) * * out = * * in } if in . sshkeysecrets ! = nil { in , out : = & in . sshkeysecrets , & out . sshkeysecrets * out = make ( [ ] string , len ( * in ) ) copy ( * out , * in ) } if in . sshhostfingerprints ! = nil { in , out : = & in . sshhostfingerprints , & out . sshhostfingerprints * out = make ( [ ] string , len ( * in ) ) copy ( * out , * in ) } if in . skipcloning ! = nil { in , out : = & in . skipcloning , & out . skipcloning * out = new ( bool ) * * out = * * in } return } 
func ( in * decorationconfig ) deepcopy ( ) * decorationconfig { if in == nil { return nil } out : = new ( decorationconfig ) in . deepcopyinto ( out ) return out } 
func ( in * gcsconfiguration ) deepcopy ( ) * gcsconfiguration { if in == nil { return nil } out : = new ( gcsconfiguration ) in . deepcopyinto ( out ) return out } 
func ( in * jenkinsspec ) deepcopy ( ) * jenkinsspec { if in == nil { return nil } out : = new ( jenkinsspec ) in . deepcopyinto ( out ) return out } 
func ( in * prowjob ) deepcopyinto ( out * prowjob ) { * out = * in out . typemeta = in . typemeta in . objectmeta . deepcopyinto ( & out . objectmeta ) in . spec . deepcopyinto ( & out . spec ) in . status . deepcopyinto ( & out . status ) return } 
func ( in * prowjob ) deepcopy ( ) * prowjob { if in == nil { return nil } out : = new ( prowjob ) in . deepcopyinto ( out ) return out } 
func ( in * prowjob ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func ( in * prowjoblist ) deepcopyinto ( out * prowjoblist ) { * out = * in out . typemeta = in . typemeta out . listmeta = in . listmeta if in . items ! = nil { in , out : = & in . items , & out . items * out = make ( [ ] prowjob , len ( * in ) ) for i : = range * in { ( * in ) [ i ] . deepcopyinto ( & ( * out ) [ i ] ) } } return } 
func ( in * prowjoblist ) deepcopy ( ) * prowjoblist { if in == nil { return nil } out : = new ( prowjoblist ) in . deepcopyinto ( out ) return out } 
func ( in * prowjoblist ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func ( in * prowjobspec ) deepcopy ( ) * prowjobspec { if in == nil { return nil } out : = new ( prowjobspec ) in . deepcopyinto ( out ) return out } 
func ( in * prowjobstatus ) deepcopyinto ( out * prowjobstatus ) { * out = * in in . starttime . deepcopyinto ( & out . starttime ) if in . completiontime ! = nil { in , out : = & in . completiontime , & out . completiontime * out = ( * in ) . deepcopy ( ) } if in . prevreportstates ! = nil { in , out : = & in . prevreportstates , & out . prevreportstates * out = make ( map [ string ] prowjobstate , len ( * in ) ) for key , val : = range * in { ( * out ) [ key ] = val } } return } 
func ( in * prowjobstatus ) deepcopy ( ) * prowjobstatus { if in == nil { return nil } out : = new ( prowjobstatus ) in . deepcopyinto ( out ) return out } 
func ( in * pull ) deepcopy ( ) * pull { if in == nil { return nil } out : = new ( pull ) in . deepcopyinto ( out ) return out } 
func ( in * refs ) deepcopyinto ( out * refs ) { * out = * in if in . pulls ! = nil { in , out : = & in . pulls , & out . pulls * out = make ( [ ] pull , len ( * in ) ) copy ( * out , * in ) } return } 
func ( in * refs ) deepcopy ( ) * refs { if in == nil { return nil } out : = new ( refs ) in . deepcopyinto ( out ) return out } 
func ( in * utilityimages ) deepcopy ( ) * utilityimages { if in == nil { return nil } out : = new ( utilityimages ) in . deepcopyinto ( out ) return out } 
func upload ( rsclient * resultstore . client , inv resultstore . invocation , target resultstore . target , test resultstore . test ) ( string , error ) { targetid : = test . name const configid = resultstore . default invname , err : = rsclient . invocations ( ) . create ( inv ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } targetname , err : = rsclient . targets ( invname ) . create ( targetid , target ) if err ! = nil { return resultstore . url ( invname ) , fmt . errorf ( " " , err ) } url : = resultstore . url ( targetname ) , err = rsclient . configurations ( invname ) . create ( configid ) if err ! = nil { return url , fmt . errorf ( " " , err ) } ctname , err : = rsclient . configuredtargets ( targetname , configid ) . create ( test . action ) if err ! = nil { return url , fmt . errorf ( " " , err ) } , err = rsclient . actions ( ctname ) . create ( " " , test ) if err ! = nil { return url , fmt . errorf ( " " , err ) } return url , nil } 
func ( d * decorationconfig ) applydefault ( def * decorationconfig ) * decorationconfig { if d == nil && def == nil { return nil } var merged decorationconfig if d ! = nil { merged = * d } else { merged = * def } if d == nil | | def == nil { return & merged } merged . utilityimages = merged . utilityimages . applydefault ( def . utilityimages ) merged . gcsconfiguration = merged . gcsconfiguration . applydefault ( def . gcsconfiguration ) if merged . timeout . duration == 0 { merged . timeout = def . timeout } if merged . graceperiod . duration == 0 { merged . graceperiod = def . graceperiod } if merged . gcscredentialssecret == " " { merged . gcscredentialssecret = def . gcscredentialssecret } if len ( merged . sshkeysecrets ) == 0 { merged . sshkeysecrets = def . sshkeysecrets } if len ( merged . sshhostfingerprints ) == 0 { merged . sshhostfingerprints = def . sshhostfingerprints } if merged . skipcloning == nil { merged . skipcloning = def . skipcloning } if merged . cookiefilesecret == " " { merged . cookiefilesecret = def . cookiefilesecret } return & merged } 
func ( d * decorationconfig ) validate ( ) error { if d . utilityimages == nil { return errors . new ( " " ) } var missing [ ] string if d . utilityimages . clonerefs == " " { missing = append ( missing , " " ) } if d . utilityimages . initupload == " " { missing = append ( missing , " " ) } if d . utilityimages . entrypoint == " " { missing = append ( missing , " " ) } if d . utilityimages . sidecar == " " { missing = append ( missing , " " ) } if len ( missing ) > 0 { return fmt . errorf ( " " , missing ) } if d . gcsconfiguration == nil { return errors . new ( " " ) } if d . gcscredentialssecret == " " { return errors . new ( " " ) } if err : = d . gcsconfiguration . validate ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( u * utilityimages ) applydefault ( def * utilityimages ) * utilityimages { if u == nil { return def } else if def == nil { return u } merged : = * u if merged . clonerefs == " " { merged . clonerefs = def . clonerefs } if merged . initupload == " " { merged . initupload = def . initupload } if merged . entrypoint == " " { merged . entrypoint = def . entrypoint } if merged . sidecar == " " { merged . sidecar = def . sidecar } return & merged } 
func ( g * gcsconfiguration ) applydefault ( def * gcsconfiguration ) * gcsconfiguration { if g == nil && def == nil { return nil } var merged gcsconfiguration if g ! = nil { merged = * g } else { merged = * def } if g == nil | | def == nil { return & merged } if merged . bucket == " " { merged . bucket = def . bucket } if merged . pathprefix == " " { merged . pathprefix = def . pathprefix } if merged . pathstrategy == " " { merged . pathstrategy = def . pathstrategy } if merged . defaultorg == " " { merged . defaultorg = def . defaultorg } if merged . defaultrepo == " " { merged . defaultrepo = def . defaultrepo } return & merged } 
func ( g * gcsconfiguration ) validate ( ) error { if g . pathstrategy ! = pathstrategylegacy && g . pathstrategy ! = pathstrategyexplicit && g . pathstrategy ! = pathstrategysingle { return fmt . errorf ( " " , pathstrategylegacy , pathstrategyexplicit , pathstrategysingle ) } if g . pathstrategy ! = pathstrategyexplicit && ( g . defaultorg == " " | | g . defaultrepo == " " ) { return fmt . errorf ( " " , g . pathstrategy ) } return nil } 
func ( j * prowjob ) setcomplete ( ) { j . status . completiontime = new ( metav1 . time ) * j . status . completiontime = metav1 . now ( ) } 
func ( j * prowjob ) clusteralias ( ) string { if j . spec . cluster == " " { return defaultclusteralias } return j . spec . cluster } 
func newresource ( name , rtype , state , owner string , t time . time ) resource { return resource { name : name , type : rtype , state : state , owner : owner , lastupdate : t , userdata : & userdata { } , } } 
func newresourcesfromconfig ( e resourceentry ) [ ] resource { var resources [ ] resource for , name : = range e . names { resources = append ( resources , newresource ( name , e . type , e . state , " " , time . time { } ) ) } return resources } 
func userdatafrommap ( m userdatamap ) * userdata { ud : = & userdata { } for k , v : = range m { ud . store ( k , v ) } return ud } 
func ( r * commaseparatedstrings ) set ( value string ) error { if len ( * r ) > 0 { return errors . new ( " " ) } for , rtype : = range strings . split ( value , " " ) { * r = append ( * r , rtype ) } return nil } 
func ( ud * userdata ) unmarshaljson ( data [ ] byte ) error { tmpmap : = userdatamap { } if err : = json . unmarshal ( data , & tmpmap ) ; err ! = nil { return err } ud . frommap ( tmpmap ) return nil } 
func ( ud * userdata ) extract ( id string , out interface { } ) error { content , ok : = ud . load ( id ) if ! ok { return & userdatanotfound { id } } return yaml . unmarshal ( [ ] byte ( content . ( string ) ) , out ) } 
func ( ud * userdata ) set ( id string , in interface { } ) error { b , err : = yaml . marshal ( in ) if err ! = nil { return err } ud . store ( id , string ( b ) ) return nil } 
func ( ud * userdata ) update ( new * userdata ) { if new == nil { return } new . range ( func ( key , value interface { } ) bool { if value . ( string ) ! = " " { ud . store ( key , value ) } else { ud . delete ( key ) } return true } ) } 
func ( ud * userdata ) tomap ( ) userdatamap { m : = userdatamap { } ud . range ( func ( key , value interface { } ) bool { m [ key . ( string ) ] = value . ( string ) return true } ) return m } 
func ( ud * userdata ) frommap ( m userdatamap ) { for key , value : = range m { ud . store ( key , value ) } } 
func itemtoresource ( i item ) ( resource , error ) { res , ok : = i . ( resource ) if ! ok { return resource { } , fmt . errorf ( " " , i ) } return res , nil } 
func addsshkeys ( paths [ ] string ) ( [ ] string , error ) { vars , err : = exec . command ( " " ) . combinedoutput ( ) if err ! = nil { return [ ] string { } , fmt . errorf ( " " , err ) } logrus . info ( " " ) parts : = strings . split ( string ( vars ) , " " ) env : = [ ] string { strings . trimspace ( parts [ 0 ] ) , strings . trimspace ( parts [ 2 ] ) } for , keypath : = range paths { if err : = filepath . walk ( keypath , func ( path string , info os . fileinfo , err error ) error { if strings . hasprefix ( info . name ( ) , " " ) { if info . isdir ( ) { return filepath . skipdir } return nil } if info . isdir ( ) { return nil } cmd : = exec . command ( " " , path ) cmd . env = append ( cmd . env , env ... ) if output , err : = cmd . combinedoutput ( ) ; err ! = nil { return fmt . errorf ( " " , path , err , output ) } logrus . infof ( " " , path ) return nil } ) ; err ! = nil { return env , fmt . errorf ( " " , keypath , err ) } } return env , nil } 
func ( f * triagefiler ) issues ( c * creator . issuecreator ) ( [ ] creator . issue , error ) { f . creator = c rawjson , err : = readhttp ( clusterdataurl ) if err ! = nil { return nil , err } clusters , err : = f . loadclusters ( rawjson ) if err ! = nil { return nil , err } topclusters : = topclusters ( clusters , f . topclusterscount ) issues : = make ( [ ] creator . issue , 0 , len ( topclusters ) ) for , clust : = range topclusters { issues = append ( issues , clust ) } return issues , nil } 
func ( f * triagefiler ) registerflags ( ) { flag . intvar ( & f . topclusterscount , " " , 3 , " " ) flag . intvar ( & f . windowdays , " " , 1 , " " ) } 
func ( f * triagefiler ) loadclusters ( jsonin [ ] byte ) ( [ ] * cluster , error ) { var err error f . data , err = parsetriagedata ( jsonin ) if err ! = nil { return nil , err } if err = f . filterandvalidate ( f . windowdays ) ; err ! = nil { return nil , err } for , clust : = range f . data . clustered { clust . filer = f clust . jobs = make ( map [ string ] [ ] int ) for , test : = range clust . tests { for , job : = range test . jobs { for , buildnum : = range job . builds { found : = false for , oldbuild : = range clust . jobs [ job . name ] { if oldbuild == buildnum { found = true break } } if ! found { clust . jobs [ job . name ] = append ( clust . jobs [ job . name ] , buildnum ) } } } } clust . totaljobs = len ( clust . jobs ) clust . totaltests = len ( clust . tests ) clust . totalbuilds = 0 for , builds : = range clust . jobs { clust . totalbuilds += len ( builds ) } } return f . data . clustered , nil } 
func parsetriagedata ( jsonin [ ] byte ) ( * triagedata , error ) { var data triagedata if err : = json . unmarshal ( jsonin , & data ) ; err ! = nil { return nil , err } if data . builds . cols . started == nil { return nil , fmt . errorf ( " " ) } if data . builds . jobsraw == nil { return nil , fmt . errorf ( " " ) } if data . builds . jobpaths == nil { return nil , fmt . errorf ( " " ) } if data . clustered == nil { return nil , fmt . errorf ( " " ) } data . builds . jobs = make ( map [ string ] buildindexer ) for jobid , mapper : = range data . builds . jobsraw { switch mapper : = mapper . ( type ) { case [ ] interface { } : data . builds . jobs [ jobid ] = contigindexer { startbuild : int ( mapper [ 0 ] . ( float64 ) ) , count : int ( mapper [ 1 ] . ( float64 ) ) , startrow : int ( mapper [ 2 ] . ( float64 ) ) , } case map [ string ] interface { } : data . builds . jobs [ jobid ] = dictindexer ( mapper ) default : return nil , fmt . errorf ( " " , jobid , reflect . typeof ( mapper ) ) } } return & data , nil } 
func topclusters ( clusters [ ] * cluster , count int ) [ ] * cluster { less : = func ( i , j int ) bool { return clusters [ i ] . totalbuilds > clusters [ j ] . totalbuilds } sort . slicestable ( clusters , less ) if len ( clusters ) < count { count = len ( clusters ) } return clusters [ 0 : count ] } 
func ( c * cluster ) topjobsfailed ( count int ) [ ] * job { slice : = make ( [ ] * job , len ( c . jobs ) ) i : = 0 for jobname , builds : = range c . jobs { slice [ i ] = & job { name : jobname , builds : builds } i ++ } less : = func ( i , j int ) bool { return len ( slice [ i ] . builds ) > len ( slice [ j ] . builds ) } sort . slicestable ( slice , less ) if len ( slice ) < count { count = len ( slice ) } return slice [ 0 : count ] } 
func ( c * cluster ) title ( ) string { return fmt . sprintf ( " " , c . identifier [ 0 : 6 ] , c . totalbuilds , c . totaljobs , c . totaltests , c . filer . windowdays , ) } 
func ( c * cluster ) labels ( ) [ ] string { labels : = [ ] string { " " } toptests : = make ( [ ] string , len ( c . tests ) ) for i , test : = range c . toptestsfailed ( len ( c . tests ) ) { toptests [ i ] = test . name } for sig : = range c . filer . creator . testssigs ( toptests ) { labels = append ( labels , " " + sig ) } return labels } 
func new ( ) * cron { return & cron { cronagent : cron . new ( ) , jobs : map [ string ] * jobstatus { } , logger : logrus . withfield ( " " , " " ) , } } 
func ( c * cron ) queuedjobs ( ) [ ] string { c . lock . lock ( ) defer c . lock . unlock ( ) res : = [ ] string { } for k , v : = range c . jobs { if v . triggered { res = append ( res , k ) } c . jobs [ k ] . triggered = false } return res } 
func ( c * cron ) syncconfig ( cfg * config . config ) error { c . lock . lock ( ) defer c . lock . unlock ( ) for , p : = range cfg . periodics { if err : = c . addperiodic ( p ) ; err ! = nil { return err } } periodicnames : = sets . newstring ( ) for , p : = range cfg . allperiodics ( ) { periodicnames . insert ( p . name ) } existing : = sets . newstring ( ) for k : = range c . jobs { existing . insert ( k ) } var removalerrors [ ] error for , job : = range existing . difference ( periodicnames ) . list ( ) { if err : = c . removejob ( job ) ; err ! = nil { removalerrors = append ( removalerrors , err ) } } return errorutil . newaggregate ( removalerrors ... ) } 
func ( c * cron ) hasjob ( name string ) bool { c . lock . lock ( ) defer c . lock . unlock ( ) , ok : = c . jobs [ name ] return ok } 
func ( c * cron ) addjob ( name , cron string ) error { id , err : = c . cronagent . addfunc ( " " + cron , func ( ) { c . lock . lock ( ) defer c . lock . unlock ( ) c . jobs [ name ] . triggered = true c . logger . infof ( " " , name ) } ) if err ! = nil { return fmt . errorf ( " " , name , cron , err ) } c . jobs [ name ] = & jobstatus { entryid : id , cronstr : cron , triggered : strings . hasprefix ( cron , " " ) , } c . logger . infof ( " " , name , cron ) return nil } 
func ( c * cron ) removejob ( name string ) error { job , ok : = c . jobs [ name ] if ! ok { return fmt . errorf ( " " , name ) } c . cronagent . remove ( job . entryid ) delete ( c . jobs , name ) c . logger . infof ( " " , name ) return nil } 
func updatecomments ( issueid int , pullrequest bool , db * gorm . db , client clientinterface ) { latest : = findlatestcommentupdate ( issueid , db , client . repositoryname ( ) ) updateissuecomments ( issueid , latest , db , client ) if pullrequest { updatepullcomments ( issueid , latest , db , client ) } } 
func gatherprowjobmetrics ( pjs [ ] prowapi . prowjob ) { metricmap : = make ( map [ string ] map [ string ] map [ string ] float64 ) for , pj : = range pjs { if metricmap [ pj . spec . job ] == nil { metricmap [ pj . spec . job ] = make ( map [ string ] map [ string ] float64 ) } if metricmap [ pj . spec . job ] [ string ( pj . spec . type ) ] == nil { metricmap [ pj . spec . job ] [ string ( pj . spec . type ) ] = make ( map [ string ] float64 ) } metricmap [ pj . spec . job ] [ string ( pj . spec . type ) ] [ string ( pj . status . state ) ] ++ } prowjobs . reset ( ) for job , jobmap : = range metricmap { for jobtype , typemap : = range jobmap { for state , count : = range typemap { prowjobs . withlabelvalues ( job , jobtype , state ) . set ( count ) } } } } 
func ( o options ) run ( ) int { code , err : = o . executeprocess ( ) if err ! = nil { logrus . witherror ( err ) . error ( " " ) } if err : = o . mark ( code ) ; err ! = nil { logrus . witherror ( err ) . error ( " " ) return internalerrorcode } if o . alwayszero { return 0 } return code } 
func optionordefault ( option , defaultvalue time . duration ) time . duration { if option == 0 { return defaultvalue } return option } 
func newgcsjobsource ( src string ) ( * gcsjobsource , error ) { gcsurl , err : = url . parse ( fmt . sprintf ( " " , src ) ) if err ! = nil { return & gcsjobsource { } , errcannotparsesource } gcspath : = & gcs . path { } err = gcspath . seturl ( gcsurl ) if err ! = nil { return & gcsjobsource { } , errcannotparsesource } tokens : = strings . fieldsfunc ( gcspath . object ( ) , func ( c rune ) bool { return c == ' / ' } ) if len ( tokens ) < 2 { return & gcsjobsource { } , errcannotparsesource } buildid : = tokens [ len ( tokens ) - 1 ] name : = tokens [ len ( tokens ) - 2 ] return & gcsjobsource { source : src , linkprefix : " " , bucket : gcspath . bucket ( ) , jobprefix : path . clean ( gcspath . object ( ) ) + " " , jobname : name , buildid : buildid , } , nil } 
func ( af * gcsartifactfetcher ) artifacts ( key string ) ( [ ] string , error ) { src , err : = newgcsjobsource ( key ) if err ! = nil { return nil , fmt . errorf ( " " , key , err ) } liststart : = time . now ( ) bucketname , prefix : = extractbucketprefixpair ( src . jobpath ( ) ) artifacts : = [ ] string { } bkt : = af . client . bucket ( bucketname ) q : = storage . query { prefix : prefix , versions : false , } objiter : = bkt . objects ( context . background ( ) , & q ) wait : = [ ] time . duration { 16 , 32 , 64 , 128 , 256 , 256 , 512 , 512 } for i : = 0 ; ; { oattrs , err : = objiter . next ( ) if err == iterator . done { break } if err ! = nil { logrus . withfields ( fieldsforjob ( src ) ) . witherror ( err ) . error ( " " ) if i >= len ( wait ) { return artifacts , fmt . errorf ( " " , err ) } time . sleep ( ( wait [ i ] + time . duration ( rand . intn ( 10 ) ) ) * time . millisecond ) i ++ continue } artifacts = append ( artifacts , strings . trimprefix ( oattrs . name , prefix ) ) i = 0 } listelapsed : = time . since ( liststart ) logrus . withfield ( " " , listelapsed ) . infof ( " " , len ( artifacts ) ) return artifacts , nil } 
func ( af * gcsartifactfetcher ) artifact ( key string , artifactname string , sizelimit int64 ) ( lenses . artifact , error ) { src , err : = newgcsjobsource ( key ) if err ! = nil { return nil , fmt . errorf ( " " , key , err ) } bucketname , prefix : = extractbucketprefixpair ( src . jobpath ( ) ) bkt : = af . client . bucket ( bucketname ) obj : = & gcsartifacthandle { bkt . object ( path . join ( prefix , artifactname ) ) } artifactlink : = & url . url { scheme : httpsscheme , host : " " , path : path . join ( src . jobpath ( ) , artifactname ) , } return newgcsartifact ( context . background ( ) , obj , artifactlink . string ( ) , artifactname , sizelimit ) , nil } 
func ( src * gcsjobsource ) canonicallink ( ) string { return path . join ( src . linkprefix , src . bucket , src . jobprefix ) } 
func ( src * gcsjobsource ) jobpath ( ) string { return fmt . sprintf ( " " , src . bucket , src . jobprefix ) } 
func expectedstatus ( querymap * config . querymap , pr * pullrequest , pool map [ string ] pullrequest , cc contextchecker ) ( string , string ) { if , ok : = pool [ prkey ( pr ) ] ; ! ok { mindiffcount : = - 1 var mindiff string for , q : = range querymap . forrepo ( string ( pr . repository . owner . login ) , string ( pr . repository . name ) ) { diff , diffcount : = requirementdiff ( pr , & q , cc ) if mindiffcount == - 1 | | diffcount < mindiffcount { mindiffcount = diffcount mindiff = diff } } return github . statuspending , fmt . sprintf ( statusnotinpool , mindiff ) } return github . statussuccess , statusinpool } 
func targeturl ( c config . getter , pr * pullrequest , log * logrus . entry ) string { var link string if tideurl : = c ( ) . tide . targeturl ; tideurl ! = " " { link = tideurl } else if baseurl : = c ( ) . tide . prstatusbaseurl ; baseurl ! = " " { parseurl , err : = url . parse ( baseurl ) if err ! = nil { log . witherror ( err ) . error ( " " ) } else { prquery : = fmt . sprintf ( " " , pr . repository . namewithowner , pr . author . login , pr . headrefname ) values : = parseurl . query ( ) values . set ( " " , prquery ) parseurl . rawquery = values . encode ( ) link = parseurl . string ( ) } } return link } 
func ( sc * statuscontroller ) waitsync ( ) { wait : = time . after ( time . until ( sc . lastsyncstart . add ( sc . config ( ) . tide . statusupdateperiod ) ) ) for { select { case < - wait : sc . lock ( ) pool : = sc . poolprs sc . unlock ( ) sc . sync ( pool ) return case more : = < - sc . newpoolpending : if ! more { return } } } } 
func newbuildconfig ( cfg rest . config , stop chan struct { } ) ( * buildconfig , error ) { bc , err : = buildset . newforconfig ( & cfg ) if err ! = nil { return nil , err } , err = bc . buildv1alpha1 ( ) . builds ( " " ) . list ( metav1 . listoptions { limit : 1 } ) if err ! = nil { return nil , err } bif : = buildinfo . newsharedinformerfactory ( bc , 30 * time . minute ) bif . build ( ) . v1alpha1 ( ) . builds ( ) . lister ( ) go bif . start ( stop ) return & buildconfig { client : bc , informer : bif . build ( ) . v1alpha1 ( ) . builds ( ) , } , nil } 
func newclient ( token string , dryrun bool ) * client { httpclient : = & http . client { transport : & oauth2 . transport { base : http . defaulttransport , source : oauth2 . reusetokensource ( nil , oauth2 . statictokensource ( & oauth2 . token { accesstoken : token } ) ) , } , } client : = github . newclient ( httpclient ) return & client { issueservice : client . issues , prservice : client . pullrequests , reposervice : client . repositories , userservice : client . users , retries : 5 , retryinitialbackoff : time . second , tokenreserve : 50 , dryrun : dryrun , } } 
func ( c * client ) retry ( action string , call func ( ) ( * github . response , error ) ) ( * github . response , error ) { var err error var resp * github . response for retrycount : = 0 ; retrycount <= c . retries ; retrycount ++ { if resp , err = call ( ) ; err == nil { c . limitrate ( & resp . rate ) return resp , nil } switch err : = err . ( type ) { case * github . ratelimiterror : c . limitrate ( & err . rate ) case * github . twofactorautherror : return resp , err case * retryabort : return resp , err } if retrycount == c . retries { return resp , err } glog . errorf ( " \n " , action , err ) c . sleepforattempt ( retrycount ) } return resp , err } 
func ( c * client ) depaginate ( action string , opts * github . listoptions , call func ( ) ( [ ] interface { } , * github . response , error ) ) ( [ ] interface { } , error ) { var allitems [ ] interface { } wrapper : = func ( ) ( * github . response , error ) { items , resp , err : = call ( ) if err == nil { allitems = append ( allitems , items ... ) } return resp , err } opts . page = 1 opts . perpage = 100 lastpage : = 1 for ; opts . page <= lastpage ; opts . page ++ { resp , err : = c . retry ( action , wrapper ) if err ! = nil { return allitems , fmt . errorf ( " " , opts . page , lastpage , err ) } if resp . lastpage > 0 { lastpage = resp . lastpage } } return allitems , nil } 
func newhelpagent ( pa pluginagent , ghc githubclient ) * helpagent { l : = logrus . withfield ( " " , " " ) return & helpagent { log : l , pa : pa , oa : neworgagent ( l , ghc , newrepodetectionlimit ) , } } 
func ( ha * helpagent ) generatepluginhelp ( ) * pluginhelp . help { config : = ha . pa . config ( ) orgtorepos : = ha . oa . orgtoreposmap ( config ) normalrevmap , externalrevmap : = reversepluginmaps ( config , orgtorepos ) allplugins , pluginhelp : = ha . generatenormalpluginhelp ( config , normalrevmap ) allexternalplugins , externalpluginhelp : = ha . generateexternalpluginhelp ( config , externalrevmap ) repoplugins : = map [ string ] [ ] string { " " : allplugins , } for repo , plugins : = range config . plugins { repoplugins [ repo ] = plugins } repoexternalplugins : = map [ string ] [ ] string { " " : allexternalplugins , } for repo , exts : = range config . externalplugins { for , ext : = range exts { repoexternalplugins [ repo ] = append ( repoexternalplugins [ repo ] , ext . name ) } } return & pluginhelp . help { allrepos : allrepos ( config , orgtorepos ) , repoplugins : repoplugins , repoexternalplugins : repoexternalplugins , pluginhelp : pluginhelp , externalpluginhelp : externalpluginhelp , } } 
func reversepluginmaps ( config * plugins . configuration , orgtorepos map [ string ] sets . string ) ( normal , external map [ string ] [ ] string ) { normal = map [ string ] [ ] string { } for repo , enabledplugins : = range config . plugins { var repos [ ] string if ! strings . contains ( repo , " " ) { if flattened , ok : = orgtorepos [ repo ] ; ok { repos = flattened . list ( ) } } else { repos = [ ] string { repo } } for , plugin : = range enabledplugins { normal [ plugin ] = append ( normal [ plugin ] , repos ... ) } } external = map [ string ] [ ] string { } for repo , extplugins : = range config . externalplugins { var repos [ ] string if flattened , ok : = orgtorepos [ repo ] ; ok { repos = flattened . list ( ) } else { repos = [ ] string { repo } } for , plugin : = range extplugins { external [ plugin . name ] = append ( external [ plugin . name ] , repos ... ) } } return } 
func orgsinconfig ( config * plugins . configuration ) sets . string { orgs : = sets . newstring ( ) for repo : = range config . plugins { if ! strings . contains ( repo , " " ) { orgs . insert ( repo ) } } for repo : = range config . externalplugins { if ! strings . contains ( repo , " " ) { orgs . insert ( repo ) } } return orgs } 
func ( o * options ) validate ( ) error { if len ( o . args ) == 0 { return errors . new ( " " ) } return o . options . validate ( ) } 
func ( o * options ) addflags ( flags * flag . flagset ) { flags . durationvar ( & o . timeout , " " , defaulttimeout , " " ) flags . durationvar ( & o . graceperiod , " " , defaultgraceperiod , " " ) flags . stringvar ( & o . artifactdir , " " , " " , " " ) o . options . addflags ( flags ) } 
func getpullcommithash ( pull string ) ( string , error ) { match : = pullcommitre . findstringsubmatch ( pull ) if len ( match ) ! = 2 { expected : = " " return " " , fmt . errorf ( " " , pull , expected ) } return match [ 1 ] , nil } 
func listjobbuilds ( bucket storagebucket , jobprefixes [ ] string ) [ ] jobbuilds { jobch : = make ( chan jobbuilds ) defer close ( jobch ) for i , jobprefix : = range jobprefixes { go func ( i int , jobprefix string ) { buildprefixes , err : = bucket . listsubdirs ( jobprefix ) if err ! = nil { logrus . witherror ( err ) . warningf ( " " , jobprefix ) } jobch < - jobbuilds { name : path . base ( jobprefix ) , buildprefixes : buildprefixes , } } ( i , jobprefix ) } jobs : = [ ] jobbuilds { } for range jobprefixes { job : = < - jobch jobs = append ( jobs , job ) } return jobs } 
func getprbuilddata ( bucket storagebucket , jobs [ ] jobbuilds ) [ ] builddata { buildch : = make ( chan builddata ) defer close ( buildch ) expected : = 0 for , job : = range jobs { for j , buildprefix : = range job . buildprefixes { go func ( j int , jobname , buildprefix string ) { build , err : = getbuilddata ( bucket , buildprefix ) if err ! = nil { logrus . witherror ( err ) . warningf ( " " , buildprefix ) } split : = strings . split ( strings . trimsuffix ( buildprefix , " " ) , " " ) build . spyglasslink = path . join ( spyglassprefix , bucket . getname ( ) , buildprefix ) build . id = split [ len ( split ) - 1 ] build . jobname = jobname build . prefix = buildprefix build . index = j buildch < - build } ( j , job . name , buildprefix ) expected ++ } } builds : = [ ] builddata { } for k : = 0 ; k < expected ; k ++ { build : = < - buildch builds = append ( builds , build ) } return builds } 
func parsepullurl ( u * url . url ) ( org , repo string , pr int , err error ) { var prstr string vals : = u . query ( ) if org = vals . get ( " " ) ; org == " " { return " " , " " , 0 , fmt . errorf ( " " ) } if repo = vals . get ( " " ) ; repo == " " { return " " , " " , 0 , fmt . errorf ( " " ) } prstr = vals . get ( " " ) pr , err = strconv . atoi ( prstr ) if err ! = nil { return " " , " " , 0 , fmt . errorf ( " " , prstr , err ) } return org , repo , pr , nil } 
func getgcsdirsforpr ( config * config . config , org , repo string , pr int ) ( map [ string ] sets . string , error ) { tosearch : = make ( map [ string ] sets . string ) fullrepo : = org + " " + repo presubmits , ok : = config . presubmits [ fullrepo ] if ! ok { return tosearch , fmt . errorf ( " " , fullrepo ) } for , presubmit : = range presubmits { var gcsconfig * v1 . gcsconfiguration if presubmit . decorationconfig ! = nil && presubmit . decorationconfig . gcsconfiguration ! = nil { gcsconfig = presubmit . decorationconfig . gcsconfiguration } else { gcsconfig = config . plank . defaultdecorationconfig . gcsconfiguration } gcspath , , : = gcsupload . pathsforjob ( gcsconfig , & downwardapi . jobspec { type : v1 . presubmitjob , job : presubmit . name , refs : & v1 . refs { repo : repo , org : org , pulls : [ ] v1 . pull { { number : pr } , } , } , } , " " ) gcspath , = path . split ( path . clean ( gcspath ) ) if , ok : = tosearch [ gcsconfig . bucket ] ; ! ok { tosearch [ gcsconfig . bucket ] = sets . string { } } tosearch [ gcsconfig . bucket ] . insert ( gcspath ) } return tosearch , nil } 
func imagecreateinpool ( d * daemon , info * api . image , storagepool string ) error { if storagepool == " " { return fmt . errorf ( " " ) } s , err : = storagepoolinit ( d . state ( ) , storagepool ) if err ! = nil { return err } err = s . imagecreate ( info . fingerprint , nil ) if err ! = nil { return err } return nil } 
func imagedeletefromdisk ( fingerprint string ) { fname : = shared . varpath ( " " , fingerprint ) if shared . pathexists ( fname ) { err : = os . remove ( fname ) if err ! = nil && ! os . isnotexist ( err ) { logger . errorf ( " " , fname , err ) } } fname = shared . varpath ( " " , fingerprint ) + " " if shared . pathexists ( fname ) { err : = os . remove ( fname ) if err ! = nil && ! os . isnotexist ( err ) { logger . errorf ( " " , fname , err ) } } } 
func donetworkscreate ( d * daemon , req api . networkspost , withdatabase bool ) error { n , err : = networkloadbyname ( d . state ( ) , req . name ) if err ! = nil { return err } err = n . start ( ) if err ! = nil { n . delete ( withdatabase ) return err } return nil } 
func networkloadbyname ( s * state . state , name string ) ( * network , error ) { id , dbinfo , err : = s . cluster . networkget ( name ) if err ! = nil { return nil , err } n : = network { state : s , id : id , name : name , description : dbinfo . description , config : dbinfo . config } return & n , nil } 
func opennode ( dir string , fresh func ( * node ) error , legacypatches map [ int ] * legacypatch ) ( * node , * dump , error ) { var dump * dump db , err : = node . open ( dir ) if err ! = nil { return nil , nil , err } legacyhook : = legacypatchhook ( db , legacypatches ) hook : = func ( version int , tx * sql . tx ) error { if version == node . updatefrompreclustering { logger . debug ( " " ) var err error dump , err = loadpreclusteringdata ( tx ) if err ! = nil { return err } } return legacyhook ( version , tx ) } initial , err : = node . ensureschema ( db , dir , hook ) if err ! = nil { return nil , nil , err } node : = & node { db : db , dir : dir , } if initial == 0 { if fresh ! = nil { err : = fresh ( node ) if err ! = nil { return nil , nil , err } } } db . setmaxopenconns ( 1 ) db . setmaxidleconns ( 1 ) return node , dump , nil } 
func ( n * node ) transaction ( f func ( * nodetx ) error ) error { nodetx : = & nodetx { } return query . transaction ( n . db , func ( tx * sql . tx ) error { nodetx . tx = tx return f ( nodetx ) } ) } 
func forlocalinspectionwithpreparedstmts ( db * sql . db ) ( * cluster , error ) { c : = forlocalinspection ( db ) stmts , err : = cluster . preparestmts ( c . db ) if err ! = nil { return nil , errors . wrap ( err , " " ) } c . stmts = stmts return c , nil } 
func ( c * cluster ) setdefaulttimeout ( timeout time . duration ) { driver : = c . db . driver ( ) . ( * dqlite . driver ) driver . setcontexttimeout ( timeout ) } 
func ( c * cluster ) transaction ( f func ( * clustertx ) error ) error { c . mu . rlock ( ) defer c . mu . runlock ( ) return c . transaction ( f ) } 
func ( c * cluster ) enterexclusive ( ) error { logger . debug ( " " ) ch : = make ( chan struct { } ) go func ( ) { c . mu . lock ( ) ch < - struct { } { } } ( ) timeout : = 20 * time . second select { case < - ch : return nil case < - time . after ( timeout ) : return fmt . errorf ( " " , timeout ) } } 
func ( c * cluster ) exitexclusive ( f func ( * clustertx ) error ) error { logger . debug ( " " ) defer c . mu . unlock ( ) return c . transaction ( f ) } 
func ( c * cluster ) close ( ) error { for , stmt : = range c . stmts { stmt . close ( ) } return c . db . close ( ) } 
func txcommit ( tx * sql . tx ) error { err : = tx . commit ( ) if err == nil | | err == sql . errtxdone { return nil } return err } 
func ( c * config ) parseremote ( raw string ) ( string , string , error ) { result : = strings . splitn ( raw , " " , 2 ) if len ( result ) == 1 { return c . defaultremote , raw , nil } , ok : = c . remotes [ result [ 0 ] ] if ! ok { if shared . issnapshot ( raw ) && shared . issnapshot ( result [ 0 ] ) { return c . defaultremote , raw , nil } return " " , " " , fmt . errorf ( " " " " , result [ 0 ] ) } return result [ 0 ] , result [ 1 ] , nil } 
func ( s * os ) initapparmor ( ) { / * detect apparmor availability * / , err : = exec . lookpath ( " " ) if os . getenv ( " " ) == " " { logger . warnf ( " " ) } else if ! shared . isdir ( " " ) { logger . warnf ( " " ) } else if err ! = nil { logger . warnf ( " " ) } else { s . apparmoravailable = true } / * detect apparmor stacking support * / s . apparmorstacking = apparmorcanstack ( ) / * detect existing apparmor stack * / if shared . pathexists ( " " ) { contentbytes , err : = ioutil . readfile ( " " ) if err == nil && string ( contentbytes ) == " \n " { s . apparmorstacked = true } } / * detect apparmor admin support * / if ! havemacadmin ( ) { if s . apparmoravailable { logger . warnf ( " " ) } } else if s . runninginuserns && ! s . apparmorstacked { if s . apparmoravailable { logger . warnf ( " " ) } } else { s . apparmoradmin = true } / * detect apparmor confinment * / profile : = util . apparmorprofile ( ) if profile ! = " " && profile ! = " " { if s . apparmoravailable { logger . warnf ( " " ) } s . apparmorconfined = true } } 
func apparmorcanstack ( ) bool { contentbytes , err : = ioutil . readfile ( " " ) if err ! = nil { return false } if string ( contentbytes ) ! = " \n " { return false } contentbytes , err = ioutil . readfile ( " " ) if err ! = nil { return false } content : = string ( contentbytes ) parts : = strings . split ( strings . trimspace ( content ) , " " ) if len ( parts ) == 0 { logger . warn ( " " , log . ctx { " " : content } ) return false } major , err : = strconv . atoi ( parts [ 0 ] ) if err ! = nil { logger . warn ( " " , log . ctx { " " : content } ) return false } minor : = 0 if len ( parts ) == 2 { minor , err = strconv . atoi ( parts [ 1 ] ) if err ! = nil { logger . warn ( " " , log . ctx { " " : content } ) return false } } return major >= 1 && minor >= 2 } 
func containerdeviceadd ( client lxd . containerserver , name string , devname string , dev map [ string ] string ) error { container , etag , err : = client . getcontainer ( name ) if err ! = nil { return err } , ok : = container . devices [ devname ] if ok { return fmt . errorf ( i18n . g ( " " ) , devname ) } container . devices [ devname ] = dev op , err : = client . updatecontainer ( name , container . writable ( ) , etag ) if err ! = nil { return err } return op . wait ( ) } 
func profiledeviceadd ( client lxd . containerserver , name string , devname string , dev map [ string ] string ) error { profile , profileetag , err : = client . getprofile ( name ) if err ! = nil { return err } , ok : = profile . devices [ devname ] if ok { return fmt . errorf ( i18n . g ( " " ) , devname ) } profile . devices [ devname ] = dev err = client . updateprofile ( name , profile . writable ( ) , profileetag ) if err ! = nil { return err } return nil } 
func ensureimagealiases ( client lxd . containerserver , aliases [ ] api . imagealias , fingerprint string ) error { if len ( aliases ) == 0 { return nil } names : = make ( [ ] string , len ( aliases ) ) for i , alias : = range aliases { names [ i ] = alias . name } sort . strings ( names ) resp , err : = client . getimagealiases ( ) if err ! = nil { return err } for , alias : = range getexistingaliases ( names , resp ) { err : = client . deleteimagealias ( alias . name ) if err ! = nil { fmt . println ( fmt . sprintf ( i18n . g ( " " ) , alias . name ) ) } } for , alias : = range aliases { aliaspost : = api . imagealiasespost { } aliaspost . name = alias . name aliaspost . target = fingerprint err : = client . createimagealias ( aliaspost ) if err ! = nil { fmt . println ( fmt . sprintf ( i18n . g ( " " ) , alias . name ) ) } } return nil } 
func getexistingaliases ( aliases [ ] string , allaliases [ ] api . imagealiasesentry ) [ ] api . imagealiasesentry { existing : = [ ] api . imagealiasesentry { } for , alias : = range allaliases { name : = alias . name pos : = sort . searchstrings ( aliases , name ) if pos < len ( aliases ) && aliases [ pos ] == name { existing = append ( existing , alias ) } } return existing } 
func ( o statuscode ) string ( ) string { return map [ statuscode ] string { operationcreated : " " , started : " " , stopped : " " , running : " " , cancelling : " " , pending : " " , success : " " , failure : " " , cancelled : " " , starting : " " , stopping : " " , aborting : " " , freezing : " " , frozen : " " , thawed : " " , error : " " , } [ o ] } 
func ( c * cluster ) imagesget ( project string , public bool ) ( [ ] string , error ) { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasimages ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = if public == true { q += " " } var fp string inargs : = [ ] interface { } { project } outfmt : = [ ] interface { } { fp } dbresults , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } results : = [ ] string { } for , r : = range dbresults { results = append ( results , r [ 0 ] . ( string ) ) } return results , nil } 
func ( c * cluster ) imagesgetexpired ( expiry int64 ) ( [ ] string , error ) { q : = ' select fingerprint , last use date , upload date from images where cached=1 ' var fpstr string var usestr string var uploadstr string inargs : = [ ] interface { } { } outfmt : = [ ] interface { } { fpstr , usestr , uploadstr } dbresults , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } results : = [ ] string { } for , r : = range dbresults { timestamp : = r [ 2 ] if r [ 1 ] ! = " " { timestamp = r [ 1 ] } var imageexpiry time . time err = imageexpiry . unmarshaltext ( [ ] byte ( timestamp . ( string ) ) ) if err ! = nil { return [ ] string { } , err } imageexpiry = imageexpiry . add ( time . duration ( expiry * 24 ) * time . hour ) if imageexpiry . after ( time . now ( ) ) { continue } results = append ( results , r [ 0 ] . ( string ) ) } return results , nil } 
func ( c * cluster ) imagesourceinsert ( id int , server string , protocol string , certificate string , alias string ) error { stmt : = ' insert into images source ( image id , server , protocol , certificate , alias ) values ( ? , ? , ? , ? , ? ) ' protocolint : = - 1 for protoint , protostring : = range imagesourceprotocol { if protostring == protocol { protocolint = protoint } } if protocolint == - 1 { return fmt . errorf ( " " , protocol ) } err : = exec ( c . db , stmt , id , server , protocolint , certificate , alias ) return err } 
func ( c * cluster ) imagesourceget ( imageid int ) ( int , api . imagesource , error ) { q : = ' select id , server , protocol , certificate , alias from images source where image id=? ' id : = 0 protocolint : = - 1 result : = api . imagesource { } arg1 : = [ ] interface { } { imageid } arg2 : = [ ] interface { } { & id , & result . server , & protocolint , & result . certificate , & result . alias } err : = dbqueryrowscan ( c . db , q , arg1 , arg2 ) if err ! = nil { if err == sql . errnorows { return - 1 , api . imagesource { } , errnosuchobject } return - 1 , api . imagesource { } , err } protocol , found : = imagesourceprotocol [ protocolint ] if ! found { return - 1 , api . imagesource { } , fmt . errorf ( " " , protocolint ) } result . protocol = protocol return id , result , nil } 
func ( c * cluster ) imagesourcegetcachedfingerprint ( server string , protocol string , alias string ) ( string , error ) { protocolint : = - 1 for protoint , protostring : = range imagesourceprotocol { if protostring == protocol { protocolint = protoint } } if protocolint == - 1 { return " " , fmt . errorf ( " " , protocol ) } q : = fingerprint : = " " arg1 : = [ ] interface { } { server , protocolint , alias } arg2 : = [ ] interface { } { & fingerprint } err : = dbqueryrowscan ( c . db , q , arg1 , arg2 ) if err ! = nil { if err == sql . errnorows { return " " , errnosuchobject } return " " , err } return fingerprint , nil } 
func ( c * cluster ) imageexists ( project string , fingerprint string ) ( bool , error ) { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasimages ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return false , err } var exists bool query : = inargs : = [ ] interface { } { project , fingerprint } outargs : = [ ] interface { } { & exists } err = dbqueryrowscan ( c . db , query , inargs , outargs ) if err == sql . errnorows { return exists , errnosuchobject } return exists , err } 
func ( c * cluster ) imagegetfromanyproject ( fingerprint string ) ( int , * api . image , error ) { var create , expire , used , upload * time . time image : = api . image { } id : = - 1 arch : = - 1 outfmt : = [ ] interface { } { & id , & image . fingerprint , & image . filename , & image . size , & image . cached , & image . public , & image . autoupdate , & arch , & create , & expire , & used , & upload } inargs : = [ ] interface { } { fingerprint } query : = err : = dbqueryrowscan ( c . db , query , inargs , outfmt ) if err ! = nil { if err == sql . errnorows { return - 1 , nil , errnosuchobject } return - 1 , nil , err } err = c . imagefill ( id , & image , create , expire , used , upload , arch ) if err ! = nil { return - 1 , nil , errors . wrapf ( err , " " ) } return id , & image , nil } 
func ( c * cluster ) imagelocate ( fingerprint string ) ( string , error ) { stmt : = var localaddress string var addresses [ ] string err : = c . transaction ( func ( tx * clustertx ) error { offlinethreshold , err : = tx . nodeofflinethreshold ( ) if err ! = nil { return err } localaddress , err = tx . nodeaddress ( ) if err ! = nil { return err } alladdresses , err : = query . selectstrings ( tx . tx , stmt , fingerprint ) if err ! = nil { return err } for , address : = range alladdresses { node , err : = tx . nodebyaddress ( address ) if err ! = nil { return err } if address ! = localaddress && node . isoffline ( offlinethreshold ) { continue } addresses = append ( addresses , address ) } return err } ) if err ! = nil { return " " , err } if len ( addresses ) == 0 { return " " , fmt . errorf ( " " ) } for , address : = range addresses { if address == localaddress { return " " , nil } } return addresses [ 0 ] , nil } 
func ( c * cluster ) imageassociatenode ( project , fingerprint string ) error { imageid , , err : = c . imageget ( project , fingerprint , false , true ) if err ! = nil { return err } err = c . transaction ( func ( tx * clustertx ) error { , err : = tx . tx . exec ( " " , imageid , c . nodeid ) return err } ) return err } 
func ( c * cluster ) imagedelete ( id int ) error { err : = exec ( c . db , " " , id ) if err ! = nil { return err } return nil } 
func ( c * cluster ) imagealiasesget ( project string ) ( [ ] string , error ) { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasimages ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = var name string inargs : = [ ] interface { } { project } outfmt : = [ ] interface { } { name } results , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } names : = [ ] string { } for , res : = range results { names = append ( names , res [ 0 ] . ( string ) ) } return names , nil } 
func ( c * cluster ) imagealiasget ( project , name string , istrustedclient bool ) ( int , api . imagealiasesentry , error ) { id : = - 1 entry : = api . imagealiasesentry { } err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasimages ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return id , entry , err } q : = if ! istrustedclient { q = q + ' and images . public=1 ' } var fingerprint , description string arg1 : = [ ] interface { } { project , name } arg2 : = [ ] interface { } { & id , & fingerprint , & description } err = dbqueryrowscan ( c . db , q , arg1 , arg2 ) if err ! = nil { if err == sql . errnorows { return - 1 , entry , errnosuchobject } return - 1 , entry , err } entry . name = name entry . target = fingerprint entry . description = description return id , entry , nil } 
func ( c * cluster ) imagealiasrename ( id int , name string ) error { err : = exec ( c . db , " " , name , id ) return err } 
func ( c * cluster ) imagealiasdelete ( project , name string ) error { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasimages ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return err } err = exec ( c . db , , project , name ) return err } 
func ( c * cluster ) imagealiasesmove ( source int , destination int ) error { err : = exec ( c . db , " " , destination , source ) return err } 
func ( c * cluster ) imagealiasadd ( project , name string , imageid int , desc string ) error { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasimages ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return err } stmt : = err = exec ( c . db , stmt , name , imageid , desc , project ) return err } 
func ( c * cluster ) imagealiasupdate ( id int , imageid int , desc string ) error { stmt : = ' update images aliases set image id=? , description=? where id=? ' err : = exec ( c . db , stmt , imageid , desc , id ) return err } 
func ( c * cluster ) imagelastaccessupdate ( fingerprint string , date time . time ) error { stmt : = ' update images set last use date=? where fingerprint=? ' err : = exec ( c . db , stmt , date , fingerprint ) return err } 
func ( c * cluster ) imagelastaccessinit ( fingerprint string ) error { stmt : = ' update images set cached=1 , last use date=strftime ( " %s " ) where fingerprint=? ' err : = exec ( c . db , stmt , fingerprint ) return err } 
func ( c * cluster ) imageupdate ( id int , fname string , sz int64 , public bool , autoupdate bool , architecture string , createdat time . time , expiresat time . time , properties map [ string ] string ) error { arch , err : = osarch . architectureid ( architecture ) if err ! = nil { arch = 0 } err = c . transaction ( func ( tx * clustertx ) error { publicint : = 0 if public { publicint = 1 } autoupdateint : = 0 if autoupdate { autoupdateint = 1 } stmt , err : = tx . tx . prepare ( ' update images set filename=? , size=? , public=? , auto update=? , architecture=? , creation date=? , expiry date=? where id=? ' ) if err ! = nil { return err } defer stmt . close ( ) , err = stmt . exec ( fname , sz , publicint , autoupdateint , arch , createdat , expiresat , id ) if err ! = nil { return err } , err = tx . tx . exec ( ' delete from images properties where image id=? ' , id ) if err ! = nil { return err } stmt2 , err : = tx . tx . prepare ( ' insert into images properties ( image id , type , key , value ) values ( ? , ? , ? , ? ) ' ) if err ! = nil { return err } defer stmt2 . close ( ) for key , value : = range properties { , err = stmt2 . exec ( id , 0 , key , value ) if err ! = nil { return err } } return nil } ) return err } 
func ( c * cluster ) imagegetpools ( imagefingerprint string ) ( [ ] int64 , error ) { poolid : = int64 ( - 1 ) query : = " " inargs : = [ ] interface { } { c . nodeid , imagefingerprint , storagepoolvolumetypeimage } outargs : = [ ] interface { } { poolid } result , err : = queryscan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] int64 { } , err } poolids : = [ ] int64 { } for , r : = range result { poolids = append ( poolids , r [ 0 ] . ( int64 ) ) } return poolids , nil } 
func ( c * cluster ) imagegetpoolnamesfromids ( poolids [ ] int64 ) ( [ ] string , error ) { var poolname string query : = " " poolnames : = [ ] string { } for , poolid : = range poolids { inargs : = [ ] interface { } { poolid } outargs : = [ ] interface { } { poolname } result , err : = queryscan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } for , r : = range result { poolnames = append ( poolnames , r [ 0 ] . ( string ) ) } } return poolnames , nil } 
func ( c * cluster ) imageuploadedat ( id int , uploadedat time . time ) error { err : = exec ( c . db , " " , uploadedat , id ) return err } 
func ( c * cluster ) imagesgetoncurrentnode ( ) ( map [ string ] [ ] string , error ) { return c . imagesgetbynodeid ( c . nodeid ) } 
func ( c * cluster ) imagesgetbynodeid ( id int64 ) ( map [ string ] [ ] string , error ) { images : = make ( map [ string ] [ ] string ) err : = c . transaction ( func ( tx * clustertx ) error { stmt : = rows , err : = tx . tx . query ( stmt , id ) if err ! = nil { return err } var fingerprint string var projectname string for rows . next ( ) { err : = rows . scan ( & fingerprint , & projectname ) if err ! = nil { return err } images [ fingerprint ] = append ( images [ fingerprint ] , projectname ) } return rows . err ( ) } ) return images , err } 
func ( c * cluster ) imagegetnodeswithimage ( fingerprint string ) ( [ ] string , error ) { q : = return c . getnodesbyimagefingerprint ( q , fingerprint ) } 
func ( c * cluster ) imagegetnodeswithoutimage ( fingerprint string ) ( [ ] string , error ) { q : = return c . getnodesbyimagefingerprint ( q , fingerprint ) } 
func ( g * group ) add ( f func , schedule schedule ) * task { i : = len ( g . tasks ) g . tasks = append ( g . tasks , task { f : f , schedule : schedule , reset : make ( chan struct { } , 16 ) , } ) return & g . tasks [ i ] } 
func ( g * group ) start ( ) { ctx : = context . background ( ) ctx , g . cancel = context . withcancel ( ctx ) g . wg . add ( len ( g . tasks ) ) g . mu . lock ( ) if g . running == nil { g . running = make ( map [ int ] bool ) } g . mu . unlock ( ) for i : = range g . tasks { g . mu . lock ( ) if g . running [ i ] { g . mu . unlock ( ) continue } g . running [ i ] = true task : = g . tasks [ i ] g . mu . unlock ( ) go func ( i int ) { task . loop ( ctx ) g . wg . done ( ) g . mu . lock ( ) g . running [ i ] = false g . mu . unlock ( ) } ( i ) } } 
func ( g * group ) stop ( timeout time . duration ) error { if g . cancel == nil { return nil } g . cancel ( ) graceful : = make ( chan struct { } , 1 ) go func ( ) { g . wg . wait ( ) close ( graceful ) } ( ) ctx , cancel : = context . withtimeout ( context . background ( ) , timeout ) defer cancel ( ) select { case < - ctx . done ( ) : running : = [ ] string { } for i , value : = range g . running { if value { running = append ( running , strconv . itoa ( i ) ) } } return fmt . errorf ( " " , strings . join ( running , " " ) ) case < - graceful : return nil } } 
func zfsisenabled ( ) bool { out , err : = exec . lookpath ( " " ) if err ! = nil | | len ( out ) == 0 { return false } return true } 
func zfstoolversionget ( ) ( string , error ) { out , err : = shared . runcommand ( " " , " " , " " , " " ) if err ! = nil { return " " , err } return strings . trimspace ( string ( out ) ) , nil } 
func zfsmoduleversionget ( ) ( string , error ) { var zfsversion string if shared . pathexists ( " " ) { out , err : = ioutil . readfile ( " " ) if err ! = nil { return " " , fmt . errorf ( " " ) } zfsversion = string ( out ) } else { out , err : = shared . runcommand ( " " , " " , " " , " " ) if err ! = nil { return " " , fmt . errorf ( " " ) } zfsversion = out } return strings . trimspace ( zfsversion ) , nil } 
func zfspoolvolumecreate ( dataset string , properties ... string ) ( string , error ) { cmd : = [ ] string { " " , " " } for , prop : = range properties { cmd = append ( cmd , [ ] string { " " , prop } ... ) } cmd = append ( cmd , [ ] string { " " , dataset } ... ) return shared . runcommand ( cmd [ 0 ] , cmd [ 1 : ] ... ) } 
func zfspoolvolumeexists ( dataset string ) ( bool , error ) { output , err : = shared . runcommand ( " " , " " , " " , " " ) if err ! = nil { return false , err } for , name : = range strings . split ( output , " \n " ) { if name == dataset { return true , nil } } return false , nil } 
func ( c * clustertx ) networkidsnotpending ( ) ( map [ string ] int64 , error ) { networks : = [ ] struct { id int64 name string } { } dest : = func ( i int ) [ ] interface { } { networks = append ( networks , struct { id int64 name string } { } ) return [ ] interface { } { & networks [ i ] . id , & networks [ i ] . name } } stmt , err : = c . tx . prepare ( " " ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest , networkpending ) if err ! = nil { return nil , err } ids : = map [ string ] int64 { } for , network : = range networks { ids [ network . name ] = network . id } return ids , nil } 
func ( c * clustertx ) networkconfigadd ( networkid , nodeid int64 , config map [ string ] string ) error { return networkconfigadd ( c . tx , networkid , nodeid , config ) } 
func ( c * clustertx ) networknodejoin ( networkid , nodeid int64 ) error { columns : = [ ] string { " " , " " } values : = [ ] interface { } { networkid , nodeid } , err : = query . upsertobject ( c . tx , " " , columns , values ) return err } 
func ( c * clustertx ) networkcreated ( name string ) error { return c . networkstate ( name , networkcreated ) } 
func ( c * clustertx ) networkerrored ( name string ) error { return c . networkstate ( name , networkerrored ) } 
func ( c * cluster ) networks ( where string , args ... interface { } ) ( [ ] string , error ) { q : = " " inargs : = [ ] interface { } { } if where ! = " " { q += fmt . sprintf ( " " , where ) for , arg : = range args { inargs = append ( inargs , arg ) } } var name string outfmt : = [ ] interface { } { name } result , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( c * cluster ) networkget ( name string ) ( int64 , * api . network , error ) { description : = sql . nullstring { } id : = int64 ( - 1 ) state : = 0 q : = " " arg1 : = [ ] interface { } { name } arg2 : = [ ] interface { } { & id , & description , & state } err : = dbqueryrowscan ( c . db , q , arg1 , arg2 ) if err ! = nil { if err == sql . errnorows { return - 1 , nil , errnosuchobject } return - 1 , nil , err } config , err : = c . networkconfigget ( id ) if err ! = nil { return - 1 , nil , err } network : = api . network { name : name , managed : true , type : " " , } network . description = description . string network . config = config switch state { case networkpending : network . status = " " case networkcreated : network . status = " " default : network . status = " " } nodes , err : = c . networknodes ( id ) if err ! = nil { return - 1 , nil , err } network . locations = nodes return id , & network , nil } 
func ( c * cluster ) networknodes ( networkid int64 ) ( [ ] string , error ) { stmt : = var nodes [ ] string err : = c . transaction ( func ( tx * clustertx ) error { var err error nodes , err = query . selectstrings ( tx . tx , stmt , networkid ) return err } ) if err ! = nil { return nil , err } return nodes , nil } 
func ( c * cluster ) networkgetinterface ( devname string ) ( int64 , * api . network , error ) { id : = int64 ( - 1 ) name : = " " value : = " " q : = " " " " arg1 : = [ ] interface { } { c . nodeid } arg2 : = [ ] interface { } { id , name , value } result , err : = queryscan ( c . db , q , arg1 , arg2 ) if err ! = nil { return - 1 , nil , err } for , r : = range result { for , entry : = range strings . split ( r [ 2 ] . ( string ) , " " ) { entry = strings . trimspace ( entry ) if entry == devname { id = r [ 0 ] . ( int64 ) name = r [ 1 ] . ( string ) } } } if id == - 1 { return - 1 , nil , fmt . errorf ( " " , devname ) } config , err : = c . networkconfigget ( id ) if err ! = nil { return - 1 , nil , err } network : = api . network { name : name , managed : true , type : " " , } network . config = config return id , & network , nil } 
func ( c * cluster ) networkconfigget ( id int64 ) ( map [ string ] string , error ) { var key , value string query : = inargs : = [ ] interface { } { id , c . nodeid } outfmt : = [ ] interface { } { key , value } results , err : = queryscan ( c . db , query , inargs , outfmt ) if err ! = nil { return nil , fmt . errorf ( " " , id ) } if len ( results ) == 0 { query : = " " var r int results , err : = queryscan ( c . db , query , [ ] interface { } { id } , [ ] interface { } { r } ) if err ! = nil { return nil , err } if len ( results ) == 0 { return nil , errnosuchobject } } config : = map [ string ] string { } for , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * cluster ) networkcreate ( name , description string , config map [ string ] string ) ( int64 , error ) { var id int64 err : = c . transaction ( func ( tx * clustertx ) error { result , err : = tx . tx . exec ( " " , name , description , networkcreated ) if err ! = nil { return err } id , err : = result . lastinsertid ( ) if err ! = nil { return err } columns : = [ ] string { " " , " " } values : = [ ] interface { } { id , c . nodeid } , err = query . upsertobject ( tx . tx , " " , columns , values ) if err ! = nil { return err } err = networkconfigadd ( tx . tx , id , c . nodeid , config ) if err ! = nil { return err } return nil } ) if err ! = nil { id = - 1 } return id , err } 
func ( c * cluster ) networkupdate ( name , description string , config map [ string ] string ) error { id , , err : = c . networkget ( name ) if err ! = nil { return err } err = c . transaction ( func ( tx * clustertx ) error { err = networkupdatedescription ( tx . tx , id , description ) if err ! = nil { return err } err = networkconfigclear ( tx . tx , id , c . nodeid ) if err ! = nil { return err } err = networkconfigadd ( tx . tx , id , c . nodeid , config ) if err ! = nil { return err } return nil } ) return err } 
func networkupdatedescription ( tx * sql . tx , id int64 , description string ) error { , err : = tx . exec ( " " , description , id ) return err } 
func networkconfigclear ( tx * sql . tx , networkid , nodeid int64 ) error { , err : = tx . exec ( " " , networkid , nodeid ) if err ! = nil { return err } return nil } 
func ( c * cluster ) networkdelete ( name string ) error { id , , err : = c . networkget ( name ) if err ! = nil { return err } err = exec ( c . db , " " , id ) if err ! = nil { return err } return nil } 
func ( c * cluster ) networkrename ( oldname string , newname string ) error { id , , err : = c . networkget ( oldname ) if err ! = nil { return err } err = c . transaction ( func ( tx * clustertx ) error { , err = tx . tx . exec ( " " , newname , id ) return err } ) return err } 
func ( r * protocollxd ) getcontainers ( ) ( [ ] api . container , error ) { containers : = [ ] api . container { } , err : = r . querystruct ( " " , " " , nil , " " , & containers ) if err ! = nil { return nil , err } return containers , nil } 
func ( r * protocollxd ) getcontainersfull ( ) ( [ ] api . containerfull , error ) { containers : = [ ] api . containerfull { } if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } , err : = r . querystruct ( " " , " " , nil , " " , & containers ) if err ! = nil { return nil , err } return containers , nil } 
func ( r * protocollxd ) getcontainer ( name string ) ( * api . container , string , error ) { container : = api . container { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & container ) if err ! = nil { return nil , " " , err } return & container , etag , nil } 
func ( r * protocollxd ) createcontainer ( container api . containerspost ) ( operation , error ) { if container . source . containeronly { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } } op , , err : = r . queryoperation ( " " , " " , container , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) createcontainerfromimage ( source imageserver , image api . image , req api . containerspost ) ( remoteoperation , error ) { req . source . type = " " if r == source { req . source . fingerprint = image . fingerprint req . source . alias = " " op , err : = r . createcontainer ( req ) if err ! = nil { return nil , err } rop : = remoteoperation { targetop : op , chdone : make ( chan bool ) , } go func ( ) { rop . err = rop . targetop . wait ( ) close ( rop . chdone ) } ( ) return & rop , nil } req . source . mode = " " if req . source . alias ! = " " && image . public { req . source . fingerprint = " " } else { req . source . fingerprint = image . fingerprint req . source . alias = " " } info , err : = source . getconnectioninfo ( ) if err ! = nil { return nil , err } req . source . protocol = info . protocol req . source . certificate = info . certificate if ! image . public { secret , err : = source . getimagesecret ( image . fingerprint ) if err ! = nil { return nil , err } req . source . secret = secret } return r . trycreatecontainer ( req , info . addresses ) } 
func ( r * protocollxd ) updatecontainer ( name string , container api . containerput , etag string ) ( operation , error ) { op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , container , etag ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) renamecontainer ( name string , container api . containerpost ) ( operation , error ) { if container . migration { return nil , fmt . errorf ( " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , container , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) deletecontainerfile ( containername string , path string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) , url . queryescape ( path ) ) , nil , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) getcontainersnapshotnames ( containername string ) ( [ ] string , error ) { urls : = [ ] string { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) ) , nil , " " , & urls ) if err ! = nil { return nil , err } names : = [ ] string { } for , uri : = range urls { fields : = strings . split ( uri , fmt . sprintf ( " " , url . queryescape ( containername ) ) ) names = append ( names , fields [ len ( fields ) - 1 ] ) } return names , nil } 
func ( r * protocollxd ) getcontainersnapshots ( containername string ) ( [ ] api . containersnapshot , error ) { snapshots : = [ ] api . containersnapshot { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) ) , nil , " " , & snapshots ) if err ! = nil { return nil , err } return snapshots , nil } 
func ( r * protocollxd ) getcontainersnapshot ( containername string , name string ) ( * api . containersnapshot , string , error ) { snapshot : = api . containersnapshot { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) , url . queryescape ( name ) ) , nil , " " , & snapshot ) if err ! = nil { return nil , " " , err } return & snapshot , etag , nil } 
func ( r * protocollxd ) createcontainersnapshot ( containername string , snapshot api . containersnapshotspost ) ( operation , error ) { if snapshot . expiresat ! = nil && ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) ) , snapshot , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) migratecontainersnapshot ( containername string , name string , container api . containersnapshotpost ) ( operation , error ) { if ! container . migration { return nil , fmt . errorf ( " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) , url . queryescape ( name ) ) , container , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) updatecontainersnapshot ( containername string , name string , container api . containersnapshotput , etag string ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) , url . queryescape ( name ) ) , container , etag ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) getcontainerstate ( name string ) ( * api . containerstate , string , error ) { state : = api . containerstate { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & state ) if err ! = nil { return nil , " " , err } return & state , etag , nil } 
func ( r * protocollxd ) updatecontainerstate ( name string , state api . containerstateput , etag string ) ( operation , error ) { op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , state , etag ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) getcontainerlogfiles ( name string ) ( [ ] string , error ) { urls : = [ ] string { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & urls ) if err ! = nil { return nil , err } logfiles : = [ ] string { } for , uri : = range logfiles { fields : = strings . split ( uri , fmt . sprintf ( " " , url . queryescape ( name ) ) ) logfiles = append ( logfiles , fields [ len ( fields ) - 1 ] ) } return logfiles , nil } 
func ( r * protocollxd ) getcontainermetadata ( name string ) ( * api . imagemetadata , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } metadata : = api . imagemetadata { } url : = fmt . sprintf ( " " , url . queryescape ( name ) ) etag , err : = r . querystruct ( " " , url , nil , " " , & metadata ) if err ! = nil { return nil , " " , err } return & metadata , etag , err } 
func ( r * protocollxd ) setcontainermetadata ( name string , metadata api . imagemetadata , etag string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } url : = fmt . sprintf ( " " , url . queryescape ( name ) ) , , err : = r . query ( " " , url , metadata , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) getcontainertemplatefiles ( containername string ) ( [ ] string , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } templates : = [ ] string { } url : = fmt . sprintf ( " " , url . queryescape ( containername ) ) , err : = r . querystruct ( " " , url , nil , " " , & templates ) if err ! = nil { return nil , err } return templates , nil } 
func ( r * protocollxd ) createcontainertemplatefile ( containername string , templatename string , content io . readseeker ) error { return r . setcontainertemplatefile ( containername , templatename , content , " " ) } 
func ( r * protocollxd ) deletecontainertemplatefile ( name string , templatename string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) , url . queryescape ( templatename ) ) , nil , " " ) return err } 
func ( r * protocollxd ) getcontainerconsolelog ( containername string , args * containerconsolelogargs ) ( io . readcloser , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } url : = fmt . sprintf ( " " , r . httphost , url . queryescape ( containername ) ) url , err : = r . setqueryattributes ( url ) if err ! = nil { return nil , err } req , err : = http . newrequest ( " " , url , nil ) if err ! = nil { return nil , err } if r . httpuseragent ! = " " { req . header . set ( " " , r . httpuseragent ) } resp , err : = r . do ( req ) if err ! = nil { return nil , err } if resp . statuscode ! = http . statusok { , , err : = lxdparseresponse ( resp ) if err ! = nil { return nil , err } } return resp . body , err } 
func ( r * protocollxd ) deletecontainerconsolelog ( containername string , args * containerconsolelogargs ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) ) , nil , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) getcontainerbackups ( containername string ) ( [ ] api . containerbackup , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } backups : = [ ] api . containerbackup { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) ) , nil , " " , & backups ) if err ! = nil { return nil , err } return backups , nil } 
func ( r * protocollxd ) getcontainerbackup ( containername string , name string ) ( * api . containerbackup , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } backup : = api . containerbackup { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) , url . queryescape ( name ) ) , nil , " " , & backup ) if err ! = nil { return nil , " " , err } return & backup , etag , nil } 
func ( r * protocollxd ) createcontainerbackup ( containername string , backup api . containerbackupspost ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) ) , backup , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) renamecontainerbackup ( containername string , name string , backup api . containerbackuppost ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) , url . queryescape ( name ) ) , backup , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) deletecontainerbackup ( containername string , name string ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( containername ) , url . queryescape ( name ) ) , nil , " " ) if err ! = nil { return nil , err } return op , nil } 
func camel ( s string ) string { words : = strings . split ( s , " " ) for i : = range words { words [ i ] = capital ( words [ i ] ) } return strings . join ( words , " " ) } 
func snake ( name string ) string { var ret bytes . buffer multipleupper : = false var lastupper rune var beforeupper rune for , c : = range name { isupper : = ( unicode . isupper ( c ) | | ( lastupper ! = 0 && ! unicode . islower ( c ) ) ) if lastupper ! = 0 { firstinrow : = ! multipleupper lastinrow : = ! isupper if ret . len ( ) > 0 && ( firstinrow | | lastinrow ) && beforeupper ! = ' ' { ret . writebyte ( ' ' ) } ret . writerune ( unicode . tolower ( lastupper ) ) } if isupper { multipleupper = ( lastupper ! = 0 ) lastupper = c continue } ret . writerune ( c ) lastupper = 0 beforeupper = c multipleupper = false } if lastupper ! = 0 { ret . writerune ( unicode . tolower ( lastupper ) ) } return string ( ret . bytes ( ) ) } 
func rsynclocalcopy ( source string , dest string , bwlimit string ) ( string , error ) { err : = os . mkdirall ( dest , 0755 ) if err ! = nil { return " " , err } rsyncverbosity : = " " if debug { rsyncverbosity = " " } if bwlimit == " " { bwlimit = " " } msg , err : = shared . runcommand ( " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , bwlimit , rsyncverbosity , shared . addslash ( source ) , dest ) if err ! = nil { runerror , ok : = err . ( shared . runerror ) if ok { exiterror , ok : = runerror . err . ( * exec . exiterror ) if ok { waitstatus : = exiterror . sys ( ) . ( syscall . waitstatus ) if waitstatus . exitstatus ( ) == 24 { return msg , nil } } } return msg , err } return msg , nil } 
func rsyncsend ( name string , path string , conn * websocket . conn , readwrapper func ( io . readcloser ) io . readcloser , features [ ] string , bwlimit string , execpath string ) error { cmd , datasocket , stderr , err : = rsyncsendsetup ( name , path , bwlimit , execpath , features ) if err ! = nil { return err } if datasocket ! = nil { defer datasocket . close ( ) } readpipe : = io . readcloser ( datasocket ) if readwrapper ! = nil { readpipe = readwrapper ( datasocket ) } readdone , writedone : = shared . websocketmirror ( conn , datasocket , readpipe , nil , nil ) cherror : = make ( chan error , 1 ) go func ( ) { err = cmd . wait ( ) if err ! = nil { datasocket . close ( ) readpipe . close ( ) } cherror < - err } ( ) output , err : = ioutil . readall ( stderr ) if err ! = nil { cmd . process . kill ( ) } err = < - cherror if err ! = nil { logger . errorf ( " " , path , err , string ( output ) ) } < - readdone < - writedone return err } 
func rsyncrecv ( path string , conn * websocket . conn , writewrapper func ( io . writecloser ) io . writecloser , features [ ] string ) error { args : = [ ] string { " " , " " , " " , " " , " " , " " , } if features ! = nil && len ( features ) > 0 { args = append ( args , rsyncfeatureargs ( features ) ... ) } args = append ( args , [ ] string { " " , path } ... ) cmd : = exec . command ( " " , args ... ) stdin , err : = cmd . stdinpipe ( ) if err ! = nil { return err } stdout , err : = cmd . stdoutpipe ( ) if err ! = nil { return err } stderr , err : = cmd . stderrpipe ( ) if err ! = nil { return err } if err : = cmd . start ( ) ; err ! = nil { return err } writepipe : = io . writecloser ( stdin ) if writewrapper ! = nil { writepipe = writewrapper ( stdin ) } readdone , writedone : = shared . websocketmirror ( conn , writepipe , stdout , nil , nil ) output , err : = ioutil . readall ( stderr ) if err ! = nil { cmd . process . kill ( ) cmd . wait ( ) return err } err = cmd . wait ( ) if err ! = nil { logger . errorf ( " " , path , err , string ( output ) ) } < - readdone < - writedone return err } 
func patchesgetnames ( ) [ ] string { names : = make ( [ ] string , len ( patches ) ) for i , patch : = range patches { names [ i ] = patch . name } return names } 
func patchrenamecustomvolumelvs ( name string , d * daemon ) error { pools , : = d . cluster . storagepools ( ) for , poolname : = range pools { poolid , pool , err : = d . cluster . storagepoolget ( poolname ) if err ! = nil { return err } stype , err : = storagestringtotype ( pool . driver ) if err ! = nil { return err } if stype ! = storagetypelvm { continue } volumes , err : = d . cluster . storagepoolnodevolumesgettype ( storagepoolvolumetypecustom , poolid ) if err ! = nil { return err } vgname : = poolname if pool . config [ " " ] ! = " " { vgname = pool . config [ " " ] } for , volume : = range volumes { oldname : = fmt . sprintf ( " " , vgname , volume ) newname : = fmt . sprintf ( " " , vgname , containernametolvname ( volume ) ) exists , err : = storagelvexists ( newname ) if err ! = nil { return err } if exists | | oldname == newname { continue } err = lvmlvrename ( vgname , oldname , newname ) if err ! = nil { return err } logger . info ( " " , log . ctx { " " : oldname , " " : newname } ) } } return nil } 
func ( r * protocollxd ) getconnectioninfo ( ) ( * connectioninfo , error ) { info : = connectioninfo { } info . certificate = r . httpcertificate info . protocol = " " info . url = r . httphost info . socketpath = r . httpunixpath info . project = r . project if info . project == " " { info . project = " " } urls : = [ ] string { } if r . httpprotocol == " " { urls = append ( urls , r . httphost ) } if r . server ! = nil && len ( r . server . environment . addresses ) > 0 { for , addr : = range r . server . environment . addresses { url : = fmt . sprintf ( " " , addr ) if ! shared . stringinslice ( url , urls ) { urls = append ( urls , url ) } } } info . addresses = urls return & info , nil } 
func ( r * protocollxd ) do ( req * http . request ) ( * http . response , error ) { if r . bakeryclient ! = nil { r . addmacaroonheaders ( req ) return r . bakeryclient . do ( req ) } return r . http . do ( req ) } 
func ( r * protocollxd ) rawquery ( method string , path string , data interface { } , etag string ) ( * api . response , string , error ) { url : = fmt . sprintf ( " " , r . httphost , path ) return r . rawquery ( method , url , data , etag ) } 
func ( r * protocollxd ) rawwebsocket ( path string ) ( * websocket . conn , error ) { return r . websocket ( path ) } 
func ( r * protocollxd ) rawoperation ( method string , path string , data interface { } , etag string ) ( operation , string , error ) { return r . queryoperation ( method , path , data , etag ) } 
func lxdparseresponse ( resp * http . response ) ( * api . response , string , error ) { etag : = resp . header . get ( " " ) decoder : = json . newdecoder ( resp . body ) response : = api . response { } err : = decoder . decode ( & response ) if err ! = nil { if resp . statuscode ! = http . statusok { return nil , " " , fmt . errorf ( " " , resp . request . url . string ( ) , resp . status ) } return nil , " " , err } if response . type == api . errorresponse { return nil , " " , fmt . errorf ( response . error ) } return & response , etag , nil } 
func profiletoapi ( profile * profile ) * api . profile { p : = & api . profile { name : profile . name , usedby : profile . usedby , } p . description = profile . description p . config = profile . config p . devices = profile . devices return p } 
func ( c * cluster ) profiles ( project string ) ( [ ] string , error ) { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasprofiles ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = fmt . sprintf ( ) inargs : = [ ] interface { } { project } var name string outfmt : = [ ] interface { } { name } result , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( c * cluster ) profileget ( project , name string ) ( int64 , * api . profile , error ) { var result * api . profile var id int64 err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasprofiles ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } profile , err : = tx . profileget ( project , name ) if err ! = nil { return err } result = profiletoapi ( profile ) id = int64 ( profile . id ) return nil } ) if err ! = nil { return - 1 , nil , err } return id , result , nil } 
func ( c * cluster ) profilesget ( project string , names [ ] string ) ( [ ] api . profile , error ) { profiles : = make ( [ ] api . profile , len ( names ) ) err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasprofiles ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } for i , name : = range names { profile , err : = tx . profileget ( project , name ) if err ! = nil { return errors . wrapf ( err , " " , name ) } profiles [ i ] = * profiletoapi ( profile ) } return nil } ) if err ! = nil { return nil , err } return profiles , nil } 
func ( c * cluster ) profileconfig ( project , name string ) ( map [ string ] string , error ) { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasprofiles ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } var key , value string query : = inargs : = [ ] interface { } { project , name } outfmt : = [ ] interface { } { key , value } results , err : = queryscan ( c . db , query , inargs , outfmt ) if err ! = nil { return nil , errors . wrapf ( err , " " , name ) } if len ( results ) == 0 { query : = " " var id int results , err : = queryscan ( c . db , query , [ ] interface { } { name } , [ ] interface { } { id } ) if err ! = nil { return nil , err } if len ( results ) == 0 { return nil , errnosuchobject } } config : = map [ string ] string { } for , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func profileconfigclear ( tx * sql . tx , id int64 ) error { , err : = tx . exec ( " " , id ) if err ! = nil { return err } , err = tx . exec ( , id ) if err ! = nil { return err } , err = tx . exec ( " " , id ) if err ! = nil { return err } return nil } 
func profileconfigadd ( tx * sql . tx , id int64 , config map [ string ] string ) error { str : = fmt . sprintf ( " " ) stmt , err : = tx . prepare ( str ) defer stmt . close ( ) if err ! = nil { return err } for k , v : = range config { if v == " " { continue } , err = stmt . exec ( id , k , v ) if err ! = nil { return err } } return nil } 
func ( c * cluster ) profilecontainersget ( project , profile string ) ( map [ string ] [ ] string , error ) { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasprofiles ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = results : = map [ string ] [ ] string { } inargs : = [ ] interface { } { profile , project } var name string outfmt : = [ ] interface { } { name , name } output , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } for , r : = range output { if results [ r [ 1 ] . ( string ) ] == nil { results [ r [ 1 ] . ( string ) ] = [ ] string { } } results [ r [ 1 ] . ( string ) ] = append ( results [ r [ 1 ] . ( string ) ] , r [ 0 ] . ( string ) ) } return results , nil } 
func ( c * cluster ) profilecleanupleftover ( ) error { stmt : = err : = exec ( c . db , stmt ) if err ! = nil { return err } return nil } 
func profilesexpandconfig ( config map [ string ] string , profiles [ ] api . profile ) map [ string ] string { expandedconfig : = map [ string ] string { } profileconfigs : = make ( [ ] map [ string ] string , len ( profiles ) ) for i , profile : = range profiles { profileconfigs [ i ] = profile . config } for i : = range profileconfigs { for k , v : = range profileconfigs [ i ] { expandedconfig [ k ] = v } } for k , v : = range config { expandedconfig [ k ] = v } return expandedconfig } 
func profilesexpanddevices ( devices types . devices , profiles [ ] api . profile ) types . devices { expandeddevices : = types . devices { } profiledevices : = make ( [ ] types . devices , len ( profiles ) ) for i , profile : = range profiles { profiledevices [ i ] = profile . devices } for i : = range profiledevices { for k , v : = range profiledevices [ i ] { expandeddevices [ k ] = v } } for k , v : = range devices { expandeddevices [ k ] = v } return expandeddevices } 
func ( r * protocollxd ) getserver ( ) ( * api . server , string , error ) { server : = api . server { } etag , err : = r . querystruct ( " " , " " , nil , " " , & server ) if err ! = nil { return nil , " " , err } if server . environment . certificatefingerprint == " " && server . environment . certificate ! = " " { var err error server . environment . certificatefingerprint , err = shared . certfingerprintstr ( server . environment . certificate ) if err ! = nil { return nil , " " , err } } if ! server . public && len ( server . authmethods ) == 0 { server . authmethods = [ ] string { " " } } r . server = & server return & server , etag , nil } 
func ( r * protocollxd ) updateserver ( server api . serverput , etag string ) error { , , err : = r . query ( " " , " " , server , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) hasextension ( extension string ) bool { if r . server == nil { return true } for , entry : = range r . server . apiextensions { if entry == extension { return true } } return false } 
func ( r * protocollxd ) getserverresources ( ) ( * api . resources , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } resources : = api . resources { } , err : = r . querystruct ( " " , " " , nil , " " , & resources ) if err ! = nil { return nil , err } return & resources , nil } 
func ( r * protocollxd ) useproject ( name string ) containerserver { return & protocollxd { server : r . server , http : r . http , httpcertificate : r . httpcertificate , httphost : r . httphost , httpprotocol : r . httpprotocol , httpuseragent : r . httpuseragent , bakeryclient : r . bakeryclient , bakeryinteractor : r . bakeryinteractor , requireauthenticated : r . requireauthenticated , clustertarget : r . clustertarget , project : name , } } 
func sqliteopen ( path string ) ( * sql . db , error ) { timeout : = 5 openpath : = fmt . sprintf ( " " , path , timeout * 1000 ) return sql . open ( " " , openpath ) } 
func accept ( state * state . state , gateway * gateway , name , address string , schema , api int ) ( [ ] db . raftnode , error ) { if name == " " { return nil , fmt . errorf ( " " ) } if address == " " { return nil , fmt . errorf ( " " ) } err : = state . cluster . transaction ( func ( tx * db . clustertx ) error { err : = membershipcheckclusterstateforaccept ( tx , name , address , schema , api ) if err ! = nil { return err } id , err : = tx . nodeadd ( name , address ) if err ! = nil { return errors . wrap ( err , " " ) } err = tx . nodepending ( id , true ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } ) if err ! = nil { return nil , err } nodes , err : = gateway . currentraftnodes ( ) if err ! = nil { return nil , errors . wrap ( err , " " ) } if len ( nodes ) < membershipmaxraftnodes { err = state . node . transaction ( func ( tx * db . nodetx ) error { id , err : = tx . raftnodeadd ( address ) if err ! = nil { return err } nodes = append ( nodes , db . raftnode { id : id , address : address } ) return nil } ) if err ! = nil { return nil , errors . wrap ( err , " " ) } } return nodes , nil } 
func purge ( cluster * db . cluster , name string ) error { logger . debugf ( " " , name ) return cluster . transaction ( func ( tx * db . clustertx ) error { node , err : = tx . nodebyname ( name ) if err ! = nil { return errors . wrapf ( err , " " , name ) } err = tx . nodeclear ( node . id ) if err ! = nil { return errors . wrapf ( err , " " , name ) } err = tx . noderemove ( node . id ) if err ! = nil { return errors . wrapf ( err , " " , name ) } return nil } ) } 
func count ( state * state . state ) ( int , error ) { var count int err : = state . cluster . transaction ( func ( tx * db . clustertx ) error { var err error count , err = tx . nodescount ( ) return err } ) return count , err } 
func enabled ( node * db . node ) ( bool , error ) { enabled : = false err : = node . transaction ( func ( tx * db . nodetx ) error { addresses , err : = tx . raftnodeaddresses ( ) if err ! = nil { return err } enabled = len ( addresses ) > 0 return nil } ) return enabled , err } 
func membershipchecknodestateforbootstraporjoin ( tx * db . nodetx , address string ) error { nodes , err : = tx . raftnodes ( ) if err ! = nil { return errors . wrap ( err , " " ) } hasclusteraddress : = address ! = " " hasraftnodes : = len ( nodes ) > 0 if ! hasclusteraddress && hasraftnodes { return fmt . errorf ( " " ) } if ! hasclusteraddress { return fmt . errorf ( " " ) } if hasraftnodes { return fmt . errorf ( " " ) } return nil } 
func membershipcheckclusterstateforbootstraporjoin ( tx * db . clustertx ) error { nodes , err : = tx . nodes ( ) if err ! = nil { return errors . wrap ( err , " " ) } if len ( nodes ) ! = 1 { return fmt . errorf ( " " ) } return nil } 
func membershipcheckclusterstateforaccept ( tx * db . clustertx , name string , address string , schema int , api int ) error { nodes , err : = tx . nodes ( ) if err ! = nil { return errors . wrap ( err , " " ) } if len ( nodes ) == 1 && nodes [ 0 ] . address == " " { return fmt . errorf ( " " ) } for , node : = range nodes { if node . name == name { return fmt . errorf ( " " , name ) } if node . address == address { return fmt . errorf ( " " , address ) } if node . schema ! = schema { return fmt . errorf ( " " , node . schema ) } if node . apiextensions ! = api { return fmt . errorf ( " " , node . apiextensions ) } } return nil } 
func membershipcheckclusterstateforleave ( tx * db . clustertx , nodeid int64 ) error { message , err : = tx . nodeisempty ( nodeid ) if err ! = nil { return err } if message ! = " " { return fmt . errorf ( message ) } nodes , err : = tx . nodes ( ) if err ! = nil { return err } if len ( nodes ) == 1 { return fmt . errorf ( " " ) } return nil } 
func membershipchecknoleftoverclustercert ( dir string ) error { for , basename : = range [ ] string { " " , " " , " " } { if shared . pathexists ( filepath . join ( dir , basename ) ) { return fmt . errorf ( " " ) } } return nil } 
func configload ( tx * db . nodetx ) ( * config , error ) { values , err : = tx . config ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } m , err : = config . safeload ( configschema , values ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return & config { tx : tx , m : m } , nil } 
func ( c * config ) replace ( values map [ string ] interface { } ) ( map [ string ] string , error ) { return c . update ( values ) } 
func ( c * config ) patch ( patch map [ string ] interface { } ) ( map [ string ] string , error ) { values : = c . dump ( ) for name , value : = range patch { values [ name ] = value } return c . update ( values ) } 
func ( c * cluster ) certificatesget ( ) ( certs [ ] * certinfo , err error ) { err = c . transaction ( func ( tx * clustertx ) error { rows , err : = tx . tx . query ( " " , ) if err ! = nil { return err } defer rows . close ( ) for rows . next ( ) { cert : = new ( certinfo ) rows . scan ( & cert . id , & cert . fingerprint , & cert . type , & cert . name , & cert . certificate , ) certs = append ( certs , cert ) } return rows . err ( ) } ) if err ! = nil { return certs , err } return certs , nil } 
func ( c * cluster ) certificateget ( fingerprint string ) ( cert * certinfo , err error ) { cert = new ( certinfo ) inargs : = [ ] interface { } { fingerprint + " " } outfmt : = [ ] interface { } { & cert . id , & cert . fingerprint , & cert . type , & cert . name , & cert . certificate , } query : = if err = dbqueryrowscan ( c . db , query , inargs , outfmt ) ; err ! = nil { if err == sql . errnorows { return nil , errnosuchobject } return nil , err } return cert , err } 
func ( c * cluster ) certsave ( cert * certinfo ) error { err : = c . transaction ( func ( tx * clustertx ) error { stmt , err : = tx . tx . prepare ( , ) if err ! = nil { return err } defer stmt . close ( ) , err = stmt . exec ( cert . fingerprint , cert . type , cert . name , cert . certificate , ) if err ! = nil { return err } return nil } ) return err } 
func ( c * cluster ) certdelete ( fingerprint string ) error { err : = exec ( c . db , " " , fingerprint ) if err ! = nil { return err } return nil } 
func ( c * cluster ) certupdate ( fingerprint string , certname string , certtype int ) error { err : = c . transaction ( func ( tx * clustertx ) error { , err : = tx . tx . exec ( " " , certname , certtype , fingerprint ) return err } ) return err } 
func createdevlxdllistener ( dir string ) ( net . listener , error ) { path : = filepath . join ( dir , " " , " " ) err : = socketunixremovestale ( path ) if err ! = nil { return nil , err } listener , err : = socketunixlisten ( path ) if err ! = nil { return nil , err } err = socketunixsetpermissions ( path , 0666 ) if err ! = nil { listener . close ( ) return nil , err } return listener , nil } 
func newraft ( database * db . node , cert * shared . certinfo , latency float64 ) ( * raftinstance , error ) { if latency <= 0 { return nil , fmt . errorf ( " " ) } var info * db . raftnode err : = database . transaction ( func ( tx * db . nodetx ) error { var err error info , err = node . determineraftnode ( tx ) return err } ) if err ! = nil { return nil , err } if info == nil { return nil , nil } logger . debug ( " " , log15 . ctx { " " : info . id , " " : info . address } ) instance , err : = raftinstanceinit ( database , info , cert , latency ) if err ! = nil { return nil , err } return instance , nil } 
func ( i * raftinstance ) servers ( ) ( [ ] raft . server , error ) { if i . raft . state ( ) ! = raft . leader { return nil , raft . errnotleader } future : = i . raft . getconfiguration ( ) err : = future . error ( ) if err ! = nil { return nil , err } configuration : = future . configuration ( ) return configuration . servers , nil } 
func ( i * raftinstance ) shutdown ( ) error { logger . debug ( " " ) timeout : = 10 * time . second errch : = make ( chan error ) timer : = time . after ( timeout ) go func ( ) { errch < - i . raft . shutdown ( ) . error ( ) } ( ) select { case err : = < - errch : if err ! = nil { return errors . wrap ( err , " " ) } case < - timer : logger . debug ( " " ) return fmt . errorf ( " " , timeout ) } err : = i . logs . close ( ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func raftconfig ( latency float64 ) * raft . config { config : = raft . defaultconfig ( ) scale : = func ( duration * time . duration ) { * duration = time . duration ( ( math . ceil ( float64 ( * duration ) * latency ) ) ) } durations : = [ ] * time . duration { & config . heartbeattimeout , & config . electiontimeout , & config . committimeout , & config . leaderleasetimeout , } for , duration : = range durations { scale ( duration ) } config . snapshotthreshold = 1024 config . trailinglogs = 512 return config } 
func raftmaybebootstrap ( conf * raft . config , logs * raftboltdb . boltstore , snaps raft . snapshotstore , trans raft . transport ) error { hasexistingstate , err : = raft . hasexistingstate ( logs , logs , snaps ) if err ! = nil { return errors . wrap ( err , " " ) } if hasexistingstate { return nil } server : = raft . server { id : conf . localid , address : trans . localaddr ( ) , } configuration : = raft . configuration { servers : [ ] raft . server { server } , } return raft . bootstrapcluster ( conf , logs , logs , snaps , trans , configuration ) } 
func cpuresource ( ) ( * api . resourcescpu , error ) { c : = api . resourcescpu { } threads , err : = getthreads ( ) if err ! = nil { return nil , err } var cur * api . resourcescpusocket c . total = uint64 ( len ( threads ) ) for , v : = range threads { if uint64 ( len ( c . sockets ) ) <= v . socketid { c . sockets = append ( c . sockets , api . resourcescpusocket { } ) cur = & c . sockets [ v . socketid ] socketcores : = map [ uint64 ] bool { } for , thread : = range threads { if thread . socketid ! = v . socketid { continue } socketcores [ thread . coreid ] = true } cur . cores = uint64 ( len ( socketcores ) ) } else { cur = & c . sockets [ v . socketid ] } cur . socket = v . socketid cur . numanode = v . numanode cur . threads ++ cur . name = v . name cur . vendor = v . vendor cur . frequency = v . frequency cur . frequencyturbo = v . frequencyturbo } return & c , nil } 
func ( r * protocollxd ) getoperationuuids ( ) ( [ ] string , error ) { urls : = [ ] string { } , err : = r . querystruct ( " " , " " , nil , " " , & urls ) if err ! = nil { return nil , err } uuids : = [ ] string { } for , url : = range urls { fields : = strings . split ( url , " " ) uuids = append ( uuids , fields [ len ( fields ) - 1 ] ) } return uuids , nil } 
func ( r * protocollxd ) getoperations ( ) ( [ ] api . operation , error ) { apioperations : = map [ string ] [ ] api . operation { } , err : = r . querystruct ( " " , " " , nil , " " , & apioperations ) if err ! = nil { return nil , err } operations : = [ ] api . operation { } for , v : = range apioperations { for , operation : = range v { operations = append ( operations , operation ) } } return operations , nil } 
func ( r * protocollxd ) getoperation ( uuid string ) ( * api . operation , string , error ) { op : = api . operation { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( uuid ) ) , nil , " " , & op ) if err ! = nil { return nil , " " , err } return & op , etag , nil } 
func ( r * protocollxd ) getoperationwebsocket ( uuid string , secret string ) ( * websocket . conn , error ) { path : = fmt . sprintf ( " " , url . queryescape ( uuid ) ) if secret ! = " " { path = fmt . sprintf ( " " , path , url . queryescape ( secret ) ) } return r . websocket ( path ) } 
func ( r * protocollxd ) deleteoperation ( uuid string ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( uuid ) ) , nil , " " ) if err ! = nil { return err } return nil } 
func trymount ( src string , dst string , fs string , flags uintptr , options string ) error { var err error for i : = 0 ; i < 20 ; i ++ { err = syscall . mount ( src , dst , fs , flags , options ) if err == nil { break } time . sleep ( 500 * time . millisecond ) } if err ! = nil { return err } return nil } 
func lxdusespool ( dbobj * db . cluster , ondiskpoolname string , driver string , ondiskproperty string ) ( bool , string , error ) { pools , err : = dbobj . storagepools ( ) if err ! = nil && err ! = db . errnosuchobject { return false , " " , err } for , pool : = range pools { , pl , err : = dbobj . storagepoolget ( pool ) if err ! = nil { continue } if pl . driver ! = driver { continue } if pl . config [ ondiskproperty ] == ondiskpoolname { return true , pl . name , nil } } return false , " " , nil } 
func ( c * clustertx ) projecturis ( filter projectfilter ) ( [ ] string , error ) { criteria : = map [ string ] interface { } { } if filter . name ! = " " { criteria [ " " ] = filter . name } var stmt * sql . stmt var args [ ] interface { } if criteria [ " " ] ! = nil { stmt = c . stmt ( projectnamesbyname ) args = [ ] interface { } { filter . name , } } else { stmt = c . stmt ( projectnames ) args = [ ] interface { } { } } code : = cluster . entitytypes [ " " ] formatter : = cluster . entityformaturis [ code ] return query . selecturis ( stmt , formatter , args ... ) } 
func ( c * clustertx ) projectget ( name string ) ( * api . project , error ) { filter : = projectfilter { } filter . name = name objects , err : = c . projectlist ( filter ) if err ! = nil { return nil , errors . wrap ( err , " " ) } switch len ( objects ) { case 0 : return nil , errnosuchobject case 1 : return & objects [ 0 ] , nil default : return nil , fmt . errorf ( " " ) } } 
func ( c * clustertx ) projectexists ( name string ) ( bool , error ) { , err : = c . projectid ( name ) if err ! = nil { if err == errnosuchobject { return false , nil } return false , err } return true , nil } 
func ( c * clustertx ) projectcreate ( object api . projectspost ) ( int64 , error ) { exists , err : = c . projectexists ( object . name ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } if exists { return - 1 , fmt . errorf ( " " ) } args : = make ( [ ] interface { } , 2 ) args [ 0 ] = object . description args [ 1 ] = object . name stmt : = c . stmt ( projectcreate ) result , err : = stmt . exec ( args ... ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } id , err : = result . lastinsertid ( ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } stmt = c . stmt ( projectcreateconfigref ) for key , value : = range object . config { , err : = stmt . exec ( id , key , value ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } } return id , nil } 
func ( c * clustertx ) projectusedbyref ( filter projectfilter ) ( map [ string ] [ ] string , error ) { objects : = make ( [ ] struct { name string value string } , 0 ) criteria : = map [ string ] interface { } { } if filter . name ! = " " { criteria [ " " ] = filter . name } var stmt * sql . stmt var args [ ] interface { } if criteria [ " " ] ! = nil { stmt = c . stmt ( projectusedbyrefbyname ) args = [ ] interface { } { filter . name , } } else { stmt = c . stmt ( projectusedbyref ) args = [ ] interface { } { } } dest : = func ( i int ) [ ] interface { } { objects = append ( objects , struct { name string value string } { } ) return [ ] interface { } { & objects [ i ] . name , & objects [ i ] . value , } } err : = query . selectobjects ( stmt , dest , args ... ) if err ! = nil { return nil , errors . wrap ( err , " " ) } index : = map [ string ] [ ] string { } for , object : = range objects { item , ok : = index [ object . name ] if ! ok { item = [ ] string { } } index [ object . name ] = append ( item , object . value ) } return index , nil } 
func ( c * clustertx ) projectrename ( name string , to string ) error { stmt : = c . stmt ( projectrename ) result , err : = stmt . exec ( to , name ) if err ! = nil { return errors . wrap ( err , " " ) } n , err : = result . rowsaffected ( ) if err ! = nil { return errors . wrap ( err , " " ) } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) projectdelete ( name string ) error { stmt : = c . stmt ( projectdelete ) result , err : = stmt . exec ( name ) if err ! = nil { return errors . wrap ( err , " " ) } n , err : = result . rowsaffected ( ) if err ! = nil { return errors . wrap ( err , " " ) } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func passwordcheck ( secret string , password string ) error { if secret == " " { return fmt . errorf ( " " ) } buff , err : = hex . decodestring ( secret ) if err ! = nil { return err } salt : = buff [ 0 : 32 ] hash , err : = scrypt . key ( [ ] byte ( password ) , salt , 1 < < 14 , 8 , 1 , 64 ) if err ! = nil { return err } if ! bytes . equal ( hash , buff [ 32 : ] ) { return fmt . errorf ( " " ) } return nil } 
func loadcert ( dir string ) ( * shared . certinfo , error ) { prefix : = " " if shared . pathexists ( filepath . join ( dir , " " ) ) { prefix = " " } cert , err : = shared . keypairandca ( dir , prefix , shared . certserver ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return cert , nil } 
func writecert ( dir , prefix string , cert , key , ca [ ] byte ) error { err : = ioutil . writefile ( filepath . join ( dir , prefix + " " ) , cert , 0644 ) if err ! = nil { return err } err = ioutil . writefile ( filepath . join ( dir , prefix + " " ) , key , 0600 ) if err ! = nil { return err } if ca ! = nil { err = ioutil . writefile ( filepath . join ( dir , prefix + " " ) , ca , 0644 ) if err ! = nil { return err } } return nil } 
func newdaemon ( config * daemonconfig , os * sys . os ) * daemon { return & daemon { config : config , os : os , setupchan : make ( chan struct { } ) , readychan : make ( chan struct { } ) , shutdownchan : make ( chan struct { } ) , } } 
func defaultdaemon ( ) * daemon { config : = defaultdaemonconfig ( ) os : = sys . defaultos ( ) return newdaemon ( config , os ) } 
func allowprojectpermission ( feature string , permission string ) func ( d * daemon , r * http . request ) response { return func ( d * daemon , r * http . request ) response { if d . userisadmin ( r ) { return emptysyncresponse } project : = projectparam ( r ) if ! d . userhaspermission ( r , project , permission ) { return forbidden ( nil ) } return emptysyncresponse } } 
func ( d * daemon ) checktrustedclient ( r * http . request ) error { trusted , , , err : = d . authenticate ( r ) if ! trusted | | err ! = nil { if err ! = nil { return err } return fmt . errorf ( " " ) } return nil } 
func ( d * daemon ) state ( ) * state . state { return state . newstate ( d . db , d . cluster , d . maas , d . os , d . endpoints ) } 
func ( d * daemon ) unixsocket ( ) string { path : = os . getenv ( " " ) if path ! = " " { return path } return filepath . join ( d . os . vardir , " " ) } 
func writejson ( w http . responsewriter , body interface { } , debug bool ) error { var output io . writer var captured * bytes . buffer output = w if debug { captured = & bytes . buffer { } output = io . multiwriter ( w , captured ) } err : = json . newencoder ( output ) . encode ( body ) if captured ! = nil { shared . debugjson ( captured ) } return err } 
func etaghash ( data interface { } ) ( string , error ) { etag : = sha256 . new ( ) err : = json . newencoder ( etag ) . encode ( data ) if err ! = nil { return " " , err } return fmt . sprintf ( " " , etag . sum ( nil ) ) , nil } 
func etagcheck ( r * http . request , data interface { } ) error { match : = r . header . get ( " " ) if match == " " { return nil } hash , err : = etaghash ( data ) if err ! = nil { return err } if hash ! = match { return fmt . errorf ( " " , hash , match ) } return nil } 
func checktruststate ( cert x509 . certificate , trustedcerts map [ string ] x509 . certificate ) ( bool , string ) { if time . now ( ) . before ( cert . notbefore ) | | time . now ( ) . after ( cert . notafter ) { return false , " " } for k , v : = range trustedcerts { if bytes . compare ( cert . raw , v . raw ) == 0 { logger . debug ( " " , log . ctx { " " : k } ) return true , k } } return false , " " } 
func listenaddresses ( value string ) ( [ ] string , error ) { addresses : = make ( [ ] string , 0 ) if value == " " { return addresses , nil } localhost , localport , err : = net . splithostport ( value ) if err ! = nil { localhost = value localport = shared . defaultport } if localhost == " " | | localhost == " " | | localhost == " " { ifaces , err : = net . interfaces ( ) if err ! = nil { return addresses , err } for , i : = range ifaces { addrs , err : = i . addrs ( ) if err ! = nil { continue } for , addr : = range addrs { var ip net . ip switch v : = addr . ( type ) { case * net . ipnet : ip = v . ip case * net . ipaddr : ip = v . ip } if ! ip . isglobalunicast ( ) { continue } if ip . to4 ( ) == nil { if localhost == " " { continue } addresses = append ( addresses , fmt . sprintf ( " " , ip , localport ) ) } else { addresses = append ( addresses , fmt . sprintf ( " " , ip , localport ) ) } } } } else { if strings . contains ( localhost , " " ) { addresses = append ( addresses , fmt . sprintf ( " " , localhost , localport ) ) } else { addresses = append ( addresses , fmt . sprintf ( " " , localhost , localport ) ) } } return addresses , nil } 
func getlisteners ( start int ) [ ] net . listener { defer func ( ) { os . unsetenv ( " " ) os . unsetenv ( " " ) } ( ) pid , err : = strconv . atoi ( os . getenv ( " " ) ) if err ! = nil { return nil } if pid ! = os . getpid ( ) { return nil } fds , err : = strconv . atoi ( os . getenv ( " " ) ) if err ! = nil { return nil } listeners : = [ ] net . listener { } for i : = start ; i < start + fds ; i ++ { syscall . closeonexec ( i ) file : = os . newfile ( uintptr ( i ) , fmt . sprintf ( " " , i ) ) listener , err : = net . filelistener ( file ) if err ! = nil { continue } listeners = append ( listeners , listener ) } return listeners } 
func internalsqlget ( d * daemon , r * http . request ) response { database : = r . formvalue ( " " ) if ! shared . stringinslice ( database , [ ] string { " " , " " } ) { return badrequest ( fmt . errorf ( " " ) ) } schemaformvalue : = r . formvalue ( " " ) schemaonly , err : = strconv . atoi ( schemaformvalue ) if err ! = nil { schemaonly = 0 } var schema string var db * sql . db if database == " " { db = d . cluster . db ( ) schema = cluster . freshschema ( ) } else { db = d . db . db ( ) schema = node . freshschema ( ) } tx , err : = db . begin ( ) if err ! = nil { return smarterror ( errors . wrap ( err , " " ) ) } defer tx . rollback ( ) dump , err : = query . dump ( tx , schema , schemaonly == 1 ) if err ! = nil { return smarterror ( errors . wrapf ( err , " " , database ) ) } return syncresponse ( true , internalsqldump { text : dump } ) } 
func keypairandca ( dir , prefix string , kind certkind ) ( * certinfo , error ) { certfilename : = filepath . join ( dir , prefix + " " ) keyfilename : = filepath . join ( dir , prefix + " " ) err : = findorgencert ( certfilename , keyfilename , kind == certclient ) if err ! = nil { return nil , err } keypair , err : = tls . loadx509keypair ( certfilename , keyfilename ) if err ! = nil { return nil , err } cafilename : = filepath . join ( dir , prefix + " " ) var ca * x509 . certificate if pathexists ( cafilename ) { ca , err = readcert ( cafilename ) if err ! = nil { return nil , err } } info : = & certinfo { keypair : keypair , ca : ca , } return info , nil } 
func ( c * certinfo ) publickey ( ) [ ] byte { data : = c . keypair ( ) . certificate [ 0 ] return pem . encodetomemory ( & pem . block { type : " " , bytes : data } ) } 
func ( c * certinfo ) privatekey ( ) [ ] byte { eckey , ok : = c . keypair ( ) . privatekey . ( * ecdsa . privatekey ) if ok { data , err : = x509 . marshalecprivatekey ( eckey ) if err ! = nil { return nil } return pem . encodetomemory ( & pem . block { type : " " , bytes : data } ) } rsakey , ok : = c . keypair ( ) . privatekey . ( * rsa . privatekey ) if ok { data : = x509 . marshalpkcs1privatekey ( rsakey ) return pem . encodetomemory ( & pem . block { type : " " , bytes : data } ) } return nil } 
func ( c * certinfo ) fingerprint ( ) string { fingerprint , err : = certfingerprintstr ( string ( c . publickey ( ) ) ) if err ! = nil { panic ( " " ) } return fingerprint } 
func mynames ( ) ( [ ] string , error ) { h , err : = os . hostname ( ) if err ! = nil { return nil , err } ret : = [ ] string { h } ifs , err : = net . interfaces ( ) if err ! = nil { return nil , err } for , iface : = range ifs { if isloopback ( & iface ) { continue } addrs , err : = iface . addrs ( ) if err ! = nil { return nil , err } for , addr : = range addrs { ret = append ( ret , addr . string ( ) ) } } return ret , nil } 
func gencert ( certf string , keyf string , certtype bool ) error { / * create the basenames if needed * / dir : = path . dir ( certf ) err : = os . mkdirall ( dir , 0750 ) if err ! = nil { return err } dir = path . dir ( keyf ) err = os . mkdirall ( dir , 0750 ) if err ! = nil { return err } certbytes , keybytes , err : = generatememcert ( certtype ) if err ! = nil { return err } certout , err : = os . create ( certf ) if err ! = nil { return fmt . errorf ( " " , certf , err ) } certout . write ( certbytes ) certout . close ( ) keyout , err : = os . openfile ( keyf , os . o wronly | os . o create | os . o trunc , 0600 ) if err ! = nil { return fmt . errorf ( " " , keyf , err ) } keyout . write ( keybytes ) keyout . close ( ) return nil } 
func printserverinfo ( c lxd . containerserver ) error { server , , err : = c . getserver ( ) if err ! = nil { return err } env : = server . environment fmt . printf ( " \n " ) fmt . printf ( " \n " , env . server ) fmt . printf ( " \n " , env . serverversion ) fmt . printf ( " \n " , env . kernel ) fmt . printf ( " \n " , env . kernelarchitecture ) fmt . printf ( " \n " , env . kernelversion ) fmt . printf ( " \n " , env . storage ) fmt . printf ( " \n " , env . storageversion ) fmt . printf ( " \n " , env . driver ) fmt . printf ( " \n " , env . driverversion ) fmt . printf ( " \n " ) return nil } 
func launchcontainers ( c lxd . containerserver , count int , parallel int , image string , privileged bool , start bool , freeze bool ) ( time . duration , error ) { var duration time . duration batchsize , err : = getbatchsize ( parallel ) if err ! = nil { return duration , err } printtestconfig ( count , batchsize , image , privileged , freeze ) fingerprint , err : = ensureimage ( c , image ) if err ! = nil { return duration , err } batchstart : = func ( index int , wg * sync . waitgroup ) { defer wg . done ( ) name : = getcontainername ( count , index ) err : = createcontainer ( c , fingerprint , name , privileged ) if err ! = nil { logf ( " " , name , err ) return } if start { err : = startcontainer ( c , name ) if err ! = nil { logf ( " " , name , err ) return } if freeze { err : = freezecontainer ( c , name ) if err ! = nil { logf ( " " , name , err ) return } } } } duration = processbatch ( count , batchsize , batchstart ) return duration , nil } 
func createcontainers ( c lxd . containerserver , count int , parallel int , fingerprint string , privileged bool ) ( time . duration , error ) { var duration time . duration batchsize , err : = getbatchsize ( parallel ) if err ! = nil { return duration , err } batchcreate : = func ( index int , wg * sync . waitgroup ) { defer wg . done ( ) name : = getcontainername ( count , index ) err : = createcontainer ( c , fingerprint , name , privileged ) if err ! = nil { logf ( " " , name , err ) return } } duration = processbatch ( count , batchsize , batchcreate ) return duration , nil } 
func getcontainers ( c lxd . containerserver ) ( [ ] api . container , error ) { containers : = [ ] api . container { } allcontainers , err : = c . getcontainers ( ) if err ! = nil { return containers , err } for , container : = range allcontainers { if container . config [ userconfigkey ] == " " { containers = append ( containers , container ) } } return containers , nil } 
func startcontainers ( c lxd . containerserver , containers [ ] api . container , parallel int ) ( time . duration , error ) { var duration time . duration batchsize , err : = getbatchsize ( parallel ) if err ! = nil { return duration , err } count : = len ( containers ) logf ( " " , count ) batchstart : = func ( index int , wg * sync . waitgroup ) { defer wg . done ( ) container : = containers [ index ] if ! container . isactive ( ) { err : = startcontainer ( c , container . name ) if err ! = nil { logf ( " " , container . name , err ) return } } } duration = processbatch ( count , batchsize , batchstart ) return duration , nil } 
func params ( n int ) string { tokens : = make ( [ ] string , n ) for i : = 0 ; i < n ; i ++ { tokens [ i ] = " " } return fmt . sprintf ( " " , strings . join ( tokens , " " ) ) } 
func setqueryparam ( uri , param , value string ) ( string , error ) { fields , err : = url . parse ( uri ) if err ! = nil { return " " , err } values : = fields . query ( ) values . set ( param , url . queryescape ( value ) ) fields . rawquery = values . encode ( ) return fields . string ( ) , nil } 
func ( r * protocollxd ) getimages ( ) ( [ ] api . image , error ) { images : = [ ] api . image { } , err : = r . querystruct ( " " , " " , nil , " " , & images ) if err ! = nil { return nil , err } return images , nil } 
func ( r * protocollxd ) getimagefingerprints ( ) ( [ ] string , error ) { urls : = [ ] string { } , err : = r . querystruct ( " " , " " , nil , " " , & urls ) if err ! = nil { return nil , err } fingerprints : = [ ] string { } for , url : = range urls { fields : = strings . split ( url , " " ) fingerprints = append ( fingerprints , fields [ len ( fields ) - 1 ] ) } return fingerprints , nil } 
func ( r * protocollxd ) getimage ( fingerprint string ) ( * api . image , string , error ) { return r . getprivateimage ( fingerprint , " " ) } 
func ( r * protocollxd ) getimagefile ( fingerprint string , req imagefilerequest ) ( * imagefileresponse , error ) { return r . getprivateimagefile ( fingerprint , " " , req ) } 
func ( r * protocollxd ) getimagesecret ( fingerprint string ) ( string , error ) { op , err : = r . createimagesecret ( fingerprint ) if err ! = nil { return " " , err } opapi : = op . get ( ) return opapi . metadata [ " " ] . ( string ) , nil } 
func ( r * protocollxd ) getprivateimage ( fingerprint string , secret string ) ( * api . image , string , error ) { image : = api . image { } path : = fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) var err error path , err = r . setqueryattributes ( path ) if err ! = nil { return nil , " " , err } if secret ! = " " { path , err = setqueryparam ( path , " " , secret ) if err ! = nil { return nil , " " , err } } etag , err : = r . querystruct ( " " , path , nil , " " , & image ) if err ! = nil { return nil , " " , err } return & image , etag , nil } 
func ( r * protocollxd ) getprivateimagefile ( fingerprint string , secret string , req imagefilerequest ) ( * imagefileresponse , error ) { if req . metafile == nil && req . rootfsfile == nil { return nil , fmt . errorf ( " " ) } uri : = fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) var err error uri , err = r . setqueryattributes ( uri ) if err ! = nil { return nil , err } if secret == " " && shared . pathexists ( " " ) && os . geteuid ( ) == 0 { unixuri : = fmt . sprintf ( " " , uri ) devlxdhttp , err : = unixhttpclient ( nil , " " ) if err == nil { resp , err : = lxddownloadimage ( fingerprint , unixuri , r . httpuseragent , devlxdhttp , req ) if err == nil { return resp , nil } } } uri = fmt . sprintf ( " " , r . httphost , uri ) if secret ! = " " { uri , err = setqueryparam ( uri , " " , secret ) if err ! = nil { return nil , err } } return lxddownloadimage ( fingerprint , uri , r . httpuseragent , r . http , req ) } 
func ( r * protocollxd ) getimagealiases ( ) ( [ ] api . imagealiasesentry , error ) { aliases : = [ ] api . imagealiasesentry { } , err : = r . querystruct ( " " , " " , nil , " " , & aliases ) if err ! = nil { return nil , err } return aliases , nil } 
func ( r * protocollxd ) getimagealias ( name string ) ( * api . imagealiasesentry , string , error ) { alias : = api . imagealiasesentry { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & alias ) if err ! = nil { return nil , " " , err } return & alias , etag , nil } 
func ( r * protocollxd ) copyimage ( source imageserver , image api . image , args * imagecopyargs ) ( remoteoperation , error ) { if r == source { return nil , fmt . errorf ( " " ) } info , err : = source . getconnectioninfo ( ) if err ! = nil { return nil , err } req : = api . imagespost { source : & api . imagespostsource { imagesource : api . imagesource { certificate : info . certificate , protocol : info . protocol , } , fingerprint : image . fingerprint , mode : " " , type : " " , } , } if ! image . public { secret , err : = source . getimagesecret ( image . fingerprint ) if err ! = nil { return nil , err } req . source . secret = secret } if args ! = nil { req . aliases = args . aliases req . autoupdate = args . autoupdate req . public = args . public if args . copyaliases { req . aliases = image . aliases if args . aliases ! = nil { req . aliases = append ( req . aliases , args . aliases ... ) } } } return r . trycopyimage ( req , info . addresses ) } 
func ( r * protocollxd ) updateimage ( fingerprint string , image api . imageput , etag string ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) , image , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) deleteimage ( fingerprint string ) ( operation , error ) { op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) , nil , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) refreshimage ( fingerprint string ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) , nil , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) createimagealias ( alias api . imagealiasespost ) error { , , err : = r . query ( " " , " " , alias , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) updateimagealias ( name string , alias api . imagealiasesentryput , etag string ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , alias , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) renameimagealias ( name string , alias api . imagealiasesentrypost ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , alias , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) deleteimagealias ( name string ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " ) if err ! = nil { return err } return nil } 
func open ( dir string ) ( * sql . db , error ) { path : = filepath . join ( dir , " " ) db , err : = sqliteopen ( path ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return db , nil } 
func ensureschema ( db * sql . db , dir string , hook schema . hook ) ( int , error ) { backupdone : = false schema : = schema ( ) schema . file ( filepath . join ( dir , " " ) ) schema . hook ( func ( version int , tx * sql . tx ) error { if ! backupdone { logger . infof ( " " " " ) path : = filepath . join ( dir , " " ) err : = shared . filecopy ( path , path + " " ) if err ! = nil { return err } backupdone = true } if version == - 1 { logger . debugf ( " " ) } else { logger . debugf ( " " , version , version + 1 ) } if hook ! = nil && version ! = - 1 { err : = hook ( version , tx ) if err ! = nil { } } return nil } ) return schema . ensure ( db ) } 
func filesystemdetect ( path string ) ( string , error ) { fs : = syscall . statfs t { } err : = syscall . statfs ( path , & fs ) if err ! = nil { return " " , err } switch fs . type { case filesystemsupermagicbtrfs : return " " , nil case filesystemsupermagiczfs : return " " , nil case filesystemsupermagictmpfs : return " " , nil case filesystemsupermagicext4 : return " " , nil case filesystemsupermagicxfs : return " " , nil case filesystemsupermagicnfs : return " " , nil default : logger . debugf ( " " , fs . type ) return string ( fs . type ) , nil } } 
func schema ( ) * schema . schema { schema : = schema . newfrommap ( updates ) schema . fresh ( freshschema ) return schema } 
func architecturegetlocal ( ) ( string , error ) { uname , err : = shared . uname ( ) if err ! = nil { return architecturedefault , err } return uname . machine , nil } 
func newcontroller ( url string , key string , machine string ) ( * controller , error ) { baseurl : = fmt . sprintf ( " " , url ) srv , err : = gomaasapi . newcontroller ( gomaasapi . controllerargs { baseurl : baseurl , apikey : key , } ) if err ! = nil { if ! strings . contains ( err . error ( ) , " " ) { return nil , err } return nil , fmt . errorf ( " " , baseurl , strings . split ( strings . split ( err . error ( ) , " " ) [ 1 ] , " " ) [ 0 ] ) } srvraw , err : = gomaasapi . newauthenticatedclient ( baseurl , key ) if err ! = nil { return nil , err } machines , err : = srv . machines ( gomaasapi . machinesargs { hostnames : [ ] string { machine } } ) if err ! = nil { return nil , err } if len ( machines ) ! = 1 { return nil , fmt . errorf ( " " , machine ) } c : = controller { } c . srv = srv c . srvraw = * srvraw c . machine = machines [ 0 ] c . url = baseurl return & c , err } 
func ( c * controller ) definedcontainer ( name string ) ( bool , error ) { devs , err : = c . machine . devices ( gomaasapi . devicesargs { hostname : [ ] string { name } } ) if err ! = nil { return false , err } if len ( devs ) == 1 { return true , nil } return false , nil } 
func ( c * controller ) renamecontainer ( name string , newname string ) error { device , err : = c . getdevice ( name ) if err ! = nil { return err } uri , err : = url . parse ( fmt . sprintf ( " " , c . url , device . systemid ( ) ) ) if err ! = nil { return err } values : = url . values { } values . set ( " " , newname ) , err = c . srvraw . put ( uri , values ) if err ! = nil { return err } return nil } 
func ( c * controller ) deletecontainer ( name string ) error { device , err : = c . getdevice ( name ) if err ! = nil { return err } err = device . delete ( ) if err ! = nil { return err } return nil } 
func newfrommap ( versionstoupdates map [ int ] update ) * schema { versions : = [ ] int { } for version : = range versionstoupdates { versions = append ( versions , version ) } sort . sort ( sort . intslice ( versions ) ) updates : = [ ] update { } for i , version : = range versions { if version ! = i + 1 { panic ( fmt . sprintf ( " " , i + 1 ) ) } updates = append ( updates , versionstoupdates [ version ] ) } return & schema { updates : updates , } } 
func ( s * schema ) add ( update update ) { s . updates = append ( s . updates , update ) } 
func ( s * schema ) ensure ( db * sql . db ) ( int , error ) { var current int aborted : = false err : = query . transaction ( db , func ( tx * sql . tx ) error { err : = execfromfile ( tx , s . path , s . hook ) if err ! = nil { return errors . wrapf ( err , " " , s . path ) } err = ensureschematableexists ( tx ) if err ! = nil { return err } current , err = querycurrentversion ( tx ) if err ! = nil { return err } if s . check ! = nil { err : = s . check ( current , tx ) if err == errgracefulabort { aborted = true return nil } if err ! = nil { return err } } if current == 0 && s . fresh ! = " " { , err = tx . exec ( s . fresh ) if err ! = nil { return fmt . errorf ( " " , err ) } } else { err = ensureupdatesareapplied ( tx , current , s . updates , s . hook ) if err ! = nil { return err } } return nil } ) if err ! = nil { return - 1 , err } if aborted { return current , errgracefulabort } return current , nil } 
func ( s * schema ) dump ( db * sql . db ) ( string , error ) { var statements [ ] string err : = query . transaction ( db , func ( tx * sql . tx ) error { err : = checkallupdatesareapplied ( tx , s . updates ) if err ! = nil { return err } statements , err = selecttablessql ( tx ) return err } ) if err ! = nil { return " " , err } for i , statement : = range statements { statements [ i ] = formatsql ( statement ) } statements = append ( statements , fmt . sprintf ( , len ( s . updates ) ) ) return strings . join ( statements , " \n " ) , nil } 
func ( s * schema ) trim ( version int ) [ ] update { trimmed : = s . updates [ version : ] s . updates = s . updates [ : version ] s . fresh = " " return trimmed } 
func ( s * schema ) exerciseupdate ( version int , hook func ( * sql . db ) ) ( * sql . db , error ) { db , err : = sql . open ( " " , " " ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } trimmed : = s . trim ( version - 1 ) , err = s . ensure ( db ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if hook ! = nil { hook ( db ) } s . add ( trimmed [ 0 ] ) , err = s . ensure ( db ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return db , nil } 
func ensureschematableexists ( tx * sql . tx ) error { exists , err : = doesschematableexist ( tx ) if err ! = nil { return fmt . errorf ( " " , err ) } if ! exists { err : = createschematable ( tx ) if err ! = nil { return fmt . errorf ( " " , err ) } } return nil } 
func querycurrentversion ( tx * sql . tx ) ( int , error ) { versions , err : = selectschemaversions ( tx ) if err ! = nil { return - 1 , fmt . errorf ( " " , err ) } hasversion : = func ( v int ) bool { return shared . intinslice ( v , versions ) } if hasversion ( 30 ) && hasversion ( 32 ) && ! hasversion ( 31 ) { err = insertschemaversion ( tx , 31 ) if err ! = nil { return - 1 , fmt . errorf ( " " ) } versions , err = selectschemaversions ( tx ) if err ! = nil { return - 1 , fmt . errorf ( " " , err ) } } if hasversion ( 37 ) && ! hasversion ( 38 ) { count , err : = query . count ( tx , " " , " " ) if err ! = nil { return - 1 , fmt . errorf ( " " , err ) } if count == 1 { err : = insertschemaversion ( tx , 38 ) if err ! = nil { return - 1 , fmt . errorf ( " " ) } versions = append ( versions , 38 ) } } current : = 0 if len ( versions ) > 0 { err = checkschemaversionshavenoholes ( versions ) if err ! = nil { return - 1 , err } current = versions [ len ( versions ) - 1 ] } return current , nil } 
func ensureupdatesareapplied ( tx * sql . tx , current int , updates [ ] update , hook hook ) error { if current > len ( updates ) { return fmt . errorf ( " " , current , len ( updates ) ) } if len ( updates ) == 0 { return nil } for , update : = range updates [ current : ] { if hook ! = nil { err : = hook ( current , tx ) if err ! = nil { return fmt . errorf ( " " , current , err ) } } err : = update ( tx ) if err ! = nil { return fmt . errorf ( " " , current , err ) } current ++ err = insertschemaversion ( tx , current ) if err ! = nil { return fmt . errorf ( " " , current ) } } return nil } 
func checkschemaversionshavenoholes ( versions [ ] int ) error { for i : = range versions [ : len ( versions ) - 1 ] { if versions [ i + 1 ] ! = versions [ i ] + 1 { return fmt . errorf ( " " , versions [ i ] , versions [ i + 1 ] ) } } return nil } 
func checkallupdatesareapplied ( tx * sql . tx , updates [ ] update ) error { versions , err : = selectschemaversions ( tx ) if err ! = nil { return fmt . errorf ( " " , err ) } if len ( versions ) == 0 { return fmt . errorf ( " " ) } err = checkschemaversionshavenoholes ( versions ) if err ! = nil { return err } current : = versions [ len ( versions ) - 1 ] if current ! = len ( updates ) { return fmt . errorf ( " " , current , len ( updates ) ) } return nil } 
func formatsql ( statement string ) string { lines : = strings . split ( statement , " \n " ) for i , line : = range lines { if strings . contains ( line , " " ) { continue } lines [ i ] = strings . replace ( line , " " , " \n " , - 1 ) } return strings . join ( lines , " \n " ) } 
func getpathmode ( path string ) ( os . filemode , error ) { s , err : = os . open ( path ) if err ! = nil { return os . filemode ( 0000 ) , err } defer s . close ( ) fi , err : = s . stat ( ) if err ! = nil { return os . filemode ( 0000 ) , err } mode , , : = getownermode ( fi ) return mode , nil } 
func llistxattr ( path string , list [ ] byte ) ( sz int , err error ) { var p0 * byte p0 , err = syscall . byteptrfromstring ( path ) if err ! = nil { return } var p1 unsafe . pointer if len ( list ) > 0 { p1 = unsafe . pointer ( & list [ 0 ] ) } else { p1 = unsafe . pointer ( nil ) } r0 , , e1 : = syscall . syscall ( syscall . sys llistxattr , uintptr ( unsafe . pointer ( p0 ) ) , uintptr ( p1 ) , uintptr ( len ( list ) ) ) sz = int ( r0 ) if e1 ! = 0 { err = e1 } return } 
func getallxattr ( path string ) ( xattrs map [ string ] string , err error ) { e1 : = fmt . errorf ( " " ) pre , err : = llistxattr ( path , nil ) if err ! = nil | | pre < 0 { return nil , err } if pre == 0 { return nil , nil } dest : = make ( [ ] byte , pre ) post , err : = llistxattr ( path , dest ) if err ! = nil | | post < 0 { return nil , err } if post ! = pre { return nil , e1 } split : = strings . split ( string ( dest ) , " \ x00 " ) if split == nil { return nil , fmt . errorf ( " " ) } if split [ len ( split ) - 1 ] == " " { split = split [ : len ( split ) - 1 ] } xattrs = make ( map [ string ] string , len ( split ) ) for , x : = range split { xattr : = string ( x ) pre , err = syscall . getxattr ( path , xattr , nil ) if err ! = nil | | pre < 0 { return nil , err } dest = make ( [ ] byte , pre ) post : = 0 if pre > 0 { post , err = syscall . getxattr ( path , xattr , dest ) if err ! = nil | | post < 0 { return nil , err } } if post ! = pre { return nil , e1 } xattrs [ xattr ] = string ( dest ) } return xattrs , nil } 
func geterrno ( err error ) ( errno error , iserrno bool ) { syserr , ok : = err . ( * os . syscallerror ) if ok { return syserr . err , true } patherr , ok : = err . ( * os . patherror ) if ok { return patherr . err , true } tmperrno , ok : = err . ( syscall . errno ) if ok { return tmperrno , true } return nil , false } 
func uname ( ) ( * utsname , error ) { uname : = syscall . utsname { } err : = syscall . uname ( & uname ) if err ! = nil { return nil , err } return & utsname { sysname : intarraytostring ( uname . sysname ) , nodename : intarraytostring ( uname . nodename ) , release : intarraytostring ( uname . release ) , version : intarraytostring ( uname . version ) , machine : intarraytostring ( uname . machine ) , domainname : intarraytostring ( uname . domainname ) , } , nil } 
func registerstmt ( sql string ) int { code : = len ( stmts ) stmts [ code ] = sql return code } 
func preparestmts ( db * sql . db ) ( map [ int ] * sql . stmt , error ) { index : = map [ int ] * sql . stmt { } for code , sql : = range stmts { stmt , err : = db . prepare ( sql ) if err ! = nil { return nil , errors . wrapf ( err , " " , sql ) } index [ code ] = stmt } return index , nil } 
func ( g * gateway ) dialfunc ( ) dqlite . dialfunc { return func ( ctx context . context , address string ) ( net . conn , error ) { if g . memorydial ! = nil { return g . memorydial ( ctx , address ) } return dqlitenetworkdial ( ctx , address , g . cert ) } } 
func ( g * gateway ) shutdown ( ) error { logger . debugf ( " " ) if g . raft ! = nil { err : = g . raft . shutdown ( ) if err ! = nil { return errors . wrap ( err , " " ) } } if g . server ! = nil { g . sync ( ) g . server . close ( ) g . memorydial = nil } return nil } 
func ( g * gateway ) sync ( ) { if g . server == nil { return } dir : = filepath . join ( g . db . dir ( ) , " " ) err : = g . server . dump ( " " , dir ) if err ! = nil { logger . warnf ( " " , err ) } } 
func ( g * gateway ) reset ( cert * shared . certinfo ) error { err : = g . shutdown ( ) if err ! = nil { return err } err = os . removeall ( filepath . join ( g . db . dir ( ) , " " ) ) if err ! = nil { return err } err = g . db . transaction ( func ( tx * db . nodetx ) error { return tx . raftnodesreplace ( nil ) } ) if err ! = nil { return err } g . cert = cert return g . init ( ) } 
func ( g * gateway ) init ( ) error { logger . debugf ( " " ) raft , err : = newraft ( g . db , g . cert , g . options . latency ) if err ! = nil { return errors . wrap ( err , " " ) } if raft ! = nil { listener , err : = net . listen ( " " , " " ) if err ! = nil { return errors . wrap ( err , " " ) } if raft . handlerfunc ( ) == nil { g . memorydial = dqlitememorydial ( listener ) g . store . inmemory = dqlite . newinmemserverstore ( ) g . store . set ( context . background ( ) , [ ] dqlite . serverinfo { { address : " " } } ) } else { go rundqliteproxy ( listener , g . acceptch ) g . store . inmemory = nil } provider : = & raftaddressprovider { db : g . db } server , err : = dqlite . newserver ( raft . raft ( ) , raft . registry ( ) , listener , dqlite . withserveraddressprovider ( provider ) , dqlite . withserverlogfunc ( dqlitelog ) , ) if err ! = nil { return errors . wrap ( err , " " ) } g . server = server g . raft = raft } else { g . server = nil g . raft = nil g . store . inmemory = nil } g . store . ondisk = dqlite . newserverstore ( g . db . db ( ) , " " , " " , " " ) return nil } 
func ( g * gateway ) waitleadership ( ) error { n : = 80 sleep : = 250 * time . millisecond for i : = 0 ; i < n ; i ++ { if g . raft . raft . state ( ) == raft . leader { return nil } time . sleep ( sleep ) } return fmt . errorf ( " " , time . duration ( n ) * sleep ) } 
func ( g * gateway ) currentraftnodes ( ) ( [ ] db . raftnode , error ) { if g . raft == nil { return nil , raft . errnotleader } servers , err : = g . raft . servers ( ) if err ! = nil { return nil , err } provider : = raftaddressprovider { db : g . db } nodes : = make ( [ ] db . raftnode , len ( servers ) ) for i , server : = range servers { address , err : = provider . serveraddr ( server . id ) if err ! = nil { if err ! = db . errnosuchobject { return nil , errors . wrap ( err , " " ) } address = server . address } id , err : = strconv . atoi ( string ( server . id ) ) if err ! = nil { return nil , errors . wrap ( err , " " ) } nodes [ i ] . id = int64 ( id ) nodes [ i ] . address = string ( address ) } return nodes , nil } 
func ( g * gateway ) cachedraftnodes ( ) ( [ ] string , error ) { var addresses [ ] string err : = g . db . transaction ( func ( tx * db . nodetx ) error { var err error addresses , err = tx . raftnodeaddresses ( ) return err } ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return addresses , nil } 
func dqlitememorydial ( listener net . listener ) dqlite . dialfunc { return func ( ctx context . context , address string ) ( net . conn , error ) { return net . dial ( " " , listener . addr ( ) . string ( ) ) } } 
func dqlitelog ( l dqlite . loglevel , format string , a ... interface { } ) { format = fmt . sprintf ( " " , format ) switch l { case dqlite . logdebug : logger . debugf ( format , a ... ) case dqlite . loginfo : logger . debugf ( format , a ... ) case dqlite . logwarn : logger . warnf ( format , a ... ) case dqlite . logerror : logger . errorf ( format , a ... ) } } 
func ( r * response ) metadataasmap ( ) ( map [ string ] interface { } , error ) { ret : = map [ string ] interface { } { } err : = r . metadataasstruct ( & ret ) if err ! = nil { return nil , err } return ret , nil } 
func ( r * response ) metadataasoperation ( ) ( * operation , error ) { op : = operation { } err : = r . metadataasstruct ( & op ) if err ! = nil { return nil , err } return & op , nil } 
func ( r * response ) metadataasstringslice ( ) ( [ ] string , error ) { sl : = [ ] string { } err : = r . metadataasstruct ( & sl ) if err ! = nil { return nil , err } return sl , nil } 
func ( r * response ) metadataasstruct ( target interface { } ) error { return json . unmarshal ( r . metadata , & target ) } 
func ( r * csvreport ) load ( ) error { file , err : = os . open ( r . filename ) if err ! = nil { return err } defer file . close ( ) reader : = csv . newreader ( file ) for line : = 1 ; err ! = io . eof ; line ++ { record , err : = reader . read ( ) if err == io . eof { break } else if err ! = nil { return err } err = r . addrecord ( record ) if err ! = nil { return err } } logf ( " " , r . filename ) return nil } 
func ( r * csvreport ) write ( ) error { file , err : = os . openfile ( r . filename , os . o wronly | os . o create | os . o trunc , 0640 ) if err ! = nil { return err } defer file . close ( ) writer : = csv . newwriter ( file ) err = writer . writeall ( r . records ) if err ! = nil { return err } logf ( " " , r . filename ) return nil } 
func ( r * csvreport ) addrecord ( label string , elapsed time . duration ) error { if len ( r . records ) == 0 { r . addrecord ( csvfields ) } record : = [ ] string { fmt . sprintf ( " " , time . now ( ) . unixnano ( ) / int64 ( time . millisecond ) ) , fmt . sprintf ( " " , elapsed / time . millisecond ) , label , " " , " " , } return r . addrecord ( record ) } 
func loadconfig ( path string ) ( * config , error ) { content , err : = ioutil . readfile ( path ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } c : = newconfig ( filepath . dir ( path ) , false ) err = yaml . unmarshal ( content , & c ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } for k , r : = range c . remotes { if ! r . public && r . authtype == " " { r . authtype = " " c . remotes [ k ] = r } } if c . remotes == nil { c . remotes = make ( map [ string ] remote ) } for k , v : = range staticremotes { if c . remotes [ k ] . project ! = " " { v . project = c . remotes [ k ] . project } c . remotes [ k ] = v } images , ok : = c . remotes [ " " ] if ok && images . protocol ! = imagesremote . protocol && images . addr == imagesremote . addr { c . remotes [ " " ] = imagesremote c . saveconfig ( path ) } return c , nil } 
func ( c * config ) saveconfig ( path string ) error { conf : = config { } err : = shared . deepcopy ( c , & conf ) if err ! = nil { return fmt . errorf ( " " , err ) } for k : = range staticremotes { if k == " " { continue } delete ( conf . remotes , k ) } f , err : = os . create ( path ) if err ! = nil { return fmt . errorf ( " " , err ) } defer f . close ( ) data , err : = yaml . marshal ( conf ) if err ! = nil { return fmt . errorf ( " " , err ) } , err = f . write ( data ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( l chrootloader ) abs ( base string , name string ) string { return filepath . clean ( fmt . sprintf ( " " , l . path , name ) ) } 
func ( l chrootloader ) get ( path string ) ( io . reader , error ) { path , err : = filepath . evalsymlinks ( path ) if err ! = nil { return nil , err } basepath , err : = filepath . evalsymlinks ( l . path ) if err ! = nil { return nil , err } if ! strings . hasprefix ( path , basepath ) { return nil , fmt . errorf ( " " ) } buf , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } return bytes . newreader ( buf ) , nil } 
func ( c * config ) configpath ( paths ... string ) string { path : = [ ] string { c . configdir } path = append ( path , paths ... ) return filepath . join ( path ... ) } 
func ( c * config ) servercertpath ( remote string ) string { return c . configpath ( " " , fmt . sprintf ( " " , remote ) ) } 
func newconfig ( configdir string , defaults bool ) * config { config : = & config { configdir : configdir } if defaults { config . remotes = defaultremotes config . defaultremote = " " } return config } 
func ( s * migrationsourcews ) checkforpredumpsupport ( ) ( bool , int ) { criumigrationargs : = criumigrationargs { cmd : lxc . migrate feature check , statedir : " " , function : " " , stop : false , actionscript : false , dumpdir : " " , predumpdir : " " , features : lxc . feature mem track , } err : = s . container . migrate ( & criumigrationargs ) if err ! = nil { return false , 0 } use pre dumps : = true tmp : = s . container . expandedconfig ( ) [ " " ] if tmp ! = " " { use pre dumps = shared . istrue ( tmp ) } var max iterations int tmp = s . container . expandedconfig ( ) [ " " ] if tmp ! = " " { max iterations , = strconv . atoi ( tmp ) } else { max iterations = 10 } if max iterations > 999 { max iterations = 999 } logger . debugf ( " " , max iterations ) return use pre dumps , max iterations } 
func readcriustatsdump ( path string ) ( uint64 , uint64 , error ) { statsdump : = shared . addslash ( path ) + " " in , err : = ioutil . readfile ( statsdump ) if err ! = nil { logger . errorf ( " " , err . error ( ) ) return 0 , 0 , err } if binary . littleendian . uint32 ( in [ 0 : 4 ] ) ! = 1427134784 { msg : = " " logger . errorf ( msg ) return 0 , 0 , fmt . errorf ( msg ) } if binary . littleendian . uint32 ( in [ 4 : 8 ] ) ! = 1460220678 { msg : = " " logger . errorf ( msg ) return 0 , 0 , fmt . errorf ( msg ) } size : = binary . littleendian . uint32 ( in [ 8 : 12 ] ) statsentry : = & migration . statsentry { } if err = proto . unmarshal ( in [ 12 : 12 + size ] , statsentry ) ; err ! = nil { logger . errorf ( " " , err . error ( ) ) return 0 , 0 , err } written : = statsentry . getdump ( ) . getpageswritten ( ) skipped : = statsentry . getdump ( ) . getpagesskippedparent ( ) return written , skipped , nil } 
func ( r * protocolsimplestreams ) getconnectioninfo ( ) ( * connectioninfo , error ) { info : = connectioninfo { } info . addresses = [ ] string { r . httphost } info . certificate = r . httpcertificate info . protocol = " " info . url = r . httphost return & info , nil } 
func newroot ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , long : , rune : func ( cmd * cobra . command , args [ ] string ) error { return fmt . errorf ( " " ) } , } cmd . addcommand ( newdb ( ) ) return cmd } 
func apiextensionscount ( ) int { count : = len ( apiextensions ) artificialbump : = os . getenv ( " " ) if artificialbump ! = " " { n , err : = strconv . atoi ( artificialbump ) if err == nil { count += n } } return count } 
func dotgo ( updates map [ int ] update , name string ) error { db , err : = sql . open ( " " , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } schema : = newfrommap ( updates ) , err = schema . ensure ( db ) if err ! = nil { return err } dump , err : = schema . dump ( db ) if err ! = nil { return err } , filename , , : = runtime . caller ( 1 ) file , err : = os . create ( path . join ( path . dir ( filename ) , name + " " ) ) if err ! = nil { return fmt . errorf ( " " , err ) } pkg : = path . base ( path . dir ( filename ) ) , err = file . write ( [ ] byte ( fmt . sprintf ( dotgotemplate , pkg , dump ) ) ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func selecturis ( stmt * sql . stmt , f func ( a ... interface { } ) string , args ... interface { } ) ( [ ] string , error ) { rows , err : = stmt . query ( args ... ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } defer rows . close ( ) columns , err : = rows . columns ( ) if err ! = nil { return nil , errors . wrap ( err , " " ) } params : = make ( [ ] interface { } , len ( columns ) ) dest : = make ( [ ] interface { } , len ( params ) ) for i : = range params { params [ i ] = " " dest [ i ] = & params [ i ] } uris : = [ ] string { } for rows . next ( ) { err : = rows . scan ( dest ... ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } uri : = f ( params ... ) uris = append ( uris , uri ) } err = rows . err ( ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } return uris , nil } 
func selectstrings ( tx * sql . tx , query string , args ... interface { } ) ( [ ] string , error ) { values : = [ ] string { } scan : = func ( rows * sql . rows ) error { var value string err : = rows . scan ( & value ) if err ! = nil { return err } values = append ( values , value ) return nil } err : = scansinglecolumn ( tx , query , args , " " , scan ) if err ! = nil { return nil , err } return values , nil } 
func insertstrings ( tx * sql . tx , stmt string , values [ ] string ) error { n : = len ( values ) if n == 0 { return nil } params : = make ( [ ] string , n ) args : = make ( [ ] interface { } , n ) for i , value : = range values { params [ i ] = " " args [ i ] = value } stmt = fmt . sprintf ( stmt , strings . join ( params , " " ) ) , err : = tx . exec ( stmt , args ... ) return err } 
func scansinglecolumn ( tx * sql . tx , query string , args [ ] interface { } , typename string , scan scanfunc ) error { rows , err : = tx . query ( query , args ... ) if err ! = nil { return err } defer rows . close ( ) for rows . next ( ) { err : = scan ( rows ) if err ! = nil { return err } } err = rows . err ( ) if err ! = nil { return err } return nil } 
func callerstackhandler ( format string , h handler ) handler { return funchandler ( func ( r * record ) error { s : = stack . callers ( ) . trimbelow ( stack . call ( r . callpc [ 0 ] ) ) . trimruntime ( ) if len ( s ) > 0 { buf : = & bytes . buffer { } buf . writebyte ( ' [ ' ) for i , pc : = range s { if i > 0 { buf . writebyte ( ' ' ) } fmt . fprintf ( buf , format , pc ) } buf . writebyte ( ' ] ' ) r . ctx = append ( r . ctx , " " , buf . string ( ) ) } return h . log ( r ) } ) } 
func lazyhandler ( h handler ) handler { return funchandler ( func ( r * record ) error { haderr : = false for i : = 1 ; i < len ( r . ctx ) ; i += 2 { lz , ok : = r . ctx [ i ] . ( lazy ) if ok { v , err : = evaluatelazy ( lz ) if err ! = nil { haderr = true r . ctx [ i ] = err } else { if cs , ok : = v . ( stack . trace ) ; ok { v = cs . trimbelow ( stack . call ( r . callpc [ 0 ] ) ) . trimruntime ( ) } r . ctx [ i ] = v } } } if haderr { r . ctx = append ( r . ctx , errorkey , " " ) } return h . log ( r ) } ) } 
func callers ( ) trace { pcs : = poolbuf ( ) pcs = pcs [ : cap ( pcs ) ] n : = runtime . callers ( 2 , pcs ) cs : = make ( [ ] call , n ) for i , pc : = range pcs [ : n ] { cs [ i ] = call ( pc ) } putpoolbuf ( pcs ) return cs } 
func ( pc call ) name ( ) string { pcfix : = uintptr ( pc ) - 1 fn : = runtime . funcforpc ( pcfix ) if fn == nil { return " " } return fn . name ( ) } 
func ( pcs trace ) format ( s fmt . state , c rune ) { s . write ( [ ] byte ( " " ) ) for i , pc : = range pcs { if i > 0 { s . write ( [ ] byte ( " " ) ) } pc . format ( s , c ) } s . write ( [ ] byte ( " " ) ) } 
func ( pcs trace ) trimbelow ( pc call ) trace { for len ( pcs ) > 0 && pcs [ 0 ] ! = pc { pcs = pcs [ 1 : ] } return pcs } 
func ( pcs trace ) trimabove ( pc call ) trace { for len ( pcs ) > 0 && pcs [ len ( pcs ) - 1 ] ! = pc { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs } 
func ( pcs trace ) trimbelowname ( name string ) trace { for len ( pcs ) > 0 && pcs [ 0 ] . name ( ) ! = name { pcs = pcs [ 1 : ] } return pcs } 
func ( pcs trace ) trimabovename ( name string ) trace { for len ( pcs ) > 0 && pcs [ len ( pcs ) - 1 ] . name ( ) ! = name { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs } 
func ( pcs trace ) trimruntime ( ) trace { for len ( pcs ) > 0 && ingoroot ( pcs [ len ( pcs ) - 1 ] . file ( ) ) { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs } 
func shiftowner ( basepath string , path string , uid int , gid int ) error { cbasepath : = c . cstring ( basepath ) defer c . free ( unsafe . pointer ( cbasepath ) ) cpath : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cpath ) ) r : = c . shiftowner ( cbasepath , cpath , c . int ( uid ) , c . int ( gid ) ) if r ! = 0 { return fmt . errorf ( " " , path ) } return nil } 
func getcaps ( path string ) ( [ ] byte , error ) { xattrs , err : = shared . getallxattr ( path ) if err ! = nil { return nil , err } valuestr , ok : = xattrs [ " " ] if ! ok { return nil , nil } return [ ] byte ( valuestr ) , nil } 
func setcaps ( path string , caps [ ] byte , uid int64 ) error { cpath : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cpath ) ) ccaps : = c . cstring ( string ( caps ) ) defer c . free ( unsafe . pointer ( ccaps ) ) r : = c . set vfs ns caps ( cpath , ccaps , c . ssize t ( len ( caps ) ) , c . uint32 t ( uid ) ) if r ! = 0 { return fmt . errorf ( " " , path ) } return nil } 
func shiftacl ( path string , shiftids func ( uid int64 , gid int64 ) ( int64 , int64 ) ) error { err : = shiftacltype ( path , c . acl type access , shiftids ) if err ! = nil { return err } err = shiftacltype ( path , c . acl type default , shiftids ) if err ! = nil { return err } return nil } 
func ( pt * progressreader ) read ( p [ ] byte ) ( int , error ) { n , err : = pt . readcloser . read ( p ) if pt . tracker ! = nil { pt . tracker . total += int64 ( n ) pt . tracker . update ( n ) } return n , err } 
func supported ( path string ) ( bool , error ) { devpath , err : = devforpath ( path ) if err ! = nil { return false , err } cdevpath : = c . cstring ( devpath ) defer c . free ( unsafe . pointer ( cdevpath ) ) return c . quota supported ( cdevpath ) == 0 , nil } 
func getproject ( path string ) ( uint32 , error ) { cpath : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cpath ) ) id : = c . quota get path ( cpath ) if id < 0 { return 0 , fmt . errorf ( " " , path ) } return uint32 ( id ) , nil } 
func setproject ( path string , id uint32 ) error { cpath : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cpath ) ) if c . quota set path ( cpath , c . uint32 t ( id ) ) ! = 0 { return fmt . errorf ( " " , id , path ) } return nil } 
func deleteproject ( path string , id uint32 ) error { err : = setproject ( path , 0 ) if err ! = nil { return err } err = setprojectquota ( path , id , 0 ) if err ! = nil { return err } return nil } 
func getprojectusage ( path string , id uint32 ) ( int64 , error ) { devpath , err : = devforpath ( path ) if err ! = nil { return - 1 , err } cdevpath : = c . cstring ( devpath ) defer c . free ( unsafe . pointer ( cdevpath ) ) size : = c . quota get usage ( cdevpath , c . uint32 t ( id ) ) if size < 0 { return - 1 , fmt . errorf ( " " , id , path ) } return int64 ( size ) , nil } 
func setprojectquota ( path string , id uint32 , bytes int64 ) error { devpath , err : = devforpath ( path ) if err ! = nil { return err } cdevpath : = c . cstring ( devpath ) defer c . free ( unsafe . pointer ( cdevpath ) ) if c . quota set ( cdevpath , c . uint32 t ( id ) , c . int ( bytes / 1024 ) ) ! = 0 { return fmt . errorf ( " " , id , path ) } return nil } 
func backuploadbyname ( s * state . state , project , name string ) ( * backup , error ) { args , err : = s . cluster . containergetbackup ( project , name ) if err ! = nil { return nil , errors . wrap ( err , " " ) } c , err : = containerloadbyid ( s , args . containerid ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return & backup { state : s , container : c , id : args . id , name : name , creationdate : args . creationdate , expirydate : args . expirydate , containeronly : args . containeronly , optimizedstorage : args . optimizedstorage , } , nil } 
func backupcreate ( s * state . state , args db . containerbackupargs , sourcecontainer container ) error { err : = s . cluster . containerbackupcreate ( args ) if err ! = nil { if err == db . erralreadydefined { return fmt . errorf ( " " , args . name ) } return errors . wrap ( err , " " ) } b , err : = backuploadbyname ( s , sourcecontainer . project ( ) , args . name ) if err ! = nil { return errors . wrap ( err , " " ) } err = sourcecontainer . storage ( ) . containerbackupcreate ( * b , sourcecontainer ) if err ! = nil { s . cluster . containerbackupremove ( args . name ) return errors . wrap ( err , " " ) } return nil } 
func ( b * backup ) rename ( newname string ) error { oldbackuppath : = shared . varpath ( " " , b . name ) newbackuppath : = shared . varpath ( " " , newname ) backupspath : = shared . varpath ( " " , b . container . name ( ) ) if ! shared . pathexists ( backupspath ) { err : = os . mkdirall ( backupspath , 0700 ) if err ! = nil { return err } } err : = os . rename ( oldbackuppath , newbackuppath ) if err ! = nil { return err } empty , : = shared . pathisempty ( backupspath ) if empty { err : = os . remove ( backupspath ) if err ! = nil { return err } } err = b . state . cluster . containerbackuprename ( b . name , newname ) if err ! = nil { return err } return nil } 
func ( b * backup ) delete ( ) error { return dobackupdelete ( b . state , b . name , b . container . name ( ) ) } 
func count ( tx * sql . tx , table string , where string , args ... interface { } ) ( int , error ) { stmt : = fmt . sprintf ( " " , table ) if where ! = " " { stmt += fmt . sprintf ( " " , where ) } rows , err : = tx . query ( stmt , args ... ) if err ! = nil { return - 1 , err } defer rows . close ( ) if ! rows . next ( ) { return - 1 , fmt . errorf ( " " ) } var count int err = rows . scan ( & count ) if err ! = nil { return - 1 , fmt . errorf ( " " ) } if rows . next ( ) { return - 1 , fmt . errorf ( " " ) } err = rows . err ( ) if err ! = nil { return - 1 , err } return count , nil } 
func countall ( tx * sql . tx ) ( map [ string ] int , error ) { tables , err : = selectstrings ( tx , " " ) if err ! = nil { return nil , errors . wrap ( err , " " ) } counts : = map [ string ] int { } for , table : = range tables { count , err : = count ( tx , table , " " ) if err ! = nil { return nil , errors . wrapf ( err , " " , table ) } counts [ table ] = count } return counts , nil } 
func inittlsconfig ( ) * tls . config { return & tls . config { minversion : tls . versiontls12 , ciphersuites : [ ] uint16 { tls . tls ecdhe ecdsa with aes 256 gcm sha384 , tls . tls ecdhe ecdsa with aes 256 cbc sha , tls . tls ecdhe ecdsa with aes 128 gcm sha256 , tls . tls ecdhe ecdsa with aes 128 cbc sha , tls . tls ecdhe rsa with aes 256 gcm sha384 , tls . tls ecdhe rsa with aes 256 cbc sha , tls . tls ecdhe rsa with aes 128 gcm sha256 , tls . tls ecdhe rsa with aes 128 cbc sha , } , preferserverciphersuites : true , } } 
func ( s * storagelvm ) copycontainerthinpool ( target container , source container , readonly bool ) error { err : = s . createsnapshotcontainer ( target , source , readonly ) if err ! = nil { logger . errorf ( " " , err ) return err } lvfilesystem : = s . getlvmfilesystem ( ) poolname : = s . getondiskpoolname ( ) containername : = target . name ( ) containerlvmname : = containernametolvname ( containername ) containerlvdevpath : = getlvmdevpath ( target . project ( ) , poolname , storagepoolvolumeapiendpointcontainers , containerlvmname ) if lvfilesystem == " " { ourumount , err : = s . containerumount ( source , source . path ( ) ) if err ! = nil { return err } if ourumount { defer s . containermount ( source ) } } msg , err : = fsgeneratenewuuid ( lvfilesystem , containerlvdevpath ) if err ! = nil { logger . errorf ( " " " " " " " " , lvfilesystem , containername , s . pool . name , msg ) return err } return nil } 
func ( s * storagelvm ) copycontainer ( target container , source container , refresh bool ) error { targetpool , err : = target . storagepool ( ) if err ! = nil { return err } targetcontainermntpoint : = getcontainermountpoint ( target . project ( ) , targetpool , target . name ( ) ) err = createcontainermountpoint ( targetcontainermntpoint , target . path ( ) , target . isprivileged ( ) ) if err ! = nil { return err } sourcepool , err : = source . storagepool ( ) if err ! = nil { return err } if s . usethinpool && targetpool == sourcepool && ! refresh { err = s . copycontainerthinpool ( target , source , false ) } else { err = s . copycontainerlv ( target , source , false , refresh ) } if err ! = nil { return err } err = target . templateapply ( " " ) if err ! = nil { return err } return nil } 
func ( s * storagelvm ) copyvolume ( sourcepool string , source string ) error { targetmntpoint : = getstoragepoolvolumemountpoint ( s . pool . name , s . volume . name ) err : = os . mkdirall ( targetmntpoint , 0711 ) if err ! = nil { return err } if s . usethinpool && sourcepool == s . pool . name { err = s . copyvolumethinpool ( source , s . volume . name , false ) } else { err = s . copyvolumelv ( sourcepool , source , s . volume . name , false ) } if err ! = nil { return err } return nil } 
func ( r * protocolsimplestreams ) getimagefingerprints ( ) ( [ ] string , error ) { images , err : = r . ssclient . listimages ( ) if err ! = nil { return nil , err } fingerprints : = [ ] string { } for , img : = range images { fingerprints = append ( fingerprints , img . fingerprint ) } return fingerprints , nil } 
func ( r * protocolsimplestreams ) getimage ( fingerprint string ) ( * api . image , string , error ) { image , err : = r . ssclient . getimage ( fingerprint ) if err ! = nil { return nil , " " , err } return image , " " , err } 
func ( r * protocolsimplestreams ) getprivateimage ( fingerprint string , secret string ) ( * api . image , string , error ) { return nil , " " , fmt . errorf ( " " ) } 
func ( r * protocolsimplestreams ) getprivateimagefile ( fingerprint string , secret string , req imagefilerequest ) ( * imagefileresponse , error ) { return nil , fmt . errorf ( " " ) } 
func ( r * protocolsimplestreams ) getimagealiasnames ( ) ( [ ] string , error ) { aliases , err : = r . ssclient . listaliases ( ) if err ! = nil { return nil , err } names : = [ ] string { } for , alias : = range aliases { names = append ( names , alias . name ) } return names , nil } 
func ( r * protocolsimplestreams ) getimagealias ( name string ) ( * api . imagealiasesentry , string , error ) { alias , err : = r . ssclient . getalias ( name ) if err ! = nil { return nil , " " , err } return alias , " " , err } 
func protorecv ( ws * websocket . conn , msg proto . message ) error { mt , r , err : = ws . nextreader ( ) if err ! = nil { return err } if mt ! = websocket . binarymessage { return fmt . errorf ( " " ) } buf , err : = ioutil . readall ( r ) if err ! = nil { return err } err = proto . unmarshal ( buf , msg ) if err ! = nil { return err } return nil } 
func protosend ( ws * websocket . conn , msg proto . message ) error { w , err : = ws . nextwriter ( websocket . binarymessage ) if err ! = nil { return err } defer w . close ( ) data , err : = proto . marshal ( msg ) if err ! = nil { return err } err = shared . writeall ( w , data ) if err ! = nil { return err } return nil } 
func protosendcontrol ( ws * websocket . conn , err error ) { message : = " " if err ! = nil { message = err . error ( ) } msg : = migrationcontrol { success : proto . bool ( err == nil ) , message : proto . string ( message ) , } protosend ( ws , & msg ) } 
func importnodeassociation ( entity string , columns [ ] string , row [ ] interface { } , tx * sql . tx ) error { stmt : = fmt . sprintf ( " " , entity , entity ) var id int64 for i , column : = range columns { if column == " " { id = row [ i ] . ( int64 ) break } } if id == 0 { return fmt . errorf ( " " , entity ) } , err : = tx . exec ( stmt , id ) if err ! = nil { return errors . wrapf ( err , " " , entity ) } return nil } 
func ( er stdinmirror ) read ( p [ ] byte ) ( int , error ) { n , err : = er . r . read ( p ) v : = rune ( p [ 0 ] ) if v == ' \ u0001 ' && ! * er . foundescape { * er . foundescape = true return 0 , err } if v == ' q ' && * er . foundescape { select { case er . consoledisconnect < - true : return 0 , err default : return 0 , err } } * er . foundescape = false return n , err } 
func docontainersgetfromnode ( project , node string , cert * shared . certinfo ) ( [ ] api . container , error ) { f : = func ( ) ( [ ] api . container , error ) { client , err : = cluster . connect ( node , cert , true ) if err ! = nil { return nil , errors . wrapf ( err , " " , node ) } client = client . useproject ( project ) containers , err : = client . getcontainers ( ) if err ! = nil { return nil , errors . wrapf ( err , " " , node ) } return containers , nil } timeout : = time . after ( 30 * time . second ) done : = make ( chan struct { } ) var containers [ ] api . container var err error go func ( ) { containers , err = f ( ) done < - struct { } { } } ( ) select { case < - timeout : err = fmt . errorf ( " " , node ) case < - done : } return containers , err } 
func extractunderlyingfd ( unixconnptr * net . unixconn ) ( int , error ) { conn : = reflect . indirect ( reflect . valueof ( unixconnptr ) ) netfdptr : = conn . fieldbyname ( " " ) if ! netfdptr . isvalid ( ) { return - 1 , fmt . errorf ( " " ) } netfd : = reflect . indirect ( netfdptr ) fd : = netfd . fieldbyname ( " " ) if ! fd . isvalid ( ) { pfdptr : = netfd . fieldbyname ( " " ) if ! pfdptr . isvalid ( ) { return - 1 , fmt . errorf ( " " ) } pfd : = reflect . indirect ( pfdptr ) fd = pfd . fieldbyname ( " " ) if ! fd . isvalid ( ) { return - 1 , fmt . errorf ( " " ) } } return int ( fd . int ( ) ) , nil } 
func retry ( f func ( ) error ) error { var err error for i : = 0 ; i < 5 ; i ++ { err = f ( ) if err ! = nil { logger . debugf ( " " , err ) if isretriableerror ( err ) { logger . debugf ( " " , err ) time . sleep ( 250 * time . millisecond ) continue } } break } return err } 
func isretriableerror ( err error ) bool { err = errors . cause ( err ) if err == nil { return false } if err == sqlite3 . errlocked | | err == sqlite3 . errbusy { return true } if strings . contains ( err . error ( ) , " " ) { return true } if strings . contains ( err . error ( ) , " " ) { return true } if strings . contains ( err . error ( ) , " " ) { return true } return false } 
func storagepoolvolumeusedbyget ( s * state . state , project , volumename string , volumetypename string ) ( [ ] string , error ) { if volumetypename == " " { cname , sname , snap : = containergetparentandsnapshotname ( volumename ) if snap { return [ ] string { fmt . sprintf ( " " , version . apiversion , cname , sname ) } , nil } return [ ] string { fmt . sprintf ( " " , version . apiversion , cname ) } , nil } if volumetypename == " " { return [ ] string { fmt . sprintf ( " " , version . apiversion , volumename ) } , nil } ctsusingvolume , err : = storagepoolvolumeusedbycontainersget ( s , project , volumename , volumetypename ) if err ! = nil { return [ ] string { } , err } volumeusedby : = [ ] string { } for , ct : = range ctsusingvolume { volumeusedby = append ( volumeusedby , fmt . sprintf ( " " , version . apiversion , ct ) ) } profiles , err : = profilesusingpoolvolumegetnames ( s . cluster , volumename , volumetypename ) if err ! = nil { return [ ] string { } , err } if len ( volumeusedby ) == 0 && len ( profiles ) == 0 { return [ ] string { } , nil } for , pname : = range profiles { volumeusedby = append ( volumeusedby , fmt . sprintf ( " " , version . apiversion , pname ) ) } return volumeusedby , nil } 
func storagepoolvolumesnapshotsget ( s * state . state , pool string , volume string , voltype int ) ( [ ] string , error ) { poolid , err : = s . cluster . storagepoolgetid ( pool ) if err ! = nil { return nil , err } snapshots , err : = s . cluster . storagepoolvolumesnapshotsgettype ( volume , voltype , poolid ) if err ! = nil { return nil , err } return snapshots , nil } 
func apparmorprofile ( ) string { contents , err : = ioutil . readfile ( " " ) if err == nil { return strings . trimspace ( string ( contents ) ) } return " " } 
func getsnapshotsubvolumepath ( project , poolname string , containername string ) string { return shared . varpath ( " " , poolname , " " , projectprefix ( project , containername ) ) } 
func ( s * storagebtrfs ) storagepoolvolumecreate ( ) error { logger . infof ( " " " " " " , s . volume . name , s . pool . name ) , err : = s . storagepoolmount ( ) if err ! = nil { return err } issnapshot : = shared . issnapshot ( s . volume . name ) var customsubvolumepath string if issnapshot { customsubvolumepath = s . getcustomsnapshotsubvolumepath ( s . pool . name ) } else { customsubvolumepath = s . getcustomsubvolumepath ( s . pool . name ) } if ! shared . pathexists ( customsubvolumepath ) { err : = os . mkdirall ( customsubvolumepath , 0700 ) if err ! = nil { return err } } var customsubvolumename string if issnapshot { customsubvolumename = getstoragepoolvolumesnapshotmountpoint ( s . pool . name , s . volume . name ) } else { customsubvolumename = getstoragepoolvolumemountpoint ( s . pool . name , s . volume . name ) } err = btrfssubvolumecreate ( customsubvolumename ) if err ! = nil { return err } if s . volume . config [ " " ] ! = " " { size , err : = shared . parsebytesizestring ( s . volume . config [ " " ] ) if err ! = nil { return err } err = s . storageentitysetquota ( storagepoolvolumetypecustom , size , nil ) if err ! = nil { return err } } logger . infof ( " " " " " " , s . volume . name , s . pool . name ) return nil } 
func ( s * storagebtrfs ) containerstorageready ( container container ) bool { containermntpoint : = getcontainermountpoint ( container . project ( ) , s . pool . name , container . name ( ) ) return isbtrfssubvolume ( containermntpoint ) } 
func ( s * storagebtrfs ) containersnapshotrename ( snapshotcontainer container , newname string ) error { logger . debugf ( " " " " , s . volume . name , s . volume . name , newname ) , err : = s . storagepoolmount ( ) if err ! = nil { return err } oldsnapshotsubvolumename : = getsnapshotmountpoint ( snapshotcontainer . project ( ) , s . pool . name , snapshotcontainer . name ( ) ) newsnapshotsubvolumename : = getsnapshotmountpoint ( snapshotcontainer . project ( ) , s . pool . name , newname ) err = os . rename ( oldsnapshotsubvolumename , newsnapshotsubvolumename ) if err ! = nil { return err } logger . debugf ( " " " " , s . volume . name , s . volume . name , newname ) return nil } 
func ( s * storagebtrfs ) containersnapshotcreateempty ( snapshotcontainer container ) error { logger . debugf ( " " " " " " , s . volume . name , s . pool . name ) , err : = s . storagepoolmount ( ) if err ! = nil { return err } sourcename , , : = containergetparentandsnapshotname ( snapshotcontainer . name ( ) ) snapshotsubvolumepath : = getsnapshotsubvolumepath ( snapshotcontainer . project ( ) , s . pool . name , sourcename ) snapshotsubvolumename : = getsnapshotmountpoint ( snapshotcontainer . project ( ) , s . pool . name , snapshotcontainer . name ( ) ) if ! shared . pathexists ( snapshotsubvolumepath ) { err : = os . mkdirall ( snapshotsubvolumepath , containersdirmode ) if err ! = nil { return err } } err = btrfssubvolumecreate ( snapshotsubvolumename ) if err ! = nil { return err } snapshotmntpointsymlinktarget : = shared . varpath ( " " , s . pool . name , " " , projectprefix ( snapshotcontainer . project ( ) , sourcename ) ) snapshotmntpointsymlink : = shared . varpath ( " " , projectprefix ( snapshotcontainer . project ( ) , sourcename ) ) if ! shared . pathexists ( snapshotmntpointsymlink ) { err : = createcontainermountpoint ( snapshotmntpointsymlinktarget , snapshotmntpointsymlink , snapshotcontainer . isprivileged ( ) ) if err ! = nil { return err } } logger . debugf ( " " " " " " , s . volume . name , s . pool . name ) return nil } 
func btrfssubvolumesdelete ( subvol string ) error { subsubvols , err : = btrfssubvolumesget ( subvol ) if err ! = nil { return err } sort . sort ( sort . reverse ( sort . stringslice ( subsubvols ) ) ) for , subsubvol : = range subsubvols { err : = btrfssubvolumedelete ( path . join ( subvol , subsubvol ) ) if err ! = nil { return err } } err = btrfssubvolumedelete ( subvol ) if err ! = nil { return err } return nil } 
func btrfssnapshot ( source string , dest string , readonly bool ) error { var output string var err error if readonly { output , err = shared . runcommand ( " " , " " , " " , " " , source , dest ) } else { output , err = shared . runcommand ( " " , " " , " " , source , dest ) } if err ! = nil { return fmt . errorf ( " " , source , dest , output , ) } return err } 
func isbtrfssubvolume ( subvolpath string ) bool { fs : = syscall . stat t { } err : = syscall . lstat ( subvolpath , & fs ) if err ! = nil { return false } if fs . ino ! = 256 { return false } return true } 
func safeload ( schema schema , values map [ string ] string ) ( map , error ) { m , err : = load ( schema , values ) if err ! = nil { errors , ok : = err . ( errorlist ) if ! ok { return m , err } for , error : = range errors { message : = fmt . sprintf ( " " , error . reason ) logger . error ( message , log . ctx { " " : error . name } ) } } return m , nil } 
func selectconfig ( tx * sql . tx , table string , where string , args ... interface { } ) ( map [ string ] string , error ) { query : = fmt . sprintf ( " " , table ) if where ! = " " { query += fmt . sprintf ( " " , where ) } rows , err : = tx . query ( query , args ... ) if err ! = nil { return nil , err } defer rows . close ( ) values : = map [ string ] string { } for rows . next ( ) { var key string var value string err : = rows . scan ( & key , & value ) if err ! = nil { return nil , err } values [ key ] = value } err = rows . err ( ) if err ! = nil { return nil , err } return values , nil } 
func updateconfig ( tx * sql . tx , table string , values map [ string ] string ) error { changes : = map [ string ] string { } deletes : = [ ] string { } for key , value : = range values { if value == " " { deletes = append ( deletes , key ) continue } changes [ key ] = value } err : = upsertconfig ( tx , table , changes ) if err ! = nil { return errors . wrap ( err , " " ) } err = deleteconfig ( tx , table , deletes ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func upsertconfig ( tx * sql . tx , table string , values map [ string ] string ) error { if len ( values ) == 0 { return nil } query : = fmt . sprintf ( " " , table ) exprs : = [ ] string { } params : = [ ] interface { } { } for key , value : = range values { exprs = append ( exprs , " " ) params = append ( params , key ) params = append ( params , value ) } query += strings . join ( exprs , " " ) , err : = tx . exec ( query , params ... ) return err } 
func deleteconfig ( tx * sql . tx , table string , keys [ ] string ) error { n : = len ( keys ) if n == 0 { return nil } query : = fmt . sprintf ( " " , table , params ( n ) ) values : = make ( [ ] interface { } , n ) for i , key : = range keys { values [ i ] = key } , err : = tx . exec ( query , values ... ) return err } 
func formatsection ( header string , content string ) string { out : = " " if header ! = " " { out += header + " \n " } for , line : = range strings . split ( content , " \n " ) { if line ! = " " { out += " " } out += line + " \n " } if header ! = " " { out += " \n " } else { out = strings . trimsuffix ( out , " \n " ) } return out } 
func ( r * protocollxd ) getprojects ( ) ( [ ] api . project , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } projects : = [ ] api . project { } , err : = r . querystruct ( " " , " " , nil , " " , & projects ) if err ! = nil { return nil , err } return projects , nil } 
func ( r * protocollxd ) getproject ( name string ) ( * api . project , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } project : = api . project { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & project ) if err ! = nil { return nil , " " , err } return & project , etag , nil } 
func ( r * protocollxd ) createproject ( project api . projectspost ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , " " , project , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) updateproject ( name string , project api . projectput , etag string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , project , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) renameproject ( name string , project api . projectpost ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , project , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( er reader ) read ( p [ ] byte ) ( int , error ) { again : n , err : = er . reader . read ( p ) if err == nil { return n , nil } errno , ok : = shared . geterrno ( err ) if ok && ( errno == syscall . eagain | | errno == syscall . eintr ) { goto again } return n , err } 
func ( ew writer ) write ( p [ ] byte ) ( int , error ) { again : n , err : = ew . writer . write ( p ) if err == nil { return n , nil } errno , ok : = shared . geterrno ( err ) if ok && ( errno == syscall . eagain | | errno == syscall . eintr ) { goto again } return n , err } 
func newcanceler ( ) * canceler { c : = canceler { } c . lock . lock ( ) c . reqchcancel = make ( map [ * http . request ] chan struct { } ) c . lock . unlock ( ) return & c } 
func ( c * canceler ) cancelable ( ) bool { c . lock . lock ( ) length : = len ( c . reqchcancel ) c . lock . unlock ( ) return length > 0 } 
func ( c * canceler ) cancel ( ) error { if ! c . cancelable ( ) { return fmt . errorf ( " " ) } c . lock . lock ( ) for req , ch : = range c . reqchcancel { close ( ch ) delete ( c . reqchcancel , req ) } c . lock . unlock ( ) return nil } 
func clusterget ( d * daemon , r * http . request ) response { name : = " " err : = d . cluster . transaction ( func ( tx * db . clustertx ) error { var err error name , err = tx . nodename ( ) return err } ) if err ! = nil { return smarterror ( err ) } if name == " " { name = " " } memberconfig , err : = clustergetmemberconfig ( d . cluster ) if err ! = nil { return smarterror ( err ) } cluster : = api . cluster { servername : name , enabled : name ! = " " , memberconfig : memberconfig , } return syncresponseetag ( true , cluster , cluster ) } 
func clustergetmemberconfig ( cluster * db . cluster ) ( [ ] api . clustermemberconfigkey , error ) { var pools map [ string ] map [ string ] string var networks map [ string ] map [ string ] string keys : = [ ] api . clustermemberconfigkey { } err : = cluster . transaction ( func ( tx * db . clustertx ) error { var err error pools , err = tx . storagepoolsnodeconfig ( ) if err ! = nil { return errors . wrapf ( err , " " ) } networks , err = tx . networksnodeconfig ( ) if err ! = nil { return errors . wrapf ( err , " " ) } return nil } ) if err ! = nil { return nil , err } for pool , config : = range pools { for key : = range config { if strings . hasprefix ( key , " " ) { continue } key : = api . clustermemberconfigkey { entity : " " , name : pool , key : key , description : fmt . sprintf ( " " " " " " , key , pool ) , } keys = append ( keys , key ) } } for network , config : = range networks { for key : = range config { if strings . hasprefix ( key , " " ) { continue } key : = api . clustermemberconfigkey { entity : " " , name : network , key : key , description : fmt . sprintf ( " " " " " " , key , network ) , } keys = append ( keys , key ) } } return keys , nil } 
func clusterput ( d * daemon , r * http . request ) response { req : = api . clusterput { } err : = json . newdecoder ( r . body ) . decode ( & req ) if err ! = nil { return badrequest ( err ) } if req . servername == " " && req . enabled { return badrequest ( fmt . errorf ( " " ) ) } if req . servername ! = " " && ! req . enabled { return badrequest ( fmt . errorf ( " " ) ) } if ! req . enabled { return clusterputdisable ( d ) } if req . clusteraddress == " " { return clusterputbootstrap ( d , req ) } return clusterputjoin ( d , req ) } 
func clusterputdisable ( d * daemon ) response { err : = d . cluster . close ( ) if err ! = nil { return smarterror ( err ) } for , suffix : = range [ ] string { " " , " " , " " } { path : = filepath . join ( d . os . vardir , " " + suffix ) if ! shared . pathexists ( path ) { continue } err : = os . remove ( path ) if err ! = nil { return internalerror ( err ) } } cert , err : = util . loadcert ( d . os . vardir ) if err ! = nil { return internalerror ( errors . wrap ( err , " " ) ) } d . endpoints . networkupdatecert ( cert ) err = d . gateway . reset ( cert ) if err ! = nil { return smarterror ( err ) } address , err : = node . httpsaddress ( d . db ) if err ! = nil { return smarterror ( err ) } store : = d . gateway . serverstore ( ) d . cluster , err = db . opencluster ( " " , store , address , " " , d . config . dqlitesetuptimeout , dqlite . withdialfunc ( d . gateway . dialfunc ( ) ) , dqlite . withcontext ( d . gateway . context ( ) ) , ) if err ! = nil { return smarterror ( err ) } d . stopclustertasks ( ) version . useragentfeatures ( nil ) return emptysyncresponse } 
func clusteracceptmember ( client lxd . containerserver , name , address string , schema , apiext int , pools [ ] api . storagepool , networks [ ] api . network ) ( * internalclusterpostacceptresponse , error ) { req : = internalclusterpostacceptrequest { name : name , address : address , schema : schema , api : apiext , storagepools : pools , networks : networks , } info : = & internalclusterpostacceptresponse { } resp , , err : = client . rawquery ( " " , " " , req , " " ) if err ! = nil { return nil , err } err = resp . metadataasstruct ( & info ) if err ! = nil { return nil , err } return info , nil } 
func tryclusterrebalance ( d * daemon ) error { leader , err : = d . gateway . leaderaddress ( ) if err ! = nil { return errors . wrap ( err , " " ) } cert : = d . endpoints . networkcert ( ) client , err : = cluster . connect ( leader , cert , true ) if err ! = nil { return errors . wrap ( err , " " ) } , , err = client . rawquery ( " " , " " , nil , " " ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func internalclusterpostrebalance ( d * daemon , r * http . request ) response { localaddress , err : = node . clusteraddress ( d . db ) if err ! = nil { return smarterror ( err ) } leader , err : = d . gateway . leaderaddress ( ) if err ! = nil { return internalerror ( err ) } if localaddress ! = leader { logger . debugf ( " " , leader ) url : = & url . url { scheme : " " , path : " " , host : leader , } return syncresponseredirect ( url . string ( ) ) } logger . debugf ( " " ) address , nodes , err : = cluster . rebalance ( d . state ( ) , d . gateway ) if err ! = nil { return smarterror ( err ) } if address == " " { return syncresponse ( true , nil ) } post : = & internalclusterpostpromoterequest { } for , node : = range nodes { post . raftnodes = append ( post . raftnodes , internalraftnode { id : node . id , address : node . address , } ) } cert : = d . endpoints . networkcert ( ) client , err : = cluster . connect ( address , cert , false ) if err ! = nil { return smarterror ( err ) } , , err = client . rawquery ( " " , " " , post , " " ) if err ! = nil { return smarterror ( err ) } return syncresponse ( true , nil ) } 
func internalclusterpostpromote ( d * daemon , r * http . request ) response { req : = internalclusterpostpromoterequest { } err : = json . newdecoder ( r . body ) . decode ( & req ) if err ! = nil { return badrequest ( err ) } if len ( req . raftnodes ) == 0 { return badrequest ( fmt . errorf ( " " ) ) } nodes : = make ( [ ] db . raftnode , len ( req . raftnodes ) ) for i , node : = range req . raftnodes { nodes [ i ] . id = node . id nodes [ i ] . address = node . address } err = cluster . promote ( d . state ( ) , d . gateway , nodes ) if err ! = nil { return smarterror ( err ) } return syncresponse ( true , nil ) } 
func packages ( ) ( map [ string ] * ast . package , error ) { packages : = map [ string ] * ast . package { } for , name : = range defaultpackages { pkg , err : = lex . parse ( name ) if err ! = nil { return nil , errors . wrapf ( err , " " , name ) } parts : = strings . split ( name , " " ) packages [ parts [ len ( parts ) - 1 ] ] = pkg } return packages , nil } 
func filters ( pkg * ast . package , entity string ) [ ] [ ] string { objects : = pkg . scope . objects filters : = [ ] [ ] string { } prefix : = fmt . sprintf ( " " , entity ) for name : = range objects { if ! strings . hasprefix ( name , prefix ) { continue } rest : = name [ len ( prefix ) : ] filters = append ( filters , strings . split ( rest , " " ) ) } sort . slicestable ( filters , func ( i , j int ) bool { return len ( filters [ i ] ) > len ( filters [ j ] ) } ) return filters } 
func parse ( pkg * ast . package , name string ) ( * mapping , error ) { str : = findstruct ( pkg . scope , name ) if str == nil { return nil , fmt . errorf ( " " , name ) } fields , err : = parsestruct ( str ) if err ! = nil { return nil , errors . wrapf ( err , " " , name ) } m : = & mapping { package : pkg . name , name : name , fields : fields , } return m , nil } 
func findstruct ( scope * ast . scope , name string ) * ast . structtype { obj : = scope . lookup ( name ) if obj == nil { return nil } typ , ok : = obj . decl . ( * ast . typespec ) if ! ok { return nil } str , ok : = typ . type . ( * ast . structtype ) if ! ok { return nil } return str } 
func parsestruct ( str * ast . structtype ) ( [ ] * field , error ) { fields : = make ( [ ] * field , 0 ) for , f : = range str . fields . list { if len ( f . names ) == 0 { ident , ok : = f . type . ( * ast . ident ) if ! ok { continue } typ , ok : = ident . obj . decl . ( * ast . typespec ) if ! ok { continue } parentstr , ok : = typ . type . ( * ast . structtype ) if ! ok { continue } parentfields , err : = parsestruct ( parentstr ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } fields = append ( fields , parentfields ... ) continue } if len ( f . names ) ! = 1 { return nil , fmt . errorf ( " " , f . names ) } field , err : = parsefield ( f ) if err ! = nil { return nil , err } fields = append ( fields , field ) } return fields , nil } 
func ( r * protocollxd ) getprofilenames ( ) ( [ ] string , error ) { urls : = [ ] string { } , err : = r . querystruct ( " " , " " , nil , " " , & urls ) if err ! = nil { return nil , err } names : = [ ] string { } for , url : = range urls { fields : = strings . split ( url , " " ) names = append ( names , strings . split ( fields [ len ( fields ) - 1 ] , " " ) [ 0 ] ) } return names , nil } 
func ( r * protocollxd ) getprofiles ( ) ( [ ] api . profile , error ) { profiles : = [ ] api . profile { } , err : = r . querystruct ( " " , " " , nil , " " , & profiles ) if err ! = nil { return nil , err } return profiles , nil } 
func ( r * protocollxd ) getprofile ( name string ) ( * api . profile , string , error ) { profile : = api . profile { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & profile ) if err ! = nil { return nil , " " , err } return & profile , etag , nil } 
func ( r * protocollxd ) createprofile ( profile api . profilespost ) error { , , err : = r . query ( " " , " " , profile , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) updateprofile ( name string , profile api . profileput , etag string ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , profile , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) renameprofile ( name string , profile api . profilepost ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , profile , " " ) if err ! = nil { return err } return nil } 
func load ( schema schema , values map [ string ] string ) ( map , error ) { m : = map { schema : schema , } , err : = m . update ( values ) return m , err } 
func ( m * map ) change ( changes map [ string ] interface { } ) ( map [ string ] string , error ) { values : = make ( map [ string ] string , len ( m . schema ) ) errors : = errorlist { } for name , change : = range changes { key , ok : = m . schema [ name ] if ok && key . hidden && change == true { change = m . getraw ( name ) } if change == nil { change = " " } s : = reflect . valueof ( change ) if s . kind ( ) ! = reflect . string { errors . add ( name , nil , fmt . sprintf ( " " , s . kind ( ) ) ) continue } values [ name ] = change . ( string ) } if errors . len ( ) > 0 { return nil , errors } for name , key : = range m . schema { , ok : = values [ name ] if ! ok { values [ name ] = key . default } } names , err : = m . update ( values ) changed : = map [ string ] string { } for , name : = range names { changed [ name ] = m . getraw ( name ) } return changed , err } 
func ( m * map ) dump ( ) map [ string ] interface { } { values : = map [ string ] interface { } { } for name , key : = range m . schema { value : = m . getraw ( name ) if value ! = key . default { if key . hidden { values [ name ] = true } else { values [ name ] = value } } } return values } 
func ( m * map ) getraw ( name string ) string { key : = m . schema . mustgetkey ( name ) value , ok : = m . values [ name ] if ! ok { value = key . default } return value } 
func ( m * map ) getstring ( name string ) string { m . schema . assertkeytype ( name , string ) return m . getraw ( name ) } 
func ( m * map ) getbool ( name string ) bool { m . schema . assertkeytype ( name , bool ) return shared . istrue ( m . getraw ( name ) ) } 
func ( m * map ) getint64 ( name string ) int64 { m . schema . assertkeytype ( name , int64 ) n , err : = strconv . parseint ( m . getraw ( name ) , 10 , 64 ) if err ! = nil { panic ( fmt . sprintf ( " " , err ) ) } return n } 
func ( m * map ) update ( values map [ string ] string ) ( [ ] string , error ) { initial : = m . values == nil if initial { m . values = make ( map [ string ] string , len ( values ) ) } errors : = errorlist { } names : = [ ] string { } for name , value : = range values { changed , err : = m . set ( name , value , initial ) if err ! = nil { errors . add ( name , value , err . error ( ) ) continue } if changed { names = append ( names , name ) } } sort . strings ( names ) var err error if errors . len ( ) > 0 { errors . sort ( ) err = errors } return names , err } 
func ( m * map ) set ( name string , value string , initial bool ) ( bool , error ) { key , ok : = m . schema [ name ] if ! ok { return false , fmt . errorf ( " " ) } err : = key . validate ( value ) if err ! = nil { return false , err } current : = m . getraw ( name ) if key . type == bool { value = normalizebool ( value ) current = normalizebool ( current ) } if value == current { return false , nil } if ! initial && key . setter ! = nil { value , err = key . setter ( value ) if err ! = nil { return false , err } } if value == " " { delete ( m . values , name ) } else { m . values [ name ] = value } return true , nil } 
func doesschematableexist ( tx * sql . tx ) ( bool , error ) { statement : = rows , err : = tx . query ( statement ) if err ! = nil { return false , err } defer rows . close ( ) if ! rows . next ( ) { return false , fmt . errorf ( " " ) } var count int err = rows . scan ( & count ) if err ! = nil { return false , err } return count == 1 , nil } 
func selectschemaversions ( tx * sql . tx ) ( [ ] int , error ) { statement : = return query . selectintegers ( tx , statement ) } 
func selecttablessql ( tx * sql . tx ) ( [ ] string , error ) { statement : = return query . selectstrings ( tx , statement ) } 
func createschematable ( tx * sql . tx ) error { statement : = , err : = tx . exec ( statement ) return err } 
func insertschemaversion ( tx * sql . tx , new int ) error { statement : = , err : = tx . exec ( statement , new ) return err } 
func execfromfile ( tx * sql . tx , path string , hook hook ) error { if ! shared . pathexists ( path ) { return nil } bytes , err : = ioutil . readfile ( path ) if err ! = nil { return errors . wrap ( err , " " ) } if hook ! = nil { err : = hook ( - 1 , tx ) if err ! = nil { return errors . wrap ( err , " " ) } } , err = tx . exec ( string ( bytes ) ) if err ! = nil { return err } err = os . remove ( path ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func newstate ( node * db . node , cluster * db . cluster , maas * maas . controller , os * sys . os , endpoints * endpoints . endpoints ) * state { return & state { node : node , cluster : cluster , maas : maas , os : os , endpoints : endpoints , } } 
func containerlxcunload ( c * containerlxc ) { runtime . setfinalizer ( c , nil ) if c . c ! = nil { c . c . release ( ) c . c = nil } } 
func containerlxcinstantiate ( s * state . state , args db . containerargs ) * containerlxc { return & containerlxc { state : s , id : args . id , project : args . project , name : args . name , description : args . description , ephemeral : args . ephemeral , architecture : args . architecture , ctype : args . ctype , creationdate : args . creationdate , lastuseddate : args . lastuseddate , profiles : args . profiles , localconfig : args . config , localdevices : args . devices , stateful : args . stateful , node : args . node , expirydate : args . expirydate , } } 
func ( c * containerlxc ) initstorage ( ) error { if c . storage ! = nil { return nil } s , err : = storagepoolvolumecontainerloadinit ( c . state , c . project ( ) , c . name ( ) ) if err ! = nil { return err } c . storage = s return nil } 
func ( c * containerlxc ) setupunixdevice ( prefix string , dev types . device , major int , minor int , path string , createmustsucceed bool , defaultmode bool ) error { if c . iscurrentlyprivileged ( ) && ! c . state . os . runninginuserns && c . state . os . cgroupdevicescontroller { err : = lxcsetconfigitem ( c . c , " " , fmt . sprintf ( " " , major , minor ) ) if err ! = nil { return err } } temp : = types . device { } err : = shared . deepcopy ( & dev , & temp ) if err ! = nil { return err } temp [ " " ] = fmt . sprintf ( " " , major ) temp [ " " ] = fmt . sprintf ( " " , minor ) temp [ " " ] = path paths , err : = c . createunixdevice ( prefix , temp , defaultmode ) if err ! = nil { logger . debug ( " " , log . ctx { " " : err , " " : prefix } ) if createmustsucceed { return err } return nil } devpath : = shared . escapepathfstab ( paths [ 0 ] ) tgtpath : = shared . escapepathfstab ( paths [ 1 ] ) val : = fmt . sprintf ( " " , devpath , tgtpath ) return lxcsetconfigitem ( c . c , " " , val ) } 
func ( c * containerlxc ) onnetworkup ( devicename string , hostname string ) error { device : = c . expandeddevices [ devicename ] device [ " " ] = hostname return c . setuphostvethdevice ( device ) } 
func ( c * containerlxc ) setuphostvethdevice ( device types . device ) error { if device [ " " ] == " " { device [ " " ] = c . gethostinterface ( device [ " " ] ) } if device [ " " ] == " " { return fmt . errorf ( " " ) } err : = c . setnetworklimits ( device ) if err ! = nil { return err } err = c . setnetworkroutes ( device ) if err ! = nil { return err } return nil } 
func ( c * containerlxc ) freeze ( ) error { ctxmap : = log . ctx { " " : c . project , " " : c . name , " " : c . creationdate , " " : c . ephemeral , " " : c . lastuseddate } if ! c . isrunning ( ) { return fmt . errorf ( " " ) } if ! c . state . os . cgroupfreezercontroller { logger . info ( " " , ctxmap ) return nil } if c . isfrozen ( ) { return fmt . errorf ( " " ) } logger . info ( " " , ctxmap ) err : = c . initlxc ( false ) if err ! = nil { ctxmap [ " " ] = err logger . error ( " " , ctxmap ) return err } err = c . c . freeze ( ) if err ! = nil { ctxmap [ " " ] = err logger . error ( " " , ctxmap ) return err } logger . info ( " " , ctxmap ) eventsendlifecycle ( c . project , " " , fmt . sprintf ( " " , c . name ) , nil ) return err } 
func ( c * containerlxc ) getlxcstate ( ) ( lxc . state , error ) { if c . issnapshot ( ) { return lxc . statemap [ " " ] , nil } err : = c . initlxc ( false ) if err ! = nil { return lxc . statemap [ " " ] , err } monitor : = make ( chan lxc . state , 1 ) go func ( c * lxc . container ) { monitor < - c . state ( ) } ( c . c ) select { case state : = < - monitor : return state , nil case < - time . after ( 5 * time . second ) : return lxc . statemap [ " " ] , lxcmonitorstateerror } } 
func ( c * containerlxc ) storage ( ) storage { if c . storage == nil { c . initstorage ( ) } return c . storage } 
func ( c * containerlxc ) storagestartsensitive ( ) ( bool , error ) { err : = c . initstorage ( ) if err ! = nil { return false , err } var isouroperation bool if c . issnapshot ( ) { isouroperation , err = c . storage . containersnapshotstart ( c ) } else { isouroperation , err = c . storage . containermount ( c ) } return isouroperation , err } 
func ( c * containerlxc ) deviceexistsindevicesfolder ( prefix string , path string ) bool { relativedestpath : = strings . trimprefix ( path , " " ) devname : = fmt . sprintf ( " " , strings . replace ( prefix , " " , " " , - 1 ) , strings . replace ( relativedestpath , " " , " " , - 1 ) ) devpath : = filepath . join ( c . devicespath ( ) , devname ) return shared . pathexists ( devpath ) } 
func ( c * containerlxc ) setnetworkpriority ( ) error { if ! c . isrunning ( ) { return fmt . errorf ( " " ) } if ! c . state . os . cgroupnetpriocontroller { return nil } networkpriority : = c . expandedconfig [ " " ] if networkpriority == " " { networkpriority = " " } networkint , err : = strconv . atoi ( networkpriority ) if err ! = nil { return err } netifs , err : = net . interfaces ( ) if err ! = nil { return err } success : = false var last error error for , netif : = range netifs { err = c . cgroupset ( " " , fmt . sprintf ( " " , netif . name , networkint ) ) if err == nil { success = true } else { last error = err } } if ! success { return fmt . errorf ( " " , last error ) } return nil } 
func ( c * containerlxc ) path ( ) string { name : = projectprefix ( c . project ( ) , c . name ( ) ) return containerpath ( name , c . issnapshot ( ) ) } 
func ( c * containerlxc ) maasinterfaces ( ) ( [ ] maas . containerinterface , error ) { interfaces : = [ ] maas . containerinterface { } for k , m : = range c . expandeddevices { if m [ " " ] ! = " " { continue } if m [ " " ] == " " && m [ " " ] == " " { continue } m , err : = c . fillnetworkdevice ( k , m ) if err ! = nil { return nil , err } subnets : = [ ] maas . containerinterfacesubnet { } if m [ " " ] ! = " " { subnet : = maas . containerinterfacesubnet { name : m [ " " ] , address : m [ " " ] , } subnets = append ( subnets , subnet ) } if m [ " " ] ! = " " { subnet : = maas . containerinterfacesubnet { name : m [ " " ] , address : m [ " " ] , } subnets = append ( subnets , subnet ) } iface : = maas . containerinterface { name : m [ " " ] , macaddress : m [ " " ] , subnets : subnets , } interfaces = append ( interfaces , iface ) } return interfaces , nil } 
func getsystemhandler ( syslog string , debug bool , format log . format ) log . handler { if syslog ! = " " { if ! debug { return log . lvlfilterhandler ( log . lvlinfo , log . must . sysloghandler ( syslog , format ) , ) } return log . must . sysloghandler ( syslog , format ) } return nil } 
func findnvidiaminorold ( ) ( string , error ) { var minor string ents , err : = ioutil . readdir ( " " ) if err ! = nil { return " " , err } rp : = regexp . mustcompile ( " " ) for , ent : = range ents { matches : = rp . findstringsubmatch ( ent . name ( ) ) if matches == nil { continue } if minor ! = " " { return " " , fmt . errorf ( " " ) } minor = matches [ 1 ] } if minor == " " { return " " , fmt . errorf ( " " ) } return minor , nil } 
func findnvidiaminor ( pci string ) ( string , error ) { nvidiapath : = fmt . sprintf ( " " , pci ) buf , err : = ioutil . readfile ( nvidiapath ) if err ! = nil { return " " , err } strbuf : = strings . trimspace ( string ( buf ) ) idx : = strings . index ( strbuf , " " ) if idx ! = - 1 { idx += len ( " " ) strbuf = strbuf [ idx : ] strbuf = strings . trimspace ( strbuf ) parts : = strings . splitn ( strbuf , " \n " , 2 ) , err = strconv . atoi ( parts [ 0 ] ) if err == nil { return parts [ 0 ] , nil } } minor , err : = findnvidiaminorold ( ) if err == nil { return minor , nil } return " " , err } 
func setlogger ( newlogger logger . logger ) func ( ) { origlog : = logger . log logger . log = newlogger return func ( ) { logger . log = origlog } } 
func waitrecord ( ch chan * log . record , timeout time . duration ) * log . record { select { case record : = < - ch : return record case < - time . after ( timeout ) : return nil } } 
func addcontext ( logger logger . logger , ctx log . ctx ) logger . logger { log15logger , ok : = logger . ( log . logger ) if ! ok { logger . error ( " " , log . ctx { " " : log15logger , " " : ctx } ) return logger } return log15logger . new ( ctx ) } 
func newdottedversion ( versionstring string ) ( * dottedversion , error ) { formaterror : = fmt . errorf ( " " , versionstring ) split : = strings . split ( versionstring , " " ) if len ( split ) < 2 { return nil , formaterror } maj , err : = strconv . atoi ( split [ 0 ] ) if err ! = nil { return nil , formaterror } min , err : = strconv . atoi ( split [ 1 ] ) if err ! = nil { return nil , formaterror } patch : = - 1 if len ( split ) == 3 { patch , err = strconv . atoi ( split [ 2 ] ) if err ! = nil { return nil , formaterror } } return & dottedversion { major : maj , minor : min , patch : patch , } , nil } 
func parse ( s string ) ( * dottedversion , error ) { r , : = regexp . compile ( ' ^ ( [ 0 - 9 ] + . [ 0 - 9 ] + ( . [ 0 - 9 ] + ) ) ? . * ' ) matches : = r . findallstringsubmatch ( s , - 1 ) if len ( matches [ 0 ] ) < 2 { return nil , fmt . errorf ( " " ) } return newdottedversion ( matches [ 0 ] [ 1 ] ) } 
func ( v * dottedversion ) string ( ) string { version : = fmt . sprintf ( " " , v . major , v . minor ) if v . patch ! = - 1 { version += fmt . sprintf ( " " , v . patch ) } return version } 
func ( v * dottedversion ) compare ( other * dottedversion ) int { result : = compareints ( v . major , other . major ) if result ! = 0 { return result } result = compareints ( v . minor , other . minor ) if result ! = 0 { return result } return compareints ( v . patch , other . patch ) } 
func prepareloopdev ( source string , flags int ) ( * os . file , error ) { cloopdev : = c . malloc ( c . size t ( c . lo name size ) ) if cloopdev == nil { return nil , fmt . errorf ( " " ) } defer c . free ( cloopdev ) csource : = c . cstring ( source ) defer c . free ( unsafe . pointer ( csource ) ) loopfd , : = c . find associated loop device ( csource , ( * c . char ) ( cloopdev ) ) if loopfd >= 0 { return os . newfile ( uintptr ( loopfd ) , c . gostring ( ( * c . char ) ( cloopdev ) ) ) , nil } loopfd , err : = c . prepare loop dev retry ( csource , ( * c . char ) ( cloopdev ) , c . int ( flags ) ) if loopfd < 0 { if err ! = nil { return nil , errors . wrapf ( err , " " , source ) } return nil , fmt . errorf ( " " , source ) } return os . newfile ( uintptr ( loopfd ) , c . gostring ( ( * c . char ) ( cloopdev ) ) ) , nil } 
func projectcreatedefaultprofile ( tx * db . clustertx , project string ) error { profile : = db . profile { } profile . project = project profile . name = " " profile . description = fmt . sprintf ( " " , project ) profile . config = map [ string ] string { } profile . devices = types . devices { } , err : = tx . profilecreate ( profile ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func projectchange ( d * daemon , project * api . project , req api . projectput ) response { featureschanged : = req . config [ " " ] ! = project . config [ " " ] | | req . config [ " " ] ! = project . config [ " " ] if project . name == " " && featureschanged { return badrequest ( fmt . errorf ( " " ) ) } if ! projectisempty ( project ) && featureschanged { return badrequest ( fmt . errorf ( " " ) ) } err : = projectvalidateconfig ( req . config ) if err ! = nil { return badrequest ( err ) } err = d . cluster . transaction ( func ( tx * db . clustertx ) error { err : = tx . projectupdate ( project . name , req ) if err ! = nil { return errors . wrap ( err , " " ) } if req . config [ " " ] ! = project . config [ " " ] { if req . config [ " " ] == " " { err = projectcreatedefaultprofile ( tx , project . name ) if err ! = nil { return err } } else { err = tx . profiledelete ( project . name , " " ) if err ! = nil { return errors . wrap ( err , " " ) } } } return nil } ) if err ! = nil { return smarterror ( err ) } return emptysyncresponse } 
func projectisempty ( project * api . project ) bool { if len ( project . usedby ) > 0 { if len ( project . usedby ) == 1 && strings . contains ( project . usedby [ 0 ] , " " ) { return true } return false } return true } 
func projectprefix ( project string , s string ) string { if project ! = " " { s = fmt . sprintf ( " " , project , s ) } return s } 
func ( r * protocollxd ) getcertificatefingerprints ( ) ( [ ] string , error ) { certificates : = [ ] string { } , err : = r . querystruct ( " " , " " , nil , " " , & certificates ) if err ! = nil { return nil , err } fingerprints : = [ ] string { } for , fingerprint : = range certificates { fields : = strings . split ( fingerprint , " " ) fingerprints = append ( fingerprints , fields [ len ( fields ) - 1 ] ) } return fingerprints , nil } 
func ( r * protocollxd ) getcertificates ( ) ( [ ] api . certificate , error ) { certificates : = [ ] api . certificate { } , err : = r . querystruct ( " " , " " , nil , " " , & certificates ) if err ! = nil { return nil , err } return certificates , nil } 
func ( r * protocollxd ) getcertificate ( fingerprint string ) ( * api . certificate , string , error ) { certificate : = api . certificate { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) , nil , " " , & certificate ) if err ! = nil { return nil , " " , err } return & certificate , etag , nil } 
func ( r * protocollxd ) createcertificate ( certificate api . certificatespost ) error { , , err : = r . query ( " " , " " , certificate , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) updatecertificate ( fingerprint string , certificate api . certificateput , etag string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) , certificate , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) deletecertificate ( fingerprint string ) error { , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( fingerprint ) ) , nil , " " ) if err ! = nil { return err } return nil } 
func containermetadatatemplatespostput ( d * daemon , r * http . request ) response { project : = projectparam ( r ) name : = mux . vars ( r ) [ " " ] response , err : = forwardedresponseifcontainerisremote ( d , r , project , name ) if err ! = nil { return smarterror ( err ) } if response ! = nil { return response } c , err : = containerloadbyprojectandname ( d . state ( ) , project , name ) if err ! = nil { return smarterror ( err ) } ourstart , err : = c . storagestart ( ) if err ! = nil { return smarterror ( err ) } if ourstart { defer c . storagestop ( ) } templatename : = r . formvalue ( " " ) if templatename == " " { return badrequest ( fmt . errorf ( " " ) ) } templatepath , err : = getcontainertemplatepath ( c , templatename ) if err ! = nil { return smarterror ( err ) } if r . method == " " && shared . pathexists ( templatepath ) { return badrequest ( fmt . errorf ( " " ) ) } template , err : = os . openfile ( templatepath , os . o wronly | os . o create | os . o trunc , 0644 ) if err ! = nil { return smarterror ( err ) } defer template . close ( ) , err = io . copy ( template , r . body ) if err ! = nil { return internalerror ( err ) } return emptysyncresponse } 
func containermetadatatemplatesdelete ( d * daemon , r * http . request ) response { project : = projectparam ( r ) name : = mux . vars ( r ) [ " " ] response , err : = forwardedresponseifcontainerisremote ( d , r , project , name ) if err ! = nil { return smarterror ( err ) } if response ! = nil { return response } c , err : = containerloadbyprojectandname ( d . state ( ) , project , name ) if err ! = nil { return smarterror ( err ) } ourstart , err : = c . storagestart ( ) if err ! = nil { return smarterror ( err ) } if ourstart { defer c . storagestop ( ) } templatename : = r . formvalue ( " " ) if templatename == " " { return badrequest ( fmt . errorf ( " " ) ) } templatepath , err : = getcontainertemplatepath ( c , templatename ) if err ! = nil { return smarterror ( err ) } if ! shared . pathexists ( templatepath ) { return notfound ( fmt . errorf ( " " , templatepath ) ) } err = os . remove ( templatepath ) if err ! = nil { return internalerror ( err ) } return emptysyncresponse } 
func getcontainertemplatepath ( c container , filename string ) ( string , error ) { if strings . contains ( filename , " " ) { return " " , fmt . errorf ( " " ) } return filepath . join ( c . path ( ) , " " , filename ) , nil } 
func ( e error ) error ( ) string { message : = fmt . sprintf ( " " , e . name ) if e . value ! = nil { message += fmt . sprintf ( " " , e . value ) } return message + fmt . sprintf ( " " , e . reason ) } 
func ( l errorlist ) error ( ) string { switch len ( l ) { case 0 : return " " case 1 : return l [ 0 ] . error ( ) } return fmt . sprintf ( " " , l [ 0 ] , len ( l ) - 1 ) } 
func ( l * errorlist ) add ( name string , value interface { } , reason string ) { * l = append ( * l , & error { name , value , reason } ) } 
func updateschema ( ) error { err : = cluster . schemadotgo ( ) if err ! = nil { return errors . wrap ( err , " " ) } err = node . schemadotgo ( ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func doprofileupdatecluster ( d * daemon , project , name string , old api . profileput ) error { nodename : = " " err : = d . cluster . transaction ( func ( tx * db . clustertx ) error { var err error nodename , err = tx . nodename ( ) return err } ) if err ! = nil { return errors . wrap ( err , " " ) } containers , err : = getprofilecontainersinfo ( d . cluster , project , name ) if err ! = nil { return errors . wrapf ( err , " " , name ) } failures : = map [ string ] error { } for , args : = range containers { err : = doprofileupdatecontainer ( d , name , old , nodename , args ) if err ! = nil { failures [ args . name ] = err } } if len ( failures ) ! = 0 { msg : = " \n " for cname , err : = range failures { msg += fmt . sprintf ( " \n " , cname , err ) } return fmt . errorf ( " " , msg ) } return nil } 
func doprofileupdatecontainer ( d * daemon , name string , old api . profileput , nodename string , args db . containerargs ) error { if args . node ! = " " && args . node ! = nodename { return nil } profiles , err : = d . cluster . profilesget ( args . project , args . profiles ) if err ! = nil { return err } for i , profilename : = range args . profiles { if profilename == name { profiles [ i ] . config = old . config profiles [ i ] . devices = old . devices break } } c : = containerlxcinstantiate ( d . state ( ) , args ) c . expandconfig ( profiles ) c . expanddevices ( profiles ) return c . update ( db . containerargs { architecture : c . architecture ( ) , config : c . localconfig ( ) , description : c . description ( ) , devices : c . localdevices ( ) , ephemeral : c . isephemeral ( ) , profiles : c . profiles ( ) , project : c . project ( ) , } , true ) } 
func getprofilecontainersinfo ( cluster * db . cluster , project , profile string ) ( [ ] db . containerargs , error ) { names , err : = cluster . profilecontainersget ( project , profile ) if err ! = nil { return nil , errors . wrapf ( err , " " , profile ) } containers : = [ ] db . containerargs { } err = cluster . transaction ( func ( tx * db . clustertx ) error { for ctproject , ctnames : = range names { for , ctname : = range ctnames { container , err : = tx . containerget ( ctproject , ctname ) if err ! = nil { return err } containers = append ( containers , db . containertoargs ( container ) ) } } return nil } ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } return containers , nil } 
func cancelablewait ( rawop interface { } , progress * progressrenderer ) error { var op lxd . operation var rop lxd . remoteoperation switch v : = rawop . ( type ) { case lxd . operation : op = v case lxd . remoteoperation : rop = v default : return fmt . errorf ( " " ) } chsignal : = make ( chan os . signal ) signal . notify ( chsignal , os . interrupt ) choperation : = make ( chan error ) go func ( ) { if op ! = nil { choperation < - op . wait ( ) } else { choperation < - rop . wait ( ) } close ( choperation ) } ( ) count : = 0 for { var err error select { case err : = < - choperation : return err case < - chsignal : if op ! = nil { err = op . cancel ( ) } else { err = rop . canceltarget ( ) } if err == nil { return fmt . errorf ( i18n . g ( " " ) ) } count ++ if count == 3 { return fmt . errorf ( i18n . g ( " " ) ) } if progress ! = nil { progress . warn ( fmt . sprintf ( i18n . g ( " " ) , err ) , time . second * 5 ) } } } } 
func ( r * protocollxd ) getnetworknames ( ) ( [ ] string , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } urls : = [ ] string { } , err : = r . querystruct ( " " , " " , nil , " " , & urls ) if err ! = nil { return nil , err } names : = [ ] string { } for , url : = range urls { fields : = strings . split ( url , " " ) names = append ( names , fields [ len ( fields ) - 1 ] ) } return names , nil } 
func ( r * protocollxd ) getnetworks ( ) ( [ ] api . network , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } networks : = [ ] api . network { } , err : = r . querystruct ( " " , " " , nil , " " , & networks ) if err ! = nil { return nil , err } return networks , nil } 
func ( r * protocollxd ) getnetwork ( name string ) ( * api . network , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } network : = api . network { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & network ) if err ! = nil { return nil , " " , err } return & network , etag , nil } 
func ( r * protocollxd ) getnetworkleases ( name string ) ( [ ] api . networklease , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } leases : = [ ] api . networklease { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & leases ) if err ! = nil { return nil , err } return leases , nil } 
func ( r * protocollxd ) getnetworkstate ( name string ) ( * api . networkstate , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } state : = api . networkstate { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & state ) if err ! = nil { return nil , err } return & state , nil } 
func ( r * protocollxd ) createnetwork ( network api . networkspost ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , " " , network , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) updatenetwork ( name string , network api . networkput , etag string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , network , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) renamenetwork ( name string , network api . networkpost ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , network , " " ) if err ! = nil { return err } return nil } 
func open ( name string , store dqlite . serverstore , options ... dqlite . driveroption ) ( * sql . db , error ) { driver , err : = dqlite . newdriver ( store , options ... ) if err ! = nil { return nil , errors . wrap ( err , " " ) } drivername : = dqlitedrivername ( ) sql . register ( drivername , driver ) if name == " " { name = " " } db , err : = sql . open ( drivername , name ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return db , nil } 
func urlencode ( path string , query map [ string ] string ) ( string , error ) { u , err : = url . parse ( path ) if err ! = nil { return " " , err } params : = url . values { } for key , value : = range query { params . add ( key , value ) } u . rawquery = params . encode ( ) return u . string ( ) , nil } 
func isunixsocket ( path string ) bool { stat , err : = os . stat ( path ) if err ! = nil { return false } return ( stat . mode ( ) & os . modesocket ) == os . modesocket } 
func hostpath ( path string ) string { if len ( path ) == 0 { return path } if path == " " { return path } snap : = os . getenv ( " " ) snapname : = os . getenv ( " " ) if snap == " " | | snapname ! = " " { return path } if path [ 0 ] ! = os . pathseparator { ppid : = os . getppid ( ) if ppid < 1 { return path } pwd , err : = os . readlink ( fmt . sprintf ( " " , ppid ) ) if err ! = nil { return path } path = filepath . clean ( strings . join ( [ ] string { pwd , path } , string ( os . pathseparator ) ) ) } for , prefix : = range [ ] string { " " , " " , " " , " " } { if path == prefix | | strings . hasprefix ( path , fmt . sprintf ( " " , prefix ) ) { return path } } return fmt . sprintf ( " " , path ) } 
func varpath ( path ... string ) string { vardir : = os . getenv ( " " ) if vardir == " " { vardir = " " } items : = [ ] string { vardir } items = append ( items , path ... ) return filepath . join ( items ... ) } 
func cachepath ( path ... string ) string { vardir : = os . getenv ( " " ) logdir : = " " if vardir ! = " " { logdir = filepath . join ( vardir , " " ) } items : = [ ] string { logdir } items = append ( items , path ... ) return filepath . join ( items ... ) } 
func randomcryptostring ( ) ( string , error ) { buf : = make ( [ ] byte , 32 ) n , err : = rand . read ( buf ) if err ! = nil { return " " , err } if n ! = len ( buf ) { return " " , fmt . errorf ( " " ) } return hex . encodetostring ( buf ) , nil } 
func filemove ( oldpath string , newpath string ) error { err : = os . rename ( oldpath , newpath ) if err == nil { return nil } err = filecopy ( oldpath , newpath ) if err ! = nil { return err } os . remove ( oldpath ) return nil } 
func filecopy ( source string , dest string ) error { s , err : = os . open ( source ) if err ! = nil { return err } defer s . close ( ) fi , err : = s . stat ( ) if err ! = nil { return err } d , err : = os . create ( dest ) if err ! = nil { if os . isexist ( err ) { d , err = os . openfile ( dest , os . o wronly , fi . mode ( ) ) if err ! = nil { return err } } else { return err } } defer d . close ( ) , err = io . copy ( d , s ) if err ! = nil { return err } / * chown not supported on windows * / if runtime . goos ! = " " { , uid , gid : = getownermode ( fi ) return d . chown ( uid , gid ) } return nil } 
func dircopy ( source string , dest string ) error { info , err : = os . stat ( source ) if err ! = nil { return errors . wrapf ( err , " " ) } if ! info . isdir ( ) { return fmt . errorf ( " " ) } if pathexists ( dest ) { err : = os . removeall ( dest ) if err ! = nil { return errors . wrapf ( err , " " , dest ) } } err = os . mkdirall ( dest , info . mode ( ) ) if err ! = nil { return errors . wrapf ( err , " " , dest ) } entries , err : = ioutil . readdir ( source ) if err ! = nil { return errors . wrapf ( err , " " , source ) } for , entry : = range entries { sourcepath : = filepath . join ( source , entry . name ( ) ) destpath : = filepath . join ( dest , entry . name ( ) ) if entry . isdir ( ) { err : = dircopy ( sourcepath , destpath ) if err ! = nil { return errors . wrapf ( err , " " , sourcepath , destpath ) } } else { err : = filecopy ( sourcepath , destpath ) if err ! = nil { return errors . wrapf ( err , " " , sourcepath , destpath ) } } } return nil } 
func stringmaphasstringkey ( m map [ string ] string , keys ... string ) bool { for , k : = range keys { if , ok : = m [ k ] ; ok { return true } } return false } 
func deepcopy ( src , dest interface { } ) error { buff : = new ( bytes . buffer ) enc : = gob . newencoder ( buff ) dec : = gob . newdecoder ( buff ) if err : = enc . encode ( src ) ; err ! = nil { return err } if err : = dec . decode ( dest ) ; err ! = nil { return err } return nil } 
func removeduplicatesfromstring ( s string , sep string ) string { dup : = sep + sep for s = strings . replace ( s , dup , sep , - 1 ) ; strings . contains ( s , dup ) ; s = strings . replace ( s , dup , sep , - 1 ) { } return s } 
func writetempfile ( dir string , prefix string , content string ) ( string , error ) { f , err : = ioutil . tempfile ( dir , prefix ) if err ! = nil { return " " , err } defer f . close ( ) , err = f . writestring ( content ) return f . name ( ) , err } 
func escapepathfstab ( path string ) string { r : = strings . newreplacer ( " " , " \ \ " , " \ t " , " \ \ " , " \n " , " \ \ " , " \ \ " , " \ \ \ \ " ) return r . replace ( path ) } 
func rendertemplate ( template string , ctx pongo2 . context ) ( string , error ) { tpl , err : = pongo2 . fromstring ( " " + template + " " ) if err ! = nil { return " " , err } ret , err : = tpl . execute ( ctx ) if err ! = nil { return ret , err } if strings . contains ( ret , " " ) | | strings . contains ( ret , " " ) { return rendertemplate ( ret , ctx ) } return ret , err } 
func every ( interval time . duration , options ... everyoption ) schedule { every : = & every { } for , option : = range options { option ( every ) } first : = true return func ( ) ( time . duration , error ) { var err error if first && every . skipfirst { err = errskip } first = false return interval , err } } 
func ( s * storagelvm ) storagecoreinit ( ) error { s . stype = storagetypelvm typename , err : = storagetypetostring ( s . stype ) if err ! = nil { return err } s . stypename = typename if lvmversion ! = " " { s . stypeversion = lvmversion return nil } output , err : = shared . runcommand ( " " , " " ) if err ! = nil { return fmt . errorf ( " \n " , err , output ) } lines : = strings . split ( output , " \n " ) s . stypeversion = " " for idx , line : = range lines { fields : = strings . splitaftern ( line , " " , 2 ) if len ( fields ) < 2 { continue } if idx > 0 { s . stypeversion += " " } s . stypeversion += strings . trimspace ( fields [ 1 ] ) } lvmversion = s . stypeversion return nil } 
func ( s * storagelvm ) storagepoolmount ( ) ( bool , error ) { source : = s . pool . config [ " " ] if source == " " { return false , fmt . errorf ( " " " " ) } if ! filepath . isabs ( source ) { return true , nil } poolmountlockid : = getpoolmountlockid ( s . pool . name ) lxdstoragemaplock . lock ( ) if waitchannel , ok : = lxdstorageongoingoperationmap [ poolmountlockid ] ; ok { lxdstoragemaplock . unlock ( ) if , ok : = < - waitchannel ; ok { logger . warnf ( " " ) } return false , nil } lxdstorageongoingoperationmap [ poolmountlockid ] = make ( chan bool ) lxdstoragemaplock . unlock ( ) removelockfrommap : = func ( ) { lxdstoragemaplock . lock ( ) if waitchannel , ok : = lxdstorageongoingoperationmap [ poolmountlockid ] ; ok { close ( waitchannel ) delete ( lxdstorageongoingoperationmap , poolmountlockid ) } lxdstoragemaplock . unlock ( ) } defer removelockfrommap ( ) if filepath . isabs ( source ) && ! shared . isblockdevpath ( source ) { loopf , looperr : = prepareloopdev ( source , 0 ) if looperr ! = nil { return false , looperr } looperr = unsetautoclearonloopdev ( int ( loopf . fd ( ) ) ) if looperr ! = nil { return false , looperr } s . loopinfo = loopf } return true , nil } 
func dump ( tx * sql . tx , schema string , schemaonly bool ) ( string , error ) { schemas : = dumpparseschema ( schema ) dump : = tabledump , err : = dumptable ( tx , " " , dumpschematable ) if err ! = nil { return " " , errors . wrapf ( err , " " ) } dump += tabledump tables : = make ( [ ] string , 0 ) for table : = range schemas { tables = append ( tables , table ) } sort . strings ( tables ) for , table : = range tables { if schemaonly { dump += schemas [ table ] + " \n " continue } tabledump , err : = dumptable ( tx , table , schemas [ table ] ) if err ! = nil { return " " , errors . wrapf ( err , " " , table ) } dump += tabledump } if ! schemaonly { tabledump , err = dumptable ( tx , " " , " " ) if err ! = nil { return " " , errors . wrapf ( err , " " ) } dump += tabledump } dump += " \n " return dump , nil } 
func dumpparseschema ( schema string ) map [ string ] string { tables : = map [ string ] string { } for , statement : = range strings . split ( schema , " " ) { statement = strings . trim ( statement , " \n " ) + " " if ! strings . hasprefix ( statement , " " ) { continue } table : = strings . split ( statement , " " ) [ 2 ] tables [ table ] = statement } return tables } 
func ( c * clustertx ) projecthasprofiles ( name string ) ( bool , error ) { return projecthasprofiles ( c . tx , name ) } 
func ( c * clustertx ) projectnames ( ) ( [ ] string , error ) { stmt : = " " names , err : = query . selectstrings ( c . tx , stmt ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return names , nil } 
func ( c * clustertx ) projectmap ( ) ( map [ int64 ] string , error ) { stmt : = " " rows , err : = c . tx . query ( stmt ) if err ! = nil { return nil , err } defer rows . close ( ) result : = map [ int64 ] string { } for i : = 0 ; rows . next ( ) ; i ++ { var id int64 var name string err : = rows . scan ( & id , & name ) if err ! = nil { return nil , err } result [ id ] = name } err = rows . err ( ) if err ! = nil { return nil , err } return result , nil } 
func ( c * clustertx ) projecthasimages ( name string ) ( bool , error ) { project , err : = c . projectget ( name ) if err ! = nil { return false , errors . wrap ( err , " " ) } enabled : = project . config [ " " ] == " " return enabled , nil } 
func ( c * clustertx ) projectupdate ( name string , object api . projectput ) error { stmt : = c . stmt ( projectupdate ) result , err : = stmt . exec ( object . description , name ) if err ! = nil { return errors . wrap ( err , " " ) } n , err : = result . rowsaffected ( ) if err ! = nil { return errors . wrap ( err , " " ) } if n ! = 1 { return fmt . errorf ( " " , n ) } id , err : = c . projectid ( name ) if err ! = nil { return errors . wrap ( err , " " ) } , err = c . tx . exec ( , id ) if err ! = nil { return errors . wrap ( err , " " ) } stmt = c . stmt ( projectcreateconfigref ) for key , value : = range object . config { , err : = stmt . exec ( id , key , value ) if err ! = nil { return errors . wrap ( err , " " ) } } return nil } 
func ( r * protocollxd ) getcluster ( ) ( * api . cluster , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } cluster : = & api . cluster { } etag , err : = r . querystruct ( " " , " " , nil , " " , & cluster ) if err ! = nil { return nil , " " , err } return cluster , etag , nil } 
func ( r * protocollxd ) updatecluster ( cluster api . clusterput , etag string ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } if cluster . serveraddress ! = " " | | cluster . clusterpassword ! = " " | | len ( cluster . memberconfig ) > 0 { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } } op , , err : = r . queryoperation ( " " , " " , cluster , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) deleteclustermember ( name string , force bool ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } params : = " " if force { params += " " } , err : = r . querystruct ( " " , fmt . sprintf ( " " , name , params ) , nil , " " , nil ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) getclustermembernames ( ) ( [ ] string , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } urls : = [ ] string { } , err : = r . querystruct ( " " , " " , nil , " " , & urls ) if err ! = nil { return nil , err } return urls , nil } 
func ( r * protocollxd ) getclustermembers ( ) ( [ ] api . clustermember , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } members : = [ ] api . clustermember { } , err : = r . querystruct ( " " , " " , nil , " " , & members ) if err ! = nil { return nil , err } return members , nil } 
func ( r * protocollxd ) getclustermember ( name string ) ( * api . clustermember , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } member : = api . clustermember { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , name ) , nil , " " , & member ) if err ! = nil { return nil , " " , err } return & member , etag , nil } 
func ( r * protocollxd ) renameclustermember ( name string , member api . clustermemberpost ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , name ) , member , " " ) if err ! = nil { return err } return nil } 
func getstate ( fd int ) ( * state , error ) { state , err : = terminal . getstate ( fd ) if err ! = nil { return nil , err } currentstate : = state ( * state ) return & currentstate , nil } 
func makeraw ( fd int ) ( * state , error ) { state , err : = terminal . makeraw ( fd ) if err ! = nil { return nil , err } oldstate : = state ( * state ) return & oldstate , nil } 
func restore ( fd int , state * state ) error { newstate : = terminal . state ( * state ) return terminal . restore ( fd , & newstate ) } 
func ( e * eventlistener ) addhandler ( types [ ] string , function func ( api . event ) ) ( * eventtarget , error ) { if function == nil { return nil , fmt . errorf ( " " ) } e . targetslock . lock ( ) defer e . targetslock . unlock ( ) target : = eventtarget { function : function , types : types , } e . targets = append ( e . targets , & target ) return & target , nil } 
func ( e * eventlistener ) removehandler ( target * eventtarget ) error { if target == nil { return fmt . errorf ( " " ) } e . targetslock . lock ( ) defer e . targetslock . unlock ( ) for i , entry : = range e . targets { if entry == target { copy ( e . targets [ i : ] , e . targets [ i + 1 : ] ) e . targets [ len ( e . targets ) - 1 ] = nil e . targets = e . targets [ : len ( e . targets ) - 1 ] return nil } } return fmt . errorf ( " " ) } 
func ( e * eventlistener ) disconnect ( ) { if e . disconnected { return } e . r . eventlistenerslock . lock ( ) defer e . r . eventlistenerslock . unlock ( ) for i , listener : = range e . r . eventlisteners { if listener == e { copy ( e . r . eventlisteners [ i : ] , e . r . eventlisteners [ i + 1 : ] ) e . r . eventlisteners [ len ( e . r . eventlisteners ) - 1 ] = nil e . r . eventlisteners = e . r . eventlisteners [ : len ( e . r . eventlisteners ) - 1 ] break } } e . err = nil e . disconnected = true close ( e . chactive ) } 
func compareversions ( version1 , version2 [ 2 ] int ) ( int , error ) { schema1 , extensions1 : = version1 [ 0 ] , version1 [ 1 ] schema2 , extensions2 : = version2 [ 0 ] , version2 [ 1 ] if schema1 == schema2 && extensions1 == extensions2 { return 0 , nil } if schema1 >= schema2 && extensions1 >= extensions2 { return 1 , nil } if schema1 <= schema2 && extensions1 <= extensions2 { return 2 , nil } return - 1 , fmt . errorf ( " " ) } 
func ( c * config ) hasclientcertificate ( ) bool { certf : = c . configpath ( " " ) keyf : = c . configpath ( " " ) if ! shared . pathexists ( certf ) | | ! shared . pathexists ( keyf ) { return false } return true } 
func ( c * config ) generateclientcertificate ( ) error { if c . hasclientcertificate ( ) { return nil } certf : = c . configpath ( " " ) keyf : = c . configpath ( " " ) return shared . findorgencert ( certf , keyf , true ) } 
func loadmodule ( module string ) error { if shared . pathexists ( fmt . sprintf ( " " , module ) ) { return nil } , err : = shared . runcommand ( " " , module ) return err } 
func parse ( name string ) ( * ast . package , error ) { base : = os . getenv ( " " ) if base == " " { base = " " } dir : = filepath . join ( base , " " , name ) fset : = token . newfileset ( ) paths , err : = filepath . glob ( filepath . join ( dir , " " ) ) if err ! = nil { return nil , errors . wrap ( err , " " ) } files : = map [ string ] * ast . file { } for , path : = range paths { if strings . contains ( path , " " ) { continue } file , err : = parser . parsefile ( fset , path , nil , parser . parsecomments ) if err ! = nil { return nil , fmt . errorf ( " " , path ) } files [ path ] = file } pkg , : = ast . newpackage ( fset , files , nil , nil ) return pkg , nil } 
func ( e * endpoints ) pprofaddress ( ) string { e . mu . rlock ( ) defer e . mu . runlock ( ) listener : = e . listeners [ pprof ] if listener == nil { return " " } return listener . addr ( ) . string ( ) } 
func ( e * endpoints ) pprofupdateaddress ( address string ) error { if address ! = " " { address = util . canonicalnetworkaddress ( address ) } oldaddress : = e . networkaddress ( ) if address == oldaddress { return nil } logger . infof ( " " ) e . mu . lock ( ) defer e . mu . unlock ( ) e . closelistener ( pprof ) if address == " " { return nil } getlistener : = func ( address string ) ( * net . listener , error ) { var err error var listener net . listener for i : = 0 ; i < 10 ; i ++ { listener , err = net . listen ( " " , address ) if err == nil { break } time . sleep ( 100 * time . millisecond ) } if err ! = nil { return nil , fmt . errorf ( " " , err ) } return & listener , nil } if address ! = " " { listener , err : = getlistener ( address ) if err ! = nil { listener , err1 : = getlistener ( oldaddress ) if err1 == nil { e . listeners [ pprof ] = * listener e . servehttp ( pprof ) } return err } e . listeners [ pprof ] = * listener e . servehttp ( pprof ) } return nil } 
func newmethod ( database , pkg , entity , kind string , config map [ string ] string ) ( * method , error ) { packages , err : = packages ( ) if err ! = nil { return nil , err } method : = & method { db : database , pkg : pkg , entity : entity , kind : kind , config : config , packages : packages , } return method , nil } 
func ( m * method ) generate ( buf * file . buffer ) error { if strings . hassuffix ( m . kind , " " ) { return m . ref ( buf ) } switch m . kind { case " " : return m . uris ( buf ) case " " : return m . list ( buf ) case " " : return m . get ( buf ) case " " : return m . id ( buf ) case " " : return m . exists ( buf ) case " " : return m . create ( buf ) case " " : return m . rename ( buf ) case " " : return m . update ( buf ) case " " : return m . delete ( buf ) default : return fmt . errorf ( " " , m . kind ) } } 
func ( c * clustertx ) storagepoolsnodeconfig ( ) ( map [ string ] map [ string ] string , error ) { names , err : = query . selectstrings ( c . tx , " " ) if err ! = nil { return nil , err } pools : = make ( map [ string ] map [ string ] string , len ( names ) ) for , name : = range names { table : = config , err : = query . selectconfig ( c . tx , table , " " , name , c . nodeid ) if err ! = nil { return nil , err } pools [ name ] = config } return pools , nil } 
func ( c * clustertx ) storagepoolid ( name string ) ( int64 , error ) { stmt : = " " ids , err : = query . selectintegers ( c . tx , stmt , name ) if err ! = nil { return - 1 , err } switch len ( ids ) { case 0 : return - 1 , errnosuchobject case 1 : return int64 ( ids [ 0 ] ) , nil default : return - 1 , fmt . errorf ( " " ) } } 
func ( c * clustertx ) storagepooldriver ( id int64 ) ( string , error ) { stmt : = " " drivers , err : = query . selectstrings ( c . tx , stmt , id ) if err ! = nil { return " " , err } switch len ( drivers ) { case 0 : return " " , errnosuchobject case 1 : return drivers [ 0 ] , nil default : return " " , fmt . errorf ( " " ) } } 
func ( c * clustertx ) storagepoolidsnotpending ( ) ( map [ string ] int64 , error ) { pools : = [ ] struct { id int64 name string } { } dest : = func ( i int ) [ ] interface { } { pools = append ( pools , struct { id int64 name string } { } ) return [ ] interface { } { & pools [ i ] . id , & pools [ i ] . name } } stmt , err : = c . tx . prepare ( " " ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest , storagepoolpending ) if err ! = nil { return nil , err } ids : = map [ string ] int64 { } for , pool : = range pools { ids [ pool . name ] = pool . id } return ids , nil } 
func ( c * clustertx ) storagepoolnodejoin ( poolid , nodeid int64 ) error { columns : = [ ] string { " " , " " } values : = [ ] interface { } { poolid , nodeid } , err : = query . upsertobject ( c . tx , " " , columns , values ) if err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func ( c * clustertx ) storagepoolnodejoinceph ( poolid , nodeid int64 ) error { stmt : = " " nodeids , err : = query . selectintegers ( c . tx , stmt , poolid ) if err ! = nil { return errors . wrap ( err , " " ) } if len ( nodeids ) == 0 { return fmt . errorf ( " " ) } othernodeid : = nodeids [ 0 ] , err = c . tx . exec ( , nodeid , poolid , othernodeid ) if err ! = nil { return errors . wrap ( err , " " ) } stmt = volumeids , err : = query . selectintegers ( c . tx , stmt , poolid , nodeid ) if err ! = nil { return errors . wrap ( err , " " ) } othervolumeids , err : = query . selectintegers ( c . tx , stmt , poolid , othernodeid ) if err ! = nil { return errors . wrap ( err , " " ) } if len ( volumeids ) ! = len ( othervolumeids ) { return fmt . errorf ( " " ) } for i , othervolumeid : = range othervolumeids { config , err : = query . selectconfig ( c . tx , " " , " " , othervolumeid ) if err ! = nil { return errors . wrap ( err , " " ) } for key , value : = range config { , err : = c . tx . exec ( , volumeids [ i ] , key , value ) if err ! = nil { return errors . wrap ( err , " " ) } } } return nil } 
func ( c * clustertx ) storagepoolconfigadd ( poolid , nodeid int64 , config map [ string ] string ) error { return storagepoolconfigadd ( c . tx , poolid , nodeid , config ) } 
func ( c * clustertx ) storagepoolcreated ( name string ) error { return c . storagepoolstate ( name , storagepoolcreated ) } 
func ( c * clustertx ) storagepoolerrored ( name string ) error { return c . storagepoolstate ( name , storagepoolerrored ) } 
func ( c * clustertx ) storagepoolnodeconfigs ( poolid int64 ) ( map [ string ] map [ string ] string , error ) { nodes , err : = c . nodes ( ) if err ! = nil { return nil , err } stmt : = defined , err : = query . selectstrings ( c . tx , stmt , poolid , storagepoolpending ) if err ! = nil { return nil , err } missing : = [ ] string { } for , node : = range nodes { if ! shared . stringinslice ( node . name , defined ) { missing = append ( missing , node . name ) } } if len ( missing ) > 0 { return nil , fmt . errorf ( " " , strings . join ( missing , " " ) ) } configs : = map [ string ] map [ string ] string { } for , node : = range nodes { config , err : = query . selectconfig ( c . tx , " " , " " , poolid , node . id ) if err ! = nil { return nil , err } configs [ node . name ] = config } return configs , nil } 
func ( c * cluster ) storagepools ( where string , args ... interface { } ) ( [ ] string , error ) { var name string stmt : = " " inargs : = [ ] interface { } { } outargs : = [ ] interface { } { name } if where ! = " " { stmt += fmt . sprintf ( " " , where ) for , arg : = range args { inargs = append ( inargs , arg ) } } result , err : = queryscan ( c . db , stmt , inargs , outargs ) if err ! = nil { return [ ] string { } , err } if len ( result ) == 0 { return [ ] string { } , errnosuchobject } pools : = [ ] string { } for , r : = range result { pools = append ( pools , r [ 0 ] . ( string ) ) } return pools , nil } 
func ( c * cluster ) storagepoolsgetdrivers ( ) ( [ ] string , error ) { var pooldriver string query : = " " inargs : = [ ] interface { } { } outargs : = [ ] interface { } { pooldriver } result , err : = queryscan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } if len ( result ) == 0 { return [ ] string { } , errnosuchobject } drivers : = [ ] string { } for , driver : = range result { drivers = append ( drivers , driver [ 0 ] . ( string ) ) } return drivers , nil } 
func ( c * cluster ) storagepoolgetid ( poolname string ) ( int64 , error ) { poolid : = int64 ( - 1 ) query : = " " inargs : = [ ] interface { } { poolname } outargs : = [ ] interface { } { & poolid } err : = dbqueryrowscan ( c . db , query , inargs , outargs ) if err ! = nil { if err == sql . errnorows { return - 1 , errnosuchobject } } return poolid , nil } 
func ( c * cluster ) storagepoolget ( poolname string ) ( int64 , * api . storagepool , error ) { var pooldriver string poolid : = int64 ( - 1 ) description : = sql . nullstring { } var state int query : = " " inargs : = [ ] interface { } { poolname } outargs : = [ ] interface { } { & poolid , & pooldriver , & description , & state } err : = dbqueryrowscan ( c . db , query , inargs , outargs ) if err ! = nil { if err == sql . errnorows { return - 1 , nil , errnosuchobject } return - 1 , nil , err } config , err : = c . storagepoolconfigget ( poolid ) if err ! = nil { return - 1 , nil , err } storagepool : = api . storagepool { name : poolname , driver : pooldriver , } storagepool . description = description . string storagepool . config = config switch state { case storagepoolpending : storagepool . status = " " case storagepoolcreated : storagepool . status = " " default : storagepool . status = " " } nodes , err : = c . storagepoolnodes ( poolid ) if err ! = nil { return - 1 , nil , err } storagepool . locations = nodes return poolid , & storagepool , nil } 
func ( c * cluster ) storagepoolnodes ( poolid int64 ) ( [ ] string , error ) { stmt : = var nodes [ ] string err : = c . transaction ( func ( tx * clustertx ) error { var err error nodes , err = query . selectstrings ( tx . tx , stmt , poolid ) return err } ) if err ! = nil { return nil , err } return nodes , nil } 
func ( c * cluster ) storagepoolconfigget ( poolid int64 ) ( map [ string ] string , error ) { var key , value string query : = " " inargs : = [ ] interface { } { poolid , c . nodeid } outargs : = [ ] interface { } { key , value } results , err : = queryscan ( c . db , query , inargs , outargs ) if err ! = nil { return nil , err } config : = map [ string ] string { } for , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * cluster ) storagepoolcreate ( poolname string , pooldescription string , pooldriver string , poolconfig map [ string ] string ) ( int64 , error ) { var id int64 err : = c . transaction ( func ( tx * clustertx ) error { result , err : = tx . tx . exec ( " " , poolname , pooldescription , pooldriver , storagepoolcreated ) if err ! = nil { return err } id , err = result . lastinsertid ( ) if err ! = nil { return err } columns : = [ ] string { " " , " " } values : = [ ] interface { } { id , c . nodeid } , err = query . upsertobject ( tx . tx , " " , columns , values ) if err ! = nil { return err } err = storagepoolconfigadd ( tx . tx , id , c . nodeid , poolconfig ) if err ! = nil { return err } return nil } ) if err ! = nil { id = - 1 } return id , nil } 
func storagepoolconfigadd ( tx * sql . tx , poolid , nodeid int64 , poolconfig map [ string ] string ) error { str : = " " stmt , err : = tx . prepare ( str ) defer stmt . close ( ) if err ! = nil { return err } for k , v : = range poolconfig { if v == " " { continue } var nodeidvalue interface { } if ! shared . stringinslice ( k , storagepoolnodeconfigkeys ) { nodeidvalue = nil } else { nodeidvalue = nodeid } , err = stmt . exec ( poolid , nodeidvalue , k , v ) if err ! = nil { return err } } return nil } 
func storagepooldriverget ( tx * sql . tx , id int64 ) ( string , error ) { stmt : = " " drivers , err : = query . selectstrings ( tx , stmt , id ) if err ! = nil { return " " , err } switch len ( drivers ) { case 0 : return " " , errnosuchobject case 1 : return drivers [ 0 ] , nil default : return " " , fmt . errorf ( " " ) } } 
func ( c * cluster ) storagepoolupdate ( poolname , description string , poolconfig map [ string ] string ) error { poolid , , err : = c . storagepoolget ( poolname ) if err ! = nil { return err } err = c . transaction ( func ( tx * clustertx ) error { err = storagepoolupdatedescription ( tx . tx , poolid , description ) if err ! = nil { return err } err = storagepoolconfigclear ( tx . tx , poolid , c . nodeid ) if err ! = nil { return err } err = storagepoolconfigadd ( tx . tx , poolid , c . nodeid , poolconfig ) if err ! = nil { return err } return nil } ) return err } 
func storagepoolconfigclear ( tx * sql . tx , poolid , nodeid int64 ) error { , err : = tx . exec ( " " , poolid , nodeid ) if err ! = nil { return err } return nil } 
func ( c * cluster ) storagepooldelete ( poolname string ) ( * api . storagepool , error ) { poolid , pool , err : = c . storagepoolget ( poolname ) if err ! = nil { return nil , err } err = exec ( c . db , " " , poolid ) if err ! = nil { return nil , err } return pool , nil } 
func ( c * cluster ) storagepoolvolumesgetnames ( poolid int64 ) ( [ ] string , error ) { var volumename string query : = " " inargs : = [ ] interface { } { poolid , c . nodeid } outargs : = [ ] interface { } { volumename } result , err : = queryscan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } var out [ ] string for , r : = range result { out = append ( out , r [ 0 ] . ( string ) ) } return out , nil } 
func ( c * cluster ) storagepoolvolumesget ( project string , poolid int64 , volumetypes [ ] int ) ( [ ] * api . storagevolume , error ) { var nodeids [ ] int err : = c . transaction ( func ( tx * clustertx ) error { var err error nodeids , err = query . selectintegers ( tx . tx , , project , storagepoolvolumetypecustom , poolid ) return err } ) if err ! = nil { return nil , err } volumes : = [ ] * api . storagevolume { } for , nodeid : = range nodeids { nodevolumes , err : = c . storagepoolvolumesget ( project , poolid , int64 ( nodeid ) , volumetypes ) if err ! = nil { return nil , err } volumes = append ( volumes , nodevolumes ... ) } return volumes , nil } 
func ( c * cluster ) storagepoolnodevolumesget ( poolid int64 , volumetypes [ ] int ) ( [ ] * api . storagevolume , error ) { return c . storagepoolvolumesget ( " " , poolid , c . nodeid , volumetypes ) } 
func ( c * cluster ) storagepoolvolumesget ( project string , poolid , nodeid int64 , volumetypes [ ] int ) ( [ ] * api . storagevolume , error ) { result : = [ ] * api . storagevolume { } for , volumetype : = range volumetypes { volumenames , err : = c . storagepoolvolumesgettype ( project , volumetype , poolid , nodeid ) if err ! = nil && err ! = sql . errnorows { return nil , errors . wrap ( err , " " ) } for , volumename : = range volumenames { , volume , err : = c . storagepoolvolumegettype ( project , volumename , volumetype , poolid , nodeid ) if err ! = nil { return nil , errors . wrap ( err , " " ) } result = append ( result , volume ) } } if len ( result ) == 0 { return result , errnosuchobject } return result , nil } 
func ( c * cluster ) storagepoolvolumesgettype ( project string , volumetype int , poolid , nodeid int64 ) ( [ ] string , error ) { var poolname string query : = inargs : = [ ] interface { } { project , storagepoolvolumetypecustom , poolid , nodeid , volumetype } outargs : = [ ] interface { } { poolname } result , err : = queryscan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( c * cluster ) storagepoolvolumesnapshotsgettype ( volumename string , volumetype int , poolid int64 ) ( [ ] string , error ) { result : = [ ] string { } regexp : = volumename + shared . snapshotdelimiter length : = len ( regexp ) query : = " " inargs : = [ ] interface { } { poolid , c . nodeid , volumetype , true , length , regexp } outfmt : = [ ] interface { } { volumename } dbresults , err : = queryscan ( c . db , query , inargs , outfmt ) if err ! = nil { return result , err } for , r : = range dbresults { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil } 
func ( c * cluster ) storagepoolnodevolumesgettype ( volumetype int , poolid int64 ) ( [ ] string , error ) { return c . storagepoolvolumesgettype ( " " , volumetype , poolid , c . nodeid ) } 
func ( c * cluster ) storagepoolvolumegettype ( project string , volumename string , volumetype int , poolid , nodeid int64 ) ( int64 , * api . storagevolume , error ) { if volumetype == storagepoolvolumetypecustom { project = " " } volumeid , err : = c . storagepoolvolumegettypeid ( project , volumename , volumetype , poolid , nodeid ) if err ! = nil { return - 1 , nil , err } volumenode , err : = c . storagevolumenodeget ( volumeid ) if err ! = nil { return - 1 , nil , err } volumeconfig , err : = c . storagevolumeconfigget ( volumeid ) if err ! = nil { return - 1 , nil , err } volumedescription , err : = c . storagevolumedescriptionget ( volumeid ) if err ! = nil { return - 1 , nil , err } volumetypename , err : = storagepoolvolumetypetoname ( volumetype ) if err ! = nil { return - 1 , nil , err } storagevolume : = api . storagevolume { type : volumetypename , } storagevolume . name = volumename storagevolume . description = volumedescription storagevolume . config = volumeconfig storagevolume . location = volumenode return volumeid , & storagevolume , nil } 
func ( c * cluster ) storagepoolnodevolumegettype ( volumename string , volumetype int , poolid int64 ) ( int64 , * api . storagevolume , error ) { return c . storagepoolnodevolumegettypebyproject ( " " , volumename , volumetype , poolid ) } 
func ( c * cluster ) storagepoolnodevolumegettypebyproject ( project , volumename string , volumetype int , poolid int64 ) ( int64 , * api . storagevolume , error ) { return c . storagepoolvolumegettype ( project , volumename , volumetype , poolid , c . nodeid ) } 
func ( c * cluster ) storagepoolvolumeupdate ( volumename string , volumetype int , poolid int64 , volumedescription string , volumeconfig map [ string ] string ) error { volumeid , , err : = c . storagepoolnodevolumegettype ( volumename , volumetype , poolid ) if err ! = nil { return err } err = c . transaction ( func ( tx * clustertx ) error { err = storagepoolvolumereplicateifceph ( tx . tx , volumeid , " " , volumename , volumetype , poolid , func ( volumeid int64 ) error { err = storagevolumeconfigclear ( tx . tx , volumeid ) if err ! = nil { return err } err = storagevolumeconfigadd ( tx . tx , volumeid , volumeconfig ) if err ! = nil { return err } return storagevolumedescriptionupdate ( tx . tx , volumeid , volumedescription ) } ) if err ! = nil { return err } return nil } ) return err } 
func ( c * cluster ) storagepoolvolumedelete ( project , volumename string , volumetype int , poolid int64 ) error { volumeid , , err : = c . storagepoolnodevolumegettypebyproject ( project , volumename , volumetype , poolid ) if err ! = nil { return err } err = c . transaction ( func ( tx * clustertx ) error { err : = storagepoolvolumereplicateifceph ( tx . tx , volumeid , project , volumename , volumetype , poolid , func ( volumeid int64 ) error { , err : = tx . tx . exec ( " " , volumeid ) return err } ) return err } ) return err } 
func ( c * cluster ) storagepoolvolumerename ( project , oldvolumename string , newvolumename string , volumetype int , poolid int64 ) error { volumeid , , err : = c . storagepoolnodevolumegettypebyproject ( project , oldvolumename , volumetype , poolid ) if err ! = nil { return err } err = c . transaction ( func ( tx * clustertx ) error { err : = storagepoolvolumereplicateifceph ( tx . tx , volumeid , project , oldvolumename , volumetype , poolid , func ( volumeid int64 ) error { , err : = tx . tx . exec ( " " , newvolumename , volumeid , volumetype ) return err } ) return err } ) return err } 
func storagepoolvolumereplicateifceph ( tx * sql . tx , volumeid int64 , project , volumename string , volumetype int , poolid int64 , f func ( int64 ) error ) error { driver , err : = storagepooldriverget ( tx , poolid ) if err ! = nil { return err } volumeids : = [ ] int64 { volumeid } if driver == " " { volumeids , err = storagevolumeidsget ( tx , project , volumename , volumetype , poolid ) if err ! = nil { return err } } for , volumeid : = range volumeids { err : = f ( volumeid ) if err ! = nil { return err } } return nil } 
func ( c * cluster ) storagepoolvolumecreate ( project , volumename , volumedescription string , volumetype int , snapshot bool , poolid int64 , volumeconfig map [ string ] string ) ( int64 , error ) { var thisvolumeid int64 err : = c . transaction ( func ( tx * clustertx ) error { nodeids : = [ ] int { int ( c . nodeid ) } driver , err : = storagepooldriverget ( tx . tx , poolid ) if err ! = nil { return err } if driver == " " { nodeids , err = query . selectintegers ( tx . tx , " " ) if err ! = nil { return err } } for , nodeid : = range nodeids { result , err : = tx . tx . exec ( , poolid , nodeid , volumetype , snapshot , volumename , volumedescription , project ) if err ! = nil { return err } volumeid , err : = result . lastinsertid ( ) if err ! = nil { return err } if int64 ( nodeid ) == c . nodeid { thisvolumeid = volumeid } err = storagevolumeconfigadd ( tx . tx , volumeid , volumeconfig ) if err ! = nil { tx . tx . rollback ( ) return err } } return nil } ) if err ! = nil { thisvolumeid = - 1 } return thisvolumeid , err } 
func ( c * cluster ) storagepoolvolumegettypeid ( project string , volumename string , volumetype int , poolid , nodeid int64 ) ( int64 , error ) { volumeid : = int64 ( - 1 ) query : = inargs : = [ ] interface { } { project , poolid , nodeid , volumename , volumetype } outargs : = [ ] interface { } { & volumeid } err : = dbqueryrowscan ( c . db , query , inargs , outargs ) if err ! = nil { if err == sql . errnorows { return - 1 , errnosuchobject } return - 1 , err } return volumeid , nil } 
func ( c * cluster ) storagepoolnodevolumegettypeid ( volumename string , volumetype int , poolid int64 ) ( int64 , error ) { return c . storagepoolvolumegettypeid ( " " , volumename , volumetype , poolid , c . nodeid ) } 
func storagepoolvolumetypetoname ( volumetype int ) ( string , error ) { switch volumetype { case storagepoolvolumetypecontainer : return storagepoolvolumetypenamecontainer , nil case storagepoolvolumetypeimage : return storagepoolvolumetypenameimage , nil case storagepoolvolumetypecustom : return storagepoolvolumetypenamecustom , nil } return " " , fmt . errorf ( " " ) } 
func devicesadd ( tx * sql . tx , w string , cid int64 , devices types . devices ) error { str1 : = fmt . sprintf ( " " , w , w ) stmt1 , err : = tx . prepare ( str1 ) if err ! = nil { return err } defer stmt1 . close ( ) str2 : = fmt . sprintf ( " " , w , w ) stmt2 , err : = tx . prepare ( str2 ) if err ! = nil { return err } defer stmt2 . close ( ) for k , v : = range devices { t , err : = dbdevicetypetoint ( v [ " " ] ) if err ! = nil { return err } result , err : = stmt1 . exec ( cid , k , t ) if err ! = nil { return err } id64 , err : = result . lastinsertid ( ) if err ! = nil { return fmt . errorf ( " " , k ) } id : = int ( id64 ) for ck , cv : = range v { if ck == " " | | cv == " " { continue } , err = stmt2 . exec ( id , ck , cv ) if err ! = nil { return err } } } return nil } 
func ( c * cluster ) devices ( project , qname string , isprofile bool ) ( types . devices , error ) { err : = c . transaction ( func ( tx * clustertx ) error { enabled , err : = tx . projecthasprofiles ( project ) if err ! = nil { return err } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } var q string if isprofile { q = } else { q = } var id , dtype int var name , stype string inargs : = [ ] interface { } { project , qname } outfmt : = [ ] interface { } { id , name , dtype } results , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } devices : = types . devices { } for , r : = range results { id = r [ 0 ] . ( int ) name = r [ 1 ] . ( string ) stype , err = dbdevicetypetostring ( r [ 2 ] . ( int ) ) if err ! = nil { return nil , err } newdev , err : = dbdeviceconfig ( c . db , id , isprofile ) if err ! = nil { return nil , err } newdev [ " " ] = stype devices [ name ] = newdev } return devices , nil } 
func ( n * node ) patches ( ) ( [ ] string , error ) { inargs : = [ ] interface { } { } outfmt : = [ ] interface { } { " " } query : = fmt . sprintf ( " " ) result , err : = queryscan ( n . db , query , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( n * node ) patchesmarkapplied ( patch string ) error { stmt : = ' insert into patches ( name , applied at ) values ( ? , strftime ( " %s " ) ) ; ' , err : = n . db . exec ( stmt , patch ) return err } 
func entitytype ( pkg string , entity string ) string { typ : = lex . capital ( entity ) if pkg ! = " " { typ = pkg + " " + typ } return typ } 
func entitypost ( entity string ) string { return fmt . sprintf ( " " , lex . capital ( lex . plural ( entity ) ) ) } 
func stmtcodevar ( entity string , kind string , filters ... string ) string { name : = fmt . sprintf ( " " , entity , lex . camel ( kind ) ) if len ( filters ) > 0 { name += " " name += strings . join ( filters , " " ) } return name } 
func activecriteria ( filter [ ] string ) string { expr : = " " for i , name : = range filter { if i > 0 { expr += " " } expr += fmt . sprintf ( " " , name ) } return expr } 
func destfunc ( slice string , typ string , fields [ ] * field ) string { f : = fmt . sprintf ( , slice , slice , typ ) for , field : = range fields { f += fmt . sprintf ( " \n " , slice , field . name ) } f += " \n " f += " " return f } 
func indextype ( fields [ ] * field , typ string ) string { index : = " " for range fields { index += " " } index += typ return index } 
func compareconfigs ( config1 , config2 map [ string ] string , exclude [ ] string ) error { if exclude == nil { exclude = [ ] string { } } delta : = [ ] string { } for key , value : = range config1 { if shared . stringinslice ( key , exclude ) { continue } if config2 [ key ] ! = value { delta = append ( delta , key ) } } for key , value : = range config2 { if shared . stringinslice ( key , exclude ) { continue } if config1 [ key ] ! = value { present : = false for i : = range delta { if delta [ i ] == key { present = true } break } if ! present { delta = append ( delta , key ) } } } sort . strings ( delta ) if len ( delta ) > 0 { return fmt . errorf ( " " , strings . join ( delta , " " ) ) } return nil } 
func copyconfig ( config map [ string ] string ) map [ string ] string { copy : = map [ string ] string { } for key , value : = range config { copy [ key ] = value } return copy } 
func events ( endpoints * endpoints . endpoints , cluster * db . cluster , f func ( int64 , api . event ) ) ( task . func , task . schedule ) { listeners : = map [ int64 ] * lxd . eventlistener { } update : = func ( ctx context . context ) { ch : = make ( chan struct { } ) go func ( ) { eventsupdatelisteners ( endpoints , cluster , listeners , f ) ch < - struct { } { } } ( ) select { case < - ch : case < - ctx . done ( ) : } } schedule : = task . every ( time . second ) return update , schedule } 
func eventsconnect ( address string , cert * shared . certinfo ) ( * lxd . eventlistener , error ) { client , err : = connect ( address , cert , true ) if err ! = nil { return nil , err } client = client . useproject ( " " ) return client . getevents ( ) } 
func ( e * idmapentry ) shift into ns ( id int64 ) ( int64 , error ) { if id < e . nsid | | id >= e . nsid + e . maprange { return 0 , fmt . errorf ( " " ) } return id - e . nsid + e . hostid , nil } 
func ( m * idmapset ) addsafe ( i idmapentry ) error { result : = [ ] idmapentry { } added : = false for , e : = range m . idmap { if ! e . intersects ( i ) { result = append ( result , e ) continue } if e . hostidsintersect ( i ) { return errhostidissubid } added = true lower : = idmapentry { isuid : e . isuid , isgid : e . isgid , hostid : e . hostid , nsid : e . nsid , maprange : i . nsid - e . nsid , } upper : = idmapentry { isuid : e . isuid , isgid : e . isgid , hostid : e . hostid + lower . maprange + i . maprange , nsid : i . nsid + i . maprange , maprange : e . maprange - i . maprange - lower . maprange , } if lower . maprange > 0 { result = append ( result , lower ) } result = append ( result , i ) if upper . maprange > 0 { result = append ( result , upper ) } } if ! added { result = append ( result , i ) } m . idmap = result return nil } 
func getfromshadow ( fname string , username string ) ( [ ] [ ] int64 , error ) { entries : = [ ] [ ] int64 { } f , err : = os . open ( fname ) if err ! = nil { return nil , err } defer f . close ( ) scanner : = bufio . newscanner ( f ) for scanner . scan ( ) { s : = strings . split ( scanner . text ( ) , " " ) if len ( s [ 0 ] ) == 0 { continue } s = strings . split ( s [ 0 ] , " " ) if len ( s ) < 3 { return nil , fmt . errorf ( " " , fname , s ) } if strings . equalfold ( s [ 0 ] , username ) { entrystart , err : = strconv . parseuint ( s [ 1 ] , 10 , 32 ) if err ! = nil { continue } entrysize , err : = strconv . parseuint ( s [ 2 ] , 10 , 32 ) if err ! = nil { continue } entries = append ( entries , [ ] int64 { int64 ( entrystart ) , int64 ( entrysize ) } ) } } if len ( entries ) == 0 { return nil , fmt . errorf ( " " , username , path . base ( fname ) ) } return entries , nil } 
func getfromproc ( fname string ) ( [ ] [ ] int64 , error ) { entries : = [ ] [ ] int64 { } f , err : = os . open ( fname ) if err ! = nil { return nil , err } defer f . close ( ) scanner : = bufio . newscanner ( f ) for scanner . scan ( ) { s : = strings . split ( scanner . text ( ) , " " ) if len ( s [ 0 ] ) == 0 { continue } s = strings . fields ( s [ 0 ] ) if len ( s ) < 3 { return nil , fmt . errorf ( " " , fname , s ) } entrystart , err : = strconv . parseuint ( s [ 0 ] , 10 , 32 ) if err ! = nil { continue } entryhost , err : = strconv . parseuint ( s [ 1 ] , 10 , 32 ) if err ! = nil { continue } entrysize , err : = strconv . parseuint ( s [ 2 ] , 10 , 32 ) if err ! = nil { continue } entries = append ( entries , [ ] int64 { int64 ( entrystart ) , int64 ( entryhost ) , int64 ( entrysize ) } ) } if len ( entries ) == 0 { return nil , fmt . errorf ( " " ) } return entries , nil } 
func currentidmapset ( ) ( * idmapset , error ) { idmapset : = new ( idmapset ) if shared . pathexists ( " " ) { entries , err : = getfromproc ( " " ) if err ! = nil { return nil , err } for , entry : = range entries { e : = idmapentry { isuid : true , nsid : entry [ 0 ] , hostid : entry [ 1 ] , maprange : entry [ 2 ] } idmapset . idmap = extend ( idmapset . idmap , e ) } } else { e : = idmapentry { isuid : true , nsid : 0 , hostid : 0 , maprange : 0 } idmapset . idmap = extend ( idmapset . idmap , e ) } if shared . pathexists ( " " ) { entries , err : = getfromproc ( " " ) if err ! = nil { return nil , err } for , entry : = range entries { e : = idmapentry { isgid : true , nsid : entry [ 0 ] , hostid : entry [ 1 ] , maprange : entry [ 2 ] } idmapset . idmap = extend ( idmapset . idmap , e ) } } else { e : = idmapentry { isgid : true , nsid : 0 , hostid : 0 , maprange : 0 } idmapset . idmap = extend ( idmapset . idmap , e ) } return idmapset , nil } 
func ( s * storagedir ) storagecoreinit ( ) error { s . stype = storagetypedir typename , err : = storagetypetostring ( s . stype ) if err ! = nil { return err } s . stypename = typename s . stypeversion = " " return nil } 
func ( s * storagedir ) storagepoolinit ( ) error { err : = s . storagecoreinit ( ) if err ! = nil { return err } return nil } 
func ( s * storagedir ) storagepoolvolumecreate ( ) error { logger . infof ( " " " " " " , s . volume . name , s . pool . name ) , err : = s . storagepoolmount ( ) if err ! = nil { return err } source : = s . pool . config [ " " ] if source == " " { return fmt . errorf ( " " " " ) } issnapshot : = shared . issnapshot ( s . volume . name ) var storagevolumepath string if issnapshot { storagevolumepath = getstoragepoolvolumesnapshotmountpoint ( s . pool . name , s . volume . name ) } else { storagevolumepath = getstoragepoolvolumemountpoint ( s . pool . name , s . volume . name ) } err = os . mkdirall ( storagevolumepath , 0711 ) if err ! = nil { return err } err = s . initquota ( storagevolumepath , s . volumeid ) if err ! = nil { return err } logger . infof ( " " " " " " , s . volume . name , s . pool . name ) return nil } 
func aaloadprofile ( c container ) error { state : = c . daemonstate ( ) if ! state . os . apparmoradmin { return nil } if err : = mkapparmornamespace ( c , aanamespace ( c ) ) ; err ! = nil { return err } profile : = path . join ( aapath , " " , aaprofileshort ( c ) ) content , err : = ioutil . readfile ( profile ) if err ! = nil && ! os . isnotexist ( err ) { return err } updated : = getaaprofilecontent ( c ) if string ( content ) ! = string ( updated ) { if err : = os . mkdirall ( path . join ( aapath , " " ) , 0700 ) ; err ! = nil { return err } if err : = os . mkdirall ( path . join ( aapath , " " ) , 0700 ) ; err ! = nil { return err } if err : = ioutil . writefile ( profile , [ ] byte ( updated ) , 0600 ) ; err ! = nil { return err } } return runapparmor ( apparmor cmd load , c ) } 
func aadestroy ( c container ) error { state : = c . daemonstate ( ) if ! state . os . apparmoradmin { return nil } if state . os . apparmorstacking && ! state . os . apparmorstacked { p : = path . join ( " " , aanamespace ( c ) ) if err : = os . remove ( p ) ; err ! = nil { logger . error ( " " , log . ctx { " " : err , " " : p } ) } } return runapparmor ( apparmor cmd unload , c ) } 
func aaparseprofile ( c container ) error { state : = c . daemonstate ( ) if ! state . os . apparmoravailable { return nil } return runapparmor ( apparmor cmd parse , c ) } 
func aadeleteprofile ( c container ) { state : = c . daemonstate ( ) if ! state . os . apparmoradmin { return } os . remove ( path . join ( getaacachedir ( ) , aaprofileshort ( c ) ) ) os . remove ( path . join ( aapath , " " , aaprofileshort ( c ) ) ) } 
func getsystemhandler ( syslog string , debug bool , format log . format ) log . handler { return nil } 
func notifyupgradecompleted ( state * state . state , cert * shared . certinfo ) error { notifier , err : = newnotifier ( state , cert , notifyall ) if err ! = nil { return err } return notifier ( func ( client lxd . containerserver ) error { info , err : = client . getconnectioninfo ( ) if err ! = nil { return errors . wrap ( err , " " ) } url : = fmt . sprintf ( " " , info . addresses [ 0 ] , databaseendpoint ) request , err : = http . newrequest ( " " , url , nil ) if err ! = nil { return errors . wrap ( err , " " ) } httpclient , err : = client . gethttpclient ( ) if err ! = nil { return errors . wrap ( err , " " ) } response , err : = httpclient . do ( request ) if err ! = nil { return errors . wrap ( err , " " ) } if response . statuscode ! = http . statusok { return fmt . errorf ( " " , response . status ) } return nil } ) } 
func keepupdated ( state * state . state ) ( task . func , task . schedule ) { f : = func ( ctx context . context ) { ch : = make ( chan struct { } ) go func ( ) { maybeupdate ( state ) close ( ch ) } ( ) select { case < - ctx . done ( ) : case < - ch : } } schedule : = task . every ( 5 * time . minute ) return f , schedule } 
func maybeupdate ( state * state . state ) { shouldupdate : = false enabled , err : = enabled ( state . node ) if err ! = nil { logger . errorf ( " " , err ) return } if ! enabled { return } err = state . cluster . transaction ( func ( tx * db . clustertx ) error { outdated , err : = tx . nodeisoutdated ( ) if err ! = nil { return err } shouldupdate = outdated return nil } ) if err ! = nil { logger . errorf ( " " , err ) return } if ! shouldupdate { logger . debugf ( " " ) return } logger . infof ( " " ) updateexecutable : = os . getenv ( " " ) if updateexecutable == " " { logger . debug ( " " ) return } logger . infof ( " " , updateexecutable ) , err = shared . runcommand ( updateexecutable ) if err ! = nil { logger . errorf ( " " , err . error ( ) ) return } } 
func newserver ( apiurl string , apikey string , agentauthurl string , agentusername string , agentprivatekey string , agentpublickey string ) ( * server , error ) { r : = server { apiurl : apiurl , apikey : apikey , lastsyncid : " " , lastchange : time . time { } , resources : make ( map [ string ] string ) , permissions : make ( map [ string ] map [ string ] [ ] string ) , permissionslock : & sync . mutex { } , } var keypair bakery . keypair keypair . private . unmarshaltext ( [ ] byte ( agentprivatekey ) ) keypair . public . unmarshaltext ( [ ] byte ( agentpublickey ) ) r . client = httpbakery . newclient ( ) authinfo : = agent . authinfo { key : & keypair , agents : [ ] agent . agent { { url : agentauthurl , username : agentusername , } , } , } err : = agent . setupauth ( r . client , & authinfo ) if err ! = nil { return nil , err } r . client . client . jar , err = cookiejar . new ( nil ) if err ! = nil { return nil , err } return & r , nil } 
func ( r * server ) startstatuscheck ( ) { r . hasstatuschanged ( ) r . statusdone = make ( chan int ) go func ( ) { for { select { case < - r . statusdone : return case < - time . after ( time . minute ) : if r . hasstatuschanged ( ) { r . flushcache ( ) } } } } ( ) } 
func ( r * server ) syncprojects ( ) error { if r . projectsfunc == nil { return fmt . errorf ( " " ) } resources : = [ ] rbacresource { } resourcesmap : = map [ string ] string { } projects , err : = r . projectsfunc ( ) if err ! = nil { return err } for id , name : = range projects { resources = append ( resources , rbacresource { name : name , identifier : strconv . formatint ( id , 10 ) , } ) resourcesmap [ name ] = strconv . formatint ( id , 10 ) } err = r . postresources ( resources , nil , true ) if err ! = nil { return err } r . resourceslock . lock ( ) r . resources = resourcesmap r . resourceslock . unlock ( ) return nil } 
func ( r * server ) addproject ( id int64 , name string ) error { resource : = rbacresource { name : name , identifier : strconv . formatint ( id , 10 ) , } err : = r . postresources ( [ ] rbacresource { resource } , nil , false ) if err ! = nil { return err } r . resourceslock . lock ( ) r . resources [ name ] = strconv . formatint ( id , 10 ) r . resourceslock . unlock ( ) return nil } 
func ( r * server ) deleteproject ( id int64 ) error { err : = r . postresources ( nil , [ ] string { strconv . formatint ( id , 10 ) } , false ) if err ! = nil { return err } r . resourceslock . lock ( ) for k , v : = range r . resources { if v == strconv . formatint ( id , 10 ) { delete ( r . resources , k ) break } } r . resourceslock . unlock ( ) return nil } 
func ( r * server ) renameproject ( id int64 , name string ) error { return r . addproject ( id , name ) } 
func ( r * server ) isadmin ( username string ) bool { r . permissionslock . lock ( ) defer r . permissionslock . unlock ( ) , cached : = r . permissions [ username ] if ! cached { r . syncpermissions ( username ) } return shared . stringinslice ( " " , r . permissions [ username ] [ " " ] ) } 
func ( r * server ) haspermission ( username , project , permission string ) bool { r . permissionslock . lock ( ) defer r . permissionslock . unlock ( ) , cached : = r . permissions [ username ] if ! cached { r . syncpermissions ( username ) } r . resourceslock . lock ( ) permissions : = r . permissions [ username ] [ r . resources [ project ] ] r . resourceslock . unlock ( ) return shared . stringinslice ( permission , permissions ) } 
func rsyncsend ( conn * websocket . conn , path string , rsyncargs string ) error { cmd , datasocket , stderr , err : = rsyncsendsetup ( path , rsyncargs ) if err ! = nil { return err } if datasocket ! = nil { defer datasocket . close ( ) } readdone , writedone : = shared . websocketmirror ( conn , datasocket , io . readcloser ( datasocket ) , nil , nil ) output , err : = ioutil . readall ( stderr ) if err ! = nil { cmd . process . kill ( ) cmd . wait ( ) return fmt . errorf ( " \n " , err , output ) } err = cmd . wait ( ) < - readdone < - writedone if err ! = nil { return fmt . errorf ( " \n " , err , output ) } return nil } 
func tlsclientconfig ( info * shared . certinfo ) ( * tls . config , error ) { keypair : = info . keypair ( ) ca : = info . ca ( ) config : = shared . inittlsconfig ( ) config . certificates = [ ] tls . certificate { keypair } config . rootcas = x509 . newcertpool ( ) if ca ! = nil { config . rootcas . addcert ( ca ) } cert , err : = x509 . parsecertificate ( keypair . certificate [ 0 ] ) if err ! = nil { return nil , err } cert . isca = true cert . keyusage = x509 . keyusagecertsign config . rootcas . addcert ( cert ) if cert . dnsnames ! = nil { config . servername = cert . dnsnames [ 0 ] } return config , nil } 
func tlscheckcert ( r * http . request , info * shared . certinfo ) bool { cert , err : = x509 . parsecertificate ( info . keypair ( ) . certificate [ 0 ] ) if err ! = nil { panic ( fmt . sprintf ( " " , err ) ) } trustedcerts : = map [ string ] x509 . certificate { " " : * cert } trusted , : = util . checktruststate ( * r . tls . peercertificates [ 0 ] , trustedcerts ) return r . tls ! = nil && trusted } 
func internalclustercontainermovedpost ( d * daemon , r * http . request ) response { project : = projectparam ( r ) containername : = mux . vars ( r ) [ " " ] err : = containerpostcreatecontainermountpoint ( d , project , containername ) if err ! = nil { return smarterror ( err ) } return emptysyncresponse } 
func containerpostcreatecontainermountpoint ( d * daemon , project , containername string ) error { c , err : = containerloadbyprojectandname ( d . state ( ) , project , containername ) if err ! = nil { return errors . wrap ( err , " " ) } poolname , err : = c . storagepool ( ) if err ! = nil { return errors . wrap ( err , " " ) } snapshotnames , err : = d . cluster . containergetsnapshots ( project , containername ) if err ! = nil { return errors . wrap ( err , " " ) } containermntpoint : = getcontainermountpoint ( c . project ( ) , poolname , containername ) err = createcontainermountpoint ( containermntpoint , c . path ( ) , c . isprivileged ( ) ) if err ! = nil { return errors . wrap ( err , " " ) } for , snapshotname : = range snapshotnames { mntpoint : = getsnapshotmountpoint ( project , poolname , snapshotname ) snapshotssymlinktarget : = shared . varpath ( " " , poolname , " " , containername ) snapshotmntpointsymlink : = shared . varpath ( " " , containername ) err : = createsnapshotmountpoint ( mntpoint , snapshotssymlinktarget , snapshotmntpointsymlink ) if err ! = nil { return errors . wrap ( err , " " ) } } return nil } 
func ( list devices ) contains ( k string , d device ) bool { if list [ k ] == nil { return false } old : = list [ k ] return deviceequals ( old , d ) } 
func ( list devices ) update ( newlist devices ) ( map [ string ] device , map [ string ] device , map [ string ] device , [ ] string ) { rmlist : = map [ string ] device { } addlist : = map [ string ] device { } updatelist : = map [ string ] device { } for key , d : = range list { if ! newlist . contains ( key , d ) { rmlist [ key ] = d } } for key , d : = range newlist { if ! list . contains ( key , d ) { addlist [ key ] = d } } updatediff : = [ ] string { } for key , d : = range addlist { srcolddevice : = rmlist [ key ] var olddevice device err : = shared . deepcopy ( & srcolddevice , & olddevice ) if err ! = nil { continue } srcnewdevice : = newlist [ key ] var newdevice device err = shared . deepcopy ( & srcnewdevice , & newdevice ) if err ! = nil { continue } updatediff = deviceequalsdiffkeys ( olddevice , newdevice ) for , k : = range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " , " " } { delete ( olddevice , k ) delete ( newdevice , k ) } if deviceequals ( olddevice , newdevice ) { delete ( rmlist , key ) delete ( addlist , key ) updatelist [ key ] = d } } return rmlist , addlist , updatelist , updatediff } 
func ( list devices ) devicenames ( ) [ ] string { sortable : = sortabledevices { } for k , d : = range list { sortable = append ( sortable , nameddevice { k , d } ) } sort . sort ( sortable ) return sortable . names ( ) } 
func debug ( msg string , ctx ... interface { } ) { if log ! = nil { log . debug ( msg , ctx ... ) } } 
func info ( msg string , ctx ... interface { } ) { if log ! = nil { log . info ( msg , ctx ... ) } } 
func warn ( msg string , ctx ... interface { } ) { if log ! = nil { log . warn ( msg , ctx ... ) } } 
func error ( msg string , ctx ... interface { } ) { if log ! = nil { log . error ( msg , ctx ... ) } } 
func crit ( msg string , ctx ... interface { } ) { if log ! = nil { log . crit ( msg , ctx ... ) } } 
func infof ( format string , args ... interface { } ) { if log ! = nil { log . info ( fmt . sprintf ( format , args ... ) ) } } 
func debugf ( format string , args ... interface { } ) { if log ! = nil { log . debug ( fmt . sprintf ( format , args ... ) ) } } 
func warnf ( format string , args ... interface { } ) { if log ! = nil { log . warn ( fmt . sprintf ( format , args ... ) ) } } 
func errorf ( format string , args ... interface { } ) { if log ! = nil { log . error ( fmt . sprintf ( format , args ... ) ) } } 
func critf ( format string , args ... interface { } ) { if log ! = nil { log . crit ( fmt . sprintf ( format , args ... ) ) } } 
func eventforward ( id int64 , event api . event ) { if event . type == " " { logentry : = api . eventlogging { } err : = json . unmarshal ( event . metadata , & logentry ) if err ! = nil { return } if ! debug && logentry . level == " " { return } if ! debug && ! verbose && logentry . level == " " { return } } err : = eventbroadcast ( " " , event , true ) if err ! = nil { logger . warnf ( " " , id , err ) } } 
func getcontainermountpoint ( project string , poolname string , containername string ) string { return shared . varpath ( " " , poolname , " " , projectprefix ( project , containername ) ) } 
func getsnapshotmountpoint ( project , poolname string , snapshotname string ) string { return shared . varpath ( " " , poolname , " " , projectprefix ( project , snapshotname ) ) } 
func getimagemountpoint ( poolname string , fingerprint string ) string { return shared . varpath ( " " , poolname , " " , fingerprint ) } 
func getstoragepoolvolumemountpoint ( poolname string , volumename string ) string { return shared . varpath ( " " , poolname , " " , volumename ) } 
func getstoragepoolvolumesnapshotmountpoint ( poolname string , snapshotname string ) string { return shared . varpath ( " " , poolname , " " , snapshotname ) } 
func storageprogressreader ( op * operation , key string , description string ) func ( io . readcloser ) io . readcloser { return func ( reader io . readcloser ) io . readcloser { if op == nil { return reader } progress : = func ( progressint int64 , speedint int64 ) { progresswrapperrender ( op , key , description , progressint , speedint ) } readpipe : = & ioprogress . progressreader { readcloser : reader , tracker : & ioprogress . progresstracker { handler : progress , } , } return readpipe } } 
func storageprogresswriter ( op * operation , key string , description string ) func ( io . writecloser ) io . writecloser { return func ( writer io . writecloser ) io . writecloser { if op == nil { return writer } progress : = func ( progressint int64 , speedint int64 ) { progresswrapperrender ( op , key , description , progressint , speedint ) } writepipe : = & ioprogress . progresswriter { writecloser : writer , tracker : & ioprogress . progresstracker { handler : progress , } , } return writepipe } } 
func getlsbrelease ( ) ( map [ string ] string , error ) { osrelease , err : = getlsbrelease ( " " ) if os . isnotexist ( err ) { return getlsbrelease ( " " ) } return osrelease , err } 
func reset ( path string , imports [ ] string ) error { content : = fmt . sprintf ( , os . getenv ( " " ) , os . args [ 0 ] ) for , uri : = range imports { content += fmt . sprintf ( " \ t \n " , uri ) } content += " \n \n " content += " \n " bytes : = [ ] byte ( content ) var err error if path == " " { , err = os . stdout . write ( bytes ) } else { err = ioutil . writefile ( path , [ ] byte ( content ) , 0644 ) } if err ! = nil { errors . wrapf ( err , " " , path ) } return nil } 
func append ( path string , snippet snippet ) error { buffer : = newbuffer ( ) buffer . n ( ) err : = snippet . generate ( buffer ) if err ! = nil { return errors . wrap ( err , " " ) } var file * os . file if path == " " { file = os . stdout } else { file , err = os . openfile ( path , os . o append | os . o wronly , 0644 ) if err ! = nil { return errors . wrapf ( err , " " , path ) } defer file . close ( ) } bytes , err : = buffer . code ( ) if err ! = nil { return err } , err = file . write ( bytes ) if err ! = nil { return errors . wrapf ( err , " " , path ) } return nil } 
func containertoargs ( container * container ) containerargs { args : = containerargs { id : container . id , project : container . project , name : container . name , node : container . node , ctype : containertype ( container . type ) , architecture : container . architecture , ephemeral : container . ephemeral , creationdate : container . creationdate , stateful : container . stateful , lastuseddate : container . lastusedate , description : container . description , config : container . config , devices : container . devices , profiles : container . profiles , expirydate : container . expirydate , } if args . devices == nil { args . devices = types . devices { } } return args } 
func ( c * clustertx ) containernames ( project string ) ( [ ] string , error ) { stmt : = return query . selectstrings ( c . tx , stmt , project , ctyperegular ) } 
func ( c * clustertx ) containernodeaddress ( project string , name string ) ( string , error ) { stmt : = var address string var id int64 rows , err : = c . tx . query ( stmt , project , name ) if err ! = nil { return " " , err } defer rows . close ( ) if ! rows . next ( ) { return " " , errnosuchobject } err = rows . scan ( & id , & address ) if err ! = nil { return " " , err } if rows . next ( ) { return " " , fmt . errorf ( " " ) } err = rows . err ( ) if err ! = nil { return " " , err } if id == c . nodeid { return " " , nil } return address , nil } 
func ( c * clustertx ) containerslistbynodeaddress ( project string ) ( map [ string ] [ ] string , error ) { offlinethreshold , err : = c . nodeofflinethreshold ( ) if err ! = nil { return nil , err } stmt : = rows , err : = c . tx . query ( stmt , ctyperegular , project ) if err ! = nil { return nil , err } defer rows . close ( ) result : = map [ string ] [ ] string { } for i : = 0 ; rows . next ( ) ; i ++ { var name string var nodeaddress string var nodeid int64 var nodeheartbeat time . time err : = rows . scan ( & name , & nodeid , & nodeaddress , & nodeheartbeat ) if err ! = nil { return nil , err } if nodeid == c . nodeid { nodeaddress = " " } else if nodeisoffline ( offlinethreshold , nodeheartbeat ) { nodeaddress = " " } result [ nodeaddress ] = append ( result [ nodeaddress ] , name ) } err = rows . err ( ) if err ! = nil { return nil , err } return result , nil } 
func ( c * clustertx ) containerlistexpanded ( ) ( [ ] container , error ) { containers , err : = c . containerlist ( containerfilter { } ) if err ! = nil { return nil , errors . wrap ( err , " " ) } profiles , err : = c . profilelist ( profilefilter { } ) if err ! = nil { return nil , errors . wrap ( err , " " ) } profilesbyprojectandname : = map [ string ] map [ string ] profile { } for , profile : = range profiles { profilesbyname , ok : = profilesbyprojectandname [ profile . project ] if ! ok { profilesbyname = map [ string ] profile { } profilesbyprojectandname [ profile . project ] = profilesbyname } profilesbyname [ profile . name ] = profile } for i , container : = range containers { profiles : = make ( [ ] api . profile , len ( container . profiles ) ) for j , name : = range container . profiles { profile : = profilesbyprojectandname [ container . project ] [ name ] profiles [ j ] = * profiletoapi ( & profile ) } containers [ i ] . config = profilesexpandconfig ( container . config , profiles ) containers [ i ] . devices = profilesexpanddevices ( container . devices , profiles ) } return containers , nil } 
func ( c * clustertx ) containersbynodename ( project string ) ( map [ string ] string , error ) { stmt : = rows , err : = c . tx . query ( stmt , ctyperegular , project ) if err ! = nil { return nil , err } defer rows . close ( ) result : = map [ string ] string { } for i : = 0 ; rows . next ( ) ; i ++ { var name string var nodename string err : = rows . scan ( & name , & nodename ) if err ! = nil { return nil , err } result [ name ] = nodename } err = rows . err ( ) if err ! = nil { return nil , err } return result , nil } 
func ( c * clustertx ) snapshotidsandnames ( name string ) ( map [ int ] string , error ) { prefix : = name + shared . snapshotdelimiter length : = len ( prefix ) objects : = make ( [ ] struct { id int name string } , 0 ) dest : = func ( i int ) [ ] interface { } { objects = append ( objects , struct { id int name string } { } ) return [ ] interface { } { & objects [ i ] . id , & objects [ i ] . name } } stmt , err : = c . tx . prepare ( " " ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest , length , prefix , ctypesnapshot ) if err ! = nil { return nil , err } result : = make ( map [ int ] string ) for i : = range objects { result [ objects [ i ] . id ] = strings . split ( objects [ i ] . name , shared . snapshotdelimiter ) [ 1 ] } return result , nil } 
func ( c * clustertx ) containernodelist ( ) ( [ ] container , error ) { node , err : = c . nodename ( ) if err ! = nil { return nil , errors . wrap ( err , " " ) } filter : = containerfilter { node : node , type : int ( ctyperegular ) , } return c . containerlist ( filter ) } 
func ( c * clustertx ) containernodeprojectlist ( project string ) ( [ ] container , error ) { node , err : = c . nodename ( ) if err ! = nil { return nil , errors . wrap ( err , " " ) } filter : = containerfilter { project : project , node : node , type : int ( ctyperegular ) , } return c . containerlist ( filter ) } 
func ( c * clustertx ) containerconfiginsert ( id int , config map [ string ] string ) error { return containerconfiginsert ( c . tx , id , config ) } 
func ( c * cluster ) containerremove ( project , name string ) error { return c . transaction ( func ( tx * clustertx ) error { return tx . containerdelete ( project , name ) } ) } 
func ( c * cluster ) containerprojectandname ( id int ) ( string , string , error ) { q : = project : = " " name : = " " arg1 : = [ ] interface { } { id } arg2 : = [ ] interface { } { & project , & name } err : = dbqueryrowscan ( c . db , q , arg1 , arg2 ) if err == sql . errnorows { return " " , " " , errnosuchobject } return project , name , err } 
func containerconfigclear ( tx * sql . tx , id int ) error { , err : = tx . exec ( " " , id ) if err ! = nil { return err } , err = tx . exec ( " " , id ) if err ! = nil { return err } , err = tx . exec ( , id ) if err ! = nil { return err } , err = tx . exec ( " " , id ) return err } 
func containerconfiginsert ( tx * sql . tx , id int , config map [ string ] string ) error { str : = " " stmt , err : = tx . prepare ( str ) if err ! = nil { return err } defer stmt . close ( ) for k , v : = range config { if v == " " { continue } , err : = stmt . exec ( id , k , v ) if err ! = nil { logger . debugf ( " " , k , v , id ) return err } } return nil } 
func ( c * cluster ) containerconfigget ( id int , key string ) ( string , error ) { q : = " " value : = " " arg1 : = [ ] interface { } { id , key } arg2 : = [ ] interface { } { & value } err : = dbqueryrowscan ( c . db , q , arg1 , arg2 ) if err == sql . errnorows { return " " , errnosuchobject } return value , err } 
func ( c * cluster ) containerconfigremove ( id int , key string ) error { err : = exec ( c . db , " " , key , id ) return err } 
func ( c * cluster ) containersetstateful ( id int , stateful bool ) error { statefulint : = 0 if stateful { statefulint = 1 } err : = exec ( c . db , " " , statefulint , id ) return err } 
func containerprofilesinsert ( tx * sql . tx , id int , project string , profiles [ ] string ) error { enabled , err : = projecthasprofiles ( tx , project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! enabled { project = " " } applyorder : = 1 str : = stmt , err : = tx . prepare ( str ) if err ! = nil { return err } defer stmt . close ( ) for , profile : = range profiles { , err = stmt . exec ( id , project , profile , applyorder ) if err ! = nil { logger . debugf ( " " , profile , err ) return err } applyorder = applyorder + 1 } return nil } 
func ( c * cluster ) containerprofiles ( id int ) ( [ ] string , error ) { var name string var profiles [ ] string query : = inargs : = [ ] interface { } { id } outfmt : = [ ] interface { } { name } results , err : = queryscan ( c . db , query , inargs , outfmt ) if err ! = nil { return nil , err } for , r : = range results { name = r [ 0 ] . ( string ) profiles = append ( profiles , name ) } return profiles , nil } 
func ( c * cluster ) containerconfig ( id int ) ( map [ string ] string , error ) { var key , value string q : = ' select key , value from containers config where container id=? ' inargs : = [ ] interface { } { id } outfmt : = [ ] interface { } { key , value } results , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } config : = map [ string ] string { } for , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * cluster ) legacycontainerslist ( ctype containertype ) ( [ ] string , error ) { q : = fmt . sprintf ( " " ) inargs : = [ ] interface { } { ctype } var container string outfmt : = [ ] interface { } { container } result , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } var ret [ ] string for , container : = range result { ret = append ( ret , container [ 0 ] . ( string ) ) } return ret , nil } 
func ( c * cluster ) containersetstate ( id int , state string ) error { err : = c . transaction ( func ( tx * clustertx ) error { str : = fmt . sprintf ( " " ) stmt , err : = tx . tx . prepare ( str ) if err ! = nil { return err } defer stmt . close ( ) if , err = stmt . exec ( id , state ) ; err ! = nil { return err } return nil } ) return err } 
func containerupdate ( tx * sql . tx , id int , description string , architecture int , ephemeral bool , expirydate time . time ) error { str : = fmt . sprintf ( " " ) stmt , err : = tx . prepare ( str ) if err ! = nil { return err } defer stmt . close ( ) ephemeralint : = 0 if ephemeral { ephemeralint = 1 } if expirydate . iszero ( ) { , err = stmt . exec ( description , architecture , ephemeralint , " " , id ) } else { , err = stmt . exec ( description , architecture , ephemeralint , expirydate , id ) } if err ! = nil { return err } return nil } 
func ( c * cluster ) containerlastusedupdate ( id int , date time . time ) error { stmt : = ' update containers set last use date=? where id=? ' err : = exec ( c . db , stmt , date , id ) return err } 
func ( c * cluster ) containergetsnapshots ( project , name string ) ( [ ] string , error ) { result : = [ ] string { } regexp : = name + shared . snapshotdelimiter length : = len ( regexp ) q : = inargs : = [ ] interface { } { project , ctypesnapshot , length , regexp } outfmt : = [ ] interface { } { name } dbresults , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return result , err } for , r : = range dbresults { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil } 
func ( c * clustertx ) containergetsnapshotsfull ( project string , name string ) ( [ ] container , error ) { filter : = containerfilter { parent : name , project : project , type : int ( ctypesnapshot ) , } return c . containerlist ( filter ) } 
func ( c * cluster ) containernextsnapshot ( project string , name string , pattern string ) int { base : = name + shared . snapshotdelimiter length : = len ( base ) q : = var numstr string inargs : = [ ] interface { } { project , ctypesnapshot , length , base } outfmt : = [ ] interface { } { numstr } results , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return 0 } max : = 0 for , r : = range results { snaponlyname : = strings . splitn ( r [ 0 ] . ( string ) , shared . snapshotdelimiter , 2 ) [ 1 ] fields : = strings . splitn ( pattern , " " , 2 ) var num int count , err : = fmt . sscanf ( snaponlyname , fmt . sprintf ( " " , fields [ 0 ] , fields [ 1 ] ) , & num ) if err ! = nil | | count ! = 1 { continue } if num >= max { max = num + 1 } } return max } 
func ( c * cluster ) containerpool ( project , containername string ) ( string , error ) { var poolname string err : = c . transaction ( func ( tx * clustertx ) error { var err error poolname , err = tx . containerpool ( project , containername ) return err } ) return poolname , err } 
func ( c * clustertx ) containerpool ( project , containername string ) ( string , error ) { poolname : = " " query : = inargs : = [ ] interface { } { project , c . nodeid , containername , storagepoolvolumetypecontainer } outargs : = [ ] interface { } { & poolname } err : = c . tx . queryrow ( query , inargs ... ) . scan ( outargs ... ) if err ! = nil { if err == sql . errnorows { return " " , errnosuchobject } return " " , err } return poolname , nil } 
func ( c * cluster ) containergetbackup ( project , name string ) ( containerbackupargs , error ) { args : = containerbackupargs { } args . name = name containeronlyint : = - 1 optimizedstorageint : = - 1 q : = arg1 : = [ ] interface { } { project , name } arg2 : = [ ] interface { } { & args . id , & args . containerid , & args . creationdate , & args . expirydate , & containeronlyint , & optimizedstorageint } err : = dbqueryrowscan ( c . db , q , arg1 , arg2 ) if err ! = nil { if err == sql . errnorows { return args , errnosuchobject } return args , err } if containeronlyint == 1 { args . containeronly = true } if optimizedstorageint == 1 { args . optimizedstorage = true } return args , nil } 
func ( c * cluster ) containergetbackups ( project , name string ) ( [ ] string , error ) { var result [ ] string q : = inargs : = [ ] interface { } { project , name } outfmt : = [ ] interface { } { name } dbresults , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } for , r : = range dbresults { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil } 
func ( c * cluster ) containerbackupcreate ( args containerbackupargs ) error { , err : = c . containerbackupid ( args . name ) if err == nil { return erralreadydefined } err = c . transaction ( func ( tx * clustertx ) error { containeronlyint : = 0 if args . containeronly { containeronlyint = 1 } optimizedstorageint : = 0 if args . optimizedstorage { optimizedstorageint = 1 } str : = fmt . sprintf ( " " ) stmt , err : = tx . tx . prepare ( str ) if err ! = nil { return err } defer stmt . close ( ) result , err : = stmt . exec ( args . containerid , args . name , args . creationdate . unix ( ) , args . expirydate . unix ( ) , containeronlyint , optimizedstorageint ) if err ! = nil { return err } , err = result . lastinsertid ( ) if err ! = nil { return fmt . errorf ( " " , args . name ) } return nil } ) return err } 
func ( c * cluster ) containerbackupremove ( name string ) error { id , err : = c . containerbackupid ( name ) if err ! = nil { return err } err = exec ( c . db , " " , id ) if err ! = nil { return err } return nil } 
func ( c * cluster ) containerbackuprename ( oldname , newname string ) error { err : = c . transaction ( func ( tx * clustertx ) error { str : = fmt . sprintf ( " " ) stmt , err : = tx . tx . prepare ( str ) if err ! = nil { return err } defer stmt . close ( ) logger . debug ( " " , log . ctx { " " : " " , " " : oldname , " " : newname } ) if , err : = stmt . exec ( newname , oldname ) ; err ! = nil { return err } return nil } ) return err } 
func ( c * cluster ) containerbackupsgetexpired ( ) ( [ ] string , error ) { var result [ ] string var name string var expirydate string q : = ' select containers backups . name , containers backups . expiry date from containers backups ' outfmt : = [ ] interface { } { name , expirydate } dbresults , err : = queryscan ( c . db , q , nil , outfmt ) if err ! = nil { return nil , err } for , r : = range dbresults { timestamp : = r [ 1 ] var backupexpiry time . time err = backupexpiry . unmarshaltext ( [ ] byte ( timestamp . ( string ) ) ) if err ! = nil { return [ ] string { } , err } if backupexpiry . iszero ( ) { continue } if time . now ( ) . unix ( ) - backupexpiry . unix ( ) >= 0 { result = append ( result , r [ 0 ] . ( string ) ) } } return result , nil } 
func defaultos ( ) * os { newos : = & os { vardir : shared . varpath ( ) , cachedir : shared . cachepath ( ) , logdir : shared . logpath ( ) , } newos . inotifywatch . fd = - 1 newos . inotifywatch . targets = make ( map [ string ] * inotifytargetinfo ) return newos } 
func ( s * os ) init ( ) error { err : = s . initdirs ( ) if err ! = nil { return err } s . architectures , err = util . getarchitectures ( ) if err ! = nil { return err } s . lxcpath = filepath . join ( s . vardir , " " ) s . backingfs , err = util . filesystemdetect ( s . lxcpath ) if err ! = nil { logger . error ( " " , log . ctx { " " : err } ) } s . idmapset = util . getidmapset ( ) s . execpath = util . getexecpath ( ) s . runninginuserns = shared . runninginuserns ( ) s . initapparmor ( ) s . initcgroup ( ) return nil } 
func ( op * operation ) addhandler ( function func ( api . operation ) ) ( * eventtarget , error ) { err : = op . setuplistener ( ) if err ! = nil { return nil , err } op . handlerlock . lock ( ) defer op . handlerlock . unlock ( ) if op . statuscode . isfinal ( ) { return nil , nil } wrapped : = func ( event api . event ) { newop : = api . operation { } err : = json . unmarshal ( event . metadata , & newop ) if err ! = nil | | newop . id ! = op . id { return } function ( newop ) } return op . listener . addhandler ( [ ] string { " " } , wrapped ) } 
func ( op * operation ) getwebsocket ( secret string ) ( * websocket . conn , error ) { return op . r . getoperationwebsocket ( op . id , secret ) } 
func ( op * operation ) removehandler ( target * eventtarget ) error { op . handlerlock . lock ( ) defer op . handlerlock . unlock ( ) if op . listener == nil { return nil } return op . listener . removehandler ( target ) } 
func ( op * operation ) refresh ( ) error { newop , , err : = op . r . getoperation ( op . id ) if err ! = nil { return err } op . operation = * newop return nil } 
func ( op * operation ) wait ( ) error { if op . statuscode . isfinal ( ) { if op . err ! = " " { return fmt . errorf ( op . err ) } return nil } err : = op . setuplistener ( ) if err ! = nil { return err } < - op . chactive if op . err ! = " " { return fmt . errorf ( op . err ) } return nil } 
func ( op * remoteoperation ) addhandler ( function func ( api . operation ) ) ( * eventtarget , error ) { var err error var target * eventtarget if op . targetop ! = nil { target , err = op . targetop . addhandler ( function ) if err ! = nil { return nil , err } } else { target = & eventtarget { function : func ( api . event ) { function ( api . operation { } ) } , types : [ ] string { " " } , } } op . handlers = append ( op . handlers , function ) return target , nil } 
func ( op * remoteoperation ) canceltarget ( ) error { if op . targetop == nil { return fmt . errorf ( " " ) } return op . targetop . cancel ( ) } 
func ( op * remoteoperation ) gettarget ( ) ( * api . operation , error ) { if op . targetop == nil { return nil , fmt . errorf ( " " ) } opapi : = op . targetop . get ( ) return & opapi , nil } 
func ( op * remoteoperation ) wait ( ) error { < - op . chdone if op . chpost ! = nil { < - op . chpost } return op . err } 
func activatedlisteners ( systemdlisteners [ ] net . listener , cert * shared . certinfo ) map [ kind ] net . listener { listeners : = map [ kind ] net . listener { } for , listener : = range systemdlisteners { var kind kind switch listener . ( type ) { case * net . unixlistener : kind = local case * net . tcplistener : kind = network listener = networktlslistener ( listener , cert ) default : continue } listeners [ kind ] = listener } return listeners } 
func ( c * config ) candidserver ( ) ( string , string , int64 , string ) { return c . m . getstring ( " " ) , c . m . getstring ( " " ) , c . m . getint64 ( " " ) , c . m . getstring ( " " ) } 
func ( c * config ) rbacserver ( ) ( string , string , int64 , string , string , string , string ) { return c . m . getstring ( " " ) , c . m . getstring ( " " ) , c . m . getint64 ( " " ) , c . m . getstring ( " " ) , c . m . getstring ( " " ) , c . m . getstring ( " " ) , c . m . getstring ( " " ) } 
func ( c * config ) autoupdateinterval ( ) time . duration { n : = c . m . getint64 ( " " ) return time . duration ( n ) * time . hour } 
func ( c * config ) maascontroller ( ) ( string , string ) { url : = c . m . getstring ( " " ) key : = c . m . getstring ( " " ) return url , key } 
func ( c * config ) offlinethreshold ( ) time . duration { n : = c . m . getint64 ( " " ) return time . duration ( n ) * time . second } 
func configgetstring ( cluster * db . cluster , key string ) ( string , error ) { config , err : = configget ( cluster ) if err ! = nil { return " " , err } return config . m . getstring ( key ) , nil } 
func configgetbool ( cluster * db . cluster , key string ) ( bool , error ) { config , err : = configget ( cluster ) if err ! = nil { return false , err } return config . m . getbool ( key ) , nil } 
func configgetint64 ( cluster * db . cluster , key string ) ( int64 , error ) { config , err : = configget ( cluster ) if err ! = nil { return 0 , err } return config . m . getint64 ( key ) , nil } 
func ( e * endpoints ) clusteraddress ( ) string { e . mu . rlock ( ) defer e . mu . runlock ( ) listener : = e . listeners [ cluster ] if listener == nil { return " " } return listener . addr ( ) . string ( ) } 
func debug ( msg string , ctx ... interface { } ) { if log ! = nil { pc , fn , line , : = runtime . caller ( 1 ) msg : = fmt . sprintf ( " " , fn , line , runtime . funcforpc ( pc ) . name ( ) , msg ) log . debug ( msg , ctx ... ) } } 
func infof ( format string , args ... interface { } ) { if log ! = nil { msg : = fmt . sprintf ( format , args ... ) pc , fn , line , : = runtime . caller ( 1 ) msg = fmt . sprintf ( " " , fn , line , runtime . funcforpc ( pc ) . name ( ) , msg ) log . info ( msg ) } } 
func projectparam ( request * http . request ) string { project : = queryparam ( request , " " ) if project == " " { project = " " } return project } 
func queryparam ( request * http . request , key string ) string { var values url . values var err error if request . url ! = nil { values , err = url . parsequery ( request . url . rawquery ) if err ! = nil { logger . warnf ( " " , request . url . rawquery , err ) return " " } } if values == nil { values = make ( url . values ) } return values . get ( key ) } 
func newdb ( ) * cobra . command { cmd : = & cobra . command { use : " " , short : " " , rune : func ( cmd * cobra . command , args [ ] string ) error { return fmt . errorf ( " " ) } , } cmd . addcommand ( newdbschema ( ) ) cmd . addcommand ( newdbmapper ( ) ) return cmd } 
func ( t operationtype ) description ( ) string { switch t { case operationclusterbootstrap : return " " case operationclusterjoin : return " " case operationbackupcreate : return " " case operationbackuprename : return " " case operationbackuprestore : return " " case operationbackupremove : return " " case operationconsoleshow : return " " case operationcontainercreate : return " " case operationcontainerupdate : return " " case operationcontainerrename : return " " case operationcontainermigrate : return " " case operationcontainerlivemigrate : return " " case operationcontainerfreeze : return " " case operationcontainerunfreeze : return " " case operationcontainerdelete : return " " case operationcontainerstart : return " " case operationcontainerstop : return " " case operationcontainerrestart : return " " case operationcommandexec : return " " case operationsnapshotcreate : return " " case operationsnapshotrename : return " " case operationsnapshotrestore : return " " case operationsnapshottransfer : return " " case operationsnapshotupdate : return " " case operationsnapshotdelete : return " " case operationimagedownload : return " " case operationimagedelete : return " " case operationimagetoken : return " " case operationimagerefresh : return " " case operationvolumecopy : return " " case operationvolumecreate : return " " case operationvolumemigrate : return " " case operationvolumemove : return " " case operationvolumesnapshotcreate : return " " case operationvolumesnapshotdelete : return " " case operationvolumesnapshotupdate : return " " case operationprojectrename : return " " case operationimagesexpire : return " " case operationimagespruneleftover : return " " case operationimagesupdate : return " " case operationimagessynchronize : return " " case operationlogsexpire : return " " case operationinstancetypesupdate : return " " case operationbackupsexpire : return " " case operationsnapshotsexpire : return " " default : return " " } } 
func ( t operationtype ) permission ( ) string { switch t { case operationbackupcreate : return " " case operationbackuprename : return " " case operationbackuprestore : return " " case operationbackupremove : return " " case operationconsoleshow : return " " case operationcontainerfreeze : return " " case operationcontainerunfreeze : return " " case operationcontainerstart : return " " case operationcontainerstop : return " " case operationcontainerrestart : return " " case operationcommandexec : return " " case operationsnapshotcreate : return " " case operationsnapshotrename : return " " case operationsnapshottransfer : return " " case operationsnapshotupdate : return " " case operationsnapshotdelete : return " " case operationcontainercreate : return " " case operationcontainerupdate : return " " case operationcontainerrename : return " " case operationcontainermigrate : return " " case operationcontainerlivemigrate : return " " case operationcontainerdelete : return " " case operationsnapshotrestore : return " " case operationimagedownload : return " " case operationimagedelete : return " " case operationimagetoken : return " " case operationimagerefresh : return " " case operationimagesupdate : return " " case operationimagessynchronize : return " " } return " " } 
func ( c * clustertx ) operationsuuids ( ) ( [ ] string , error ) { stmt : = " " return query . selectstrings ( c . tx , stmt , c . nodeid ) } 
func ( c * clustertx ) operationnodes ( project string ) ( [ ] string , error ) { stmt : = return query . selectstrings ( c . tx , stmt , project ) } 
func ( c * clustertx ) operationbyuuid ( uuid string ) ( operation , error ) { null : = operation { } operations , err : = c . operations ( " " , uuid ) if err ! = nil { return null , err } switch len ( operations ) { case 0 : return null , errnosuchobject case 1 : return operations [ 0 ] , nil default : return null , fmt . errorf ( " " ) } } 
func ( c * clustertx ) operationadd ( project , uuid string , typ operationtype ) ( int64 , error ) { var projectid interface { } if project ! = " " { var err error projectid , err = c . projectid ( project ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } } else { projectid = nil } columns : = [ ] string { " " , " " , " " , " " } values : = [ ] interface { } { uuid , c . nodeid , typ , projectid } return query . upsertobject ( c . tx , " " , columns , values ) } 
func ( c * clustertx ) operationremove ( uuid string ) error { result , err : = c . tx . exec ( " " , uuid ) if err ! = nil { return err } n , err : = result . rowsaffected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) operations ( where string , args ... interface { } ) ( [ ] operation , error ) { operations : = [ ] operation { } dest : = func ( i int ) [ ] interface { } { operations = append ( operations , operation { } ) return [ ] interface { } { & operations [ i ] . id , & operations [ i ] . uuid , & operations [ i ] . nodeaddress , & operations [ i ] . type , } } sql : = if where ! = " " { sql += fmt . sprintf ( " " , where ) } sql += " " stmt , err : = c . tx . prepare ( sql ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest , args ... ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return operations , nil } 
func expirelogstask ( state * state . state ) ( task . func , task . schedule ) { f : = func ( ctx context . context ) { oprun : = func ( op * operation ) error { return expirelogs ( ctx , state ) } op , err : = operationcreate ( state . cluster , " " , operationclasstask , db . operationlogsexpire , nil , nil , oprun , nil , nil ) if err ! = nil { logger . error ( " " , log . ctx { " " : err } ) return } logger . infof ( " " ) , err = op . run ( ) if err ! = nil { logger . error ( " " , log . ctx { " " : err } ) } logger . infof ( " " ) } return f , task . daily ( ) } 
func abspath ( path string ) string { , filename , , : = runtime . caller ( 1 ) elems : = strings . split ( filename , string ( filepath . separator ) ) for i : = len ( elems ) - 1 ; i >= 0 ; i -- { if elems [ i ] == " " { elems = append ( [ ] string { string ( filepath . separator ) } , elems [ : i ] ... ) elems = append ( elems , path ) return filepath . join ( elems ... ) } } log . fatalf ( " " ) return " " } 
func ( s schema ) keys ( ) [ ] string { keys : = make ( [ ] string , len ( s ) ) i : = 0 for key : = range s { keys [ i ] = key i ++ } sort . strings ( keys ) return keys } 
func ( s schema ) defaults ( ) map [ string ] interface { } { values : = make ( map [ string ] interface { } , len ( s ) ) for name , key : = range s { values [ name ] = key . default } return values } 
func ( s schema ) mustgetkey ( name string ) key { key , ok : = s [ name ] if ! ok { panic ( fmt . sprintf ( " " , name ) ) } return key } 
func ( s schema ) assertkeytype ( name string , code type ) { key : = s . mustgetkey ( name ) if key . type ! = code { panic ( fmt . sprintf ( " " , name , key . type , code ) ) } } 
func ( v * key ) validate ( value string ) error { validator : = v . validator if validator == nil { validator = func ( string ) error { return nil } } if value == " " { return validator ( v . default ) } switch v . type { case string : case bool : if ! shared . stringinslice ( strings . tolower ( value ) , booleans ) { return fmt . errorf ( " " ) } case int64 : , err : = strconv . parseint ( value , 10 , 64 ) if err ! = nil { return fmt . errorf ( " " ) } default : panic ( fmt . sprintf ( " " , v . type ) ) } if v . deprecated ! = " " && value ! = v . default { return fmt . errorf ( " " , v . deprecated ) } return validator ( value ) } 
func ( r * protocollxd ) getstoragepoolvolumes ( pool string ) ( [ ] api . storagevolume , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } volumes : = [ ] api . storagevolume { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( pool ) ) , nil , " " , & volumes ) if err ! = nil { return nil , err } return volumes , nil } 
func ( r * protocollxd ) getstoragepoolvolume ( pool string , voltype string , name string ) ( * api . storagevolume , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } volume : = api . storagevolume { } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( voltype ) , url . queryescape ( name ) ) etag , err : = r . querystruct ( " " , path , nil , " " , & volume ) if err ! = nil { return nil , " " , err } return & volume , etag , nil } 
func ( r * protocollxd ) createstoragepoolvolume ( pool string , volume api . storagevolumespost ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( volume . type ) ) , , err : = r . query ( " " , path , volume , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) createstoragepoolvolumesnapshot ( pool string , volumetype string , volumename string , snapshot api . storagevolumesnapshotspost ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( volumetype ) , url . queryescape ( volumename ) ) op , , err : = r . queryoperation ( " " , path , snapshot , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) getstoragepoolvolumesnapshots ( pool string , volumetype string , volumename string ) ( [ ] api . storagevolumesnapshot , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } snapshots : = [ ] api . storagevolumesnapshot { } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( volumetype ) , url . queryescape ( volumename ) ) , err : = r . querystruct ( " " , path , nil , " " , & snapshots ) if err ! = nil { return nil , err } return snapshots , nil } 
func ( r * protocollxd ) getstoragepoolvolumesnapshot ( pool string , volumetype string , volumename string , snapshotname string ) ( * api . storagevolumesnapshot , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } snapshot : = api . storagevolumesnapshot { } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( volumetype ) , url . queryescape ( volumename ) , url . queryescape ( snapshotname ) ) etag , err : = r . querystruct ( " " , path , nil , " " , & snapshot ) if err ! = nil { return nil , " " , err } return & snapshot , etag , nil } 
func ( r * protocollxd ) updatestoragepoolvolumesnapshot ( pool string , volumetype string , volumename string , snapshotname string , volume api . storagevolumesnapshotput , etag string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( volumetype ) , url . queryescape ( volumename ) , url . queryescape ( snapshotname ) ) , , err : = r . queryoperation ( " " , path , volume , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) migratestoragepoolvolume ( pool string , volume api . storagevolumepost ) ( operation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } if ! volume . migration { return nil , fmt . errorf ( " " ) } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , volume . name ) op , , err : = r . queryoperation ( " " , path , volume , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * protocollxd ) movestoragepoolvolume ( pool string , source containerserver , sourcepool string , volume api . storagevolume , args * storagepoolvolumemoveargs ) ( remoteoperation , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } if r ! = source { return nil , fmt . errorf ( " " ) } req : = api . storagevolumepost { name : args . name , pool : pool , } op , , err : = r . queryoperation ( " " , fmt . sprintf ( " " , url . queryescape ( sourcepool ) , url . queryescape ( volume . type ) , volume . name ) , req , " " ) if err ! = nil { return nil , err } rop : = remoteoperation { targetop : op , chdone : make ( chan bool ) , } go func ( ) { rop . err = rop . targetop . wait ( ) close ( rop . chdone ) } ( ) return & rop , nil } 
func ( r * protocollxd ) updatestoragepoolvolume ( pool string , voltype string , name string , volume api . storagevolumeput , etag string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } if volume . restore ! = " " && ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( voltype ) , url . queryescape ( name ) ) , , err : = r . query ( " " , path , volume , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) deletestoragepoolvolume ( pool string , voltype string , name string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( voltype ) , url . queryescape ( name ) ) , , err : = r . query ( " " , path , nil , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) renamestoragepoolvolume ( pool string , voltype string , name string , volume api . storagevolumepost ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } path : = fmt . sprintf ( " " , url . queryescape ( pool ) , url . queryescape ( voltype ) , url . queryescape ( name ) ) , , err : = r . query ( " " , path , volume , " " ) if err ! = nil { return err } return nil } 
func dostoragepoolcreateinternal ( state * state . state , poolname , pooldescription string , driver string , config map [ string ] string , isnotification bool ) error { tryundo : = true s , err : = storagepoolinit ( state , poolname ) if err ! = nil { return err } if s , ok : = s . ( * storageceph ) ; ok && isnotification { volumemntpoint : = getstoragepoolvolumemountpoint ( s . pool . name , s . volume . name ) return os . mkdirall ( volumemntpoint , 0711 ) } err = s . storagepoolcreate ( ) if err ! = nil { return err } defer func ( ) { if ! tryundo { return } s . storagepooldelete ( ) } ( ) postcreateconfig : = s . getstoragepoolwritable ( ) . config configdiff , : = storageconfigdiff ( config , postcreateconfig ) if len ( configdiff ) > 0 { err = state . cluster . storagepoolupdate ( poolname , pooldescription , postcreateconfig ) if err ! = nil { return fmt . errorf ( " " , poolname , err ) } } tryundo = false return nil } 
func dbstoragepoolcreateandupdatecache ( db * db . cluster , poolname string , pooldescription string , pooldriver string , poolconfig map [ string ] string ) ( int64 , error ) { id , err : = db . storagepoolcreate ( poolname , pooldescription , pooldriver , poolconfig ) if err ! = nil { return id , err } storagepooldriverscacheupdate ( db ) return id , nil } 
func dbstoragepooldeleteandupdatecache ( db * db . cluster , poolname string ) error { , err : = db . storagepooldelete ( poolname ) if err ! = nil { return err } storagepooldriverscacheupdate ( db ) return err } 
func containergetparentandsnapshotname ( name string ) ( string , string , bool ) { fields : = strings . splitn ( name , shared . snapshotdelimiter , 2 ) if len ( fields ) == 1 { return name , " " , false } return fields [ 0 ] , fields [ 1 ] , true } 
func containerloadfromallprojects ( s * state . state ) ( [ ] container , error ) { var projects [ ] string err : = s . cluster . transaction ( func ( tx * db . clustertx ) error { var err error projects , err = tx . projectnames ( ) return err } ) if err ! = nil { return nil , err } containers : = [ ] container { } for , project : = range projects { projectcontainers , err : = containerloadbyproject ( s , project ) if err ! = nil { return nil , errors . wrapf ( nil , " " , project ) } containers = append ( containers , projectcontainers ... ) } return containers , nil } 
func containerloadnodeall ( s * state . state ) ( [ ] container , error ) { var cts [ ] db . container err : = s . cluster . transaction ( func ( tx * db . clustertx ) error { var err error cts , err = tx . containernodelist ( ) if err ! = nil { return err } return nil } ) if err ! = nil { return nil , err } return containerloadallinternal ( cts , s ) } 
func containerloadnodeprojectall ( s * state . state , project string ) ( [ ] container , error ) { var cts [ ] db . container err : = s . cluster . transaction ( func ( tx * db . clustertx ) error { var err error cts , err = tx . containernodeprojectlist ( project ) if err ! = nil { return err } return nil } ) if err ! = nil { return nil , err } return containerloadallinternal ( cts , s ) } 
func heartbeatnode ( taskctx context . context , address string , cert * shared . certinfo , raftnodes [ ] db . raftnode ) error { logger . debugf ( " " , address ) config , err : = tlsclientconfig ( cert ) if err ! = nil { return err } url : = fmt . sprintf ( " " , address , databaseendpoint ) client : = & http . client { transport : & http . transport { tlsclientconfig : config } } buffer : = bytes . buffer { } err = json . newencoder ( & buffer ) . encode ( raftnodes ) if err ! = nil { return err } request , err : = http . newrequest ( " " , url , bytes . newreader ( buffer . bytes ( ) ) ) if err ! = nil { return err } ctx , cancel : = context . withtimeout ( context . background ( ) , 2 * time . second ) defer cancel ( ) request = request . withcontext ( ctx ) request . close = true errch : = make ( chan error ) go func ( ) { response , err : = client . do ( request ) if err ! = nil { errch < - errors . wrap ( err , " " ) return } defer response . body . close ( ) if response . statuscode ! = http . statusok { errch < - fmt . errorf ( " " , response . status ) return } errch < - nil } ( ) select { case err : = < - errch : return err case < - taskctx . done ( ) : return taskctx . err ( ) } } 
func ( c * cmdlist ) dotprefixmatch ( short string , full string ) bool { fullmembs : = strings . split ( full , " " ) shortmembs : = strings . split ( short , " " ) if len ( fullmembs ) ! = len ( shortmembs ) { return false } for i : = range fullmembs { if ! strings . hasprefix ( fullmembs [ i ] , shortmembs [ i ] ) { return false } } return true } 
func ( s * storagezfs ) storagecoreinit ( ) error { s . stype = storagetypezfs typename , err : = storagetypetostring ( s . stype ) if err ! = nil { return err } s . stypename = typename if zfsversion ! = " " { s . stypeversion = zfsversion return nil } util . loadmodule ( " " ) if ! zfsisenabled ( ) { return fmt . errorf ( " " " " ) } s . stypeversion , err = zfstoolversionget ( ) if err ! = nil { s . stypeversion , err = zfsmoduleversionget ( ) if err ! = nil { return err } } zfsversion = s . stypeversion return nil } 
func ( s * storagezfs ) storagepoolinit ( ) error { err : = s . storagecoreinit ( ) if err ! = nil { return err } if s . pool . config [ " " ] ! = " " { s . dataset = s . pool . config [ " " ] } return nil } 
func ( s * storagezfs ) containermount ( c container ) ( bool , error ) { return s . docontainermount ( c . project ( ) , c . name ( ) , c . isprivileged ( ) ) } 
func ( s * storagezfs ) containerstorageready ( container container ) bool { volumename : = projectprefix ( container . project ( ) , container . name ( ) ) fs : = fmt . sprintf ( " " , volumename ) return zfsfilesystementityexists ( s . getondiskpoolname ( ) , fs ) } 
func askbool ( question string , defaultanswer string ) bool { for { answer : = askquestion ( question , defaultanswer ) if shared . stringinslice ( strings . tolower ( answer ) , [ ] string { " " , " " } ) { return true } else if shared . stringinslice ( strings . tolower ( answer ) , [ ] string { " " , " " } ) { return false } invalidinput ( ) } } 
func askchoice ( question string , choices [ ] string , defaultanswer string ) string { for { answer : = askquestion ( question , defaultanswer ) if shared . stringinslice ( answer , choices ) { return answer } invalidinput ( ) } } 
func askint ( question string , min int64 , max int64 , defaultanswer string ) int64 { for { answer : = askquestion ( question , defaultanswer ) result , err : = strconv . parseint ( answer , 10 , 64 ) if err == nil && ( min == - 1 | | result >= min ) && ( max == - 1 | | result <= max ) { return result } invalidinput ( ) } } 
func askstring ( question string , defaultanswer string , validate func ( string ) error ) string { for { answer : = askquestion ( question , defaultanswer ) if validate ! = nil { error : = validate ( answer ) if error ! = nil { fmt . fprintf ( os . stderr , " \n \n " , error ) continue } return answer } if len ( answer ) ! = 0 { return answer } invalidinput ( ) } } 
func askpassword ( question string ) string { for { fmt . printf ( question ) pwd , : = terminal . readpassword ( 0 ) fmt . println ( " " ) infirst : = string ( pwd ) infirst = strings . trimsuffix ( infirst , " \n " ) fmt . printf ( " " ) pwd , = terminal . readpassword ( 0 ) fmt . println ( " " ) insecond : = string ( pwd ) insecond = strings . trimsuffix ( insecond , " \n " ) if infirst == insecond { return infirst } invalidinput ( ) } } 
func askpasswordonce ( question string ) string { fmt . printf ( question ) pwd , : = terminal . readpassword ( 0 ) fmt . println ( " " ) return string ( pwd ) } 
func askquestion ( question , defaultanswer string ) string { fmt . printf ( question ) return readanswer ( defaultanswer ) } 
func readanswer ( defaultanswer string ) string { answer , : = stdin . readstring ( ' \n ' ) answer = strings . trimsuffix ( answer , " \n " ) answer = strings . trimspace ( answer ) if answer == " " { answer = defaultanswer } return answer } 
func profilesget ( d * daemon , r * http . request ) response { project : = projectparam ( r ) recursion : = util . isrecursionrequest ( r ) var result interface { } err : = d . cluster . transaction ( func ( tx * db . clustertx ) error { hasprofiles , err : = tx . projecthasprofiles ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! hasprofiles { project = " " } filter : = db . profilefilter { project : project , } if recursion { profiles , err : = tx . profilelist ( filter ) if err ! = nil { return err } apiprofiles : = make ( [ ] * api . profile , len ( profiles ) ) for i , profile : = range profiles { apiprofiles [ i ] = db . profiletoapi ( & profile ) } result = apiprofiles } else { result , err = tx . profileuris ( filter ) } return err } ) if err ! = nil { return smarterror ( err ) } return syncresponse ( true , result ) } 
func profiledelete ( d * daemon , r * http . request ) response { project : = projectparam ( r ) name : = mux . vars ( r ) [ " " ] if name == " " { return forbidden ( errors . new ( " " ) ) } err : = d . cluster . transaction ( func ( tx * db . clustertx ) error { hasprofiles , err : = tx . projecthasprofiles ( project ) if err ! = nil { return errors . wrap ( err , " " ) } if ! hasprofiles { project = " " } profile , err : = tx . profileget ( project , name ) if err ! = nil { return err } if len ( profile . usedby ) > 0 { return fmt . errorf ( " " ) } return tx . profiledelete ( project , name ) } ) if err ! = nil { return smarterror ( err ) } return emptysyncresponse } 
func isrootdiskdevice ( device map [ string ] string ) bool { if device [ " " ] == " " && device [ " " ] == " " && device [ " " ] == " " { return true } return false } 
func getrootdiskdevice ( devices map [ string ] map [ string ] string ) ( string , map [ string ] string , error ) { var devname string var dev map [ string ] string for n , d : = range devices { if isrootdiskdevice ( d ) { if devname ! = " " { return " " , nil , fmt . errorf ( " " ) } devname = n dev = d } } if devname ! = " " { return devname , dev , nil } return " " , nil , fmt . errorf ( " " ) } 
func configkeychecker ( key string ) ( func ( value string ) error , error ) { if f , ok : = knowncontainerconfigkeys [ key ] ; ok { return f , nil } if strings . hasprefix ( key , " " ) { if strings . hassuffix ( key , " " ) { return isany , nil } if strings . hassuffix ( key , " " ) { return isany , nil } if strings . hassuffix ( key , " " ) { return isany , nil } } if strings . hasprefix ( key , " " ) { return isany , nil } if strings . hasprefix ( key , " " ) { return isany , nil } if strings . hasprefix ( key , " " ) { return isany , nil } if strings . hasprefix ( key , " " ) && ( len ( key ) > len ( " " ) ) { return isany , nil } return nil , fmt . errorf ( " " , key ) } 
func forwardedresponse ( client lxd . containerserver , request * http . request ) response { return & forwardedresponse { client : client , request : request , } } 
func forwardedresponseiftargetisremote ( d * daemon , request * http . request ) response { targetnode : = queryparam ( request , " " ) if targetnode == " " { return nil } address , err : = cluster . resolvetarget ( d . cluster , targetnode ) if err ! = nil { return smarterror ( err ) } if address ! = " " { cert : = d . endpoints . networkcert ( ) client , err : = cluster . connect ( address , cert , false ) if err ! = nil { return smarterror ( err ) } return forwardedresponse ( client , request ) } return nil } 
func forwardedresponseifcontainerisremote ( d * daemon , r * http . request , project , name string ) ( response , error ) { cert : = d . endpoints . networkcert ( ) client , err : = cluster . connectifcontainerisremote ( d . cluster , project , name , cert ) if err ! = nil { return nil , err } if client == nil { return nil , nil } return forwardedresponse ( client , r ) , nil } 
func forwardedresponseifvolumeisremote ( d * daemon , r * http . request , poolid int64 , volumename string , volumetype int ) response { if queryparam ( r , " " ) ! = " " { return nil } cert : = d . endpoints . networkcert ( ) client , err : = cluster . connectifvolumeisremote ( d . cluster , poolid , volumename , volumetype , cert ) if err ! = nil && err ! = db . errnosuchobject { return smarterror ( err ) } if client == nil { return nil } return forwardedresponse ( client , r ) } 
func forwardedoperationresponse ( project string , op * api . operation ) response { return & forwardedoperationresponse { op : op , project : project , } } 
func smarterror ( err error ) response { switch errors . cause ( err ) { case nil : return emptysyncresponse case os . errnotexist , sql . errnorows , db . errnosuchobject : return notfound ( nil ) case os . errpermission : return forbidden ( nil ) case db . erralreadydefined , sqlite3 . errconstraintunique : return conflict ( nil ) case dqlite . errnoavailableleader : return unavailable ( err ) default : return internalerror ( err ) } } 
func keyvalue ( s string ) ( string , string , error ) { parts : = strings . split ( s , " " ) if len ( parts ) ! = 2 { return " " , " " , fmt . errorf ( " " , s ) } return parts [ 0 ] , parts [ 1 ] , nil } 
func ( p * progressrenderer ) done ( msg string ) { p . lock . lock ( ) defer p . lock . unlock ( ) if p . done { return } p . done = true if p . quiet { msg = " " } msg = p . truncate ( msg ) if msg == " " && p . maxlength == 0 { return } if msg ! = " " { msg += " \n " } if len ( msg ) > p . maxlength { p . maxlength = len ( msg ) } else { fmt . printf ( " " , strings . repeat ( " " , p . maxlength ) ) } fmt . print ( " " ) fmt . print ( msg ) } 
func ( p * progressrenderer ) update ( status string ) { timeout : = p . wait . sub ( time . now ( ) ) if timeout . seconds ( ) > 0 { time . sleep ( timeout ) } p . lock . lock ( ) defer p . lock . unlock ( ) if p . done { return } if p . quiet { return } if p . terminal == 0 { if ! termios . isterminal ( int ( os . stdout . fd ( ) ) ) { p . terminal = - 1 } p . terminal = 1 } if p . terminal ! = 1 { return } msg : = " " if p . format ! = " " { msg = p . format } msg = fmt . sprintf ( msg , status ) msg = " " + p . truncate ( msg ) if len ( msg ) == 1 && p . maxlength == 0 { return } if len ( msg ) > p . maxlength { p . maxlength = len ( msg ) } else { fmt . printf ( " " , strings . repeat ( " " , p . maxlength ) ) } fmt . print ( msg ) } 
func ( p * progressrenderer ) warn ( status string , timeout time . duration ) { p . lock . lock ( ) defer p . lock . unlock ( ) if p . done { return } p . wait = time . now ( ) . add ( timeout ) msg : = fmt . sprintf ( " " , status ) msg = " " + p . truncate ( msg ) if len ( msg ) == 1 && p . maxlength == 0 { return } if len ( msg ) > p . maxlength { p . maxlength = len ( msg ) } else { fmt . printf ( " " , strings . repeat ( " " , p . maxlength ) ) } fmt . print ( msg ) } 
func ( p * progressrenderer ) updateprogress ( progress ioprogress . progressdata ) { p . update ( progress . text ) } 
func ( p * progressrenderer ) updateop ( op api . operation ) { if op . metadata == nil { return } for key , value : = range op . metadata { if ! strings . hassuffix ( key , " " ) { continue } p . update ( value . ( string ) ) break } } 
func localcreatelistener ( path string , group string ) ( net . listener , error ) { err : = checkalreadyrunning ( path ) if err ! = nil { return nil , err } err = socketunixremovestale ( path ) if err ! = nil { return nil , err } listener , err : = socketunixlisten ( path ) if err ! = nil { return nil , err } err = localsetaccess ( path , group ) if err ! = nil { listener . close ( ) return nil , err } return listener , nil } 
func localsetaccess ( path string , group string ) error { err : = socketunixsetpermissions ( path , 0660 ) if err ! = nil { return err } err = socketunixsetownership ( path , group ) if err ! = nil { return err } return nil } 
func newstmt ( database , pkg , entity , kind string , config map [ string ] string ) ( * stmt , error ) { packages , err : = packages ( ) if err ! = nil { return nil , err } stmt : = & stmt { db : database , pkg : pkg , entity : entity , kind : kind , config : config , packages : packages , } return stmt , nil } 
func ( s * stmt ) generate ( buf * file . buffer ) error { if strings . hasprefix ( s . kind , " " ) { return s . objects ( buf ) } if strings . hasprefix ( s . kind , " " ) && strings . hassuffix ( s . kind , " " ) { return s . createref ( buf ) } if strings . hassuffix ( s . kind , " " ) | | strings . contains ( s . kind , " " ) { return s . ref ( buf ) } if strings . hasprefix ( s . kind , " " ) { return s . names ( buf ) } switch s . kind { case " " : return s . create ( buf ) case " " : return s . id ( buf ) case " " : return s . rename ( buf ) case " " : return s . update ( buf ) case " " : return s . delete ( buf ) default : return fmt . errorf ( " " , s . kind ) } } 
func ( s * stmt ) register ( buf * file . buffer , sql string , filters ... string ) { kind : = strings . replace ( s . kind , " " , " " , - 1 ) if kind == " " { kind = " " } buf . l ( " \n \n " , stmtcodevar ( s . entity , kind , filters ... ) , s . db , sql ) } 
func connectlxdunix ( path string , args * connectionargs ) ( containerserver , error ) { logger . debugf ( " " ) if args == nil { args = & connectionargs { } } server : = protocollxd { httphost : " " , httpunixpath : path , httpprotocol : " " , httpuseragent : args . useragent , } if path == " " { path = os . getenv ( " " ) if path == " " { lxddir : = os . getenv ( " " ) if lxddir == " " { lxddir = " " } path = filepath . join ( lxddir , " " ) } } httpclient , err : = unixhttpclient ( args . httpclient , path ) if err ! = nil { return nil , err } server . http = httpclient if ! args . skipgetserver { serverstatus , , err : = server . getserver ( ) if err ! = nil { return nil , err } server . httpcertificate = serverstatus . environment . certificate } return & server , nil } 
func httpslxd ( url string , args * connectionargs ) ( containerserver , error ) { if args == nil { args = & connectionargs { } } server : = protocollxd { httpcertificate : args . tlsservercert , httphost : url , httpprotocol : " " , httpuseragent : args . useragent , bakeryinteractor : args . authinteractor , } if args . authtype == " " { server . requireauthenticated ( true ) } httpclient , err : = tlshttpclient ( args . httpclient , args . tlsclientcert , args . tlsclientkey , args . tlsca , args . tlsservercert , args . insecureskipverify , args . proxy ) if err ! = nil { return nil , err } if args . cookiejar ! = nil { httpclient . jar = args . cookiejar } server . http = httpclient if args . authtype == " " { server . setupbakeryclient ( ) } if ! args . skipgetserver { , , err : = server . getserver ( ) if err ! = nil { return nil , err } } return & server , nil } 
func moveclustercontainer ( conf * config . config , sourceresource , destresource , target string ) error { sourceremote , sourcename , err : = conf . parseremote ( sourceresource ) if err ! = nil { return err } , destname , err : = conf . parseremote ( destresource ) if err ! = nil { return err } if sourcename == " " { return fmt . errorf ( i18n . g ( " " ) ) } if destname == " " { destname = sourcename } source , err : = conf . getcontainerserver ( sourceremote ) if err ! = nil { return errors . wrap ( err , i18n . g ( " " ) ) } if ! source . isclustered ( ) { return fmt . errorf ( i18n . g ( " " ) ) } source = source . usetarget ( target ) req : = api . containerpost { name : destname , migration : true } op , err : = source . migratecontainer ( sourcename , req ) if err ! = nil { return errors . wrap ( err , i18n . g ( " " ) ) } err = op . wait ( ) if err ! = nil { return errors . wrap ( err , i18n . g ( " " ) ) } return nil } 
func ( c container ) isactive ( ) bool { switch c . statuscode { case stopped : return false case error : return false default : return true } } 
func ( n * nodetx ) raftnodes ( ) ( [ ] raftnode , error ) { nodes : = [ ] raftnode { } dest : = func ( i int ) [ ] interface { } { nodes = append ( nodes , raftnode { } ) return [ ] interface { } { & nodes [ i ] . id , & nodes [ i ] . address } } stmt , err : = n . tx . prepare ( " " ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return nodes , nil } 
func ( n * nodetx ) raftnodeaddress ( id int64 ) ( string , error ) { stmt : = " " addresses , err : = query . selectstrings ( n . tx , stmt , id ) if err ! = nil { return " " , err } switch len ( addresses ) { case 0 : return " " , errnosuchobject case 1 : return addresses [ 0 ] , nil default : return " " , fmt . errorf ( " " ) } } 
func ( n * nodetx ) raftnodefirst ( address string ) error { columns : = [ ] string { " " , " " } values : = [ ] interface { } { int64 ( 1 ) , address } id , err : = query . upsertobject ( n . tx , " " , columns , values ) if err ! = nil { return err } if id ! = 1 { return fmt . errorf ( " " ) } return nil } 
func ( n * nodetx ) raftnodeadd ( address string ) ( int64 , error ) { columns : = [ ] string { " " } values : = [ ] interface { } { address } return query . upsertobject ( n . tx , " " , columns , values ) } 
func ( n * nodetx ) raftnodedelete ( id int64 ) error { deleted , err : = query . deleteobject ( n . tx , " " , id ) if err ! = nil { return err } if ! deleted { return errnosuchobject } return nil } 
func ( n * nodetx ) raftnodesreplace ( nodes [ ] raftnode ) error { , err : = n . tx . exec ( " " ) if err ! = nil { return err } columns : = [ ] string { " " , " " } for , node : = range nodes { values : = [ ] interface { } { node . id , node . address } , err : = query . upsertobject ( n . tx , " " , columns , values ) if err ! = nil { return err } } return nil } 
func ( s * os ) initcgroup ( ) { flags : = [ ] * bool { & s . cgroupblkiocontroller , & s . cgroupcpucontroller , & s . cgroupcpuacctcontroller , & s . cgroupcpusetcontroller , & s . cgroupdevicescontroller , & s . cgroupfreezercontroller , & s . cgroupmemorycontroller , & s . cgroupnetpriocontroller , & s . cgrouppidscontroller , & s . cgroupswapaccounting , } for i , flag : = range flags { * flag = shared . pathexists ( " " + cgroups [ i ] . path ) if ! * flag { logger . warnf ( cgroups [ i ] . warn ) } } } 
func sqlitedirectaccess ( conn * sqlite3 . sqliteconn ) error { , err : = conn . exec ( " " , nil ) if err ! = nil { return err } , err = conn . exec ( " " , nil ) if err ! = nil { return err } , err = conn . exec ( " " , nil ) if err ! = nil { return err } return nil } 
func ( c * clustertx ) containerget ( project string , name string ) ( * container , error ) { filter : = containerfilter { } filter . project = project filter . name = name filter . type = - 1 objects , err : = c . containerlist ( filter ) if err ! = nil { return nil , errors . wrap ( err , " " ) } switch len ( objects ) { case 0 : return nil , errnosuchobject case 1 : return & objects [ 0 ] , nil default : return nil , fmt . errorf ( " " ) } } 
func ( c * clustertx ) containerid ( project string , name string ) ( int64 , error ) { stmt : = c . stmt ( containerid ) rows , err : = stmt . query ( project , name ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } defer rows . close ( ) if ! rows . next ( ) { return - 1 , errnosuchobject } var id int64 err = rows . scan ( & id ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } if rows . next ( ) { return - 1 , fmt . errorf ( " " ) } err = rows . err ( ) if err ! = nil { return - 1 , errors . wrap ( err , " " ) } return id , nil } 
func ( c * clustertx ) containerexists ( project string , name string ) ( bool , error ) { , err : = c . containerid ( project , name ) if err ! = nil { if err == errnosuchobject { return false , nil } return false , err } return true , nil } 
func ( m * mapping ) naturalkey ( ) [ ] * field { key : = [ ] * field { } for , field : = range m . fields { if field . config . get ( " " ) ! = " " { key = append ( key , field ) } } if len ( key ) == 0 { key = append ( key , m . fieldbyname ( " " ) ) } return key } 
func ( m * mapping ) containsfields ( fields [ ] * field ) bool { matches : = map [ * field ] bool { } for , field : = range m . fields { for , other : = range fields { if field . name == other . name && field . type . name == other . type . name { matches [ field ] = true } } } return len ( matches ) == len ( fields ) } 
func ( m * mapping ) fieldbyname ( name string ) * field { for , field : = range m . fields { if field . name == name { return field } } return nil } 
func ( m * mapping ) fieldcolumnname ( name string ) string { field : = m . fieldbyname ( name ) return fmt . sprintf ( " " , entitytable ( m . name ) , field . column ( ) ) } 
func ( m * mapping ) filterfieldbyname ( name string ) ( * field , error ) { field : = m . fieldbyname ( name ) if field == nil { return nil , fmt . errorf ( " " , name ) } if field . type . code ! = typecolumn { return nil , fmt . errorf ( " " , name ) } return field , nil } 
func ( m * mapping ) columnfields ( exclude ... string ) [ ] * field { fields : = [ ] * field { } for , field : = range m . fields { if shared . stringinslice ( field . name , exclude ) { continue } if field . type . code == typecolumn { fields = append ( fields , field ) } } return fields } 
func ( m * mapping ) scalarfields ( ) [ ] * field { fields : = [ ] * field { } for , field : = range m . fields { if field . config . get ( " " ) ! = " " { fields = append ( fields , field ) } } return fields } 
func ( m * mapping ) reffields ( ) [ ] * field { fields : = [ ] * field { } for , field : = range m . fields { if field . type . code == typeslice | | field . type . code == typemap { fields = append ( fields , field ) } } return fields } 
func ( f * field ) column ( ) string { if f . type . code ! = typecolumn { panic ( " " ) } column : = lex . snake ( f . name ) join : = f . config . get ( " " ) if join ! = " " { column = fmt . sprintf ( " " , join , column ) } return column } 
func ( f * field ) zerovalue ( ) string { if f . type . code ! = typecolumn { panic ( " " ) } switch f . type . name { case " " : return ' " " ' case " " : return " " default : panic ( " " ) } } 
func fieldcolumns ( fields [ ] * field ) string { columns : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { columns [ i ] = field . column ( ) } return strings . join ( columns , " " ) } 
func fieldargs ( fields [ ] * field ) string { args : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { args [ i ] = fmt . sprintf ( " " , lex . minuscule ( field . name ) , field . type . name ) } return strings . join ( args , " " ) } 
func fieldparams ( fields [ ] * field ) string { args : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { args [ i ] = lex . minuscule ( field . name ) } return strings . join ( args , " " ) } 
func fieldcriteria ( fields [ ] * field ) string { criteria : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { criteria [ i ] = fmt . sprintf ( " " , field . column ( ) ) } return strings . join ( criteria , " " ) } 
func initdataclusterapply ( d lxd . containerserver , config * initdatacluster ) error { if config == nil | | ! config . enabled { return nil } currentcluster , etag , err : = d . getcluster ( ) if err ! = nil { return errors . wrap ( err , " " ) } if ! currentcluster . enabled { op , err : = d . updatecluster ( config . clusterput , etag ) if err ! = nil { return errors . wrap ( err , " " ) } err = op . wait ( ) if err ! = nil { return errors . wrap ( err , " " ) } } return nil } 
func terminalformat ( ) format { return formatfunc ( func ( r * record ) [ ] byte { var color = 0 switch r . lvl { case lvlcrit : color = 35 case lvlerror : color = 31 case lvlwarn : color = 33 case lvlinfo : color = 32 case lvldebug : color = 36 } b : = & bytes . buffer { } lvl : = strings . toupper ( r . lvl . string ( ) ) if color > 0 { fmt . fprintf ( b , " \ x1b \ x1b " , color , lvl , r . time . format ( termtimeformat ) , r . msg ) } else { fmt . fprintf ( b , " " , lvl , r . time . format ( termtimeformat ) , r . msg ) } if len ( r . ctx ) > 0 && len ( r . msg ) < termmsgjust { b . write ( bytes . repeat ( [ ] byte { ' ' } , termmsgjust - len ( r . msg ) ) ) } logfmt ( b , r . ctx , color ) return b . bytes ( ) } ) } 
func jsonformatex ( pretty , lineseparated bool ) format { jsonmarshal : = json . marshal if pretty { jsonmarshal = func ( v interface { } ) ( [ ] byte , error ) { return json . marshalindent ( v , " " , " " ) } } return formatfunc ( func ( r * record ) [ ] byte { props : = make ( map [ string ] interface { } ) props [ r . keynames . time ] = r . time props [ r . keynames . lvl ] = r . lvl props [ r . keynames . msg ] = r . msg for i : = 0 ; i < len ( r . ctx ) ; i += 2 { k , ok : = r . ctx [ i ] . ( string ) if ! ok { props [ errorkey ] = fmt . sprintf ( " " , r . ctx [ i ] ) } props [ k ] = formatjsonvalue ( r . ctx [ i + 1 ] ) } b , err : = jsonmarshal ( props ) if err ! = nil { b , = jsonmarshal ( map [ string ] string { errorkey : err . error ( ) , } ) return b } if lineseparated { b = append ( b , ' \n ' ) } return b } ) } 
func formatlogfmtvalue ( value interface { } ) string { if value == nil { return " " } value = formatshared ( value ) switch v : = value . ( type ) { case bool : return strconv . formatbool ( v ) case float32 : return strconv . formatfloat ( float64 ( v ) , floatformat , 3 , 64 ) case float64 : return strconv . formatfloat ( v , floatformat , 3 , 64 ) case int , int8 , int16 , int32 , int64 , uint , uint8 , uint16 , uint32 , uint64 : return fmt . sprintf ( " " , value ) case string : return escapestring ( v ) default : return escapestring ( fmt . sprintf ( " " , value ) ) } } 
func resolvetarget ( cluster * db . cluster , target string ) ( string , error ) { address : = " " err : = cluster . transaction ( func ( tx * db . clustertx ) error { name , err : = tx . nodename ( ) if err ! = nil { return err } if target == name { return nil } node , err : = tx . nodebyname ( target ) if err ! = nil { if err == db . errnosuchobject { return fmt . errorf ( " " , target ) } return err } if node . name ! = name { address = node . address } return nil } ) return address , err } 
func ( pt * progresswriter ) write ( p [ ] byte ) ( int , error ) { n , err : = pt . writecloser . write ( p ) if pt . tracker ! = nil { pt . tracker . total += int64 ( n ) pt . tracker . update ( n ) } return n , err } 
func updatenodeversion ( tx * sql . tx , address string , apiextensions int ) error { stmt : = " " result , err : = tx . exec ( stmt , len ( updates ) , apiextensions , address ) if err ! = nil { return err } n , err : = result . rowsaffected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func selectnodesversions ( tx * sql . tx ) ( [ ] [ 2 ] int , error ) { versions : = [ ] [ 2 ] int { } dest : = func ( i int ) [ ] interface { } { versions = append ( versions , [ 2 ] int { } ) return [ ] interface { } { & versions [ i ] [ 0 ] , & versions [ i ] [ 1 ] } } stmt , err : = tx . prepare ( " " ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest ) if err ! = nil { return nil , err } return versions , nil } 
func getarchitectures ( ) ( [ ] int , error ) { architectures : = [ ] int { } architecturename , err : = osarch . architecturegetlocal ( ) if err ! = nil { return nil , err } architecture , err : = osarch . architectureid ( architecturename ) if err ! = nil { return nil , err } architectures = append ( architectures , architecture ) personalities , err : = osarch . architecturepersonalities ( architecture ) if err ! = nil { return nil , err } for , personality : = range personalities { architectures = append ( architectures , personality ) } return architectures , nil } 
func getidmapset ( ) * idmap . idmapset { idmapset , err : = idmap . defaultidmapset ( " " , " " ) if err ! = nil { logger . warn ( " " , log . ctx { " " : err . error ( ) } ) logger . warnf ( " " ) idmapset = nil } else { kernelidmapset , err : = idmap . currentidmapset ( ) if err == nil { logger . infof ( " " ) for , lxcmap : = range kernelidmapset . tolxcstring ( ) { logger . infof ( fmt . sprintf ( " " , lxcmap ) ) } } if len ( idmapset . idmap ) == 0 { logger . warnf ( " " ) logger . warnf ( " " ) idmapset = nil } else { logger . infof ( " " ) for , lxcmap : = range idmapset . idmap { suffix : = " " if lxcmap . usable ( ) ! = nil { suffix = " " } for , lxcentry : = range lxcmap . tolxcstring ( ) { logger . infof ( " " , lxcentry , suffix ) } } err = idmapset . usable ( ) if err ! = nil { logger . warnf ( " " ) logger . warnf ( " " ) idmapset = nil } } } return idmapset } 
func runtimeliblxcversionatleast ( major int , minor int , micro int ) bool { version : = golxc . version ( ) version = strings . replace ( version , " " , " " , 1 ) parts : = strings . split ( version , " " ) partslen : = len ( parts ) if partslen == 0 { return false } develparts : = strings . split ( parts [ partslen - 1 ] , " " ) if len ( develparts ) == 2 && develparts [ 1 ] == " " { return true } maj : = - 1 min : = - 1 mic : = - 1 for i , v : = range parts { if i > 2 { break } num , err : = strconv . atoi ( v ) if err ! = nil { return false } switch i { case 0 : maj = num case 1 : min = num case 2 : mic = num } } / * major version is greater . * / if maj > major { return true } if maj < major { return false } / * minor number is greater . * / if min > minor { return true } if min < minor { return false } / * patch number is greater . * / if mic > micro { return true } if mic < micro { return false } return true } 
func getexecpath ( ) string { execpath : = os . getenv ( " " ) if execpath ! = " " { return execpath } execpath , err : = os . readlink ( " " ) if err ! = nil { execpath = " " } return execpath } 
func connect ( address string , cert * shared . certinfo , notify bool ) ( lxd . containerserver , error ) { args : = & lxd . connectionargs { tlsservercert : string ( cert . publickey ( ) ) , tlsclientcert : string ( cert . publickey ( ) ) , tlsclientkey : string ( cert . privatekey ( ) ) , skipgetserver : true , } if notify { args . useragent = " " } url : = fmt . sprintf ( " " , address ) return lxd . connectlxd ( url , args ) } 
func connectifcontainerisremote ( cluster * db . cluster , project , name string , cert * shared . certinfo ) ( lxd . containerserver , error ) { var address string err : = cluster . transaction ( func ( tx * db . clustertx ) error { var err error address , err = tx . containernodeaddress ( project , name ) return err } ) if err ! = nil { return nil , err } if address == " " { return nil , nil } return connect ( address , cert , false ) } 
func connectifvolumeisremote ( cluster * db . cluster , poolid int64 , volumename string , volumetype int , cert * shared . certinfo ) ( lxd . containerserver , error ) { var addresses [ ] string err : = cluster . transaction ( func ( tx * db . clustertx ) error { var err error addresses , err = tx . storagevolumenodeaddresses ( poolid , " " , volumename , volumetype ) return err } ) if err ! = nil { return nil , err } if len ( addresses ) > 1 { var driver string err : = cluster . transaction ( func ( tx * db . clustertx ) error { var err error driver , err = tx . storagepooldriver ( poolid ) return err } ) if err ! = nil { return nil , err } if driver == " " { return nil , nil } return nil , fmt . errorf ( " " , volumename ) } address : = addresses [ 0 ] if address == " " { return nil , nil } return connect ( address , cert , false ) } 
func setuptrust ( cert , targetaddress , targetcert , targetpassword string ) error { args : = & lxd . connectionargs { tlsservercert : targetcert , } target , err : = lxd . connectlxd ( fmt . sprintf ( " " , targetaddress ) , args ) if err ! = nil { return errors . wrap ( err , " " ) } block , : = pem . decode ( [ ] byte ( cert ) ) if block == nil { return errors . wrap ( err , " " ) } certificate : = base64 . stdencoding . encodetostring ( block . bytes ) post : = api . certificatespost { password : targetpassword , certificate : certificate , } fingerprint , err : = shared . certfingerprintstr ( cert ) if err ! = nil { return errors . wrap ( err , " " ) } post . name = fmt . sprintf ( " " , fingerprint ) post . type = " " err = target . createcertificate ( post ) if err ! = nil && err . error ( ) ! = " " { return errors . wrap ( err , " " ) } return nil } 
func ( r * protocollxd ) getstoragepools ( ) ( [ ] api . storagepool , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } pools : = [ ] api . storagepool { } , err : = r . querystruct ( " " , " " , nil , " " , & pools ) if err ! = nil { return nil , err } return pools , nil } 
func ( r * protocollxd ) getstoragepool ( name string ) ( * api . storagepool , string , error ) { if ! r . hasextension ( " " ) { return nil , " " , fmt . errorf ( " " " " ) } pool : = api . storagepool { } etag , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & pool ) if err ! = nil { return nil , " " , err } return & pool , etag , nil } 
func ( r * protocollxd ) createstoragepool ( pool api . storagepoolspost ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } if pool . driver == " " && ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , " " , pool , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) updatestoragepool ( name string , pool api . storagepoolput , etag string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , pool , etag ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) deletestoragepool ( name string ) error { if ! r . hasextension ( " " ) { return fmt . errorf ( " " " " ) } , , err : = r . query ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " ) if err ! = nil { return err } return nil } 
func ( r * protocollxd ) getstoragepoolresources ( name string ) ( * api . resourcesstoragepool , error ) { if ! r . hasextension ( " " ) { return nil , fmt . errorf ( " " " " ) } res : = api . resourcesstoragepool { } , err : = r . querystruct ( " " , fmt . sprintf ( " " , url . queryescape ( name ) ) , nil , " " , & res ) if err ! = nil { return nil , err } return & res , nil } 
func ( s * os ) initdirs ( ) error { dirs : = [ ] struct { path string mode os . filemode } { { s . vardir , 0711 } , { filepath . join ( s . vardir , " " ) , 0700 } , { s . cachedir , 0700 } , { filepath . join ( s . vardir , " " ) , 0711 } , { filepath . join ( s . vardir , " " ) , 0700 } , { filepath . join ( s . vardir , " " ) , 0711 } , { filepath . join ( s . vardir , " " ) , 0755 } , { filepath . join ( s . vardir , " " ) , 0700 } , { filepath . join ( s . vardir , " " ) , 0700 } , { s . logdir , 0700 } , { filepath . join ( s . vardir , " " ) , 0711 } , { filepath . join ( s . vardir , " " ) , 0700 } , { filepath . join ( s . vardir , " " ) , 0711 } , { filepath . join ( s . vardir , " " ) , 0700 } , { filepath . join ( s . vardir , " " ) , 0711 } , } for , dir : = range dirs { err : = os . mkdir ( dir . path , dir . mode ) if err ! = nil && ! os . isexist ( err ) { return errors . wrapf ( err , " " , dir . path ) } } return nil } 
func ( n * nodetx ) config ( ) ( map [ string ] string , error ) { return query . selectconfig ( n . tx , " " , " " ) } 
func ( n * nodetx ) updateconfig ( values map [ string ] string ) error { return query . updateconfig ( n . tx , " " , values ) } 
func ( c * clustertx ) config ( ) ( map [ string ] string , error ) { return query . selectconfig ( c . tx , " " , " " ) } 
func ( c * clustertx ) updateconfig ( values map [ string ] string ) error { return query . updateconfig ( c . tx , " " , values ) } 
func configvalueset ( c * cluster , key string , value string ) error { err : = c . transaction ( func ( tx * clustertx ) error { , err : = tx . tx . exec ( " " , key ) if err ! = nil { return err } if value ! = " " { str : = ' insert into config ( key , value ) values ( ? , ? ) ; ' stmt , err : = tx . tx . prepare ( str ) if err ! = nil { return err } defer stmt . close ( ) , err = stmt . exec ( key , value ) if err ! = nil { return err } } return nil } ) return err } 
func storagepoolvalidateclusterconfig ( reqconfig map [ string ] string ) error { for key : = range reqconfig { if shared . stringinslice ( key , db . storagepoolnodeconfigkeys ) { return fmt . errorf ( " " , key ) } } return nil } 
func storagepoolclusterconfigforetag ( dbconfig map [ string ] string ) map [ string ] string { config : = util . copyconfig ( dbconfig ) for , key : = range db . storagepoolnodeconfigkeys { delete ( config , key ) } return config } 
func storagepoolclusterfillwithnodeconfig ( dbconfig , reqconfig map [ string ] string ) map [ string ] string { config : = util . copyconfig ( reqconfig ) for , key : = range db . storagepoolnodeconfigkeys { config [ key ] = dbconfig [ key ] } return config } 
func logfmtformat ( ) log . format { return log . formatfunc ( func ( r * log . record ) [ ] byte { common : = [ ] interface { } { r . keynames . time , r . time , r . keynames . lvl , r . lvl , r . keynames . msg , r . msg } buf : = & bytes . buffer { } logfmt ( buf , common , 0 , false ) buf . truncate ( buf . len ( ) - 1 ) buf . writebyte ( ' ' ) logfmt ( buf , r . ctx , 0 , true ) return buf . bytes ( ) } ) } 
func ( c * clustertx ) storagevolumenodeaddresses ( poolid int64 , project , name string , typ int ) ( [ ] string , error ) { nodes : = [ ] struct { id int64 address string } { } dest : = func ( i int ) [ ] interface { } { nodes = append ( nodes , struct { id int64 address string } { } ) return [ ] interface { } { & nodes [ i ] . id , & nodes [ i ] . address } } sql : = stmt , err : = c . tx . prepare ( sql ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest , poolid , project , name , typ ) if err ! = nil { return nil , err } addresses : = [ ] string { } for , node : = range nodes { address : = node . address if node . id == c . nodeid { address = " " } addresses = append ( addresses , address ) } sort . strings ( addresses ) if len ( addresses ) == 0 { return nil , errnosuchobject } return addresses , nil } 
func ( c * cluster ) storagevolumenodeget ( volumeid int64 ) ( string , error ) { name : = " " query : = inargs : = [ ] interface { } { volumeid } outargs : = [ ] interface { } { & name } err : = dbqueryrowscan ( c . db , query , inargs , outargs ) if err ! = nil { if err == sql . errnorows { return " " , errnosuchobject } return " " , err } return name , nil } 
func ( c * cluster ) storagevolumeconfigget ( volumeid int64 ) ( map [ string ] string , error ) { var key , value string query : = " " inargs : = [ ] interface { } { volumeid } outargs : = [ ] interface { } { key , value } results , err : = queryscan ( c . db , query , inargs , outargs ) if err ! = nil { return nil , err } config : = map [ string ] string { } for , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * cluster ) storagevolumedescriptionget ( volumeid int64 ) ( string , error ) { description : = sql . nullstring { } query : = " " inargs : = [ ] interface { } { volumeid } outargs : = [ ] interface { } { & description } err : = dbqueryrowscan ( c . db , query , inargs , outargs ) if err ! = nil { if err == sql . errnorows { return " " , errnosuchobject } return " " , err } return description . string , nil } 
func ( c * cluster ) storagevolumenextsnapshot ( name string , typ int ) int { base : = name + shared . snapshotdelimiter + " " length : = len ( base ) q : = fmt . sprintf ( " " ) var numstr string inargs : = [ ] interface { } { typ , true , length , base } outfmt : = [ ] interface { } { numstr } results , err : = queryscan ( c . db , q , inargs , outfmt ) if err ! = nil { return 0 } max : = 0 for , r : = range results { numstr = r [ 0 ] . ( string ) if len ( numstr ) <= length { continue } substr : = numstr [ length : ] var num int count , err : = fmt . sscanf ( substr , " " , & num ) if err ! = nil | | count ! = 1 { continue } if num >= max { max = num + 1 } } return max } 
func ( c * cluster ) storagevolumeisavailable ( pool , volume string ) ( bool , error ) { isavailable : = false err : = c . transaction ( func ( tx * clustertx ) error { id , err : = tx . storagepoolid ( pool ) if err ! = nil { return errors . wrapf ( err , " " , pool ) } driver , err : = tx . storagepooldriver ( id ) if err ! = nil { return errors . wrapf ( err , " " , pool ) } if driver ! = " " { isavailable = true return nil } node , err : = tx . nodename ( ) if err ! = nil { return errors . wrapf ( err , " " ) } containers , err : = tx . containerlistexpanded ( ) if err ! = nil { return errors . wrapf ( err , " " ) } for , container : = range containers { for , device : = range container . devices { if device [ " " ] ! = " " { continue } if device [ " " ] ! = pool { continue } if device [ " " ] ! = volume { continue } if container . node ! = node { return nil } } } isavailable = true return nil } ) if err ! = nil { return false , err } return isavailable , nil } 
func storagevolumedescriptionupdate ( tx * sql . tx , volumeid int64 , description string ) error { , err : = tx . exec ( " " , description , volumeid ) return err } 
func storagevolumeconfigadd ( tx * sql . tx , volumeid int64 , volumeconfig map [ string ] string ) error { str : = " " stmt , err : = tx . prepare ( str ) defer stmt . close ( ) if err ! = nil { return err } for k , v : = range volumeconfig { if v == " " { continue } , err = stmt . exec ( volumeid , k , v ) if err ! = nil { return err } } return nil } 
func storagevolumeconfigclear ( tx * sql . tx , volumeid int64 ) error { , err : = tx . exec ( " " , volumeid ) if err ! = nil { return err } return nil } 
func storagevolumeidsget ( tx * sql . tx , project , volumename string , volumetype int , poolid int64 ) ( [ ] int64 , error ) { ids , err : = query . selectintegers ( tx , , project , volumename , volumetype , poolid ) if err ! = nil { return nil , err } ids64 : = make ( [ ] int64 , len ( ids ) ) for i , id : = range ids { ids64 [ i ] = int64 ( id ) } return ids64 , nil } 
func ( c * cluster ) storagevolumecleanupimages ( fingerprints [ ] string ) error { stmt : = fmt . sprintf ( " " , query . params ( len ( fingerprints ) ) ) args : = [ ] interface { } { storagepoolvolumetypeimage } for , fingerprint : = range fingerprints { args = append ( args , fingerprint ) } err : = exec ( c . db , stmt , args ... ) return err } 
func ( c * cluster ) storagevolumemovetolvmthinpoolnamekey ( ) error { err : = exec ( c . db , " " ) if err ! = nil { return err } err = exec ( c . db , " " ) if err ! = nil { return err } return nil } 
func ( b * buffer ) l ( format string , a ... interface { } ) { fmt . fprintf ( b . buf , format , a ... ) b . n ( ) } 
func ( b * buffer ) code ( ) ( [ ] byte , error ) { code , err : = format . source ( b . buf . bytes ( ) ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return code , nil } 
func pretty ( input interface { } ) string { pretty , err : = json . marshalindent ( input , " \ t " , " \ t " ) if err ! = nil { return fmt . sprintf ( " " , input ) } return fmt . sprintf ( " \n \ t " , pretty ) } 
func ( e * endpoints ) networkpublickey ( ) [ ] byte { e . mu . rlock ( ) defer e . mu . runlock ( ) return e . cert . publickey ( ) } 
func ( e * endpoints ) networkprivatekey ( ) [ ] byte { e . mu . rlock ( ) defer e . mu . runlock ( ) return e . cert . privatekey ( ) } 
func ( e * endpoints ) networkcert ( ) * shared . certinfo { e . mu . rlock ( ) defer e . mu . runlock ( ) return e . cert } 
func ( e * endpoints ) networkaddress ( ) string { e . mu . rlock ( ) defer e . mu . runlock ( ) listener : = e . listeners [ network ] if listener == nil { return " " } return listener . addr ( ) . string ( ) } 
func ( e * endpoints ) networkupdateaddress ( address string ) error { if address ! = " " { address = util . canonicalnetworkaddress ( address ) } oldaddress : = e . networkaddress ( ) if address == oldaddress { return nil } clusteraddress : = e . clusteraddress ( ) logger . infof ( " " ) e . mu . lock ( ) defer e . mu . unlock ( ) e . closelistener ( network ) if address == " " { return nil } if clusteraddress ! = " " && util . isaddresscovered ( clusteraddress , address ) { e . closelistener ( cluster ) } getlistener : = func ( address string ) ( * net . listener , error ) { var err error var listener net . listener for i : = 0 ; i < 10 ; i ++ { listener , err = net . listen ( " " , address ) if err == nil { break } time . sleep ( 100 * time . millisecond ) } if err ! = nil { return nil , fmt . errorf ( " " , err ) } return & listener , nil } if address ! = " " { listener , err : = getlistener ( address ) if err ! = nil { listener , err1 : = getlistener ( oldaddress ) if err1 == nil { e . listeners [ network ] = networktlslistener ( * listener , e . cert ) e . servehttp ( network ) } return err } e . listeners [ network ] = networktlslistener ( * listener , e . cert ) e . servehttp ( network ) } return nil } 
func ( e * endpoints ) networkupdatecert ( cert * shared . certinfo ) { e . mu . lock ( ) defer e . mu . unlock ( ) e . cert = cert listener , ok : = e . listeners [ network ] if ! ok { return } listener . ( * networklistener ) . config ( cert ) listener , ok = e . listeners [ cluster ] if ! ok { return } listener . ( * networklistener ) . config ( cert ) } 
func networkcreatelistener ( address string , cert * shared . certinfo ) net . listener { listener , err : = net . listen ( " " , util . canonicalnetworkaddress ( address ) ) if err ! = nil { logger . error ( " " , log . ctx { " " : err } ) return nil } return networktlslistener ( listener , cert ) } 
func ( l * networklistener ) accept ( ) ( net . conn , error ) { c , err : = l . listener . accept ( ) if err ! = nil { return nil , err } l . mu . rlock ( ) defer l . mu . runlock ( ) config : = l . config return tls . server ( c , config ) , nil } 
func ( l * networklistener ) config ( cert * shared . certinfo ) { config : = util . servertlsconfig ( cert ) l . mu . lock ( ) defer l . mu . unlock ( ) l . config = config } 
func start ( f func , schedule schedule ) ( func ( time . duration ) error , func ( ) ) { group : = group { } task : = group . add ( f , schedule ) group . start ( ) stop : = group . stop reset : = task . reset return stop , reset } 
func ( n nodeinfo ) isoffline ( threshold time . duration ) bool { return nodeisoffline ( threshold , n . heartbeat ) } 
func ( c * clustertx ) nodebyaddress ( address string ) ( nodeinfo , error ) { null : = nodeinfo { } nodes , err : = c . nodes ( false / * not pending * / , " " , address ) if err ! = nil { return null , err } switch len ( nodes ) { case 0 : return null , errnosuchobject case 1 : return nodes [ 0 ] , nil default : return null , fmt . errorf ( " " ) } } 
func ( c * clustertx ) nodependingbyaddress ( address string ) ( nodeinfo , error ) { null : = nodeinfo { } nodes , err : = c . nodes ( true / * pending * / , " " , address ) if err ! = nil { return null , err } switch len ( nodes ) { case 0 : return null , errnosuchobject case 1 : return nodes [ 0 ] , nil default : return null , fmt . errorf ( " " ) } } 
func ( c * clustertx ) nodebyname ( name string ) ( nodeinfo , error ) { null : = nodeinfo { } nodes , err : = c . nodes ( false / * not pending * / , " " , name ) if err ! = nil { return null , err } switch len ( nodes ) { case 0 : return null , errnosuchobject case 1 : return nodes [ 0 ] , nil default : return null , fmt . errorf ( " " ) } } 
func ( c * clustertx ) nodename ( ) ( string , error ) { stmt : = " " names , err : = query . selectstrings ( c . tx , stmt , c . nodeid ) if err ! = nil { return " " , err } switch len ( names ) { case 0 : return " " , nil case 1 : return names [ 0 ] , nil default : return " " , fmt . errorf ( " " ) } } 
func ( c * clustertx ) nodeaddress ( ) ( string , error ) { stmt : = " " addresses , err : = query . selectstrings ( c . tx , stmt , c . nodeid ) if err ! = nil { return " " , err } switch len ( addresses ) { case 0 : return " " , nil case 1 : return addresses [ 0 ] , nil default : return " " , fmt . errorf ( " " ) } } 
func ( c * clustertx ) nodeisoutdated ( ) ( bool , error ) { nodes , err : = c . nodes ( false / * not pending * / , " " ) if err ! = nil { return false , errors . wrap ( err , " " ) } version : = [ 2 ] int { } for , node : = range nodes { if node . id == c . nodeid { version = node . version ( ) } } if version [ 0 ] == 0 | | version [ 1 ] == 0 { return false , fmt . errorf ( " " ) } for , node : = range nodes { if node . id == c . nodeid { continue } n , err : = util . compareversions ( node . version ( ) , version ) if err ! = nil { errors . wrapf ( err , " " , node . name ) } if n == 1 { return true , nil } } return false , nil } 
func ( c * clustertx ) nodescount ( ) ( int , error ) { count , err : = query . count ( c . tx , " " , " " ) if err ! = nil { return 0 , errors . wrap ( err , " " ) } return count , nil } 
func ( c * clustertx ) noderename ( old , new string ) error { count , err : = query . count ( c . tx , " " , " " , new ) if err ! = nil { return errors . wrap ( err , " " ) } if count ! = 0 { return erralreadydefined } stmt : = ' update nodes set name=? where name=? ' result , err : = c . tx . exec ( stmt , new , old ) if err ! = nil { return errors . wrap ( err , " " ) } n , err : = result . rowsaffected ( ) if err ! = nil { return errors . wrap ( err , " " ) } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) nodes ( pending bool , where string , args ... interface { } ) ( [ ] nodeinfo , error ) { nodes : = [ ] nodeinfo { } dest : = func ( i int ) [ ] interface { } { nodes = append ( nodes , nodeinfo { } ) return [ ] interface { } { & nodes [ i ] . id , & nodes [ i ] . name , & nodes [ i ] . address , & nodes [ i ] . description , & nodes [ i ] . schema , & nodes [ i ] . apiextensions , & nodes [ i ] . heartbeat , } } if pending { args = append ( [ ] interface { } { 1 } , args ... ) } else { args = append ( [ ] interface { } { 0 } , args ... ) } sql : = if where ! = " " { sql += fmt . sprintf ( " " , where ) } sql += " " stmt , err : = c . tx . prepare ( sql ) if err ! = nil { return nil , err } defer stmt . close ( ) err = query . selectobjects ( stmt , dest , args ... ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return nodes , nil } 
func ( c * clustertx ) nodeadd ( name string , address string ) ( int64 , error ) { columns : = [ ] string { " " , " " , " " , " " } values : = [ ] interface { } { name , address , cluster . schemaversion , version . apiextensionscount ( ) } return query . upsertobject ( c . tx , " " , columns , values ) } 
func ( c * clustertx ) nodepending ( id int64 , pending bool ) error { value : = 0 if pending { value = 1 } result , err : = c . tx . exec ( " " , value , id ) if err ! = nil { return err } n , err : = result . rowsaffected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) nodeupdate ( id int64 , name string , address string ) error { result , err : = c . tx . exec ( " " , name , address , id ) if err ! = nil { return err } n , err : = result . rowsaffected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) noderemove ( id int64 ) error { result , err : = c . tx . exec ( " " , id ) if err ! = nil { return err } n , err : = result . rowsaffected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) nodeheartbeat ( address string , heartbeat time . time ) error { stmt : = " " result , err : = c . tx . exec ( stmt , heartbeat , address ) if err ! = nil { return err } n , err : = result . rowsaffected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) nodeclear ( id int64 ) error { , err : = c . tx . exec ( " " , id ) if err ! = nil { return err } ids , err : = query . selectintegers ( c . tx , " " , id ) if err ! = nil { return err } , err = c . tx . exec ( " " , id ) if err ! = nil { return err } for , id : = range ids { count , err : = query . count ( c . tx , " " , " " , id ) if err ! = nil { return err } if count > 0 { continue } , err = c . tx . exec ( " " , id ) if err ! = nil { return err } } return nil } 
func ( c * clustertx ) nodeofflinethreshold ( ) ( time . duration , error ) { threshold : = time . duration ( defaultofflinethreshold ) * time . second values , err : = query . selectstrings ( c . tx , " " ) if err ! = nil { return - 1 , err } if len ( values ) > 0 { seconds , err : = strconv . atoi ( values [ 0 ] ) if err ! = nil { return - 1 , err } threshold = time . duration ( seconds ) * time . second } return threshold , nil } 
func ( c * clustertx ) nodewithleastcontainers ( ) ( string , error ) { threshold , err : = c . nodeofflinethreshold ( ) if err ! = nil { return " " , errors . wrap ( err , " " ) } nodes , err : = c . nodes ( ) if err ! = nil { return " " , errors . wrap ( err , " " ) } name : = " " containers : = - 1 for , node : = range nodes { if node . isoffline ( threshold ) { continue } created , err : = query . count ( c . tx , " " , " " , node . id ) if err ! = nil { return " " , errors . wrap ( err , " " ) } pending , err : = query . count ( c . tx , " " , " " , node . id , operationcontainercreate ) if err ! = nil { return " " , errors . wrap ( err , " " ) } count : = created + pending if containers == - 1 | | count < containers { containers = count name = node . name } } return name , nil } 
func ( c * clustertx ) nodeupdateversion ( id int64 , version [ 2 ] int ) error { stmt : = " " result , err : = c . tx . exec ( stmt , version [ 0 ] , version [ 1 ] , id ) if err ! = nil { return errors . wrap ( err , " " ) } n , err : = result . rowsaffected ( ) if err ! = nil { return errors . wrap ( err , " " ) } if n ! = 1 { return fmt . errorf ( " " ) } return nil } 
func transaction ( db * sql . db , f func ( * sql . tx ) error ) error { tx , err : = db . begin ( ) if err ! = nil { return errors . wrap ( err , " " ) } err = f ( tx ) if err ! = nil { return rollback ( tx , err ) } err = tx . commit ( ) if err == sql . errtxdone { err = nil } return err } 
func rollback ( tx * sql . tx , reason error ) error { err : = tx . rollback ( ) if err ! = nil { logger . warnf ( " " , reason , err ) } return reason } 
func ( c * clustertx ) profileuris ( filter profilefilter ) ( [ ] string , error ) { criteria : = map [ string ] interface { } { } if filter . project ! = " " { criteria [ " " ] = filter . project } if filter . name ! = " " { criteria [ " " ] = filter . name } var stmt * sql . stmt var args [ ] interface { } if criteria [ " " ] ! = nil && criteria [ " " ] ! = nil { stmt = c . stmt ( profilenamesbyprojectandname ) args = [ ] interface { } { filter . project , filter . name , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( profilenamesbyproject ) args = [ ] interface { } { filter . project , } } else { stmt = c . stmt ( profilenames ) args = [ ] interface { } { } } code : = cluster . entitytypes [ " " ] formatter : = cluster . entityformaturis [ code ] return query . selecturis ( stmt , formatter , args ... ) } 
func ( c * clustertx ) profileget ( project string , name string ) ( * profile , error ) { filter : = profilefilter { } filter . project = project filter . name = name objects , err : = c . profilelist ( filter ) if err ! = nil { return nil , errors . wrap ( err , " " ) } switch len ( objects ) { case 0 : return nil , errnosuchobject case 1 : return & objects [ 0 ] , nil default : return nil , fmt . errorf ( " " ) } } 
func ( c * clustertx ) profileexists ( project string , name string ) ( bool , error ) { , err : = c . profileid ( project , name ) if err ! = nil { if err == errnosuchobject { return false , nil } return false , err } return true , nil } 
func ( c * clustertx ) profilerename ( project string , name string , to string ) error { stmt : = c . stmt ( profilerename ) result , err : = stmt . exec ( to , project , name ) if err ! = nil { return errors . wrap ( err , " " ) } n , err : = result . rowsaffected ( ) if err ! = nil { return errors . wrap ( err , " " ) } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func ( c * clustertx ) profiledelete ( project string , name string ) error { stmt : = c . stmt ( profiledelete ) result , err : = stmt . exec ( project , name ) if err ! = nil { return errors . wrap ( err , " " ) } n , err : = result . rowsaffected ( ) if err ! = nil { return errors . wrap ( err , " " ) } if n ! = 1 { return fmt . errorf ( " " , n ) } return nil } 
func inmemorynetwork ( ) ( net . listener , func ( ) net . conn ) { listener : = & inmemorylistener { conns : make ( chan net . conn , 16 ) , closed : make ( chan struct { } ) , } dialer : = func ( ) net . conn { server , client : = net . pipe ( ) listener . conns < - server return client } return listener , dialer } 
func ( l * inmemorylistener ) accept ( ) ( net . conn , error ) { select { case conn : = < - l . conns : return conn , nil case < - l . closed : return nil , fmt . errorf ( " " ) } } 
func canonicalnetworkaddress ( address string ) string { , , err : = net . splithostport ( address ) if err ! = nil { ip : = net . parseip ( address ) if ip ! = nil && ip . to4 ( ) == nil { address = fmt . sprintf ( " " , address , shared . defaultport ) } else { address = fmt . sprintf ( " " , address , shared . defaultport ) } } return address } 
func servertlsconfig ( cert * shared . certinfo ) * tls . config { config : = shared . inittlsconfig ( ) config . clientauth = tls . requestclientcert config . certificates = [ ] tls . certificate { cert . keypair ( ) } config . nextprotos = [ ] string { " " } if cert . ca ( ) ! = nil { pool : = x509 . newcertpool ( ) pool . addcert ( cert . ca ( ) ) config . rootcas = pool config . clientcas = pool logger . infof ( " " ) } config . buildnametocertificate ( ) return config } 
func networkinterfaceaddress ( ) string { ifaces , err : = net . interfaces ( ) if err ! = nil { return " " } for , iface : = range ifaces { if shared . isloopback ( & iface ) { continue } addrs , err : = iface . addrs ( ) if err ! = nil { continue } if len ( addrs ) == 0 { continue } addr , ok : = addrs [ 0 ] . ( * net . ipnet ) if ! ok { continue } return addr . ip . string ( ) } return " " } 
func isaddresscovered ( address1 , address2 string ) bool { if address1 == address2 { return true } host1 , port1 , err : = net . splithostport ( address1 ) if err ! = nil { return false } host2 , port2 , err : = net . splithostport ( address2 ) if err ! = nil { return false } if port2 ! = port1 { return false } if host2 == " " { ip : = net . parseip ( host1 ) if ip ! = nil && ip . to4 ( ) ! = nil { return true } return false } if host2 == " " | | host2 == " " { return true } return false } 
func selectobjects ( stmt * sql . stmt , dest dest , args ... interface { } ) error { rows , err : = stmt . query ( args ... ) if err ! = nil { return err } defer rows . close ( ) for i : = 0 ; rows . next ( ) ; i ++ { err : = rows . scan ( dest ( i ) ... ) if err ! = nil { return err } } err = rows . err ( ) if err ! = nil { return err } return nil } 
func upsertobject ( tx * sql . tx , table string , columns [ ] string , values [ ] interface { } ) ( int64 , error ) { n : = len ( columns ) if n == 0 { return - 1 , fmt . errorf ( " " ) } if n ! = len ( values ) { return - 1 , fmt . errorf ( " " ) } stmt : = fmt . sprintf ( " " , table , strings . join ( columns , " " ) , params ( n ) ) result , err : = tx . exec ( stmt , values ... ) if err ! = nil { return - 1 , err } id , err : = result . lastinsertid ( ) if err ! = nil { return - 1 , err } return id , nil } 
func deleteobject ( tx * sql . tx , table string , id int64 ) ( bool , error ) { stmt : = fmt . sprintf ( " " , table ) result , err : = tx . exec ( stmt , id ) if err ! = nil { return false , err } n , err : = result . rowsaffected ( ) if err ! = nil { return false , err } if n > 1 { return true , fmt . errorf ( " " ) } return n == 1 , nil } 
func ( t * task ) loop ( ctx context . context ) { delay : = immediately for { var timer < - chan time . time schedule , err : = t . schedule ( ) switch err { case errskip : delay = schedule fallthrough case nil : if schedule > 0 { timer = time . after ( delay ) } else { timer = make ( chan time . time ) } default : if schedule <= 0 { return } timer = time . after ( schedule ) } select { case < - timer : if err == nil { t . f ( ctx ) delay = schedule } else { delay = immediately } case < - ctx . done ( ) : return case < - t . reset : delay = immediately } } } 
func isterminal ( fd int ) bool { , err : = getstate ( fd ) return err == nil } 
func getstate ( fd int ) ( * state , error ) { termios : = syscall . termios { } ret , err : = c . tcgetattr ( c . int ( fd ) , ( * c . struct termios ) ( unsafe . pointer ( & termios ) ) ) if ret ! = 0 { return nil , err . ( syscall . errno ) } state : = state { } state . termios = termios return & state , nil } 
func makeraw ( fd int ) ( * state , error ) { var err error var oldstate , newstate * state oldstate , err = getstate ( fd ) if err ! = nil { return nil , err } err = shared . deepcopy ( & oldstate , & newstate ) if err ! = nil { return nil , err } c . cfmakeraw ( ( * c . struct termios ) ( unsafe . pointer ( & newstate . termios ) ) ) err = restore ( fd , newstate ) if err ! = nil { return nil , err } return oldstate , nil } 
func restore ( fd int , state * state ) error { ret , err : = c . tcsetattr ( c . int ( fd ) , c . tcsanow , ( * c . struct termios ) ( unsafe . pointer ( & state . termios ) ) ) if ret ! = 0 { return err . ( syscall . errno ) } return nil } 
func socketunixlisten ( path string ) ( net . listener , error ) { addr , err : = net . resolveunixaddr ( " " , path ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } listener , err : = net . listenunix ( " " , addr ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return listener , err } 
func checkalreadyrunning ( path string ) error { pid , err : = strconv . atoi ( os . getenv ( " " ) ) if err == nil { if pid == os . getpid ( ) { return nil } } if ! shared . pathexists ( path ) { return nil } , err = lxd . connectlxdunix ( path , nil ) if err == nil { return fmt . errorf ( " " ) } return nil } 
func socketunixremovestale ( path string ) error { if ! shared . pathexists ( path ) { return nil } logger . debugf ( " " ) err : = os . remove ( path ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func socketunixsetpermissions ( path string , mode os . filemode ) error { err : = os . chmod ( path , mode ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func socketunixsetownership ( path string , group string ) error { var gid int var err error if group ! = " " { gid , err = shared . groupid ( group ) if err ! = nil { return fmt . errorf ( " " , group , err ) } } else { gid = os . getgid ( ) } err = os . chown ( path , os . getuid ( ) , gid ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func cephosdpoolexists ( clustername string , poolname string , username string ) bool { , err : = shared . runcommand ( " " , " " , fmt . sprintf ( " " , username ) , " " , clustername , " " , " " , " " , poolname , " " ) if err ! = nil { return false } return true } 
func cephosdpooldestroy ( clustername string , poolname string , username string ) error { , err : = shared . runcommand ( " " , " " , fmt . sprintf ( " " , username ) , " " , clustername , " " , " " , " " , poolname , poolname , " " ) if err ! = nil { return err } return nil } 
func cephrbdvolumecreate ( clustername string , poolname string , volumename string , volumetype string , size string , username string ) error { , err : = shared . runcommand ( " " , " " , username , " " , " " , " " , clustername , " " , poolname , " " , size , " " , fmt . sprintf ( " " , volumetype , volumename ) ) return err } 
func cephrbdvolumeexists ( clustername string , poolname string , volumename string , volumetype string , username string ) bool { , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , poolname , " " , " " , fmt . sprintf ( " " , volumetype , volumename ) ) if err ! = nil { return false } return true } 
func cephrbdvolumemap ( clustername string , poolname string , volumename string , volumetype string , username string ) ( string , error ) { devpath , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , poolname , " " , fmt . sprintf ( " " , volumetype , volumename ) ) if err ! = nil { return " " , err } idx : = strings . index ( devpath , " " ) if idx < 0 { return " " , fmt . errorf ( " " ) } devpath = devpath [ idx : ] return strings . trimspace ( devpath ) , nil } 
func cephrbdsnapshotprotect ( clustername string , poolname string , volumename string , volumetype string , snapshotname string , username string ) error { , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , poolname , " " , " " , " " , snapshotname , fmt . sprintf ( " " , volumetype , volumename ) ) if err ! = nil { runerror , ok : = err . ( shared . runerror ) if ok { exiterror , ok : = runerror . err . ( * exec . exiterror ) if ok { waitstatus : = exiterror . sys ( ) . ( syscall . waitstatus ) if waitstatus . exitstatus ( ) == 16 { return nil } } } return err } return nil } 
func cephrbdclonecreate ( sourceclustername string , sourcepoolname string , sourcevolumename string , sourcevolumetype string , sourcesnapshotname string , targetpoolname string , targetvolumename string , targetvolumetype string , username string ) error { , err : = shared . runcommand ( " " , " " , username , " " , sourceclustername , " " , " " , " " , fmt . sprintf ( " " , sourcepoolname , sourcevolumetype , sourcevolumename , sourcesnapshotname ) , fmt . sprintf ( " " , targetpoolname , targetvolumetype , targetvolumename ) ) if err ! = nil { return err } return nil } 
func cephrbdsnapshotlistclones ( clustername string , poolname string , volumename string , volumetype string , snapshotname string , username string ) ( [ ] string , error ) { msg , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , poolname , " " , " " , fmt . sprintf ( " " , volumetype , volumename ) , " " , snapshotname ) if err ! = nil { return nil , err } msg = strings . trimspace ( msg ) clones : = strings . fields ( msg ) if len ( clones ) == 0 { return nil , db . errnosuchobject } return clones , nil } 
func cephrbdvolumemarkdeleted ( clustername string , poolname string , volumetype string , oldvolumename string , newvolumename string , username string , suffix string ) error { deletedname : = fmt . sprintf ( " " , poolname , volumetype , newvolumename ) if suffix ! = " " { deletedname = fmt . sprintf ( " " , deletedname , suffix ) } , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , fmt . sprintf ( " " , poolname , volumetype , oldvolumename ) , deletedname ) if err ! = nil { return err } return nil } 
func cephrbdvolumeunmarkdeleted ( clustername string , poolname string , volumename string , volumetype string , username string , oldsuffix string , newsuffix string ) error { oldname : = fmt . sprintf ( " " , poolname , volumetype , volumename ) if oldsuffix ! = " " { oldname = fmt . sprintf ( " " , oldname , oldsuffix ) } newname : = fmt . sprintf ( " " , poolname , volumetype , volumename ) if newsuffix ! = " " { newname = fmt . sprintf ( " " , newname , newsuffix ) } , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , oldname , newname ) if err ! = nil { return err } return nil } 
func cephrbdvolumegetparent ( clustername string , poolname string , volumename string , volumetype string , username string ) ( string , error ) { msg , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , poolname , " " , fmt . sprintf ( " " , volumetype , volumename ) ) if err ! = nil { return " " , err } idx : = strings . index ( msg , " " ) if idx == - 1 { return " " , db . errnosuchobject } msg = msg [ ( idx + len ( " " ) ) : ] msg = strings . trimspace ( msg ) idx = strings . index ( msg , " \n " ) if idx == - 1 { return " " , fmt . errorf ( " " ) } msg = msg [ : idx ] msg = strings . trimspace ( msg ) return msg , nil } 
func cephrbdsnapshotdelete ( clustername string , poolname string , volumename string , volumetype string , snapshotname string , username string ) error { , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , poolname , " " , " " , fmt . sprintf ( " " , volumetype , volumename , snapshotname ) ) if err ! = nil { return err } return nil } 
func cephrbdvolumecopy ( clustername string , oldvolumename string , newvolumename string , username string ) error { , err : = shared . runcommand ( " " , " " , username , " " , clustername , " " , oldvolumename , newvolumename ) if err ! = nil { return err } return nil } 
func cephrbdvolumelistsnapshots ( clustername string , poolname string , volumename string , volumetype string , username string ) ( [ ] string , error ) { msg , err : = shared . runcommand ( " " , " " , username , " " , " " , " " , clustername , " " , poolname , " " , " " , fmt . sprintf ( " " , volumetype , volumename ) ) if err ! = nil { return [ ] string { } , err } var data [ ] map [ string ] interface { } err = json . unmarshal ( [ ] byte ( msg ) , & data ) if err ! = nil { return [ ] string { } , err } snapshots : = [ ] string { } for , v : = range data { , ok : = v [ " " ] if ! ok { return [ ] string { } , fmt . errorf ( " " " " ) } name , ok : = v [ " " ] . ( string ) if ! ok { return [ ] string { } , fmt . errorf ( " " " " ) } name = strings . trimspace ( name ) snapshots = append ( snapshots , name ) } if len ( snapshots ) == 0 { return [ ] string { } , db . errnosuchobject } return snapshots , nil } 
func ( s * storageceph ) getrbdsize ( ) ( string , error ) { sz , err : = shared . parsebytesizestring ( s . volume . config [ " " ] ) if err ! = nil { return " " , err } if sz == 0 { sz , = shared . parsebytesizestring ( " " ) } return fmt . sprintf ( " " , sz ) , nil } 
func ( s * storageceph ) getrbdfilesystem ( ) string { if s . volume . config [ " " ] ! = " " { return s . volume . config [ " " ] } if s . pool . config [ " " ] ! = " " { return s . pool . config [ " " ] } return " " } 
func ( s * storageceph ) copywithsnapshots ( sourcevolumename string , targetvolumename string , sourceparentsnapshot string ) error { logger . debugf ( ' creating non - sparse copy of rbd storage volume " %s to " %s " ' , sourcevolumename , targetvolumename ) args : = [ ] string { " " , " " , s . username , " " , s . clustername , sourcevolumename , } if sourceparentsnapshot ! = " " { args = append ( args , " " , sourceparentsnapshot ) } args = append ( args , " " ) rbdsendcmd : = exec . command ( " " , args ... ) rbdrecvcmd : = exec . command ( " " , " " , s . username , " " , " " , s . clustername , " " , targetvolumename ) rbdrecvcmd . stdin , = rbdsendcmd . stdoutpipe ( ) rbdrecvcmd . stdout = os . stdout rbdrecvcmd . stderr = os . stderr err : = rbdrecvcmd . start ( ) if err ! = nil { return err } err = rbdsendcmd . run ( ) if err ! = nil { return err } err = rbdrecvcmd . wait ( ) if err ! = nil { return err } logger . debugf ( ' created non - sparse copy of rbd storage volume " %s " to " %s " ' , sourcevolumename , targetvolumename ) return nil } 
func parseclone ( clone string ) ( string , string , string , error ) { idx : = strings . index ( clone , " " ) if idx == - 1 { return " " , " " , " " , fmt . errorf ( " " ) } slider : = clone [ ( idx + 1 ) : ] poolname : = clone [ : idx ] volumetype : = slider idx = strings . index ( slider , " " ) if idx == 0 { idx += len ( " " ) volumetype = slider slider = slider [ idx : ] } idxtype : = strings . index ( slider , " " ) if idxtype == - 1 { return " " , " " , " " , fmt . errorf ( " " ) } if idx == len ( " " ) { idxtype += idx } volumetype = volumetype [ : idxtype ] idx = strings . index ( slider , " " ) if idx == - 1 { return " " , " " , " " , fmt . errorf ( " " ) } volumename : = slider idx = strings . index ( volumename , " " ) if idx == - 1 { return " " , " " , " " , fmt . errorf ( " " ) } volumename = volumename [ ( idx + 1 ) : ] return poolname , volumetype , volumename , nil } 
func ( s * storageceph ) cephrbdvolumedumptofile ( sourcevolumename string , file string ) error { logger . debugf ( ' dumping rbd storage volume " %s " to " %s " ' , sourcevolumename , file ) args : = [ ] string { " " , " " , s . username , " " , s . clustername , sourcevolumename , file , } rbdsendcmd : = exec . command ( " " , args ... ) err : = rbdsendcmd . run ( ) if err ! = nil { return err } logger . debugf ( ' dumped rbd storage volume " %s " to " %s " ' , sourcevolumename , file ) return nil } 
func ( s * storageceph ) cephrbdgenerateuuid ( volumename string , volumetype string ) error { rbddevpath , err : = cephrbdvolumemap ( s . clustername , s . osdpoolname , volumename , volumetype , s . username ) if err ! = nil { return err } defer cephrbdvolumeunmap ( s . clustername , s . osdpoolname , volumename , volumetype , s . username , true ) msg , err : = fsgeneratenewuuid ( s . getrbdfilesystem ( ) , rbddevpath ) if err ! = nil { return fmt . errorf ( " " , volumename , err , msg ) } return nil } 
func getconfigcmd ( noportforwarding * bool ) * cobra . command { var format string getconfig : = & cobra . command { short : " " , long : " " , run : cmdutil . runfixedargs ( 0 , func ( args [ ] string ) error { c , err : = client . newonusermachine ( true , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) resp , err : = c . getconfiguration ( c . ctx ( ) , & auth . getconfigurationrequest { } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } if resp . configuration == nil { fmt . println ( " " ) return nil } output , err : = json . marshalindent ( resp . configuration , " " , " " ) if err ! = nil { return fmt . errorf ( " \n \n " , resp . configuration , err ) } switch format { case " " : case " " : output , err = yaml . jsontoyaml ( output ) if err ! = nil { return fmt . errorf ( " " , err ) } default : return fmt . errorf ( " " , format ) } fmt . println ( string ( output ) ) return nil } ) , } getconfig . flags ( ) . stringvarp ( & format , " " , " " , " " , " " + " " " " " " ) return cmdutil . createalias ( getconfig , " " ) } 
func setconfigcmd ( noportforwarding * bool ) * cobra . command { var file string setconfig : = & cobra . command { short : " " , long : " " , run : cmdutil . runfixedargs ( 0 , func ( args [ ] string ) error { c , err : = client . newonusermachine ( true , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) var configbytes [ ] byte if file == " " { var err error configbytes , err = ioutil . readall ( os . stdin ) if err ! = nil { return fmt . errorf ( " " , err ) } } else if file ! = " " { var err error configbytes , err = ioutil . readfile ( file ) if err ! = nil { return fmt . errorf ( " " , file , err ) } } else { return errors . new ( " " " " ) } var config auth . authconfig if err : = yaml . unmarshal ( configbytes , & config ) ; err ! = nil { return fmt . errorf ( " " , err ) } , err = c . setconfiguration ( c . ctx ( ) , & auth . setconfigurationrequest { configuration : & config , } ) return grpcutil . scrubgrpc ( err ) } ) , } setconfig . flags ( ) . stringvarp ( & file , " " , " " , " " , " " + " " ) return cmdutil . createalias ( setconfig , " " ) } 
func newsharder ( discoveryclient discovery . client , numshards uint64 , namespace string ) sharder { return newsharder ( discoveryclient , numshards , namespace ) } 
func newrouter ( sharder sharder , dialer grpcutil . dialer , localaddress string , ) router { return newrouter ( sharder , dialer , localaddress , ) } 
func renewusercredentials ( ctx context . context , pachdaddress string , admintoken string , usertoken string , ttl time . duration ) error { client , err : = pclient . newfromaddress ( pachdaddress ) if err ! = nil { return err } defer client . close ( ) client = client . withctx ( ctx ) client . setauthtoken ( admintoken ) , err = client . authapiclient . extendauthtoken ( client . ctx ( ) , & auth . extendauthtokenrequest { token : usertoken , ttl : int64 ( ttl . seconds ( ) ) , } ) if err ! = nil { return err } return nil } 
func newlocalclient ( root string ) ( client , error ) { if err : = os . mkdirall ( root , 0755 ) ; err ! = nil { return nil , err } return & localclient { root } , nil } 
func addspantoanyexisting ( ctx context . context , operation string , kvs ... interface { } ) ( opentracing . span , context . context ) { if parentspan : = opentracing . spanfromcontext ( ctx ) ; parentspan ! = nil { span : = opentracing . startspan ( operation , opentracing . childof ( parentspan . context ( ) ) ) tagspan ( span , kvs ) return span , opentracing . contextwithspan ( ctx , span ) } return nil , ctx } 
func installjaegertracerfromenv ( ) { jaegeronce . do ( func ( ) { jaegerendpoint , onusermachine : = os . lookupenv ( jaegerendpointenvvar ) if ! onusermachine { if host , ok : = os . lookupenv ( " " ) ; ok { port : = os . getenv ( " " ) jaegerendpoint = fmt . sprintf ( " " , host , port ) } } if jaegerendpoint == " " { return } jaegerendpoint = strings . trimprefix ( jaegerendpoint , " " ) jaegerendpoint = strings . trimsuffix ( jaegerendpoint , " " ) jaegerendpoint = fmt . sprintf ( " " , jaegerendpoint ) cfg : = jaegercfg . configuration { sampler : & jaegercfg . samplerconfig { type : " " , param : 1 , } , reporter : & jaegercfg . reporterconfig { logspans : true , bufferflushinterval : 1 * time . second , collectorendpoint : jaegerendpoint , } , } logger : = jaeger . logger ( jaeger . nulllogger ) if ! onusermachine { logger = jaeger . stdlogger } tracer , , err : = cfg . new ( jaegerservicename , jaegercfg . logger ( logger ) ) if err ! = nil { panic ( fmt . sprintf ( " " , err ) ) } opentracing . setglobaltracer ( tracer ) } ) } 
func unaryclientinterceptor ( ) grpc . unaryclientinterceptor { return otgrpc . opentracingclientinterceptor ( opentracing . globaltracer ( ) , otgrpc . includingspans ( addtraceiftracingenabled ) ) } 
func streamclientinterceptor ( ) grpc . streamclientinterceptor { return otgrpc . opentracingstreamclientinterceptor ( opentracing . globaltracer ( ) , otgrpc . includingspans ( addtraceiftracingenabled ) ) } 
func unaryserverinterceptor ( ) grpc . unaryserverinterceptor { return otgrpc . opentracingserverinterceptor ( opentracing . globaltracer ( ) , otgrpc . includingspans ( addtraceiftracingenabled ) ) } 
func streamserverinterceptor ( ) grpc . streamserverinterceptor { return otgrpc . opentracingstreamserverinterceptor ( opentracing . globaltracer ( ) , otgrpc . includingspans ( addtraceiftracingenabled ) ) } 
func closeandreporttraces ( ) { if c , ok : = opentracing . globaltracer ( ) . ( io . closer ) ; ok { c . close ( ) } } 
func newwriter ( ctx context . context , objc obj . client , prefix string ) * writer { hash : = buzhash64 . new ( ) hash . write ( make ( [ ] byte , windowsize ) ) return & writer { ctx : ctx , objc : objc , prefix : prefix , cbs : [ ] func ( [ ] * dataref ) error { } , buf : & bytes . buffer { } , hash : hash , splitmask : ( 1 < < uint64 ( averagebits ) ) - 1 , } } 
func ( w * writer ) rangestart ( cb func ( [ ] * dataref ) error ) { if w . datarefs ! = nil { w . rangefinish ( ) } w . cbs = append ( w . cbs , cb ) w . datarefs = [ ] * dataref { & dataref { offsetbytes : int64 ( w . buf . len ( ) ) } } w . rangesize = 0 w . rangecount ++ } 
func ( w * writer ) write ( data [ ] byte ) ( int , error ) { offset : = 0 size : = w . buf . len ( ) for i , b : = range data { size ++ w . hash . roll ( b ) if w . hash . sum64 ( ) & w . splitmask == 0 { w . buf . write ( data [ offset : i + 1 ] ) if err : = w . put ( ) ; err ! = nil { return 0 , err } w . buf . reset ( ) offset = i + 1 size = 0 } } w . buf . write ( data [ offset : ] ) w . rangesize += int64 ( len ( data ) ) return len ( data ) , nil } 
func identifyuser ( client * analytics . client , userid string ) { err : = client . identify ( & analytics . identify { userid : userid , } ) if err ! = nil { log . errorf ( " " , err . error ( ) ) } } 
func ( b * constantbackoff ) getelapsedtime ( ) time . duration { return time . now ( ) . sub ( b . starttime ) } 
func ( l * logger ) log ( request interface { } , response interface { } , err error , duration time . duration ) { if err ! = nil { l . logatlevelfromdepth ( request , response , err , duration , logrus . errorlevel , 4 ) } else { l . logatlevelfromdepth ( request , response , err , duration , logrus . infolevel , 4 ) } go l . reportmetric ( getmethodname ( ) , duration , err ) } 
func ( f formatterfunc ) format ( entry * logrus . entry ) ( [ ] byte , error ) { return f ( entry ) } 
func pretty ( entry * logrus . entry ) ( [ ] byte , error ) { serialized : = [ ] byte ( fmt . sprintf ( " " , entry . time . format ( logrus . defaulttimestampformat ) , strings . toupper ( entry . level . string ( ) ) , ) , ) if entry . data [ " " ] ! = nil { serialized = append ( serialized , [ ] byte ( fmt . sprintf ( " " , entry . data [ " " ] , entry . data [ " " ] ) ) ... ) } if len ( entry . data ) > 2 { delete ( entry . data , " " ) delete ( entry . data , " " ) if entry . data [ " " ] ! = nil { entry . data [ " " ] = entry . data [ " " ] . ( time . duration ) . seconds ( ) } data , err : = json . marshal ( entry . data ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } serialized = append ( serialized , [ ] byte ( string ( data ) ) ... ) serialized = append ( serialized , ' ' ) } serialized = append ( serialized , [ ] byte ( entry . message ) ... ) serialized = append ( serialized , ' \n ' ) return serialized , nil } 
func newgrpclogwriter ( logger * logrus . logger , source string ) * grpclogwriter { return & grpclogwriter { logger : logger , source : source , } } 
func ( l * grpclogwriter ) write ( p [ ] byte ) ( int , error ) { parts : = strings . splitn ( string ( p ) , " " , 4 ) entry : = l . logger . withfield ( " " , l . source ) if len ( parts ) == 4 { level : = parts [ 0 ] message : = strings . trimspace ( parts [ 3 ] ) if level == " " { entry . info ( message ) } else if level == " " { entry . error ( message ) } else if level == " " { entry . warning ( message ) } else if level == " " { entry . error ( message ) } else { entry . error ( message ) entry . error ( " " , level ) } } else { entry : = l . logger . withfields ( logrus . fields { " " : l . source , } ) entry . error ( p ) entry . error ( " " ) } return len ( p ) , nil } 
func read ( ) ( * config , error ) { var c * config p : = configpath ( ) if raw , err : = ioutil . readfile ( p ) ; err == nil { err = json . unmarshal ( raw , & c ) if err ! = nil { return nil , err } } else if os . isnotexist ( err ) { fmt . println ( " " , p ) c = & config { } } else { return nil , fmt . errorf ( " " , p , err ) } if c . userid == " " { fmt . printf ( " " + " \n " , p ) uuid , err : = uuid . newv4 ( ) if err ! = nil { return nil , err } c . userid = uuid . string ( ) if err : = c . write ( ) ; err ! = nil { return nil , err } } return c , nil } 
func ( c * config ) write ( ) error { rawconfig , err : = json . marshalindent ( c , " " , " " ) if err ! = nil { return err } p : = configpath ( ) if , ok : = os . lookupenv ( configenvvar ) ; ok { d : = filepath . dir ( p ) if , err : = os . stat ( d ) ; err ! = nil { return fmt . errorf ( " " , p , err ) } } else { err = os . mkdirall ( defaultconfigdir , 0755 ) if err ! = nil { return err } } return ioutil . writefile ( p , rawconfig , 0644 ) } 
func ( r * readwriter ) read ( val proto . message ) error { buf , err : = r . readbytes ( ) if err ! = nil { return err } return proto . unmarshal ( buf , val ) } 
func ( r * readwriter ) write ( val proto . message ) ( int64 , error ) { bytes , err : = proto . marshal ( val ) if err ! = nil { return 0 , err } return r . writebytes ( bytes ) } 
func newreadwriter ( rw io . readwriter ) readwriter { return & readwriter { r : rw , w : rw } } 
func rungithookserver ( address string , etcdaddress string , etcdprefix string ) error { c , err : = client . newfromaddress ( address ) if err ! = nil { return err } etcdclient , err : = etcd . new ( etcd . config { endpoints : [ ] string { etcdaddress } , dialoptions : client . defaultdialoptions ( ) , } ) if err ! = nil { return err } hook , err : = github . new ( ) if err ! = nil { return err } s : = & githookserver { hook , c , etcdclient , ppsdb . pipelines ( etcdclient , etcdprefix ) , } return http . listenandserve ( fmt . sprintf ( " " , githookport ) , s ) } 
func newloggingpipe ( ) * loggingpipe { p : = & loggingpipe { } p . clientreader , p . clientwriter = io . pipe ( ) p . clientreader = io . teereader ( p . clientreader , & p . servertoclientbuf ) p . serverreader , p . serverwriter = io . pipe ( ) p . serverreader = io . teereader ( p . serverreader , & p . clienttoserverbuf ) return p } 
func ( p * loggingpipe ) close ( ) error { p . clientwriter . close ( ) p . serverwriter . close ( ) return nil } 
func ( p * loggingpipe ) clientconn ( ) * loggingconn { return & loggingconn { pipe : p , r : p . clientreader , w : p . serverwriter , } } 
func ( p * loggingpipe ) serverconn ( ) * loggingconn { return & loggingconn { pipe : p , r : p . serverreader , w : p . clientwriter , } } 
func ( l * loggingconn ) read ( b [ ] byte ) ( n int , err error ) { return l . r . read ( b ) } 
func ( l * loggingconn ) write ( b [ ] byte ) ( n int , err error ) { return l . w . write ( b ) } 
func ( l * testlistener ) dial ( context . context , string , string ) ( net . conn , error ) { l . connmu . lock ( ) defer l . connmu . unlock ( ) if l . conn ! = nil { return nil , errors . new ( " " ) } p : = newloggingpipe ( ) l . conn = p . serverconn ( ) l . connch < - p . serverconn ( ) close ( l . connch ) return p . clientconn ( ) , nil } 
func ( l * testlistener ) accept ( ) ( net . conn , error ) { conn : = < - l . connch if conn == nil { return nil , errors . new ( " " ) } return conn , nil } 
func ( l * testlistener ) close ( ) error { l . connmu . lock ( ) defer l . connmu . unlock ( ) c : = < - l . connch if c ! = nil { close ( l . connch ) } return nil } 
func code ( err error ) errcode { if err == nil { return ok } hte , ok : = err . ( * hashtreeerror ) if ! ok { return unknown } return hte . code } 
func errorf ( c errcode , fmtstr string , args ... interface { } ) error { return & hashtreeerror { code : c , s : fmt . sprintf ( fmtstr , args ... ) , } } 
func initpachonlyenv ( config * configuration ) * serviceenv { env : = & serviceenv { configuration : config } env . pachaddress = net . joinhostport ( " " , fmt . sprintf ( " " , env . peerport ) ) env . pacheg . go ( env . initpachclient ) return env } 
func initserviceenv ( config * configuration ) * serviceenv { env : = initpachonlyenv ( config ) env . etcdaddress = fmt . sprintf ( " " , net . joinhostport ( env . etcdhost , env . etcdport ) ) env . etcdeg . go ( env . initetcdclient ) return env } 
func initwithkube ( config * configuration ) * serviceenv { env : = initserviceenv ( config ) env . kubeeg . go ( env . initkubeclient ) return env } 
func ( env * serviceenv ) getpachclient ( ctx context . context ) * client . apiclient { if err : = env . pacheg . wait ( ) ; err ! = nil { panic ( err ) } return env . pachclient . withctx ( ctx ) } 
func ( env * serviceenv ) getetcdclient ( ) * etcd . client { if err : = env . etcdeg . wait ( ) ; err ! = nil { panic ( err ) } if env . etcdclient == nil { panic ( " " ) } return env . etcdclient } 
func ( env * serviceenv ) getkubeclient ( ) * kube . clientset { if err : = env . kubeeg . wait ( ) ; err ! = nil { panic ( err ) } if env . kubeclient == nil { panic ( " " ) } return env . kubeclient } 
func newhasher ( jobmodulus uint64 , pipelinemodulus uint64 ) * hasher { return & hasher { jobmodulus : jobmodulus , pipelinemodulus : pipelinemodulus , } } 
func ( s * hasher ) hashjob ( jobid string ) uint64 { return uint64 ( adler32 . checksum ( [ ] byte ( jobid ) ) ) %s . jobmodulus } 
func ( s * hasher ) hashpipeline ( pipelinename string ) uint64 { return uint64 ( adler32 . checksum ( [ ] byte ( pipelinename ) ) ) %s . pipelinemodulus } 
func status ( ctx context . context , pipelinercname string , etcdclient * etcd . client , etcdprefix string , workergrpcport uint16 ) ( [ ] * pps . workerstatus , error ) { workerclients , err : = clients ( ctx , pipelinercname , etcdclient , etcdprefix , workergrpcport ) if err ! = nil { return nil , err } var result [ ] * pps . workerstatus for , workerclient : = range workerclients { status , err : = workerclient . status ( ctx , & types . empty { } ) if err ! = nil { return nil , err } result = append ( result , status ) } return result , nil } 
func cancel ( ctx context . context , pipelinercname string , etcdclient * etcd . client , etcdprefix string , workergrpcport uint16 , jobid string , datafilter [ ] string ) error { workerclients , err : = clients ( ctx , pipelinercname , etcdclient , etcdprefix , workergrpcport ) if err ! = nil { return err } success : = false for , workerclient : = range workerclients { resp , err : = workerclient . cancel ( ctx , & cancelrequest { jobid : jobid , datafilters : datafilter , } ) if err ! = nil { return err } if resp . success { success = true } } if ! success { return fmt . errorf ( " " , datafilter , jobid ) } return nil } 
func conns ( ctx context . context , pipelinercname string , etcdclient * etcd . client , etcdprefix string , workergrpcport uint16 ) ( [ ] * grpc . clientconn , error ) { resp , err : = etcdclient . get ( ctx , path . join ( etcdprefix , workeretcdprefix , pipelinercname ) , etcd . withprefix ( ) ) if err ! = nil { return nil , err } var result [ ] * grpc . clientconn for , kv : = range resp . kvs { conn , err : = grpc . dial ( fmt . sprintf ( " " , path . base ( string ( kv . key ) ) , workergrpcport ) , append ( client . defaultdialoptions ( ) , grpc . withinsecure ( ) ) ... ) if err ! = nil { return nil , err } result = append ( result , conn ) } return result , nil } 
func clients ( ctx context . context , pipelinercname string , etcdclient * etcd . client , etcdprefix string , workergrpcport uint16 ) ( [ ] client , error ) { conns , err : = conns ( ctx , pipelinercname , etcdclient , etcdprefix , workergrpcport ) if err ! = nil { return nil , err } var result [ ] client for , conn : = range conns { result = append ( result , newclient ( conn ) ) } return result , nil } 
func newclient ( address string ) ( client , error ) { port , err : = strconv . atoi ( os . getenv ( client . ppsworkerportenv ) ) if err ! = nil { return client { } , err } conn , err : = grpc . dial ( fmt . sprintf ( " " , address , port ) , append ( client . defaultdialoptions ( ) , grpc . withinsecure ( ) ) ... ) if err ! = nil { return client { } , err } return newclient ( conn ) , nil } 
func scrubgrpc ( err error ) error { if err == nil { return nil } if s , ok : = status . fromerror ( err ) ; ok { return errors . new ( s . message ( ) ) } return err } 
func runfixedargs ( numargs int , run func ( [ ] string ) error ) func ( * cobra . command , [ ] string ) { return func ( cmd * cobra . command , args [ ] string ) { if len ( args ) ! = numargs { fmt . printf ( " \n \n " , numargs , len ( args ) ) cmd . usage ( ) } else { if err : = run ( args ) ; err ! = nil { errorandexit ( " " , err ) } } } } 
func runboundedargs ( min int , max int , run func ( [ ] string ) error ) func ( * cobra . command , [ ] string ) { return func ( cmd * cobra . command , args [ ] string ) { if len ( args ) < min | | len ( args ) > max { fmt . printf ( " \n \n " , min , max , len ( args ) ) cmd . usage ( ) } else { if err : = run ( args ) ; err ! = nil { errorandexit ( " " , err ) } } } } 
func run ( run func ( args [ ] string ) error ) func ( * cobra . command , [ ] string ) { return func ( * cobra . command , args [ ] string ) { if err : = run ( args ) ; err ! = nil { errorandexit ( err . error ( ) ) } } } 
func errorandexit ( format string , args ... interface { } ) { if errstring : = strings . trimspace ( fmt . sprintf ( format , args ... ) ) ; errstring ! = " " { fmt . fprintf ( os . stderr , " \n " , errstring ) } os . exit ( 1 ) } 
func parsecommit ( arg string ) ( * pfs . commit , error ) { parts : = strings . splitn ( arg , " " , 2 ) if parts [ 0 ] == " " { return nil , fmt . errorf ( " " " " , arg ) } commit : = & pfs . commit { repo : & pfs . repo { name : parts [ 0 ] , } , id : " " , } if len ( parts ) == 2 { commit . id = parts [ 1 ] } return commit , nil } 
func parsecommits ( args [ ] string ) ( [ ] * pfs . commit , error ) { var results [ ] * pfs . commit for , arg : = range args { commit , err : = parsecommit ( arg ) if err ! = nil { return nil , err } results = append ( results , commit ) } return results , nil } 
func parsebranch ( arg string ) ( * pfs . branch , error ) { commit , err : = parsecommit ( arg ) if err ! = nil { return nil , err } return & pfs . branch { repo : commit . repo , name : commit . id } , nil } 
func parsebranches ( args [ ] string ) ( [ ] * pfs . branch , error ) { var results [ ] * pfs . branch for , arg : = range args { branch , err : = parsebranch ( arg ) if err ! = nil { return nil , err } results = append ( results , branch ) } return results , nil } 
func parsefile ( arg string ) ( * pfs . file , error ) { repoandrest : = strings . splitn ( arg , " " , 2 ) if repoandrest [ 0 ] == " " { return nil , fmt . errorf ( " " " " , arg ) } file : = & pfs . file { commit : & pfs . commit { repo : & pfs . repo { name : repoandrest [ 0 ] , } , id : " " , } , path : " " , } if len ( repoandrest ) > 1 { commitandpath : = strings . splitn ( repoandrest [ 1 ] , " " , 2 ) if commitandpath [ 0 ] == " " { return nil , fmt . errorf ( " " " " , arg ) } file . commit . id = commitandpath [ 0 ] if len ( commitandpath ) > 1 { file . path = commitandpath [ 1 ] } } return file , nil } 
func parsefiles ( args [ ] string ) ( [ ] * pfs . file , error ) { var results [ ] * pfs . file for , arg : = range args { commit , err : = parsefile ( arg ) if err ! = nil { return nil , err } results = append ( results , commit ) } return results , nil } 
func ( r * repeatedstringarg ) set ( s string ) error { * r = append ( * r , s ) return nil } 
func createalias ( cmd * cobra . command , invocation string ) * cobra . command { var root , prev * cobra . command args : = strings . split ( invocation , " " ) for i , arg : = range args { cur : = & cobra . command { } if i == len ( args ) - 1 { * cur = * cmd if cmd . use == " " { cur . use = arg } else { cur . use = strings . replace ( cmd . use , " " , arg , - 1 ) } cur . example = strings . replace ( cmd . example , " " , fmt . sprintf ( " " , os . args [ 0 ] , invocation ) , - 1 ) } else { cur . use = arg } if root == nil { root = cur } else if prev ! = nil { prev . addcommand ( cur ) } prev = cur } return root } 
func mergecommands ( root * cobra . command , children [ ] * cobra . command ) { findcommand : = func ( parent * cobra . command , name string ) * cobra . command { for , cmd : = range parent . commands ( ) { if cmd . name ( ) == name { return cmd } } return nil } var depth func ( * cobra . command ) int depth = func ( cmd * cobra . command ) int { maxdepth : = 0 for , subcmd : = range cmd . commands ( ) { subcmddepth : = depth ( subcmd ) if subcmddepth > maxdepth { maxdepth = subcmddepth } } return maxdepth + 1 } sort . slice ( children , func ( i , j int ) bool { return depth ( children [ i ] ) < depth ( children [ j ] ) } ) for , cmd : = range children { parent : = findcommand ( root , cmd . name ( ) ) if parent == nil { root . addcommand ( cmd ) } else { mergecommands ( parent , cmd . commands ( ) ) } } } 
func setdocsusage ( command * cobra . command ) { command . sethelptemplate ( ) command . setusagefunc ( func ( cmd * cobra . command ) error { rootcmd : = cmd . root ( ) var associated [ ] * cobra . command var walk func ( * cobra . command ) walk = func ( cursor * cobra . command ) { if cursor . name ( ) == cmd . name ( ) && cursor . commandpath ( ) ! = cmd . commandpath ( ) { associated = append ( associated , cursor ) } for , subcmd : = range cursor . commands ( ) { walk ( subcmd ) } } walk ( rootcmd ) var maxcommandpath int for , x : = range associated { commandpathlen : = len ( x . commandpath ( ) ) if commandpathlen > maxcommandpath { maxcommandpath = commandpathlen } } templatefuncs : = template . funcmap { " " : func ( s string ) string { format : = fmt . sprintf ( " " , maxcommandpath + 1 ) return fmt . sprintf ( format , s ) } , " " : func ( ) [ ] * cobra . command { return associated } , } text : = t : = template . new ( " " ) t . funcs ( templatefuncs ) template . must ( t . parse ( text ) ) return t . execute ( cmd . out ( ) , cmd ) } ) } 
func ( o * tracingobjclient ) writer ( ctx context . context , name string ) ( io . writecloser , error ) { span , ctx : = tracing . addspantoanyexisting ( ctx , o . provider + " " , " " , name ) if span ! = nil { defer span . finish ( ) } return o . client . writer ( ctx , name ) } 
func ( o * tracingobjclient ) reader ( ctx context . context , name string , offset uint64 , size uint64 ) ( io . readcloser , error ) { span , ctx : = tracing . addspantoanyexisting ( ctx , o . provider + " " , " " , name , " " , fmt . sprintf ( " " , offset ) , " " , fmt . sprintf ( " " , size ) ) defer tracing . finishanyspan ( span ) return o . client . reader ( ctx , name , offset , size ) } 
func ( o * tracingobjclient ) delete ( ctx context . context , name string ) error { span , ctx : = tracing . addspantoanyexisting ( ctx , o . provider + " " , " " , name ) defer tracing . finishanyspan ( span ) return o . client . delete ( ctx , name ) } 
func ( o * tracingobjclient ) walk ( ctx context . context , prefix string , fn func ( name string ) error ) error { span , ctx : = tracing . addspantoanyexisting ( ctx , o . provider + " " , " " , prefix ) defer tracing . finishanyspan ( span ) return o . client . walk ( ctx , prefix , fn ) } 
func ( o * tracingobjclient ) exists ( ctx context . context , name string ) bool { span , ctx : = tracing . addspantoanyexisting ( ctx , o . provider + " " , " " , name ) defer tracing . finishanyspan ( span ) return o . client . exists ( ctx , name ) } 
func ( c * commit ) fullid ( ) string { return fmt . sprintf ( " " , c . repo . name , c . id ) } 
func getblock ( hash hash . hash ) * block { return & block { hash : base64 . urlencoding . encodetostring ( hash . sum ( nil ) ) , } } 
func ( h * healthserver ) health ( context . context , * types . empty ) ( * types . empty , error ) { if ! h . ready { return nil , fmt . errorf ( " " ) } return & types . empty { } , nil } 
func clean ( p string ) string { if ! strings . hasprefix ( p , " " ) { p = " " + p } return internaldefault ( path . clean ( p ) ) } 
func split ( p string ) ( string , string ) { return clean ( path . dir ( p ) ) , base ( p ) } 
func validatepath ( path string ) error { path = clean ( path ) match , : = regexp . matchstring ( " " , path ) if ! match { return fmt . errorf ( " " , path ) } if isglob ( path ) { return fmt . errorf ( " " , path , globregex . findstring ( path ) ) } return nil } 
func matchdatum ( filter [ ] string , data [ ] * pps . inputfile ) bool { matchesdata : = true datafilters : for , datafilter : = range filter { for , datum : = range data { if datafilter == datum . path | | datafilter == base64 . stdencoding . encodetostring ( datum . hash ) | | datafilter == hex . encodetostring ( datum . hash ) { continue datafilters } } matchesdata = false break } return matchesdata } 
func newcacheserver ( router shard . router , shards uint64 ) cacheserver { server : = & groupcacheserver { logger : log . newlogger ( " " ) , router : router , localshards : make ( map [ uint64 ] bool ) , shards : shards , } groupcache . registerpeerpicker ( func ( ) groupcache . peerpicker { return server } ) return server } 
func ( a * apiserver ) hardstoppipeline ( pachclient * client . apiclient , pipelineinfo * pps . pipelineinfo ) error { if err : = pachclient . createbranch ( pipelineinfo . pipeline . name , pipelineinfo . outputbranch , pipelineinfo . outputbranch , nil , ) ; err ! = nil && ! isnotfounderr ( err ) { return fmt . errorf ( " " , err ) } iter , err : = pachclient . listcommitstream ( pachclient . ctx ( ) , & pfs . listcommitrequest { repo : client . newrepo ( pipelineinfo . pipeline . name ) , to : client . newcommit ( pipelineinfo . pipeline . name , pipelineinfo . outputbranch ) , } ) if err ! = nil { return fmt . errorf ( " " , pipelineinfo . outputbranch , err ) } for { ci , err : = iter . recv ( ) if err == io . eof { break } else if err ! = nil { return err } if ci . finished == nil { pachclient . pfsapiclient . finishcommit ( pachclient . ctx ( ) , & pfs . finishcommitrequest { commit : ci . commit , empty : true , } ) } } return nil } 
func ( a * apiserver ) sudo ( pachclient * client . apiclient , f func ( * client . apiclient ) error ) error { superusertokenonce . do ( func ( ) { b : = backoff . newexponentialbackoff ( ) b . maxelapsedtime = 60 * time . second b . maxinterval = 5 * time . second if err : = backoff . retry ( func ( ) error { superusertokencol : = col . newcollection ( a . env . getetcdclient ( ) , ppsconsts . ppstokenkey , nil , & types . stringvalue { } , nil , nil ) . readonly ( pachclient . ctx ( ) ) var result types . stringvalue if err : = superusertokencol . get ( " " , & result ) ; err ! = nil { return err } superusertoken = result . value return nil } , b ) ; err ! = nil { panic ( fmt . sprintf ( " " , err ) ) } } ) superuserclient : = pachclient . withctx ( pachclient . ctx ( ) ) superuserclient . setauthtoken ( superusertoken ) return f ( superuserclient ) } 
func ( a * apiserver ) makepipelineinfocommit ( pachclient * client . apiclient , pipelineinfo * pps . pipelineinfo ) ( result * pfs . commit , reterr error ) { pipelinename : = pipelineinfo . pipeline . name var commit * pfs . commit if err : = a . sudo ( pachclient , func ( superuserclient * client . apiclient ) error { data , err : = pipelineinfo . marshal ( ) if err ! = nil { return fmt . errorf ( " " , err ) } if , err = superuserclient . putfileoverwrite ( ppsconsts . specrepo , pipelinename , ppsconsts . specfile , bytes . newreader ( data ) , 0 ) ; err ! = nil { return err } branchinfo , err : = superuserclient . inspectbranch ( ppsconsts . specrepo , pipelinename ) if err ! = nil { return err } commit = branchinfo . head return nil } ) ; err ! = nil { return nil , err } return commit , nil } 
func ( a * apiserver ) incrementgcgeneration ( ctx context . context ) error { resp , err : = a . env . getetcdclient ( ) . get ( ctx , client . gcgenerationkey ) if err ! = nil { return err } if resp . count == 0 { if , err : = a . env . getetcdclient ( ) . put ( ctx , client . gcgenerationkey , " " ) ; err ! = nil { return err } } else { oldgen , err : = strconv . atoi ( string ( resp . kvs [ 0 ] . value ) ) if err ! = nil { return err } newgen : = oldgen + 1 if , err : = a . env . getetcdclient ( ) . put ( ctx , client . gcgenerationkey , strconv . itoa ( newgen ) ) ; err ! = nil { return err } } return nil } 
func newdebugserver ( name string , etcdclient * etcd . client , etcdprefix string , workergrpcport uint16 ) debug . debugserver { return & debugserver { name : name , etcdclient : etcdclient , etcdprefix : etcdprefix , workergrpcport : workergrpcport , } } 
func ( c apiclient ) health ( ) error { , err : = c . healthclient . health ( c . ctx ( ) , & types . empty { } ) return grpcutil . scrubgrpc ( err ) } 
func newobjblockapiserver ( dir string , cachebytes int64 , etcdaddress string , objclient obj . client , test bool ) ( * objblockapiserver , error ) { if err : = obj . teststorage ( context . background ( ) , objclient ) ; err ! = nil { return nil , err } onecacheshare : = cachebytes / ( objectcacheshares + tagcacheshares + objectinfocacheshares + blockcacheshares ) s : = & objblockapiserver { logger : log . newlogger ( " " ) , dir : dir , objclient : objclient , objectindexes : make ( map [ string ] * pfsclient . objectindex ) , objectcachebytes : onecacheshare * objectcacheshares , } objectgroupname : = " " taggroupname : = " " objectinfogroupname : = " " blockgroupname : = " " if test { uuid : = uuid . new ( ) objectgroupname += uuid taggroupname += uuid objectinfogroupname += uuid blockgroupname += uuid } s . objectcache = groupcache . newgroup ( objectgroupname , onecacheshare * objectcacheshares , groupcache . getterfunc ( s . objectgetter ) ) s . tagcache = groupcache . newgroup ( taggroupname , onecacheshare * tagcacheshares , groupcache . getterfunc ( s . taggetter ) ) s . objectinfocache = groupcache . newgroup ( objectinfogroupname , onecacheshare * objectinfocacheshares , groupcache . getterfunc ( s . objectinfogetter ) ) s . blockcache = groupcache . newgroup ( blockgroupname , onecacheshare * blockcacheshares , groupcache . getterfunc ( s . blockgetter ) ) if ! test { registercachestats ( " " , & s . tagcache . stats ) registercachestats ( " " , & s . objectcache . stats ) registercachestats ( " " , & s . objectinfocache . stats ) } go s . watchgc ( etcdaddress ) return s , nil } 
func ( s * objblockapiserver ) watchgc ( etcdaddress string ) { b : = backoff . newinfinitebackoff ( ) backoff . retrynotify ( func ( ) error { etcdclient , err : = etcd . new ( etcd . config { endpoints : [ ] string { etcdaddress } , dialoptions : client . defaultdialoptions ( ) , } ) if err ! = nil { return fmt . errorf ( " " , err ) } watcher , err : = watch . newwatcher ( context . background ( ) , etcdclient , " " , client . gcgenerationkey , nil ) if err ! = nil { return fmt . errorf ( " " , err ) } defer watcher . close ( ) for { ev , ok : = < - watcher . watch ( ) if ev . err ! = nil { return fmt . errorf ( " " , ev . err ) } if ! ok { return fmt . errorf ( " " ) } newgen , err : = strconv . atoi ( string ( ev . value ) ) if err ! = nil { return fmt . errorf ( " " , err ) } s . setgeneration ( newgen ) } } , b , func ( err error , d time . duration ) error { logrus . errorf ( " " , err , d ) return nil } ) } 
func ( s * objblockapiserver ) writeinternal ( ctx context . context , path string , data [ ] byte ) ( reterr error ) { defer func ( ) { if reterr ! = nil { return } reterr = func ( ) ( reterr error ) { if ! s . objclient . exists ( ctx , path ) { logrus . errorf ( " " , path ) return fmt . errorf ( " " , path ) } return nil } ( ) } ( ) w , err : = s . objclient . writer ( ctx , path ) if err ! = nil { return err } defer func ( ) { if err : = w . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) , err = w . write ( data ) return err } 
func ( s * objblockapiserver ) splitkey ( key string ) string { gen : = s . getgeneration ( ) if len ( key ) < prefixlength { return fmt . sprintf ( " " , key , gen ) } return fmt . sprintf ( " " , key [ : prefixlength ] , key [ prefixlength : ] , gen ) } 
func newwriter ( w io . writer , header string ) * writer { if header [ len ( header ) - 1 ] ! = ' \n ' { panic ( " " ) } tabwriter : = ansiterm . newtabwriter ( w , 0 , 1 , 1 , ' ' , 0 ) tabwriter . write ( [ ] byte ( header ) ) return & writer { w : tabwriter , lines : 1 , header : [ ] byte ( header ) , } } 
func ( w * writer ) write ( buf [ ] byte ) ( int , error ) { if w . lines >= termheight { if err : = w . flush ( ) ; err ! = nil { return 0 , err } if , err : = w . w . write ( w . header ) ; err ! = nil { return 0 , err } w . lines ++ } w . lines += bytes . count ( buf , [ ] byte { ' \n ' } ) return w . w . write ( buf ) } 
func printrepoheader ( w io . writer , printauth bool ) { if printauth { fmt . fprint ( w , repoauthheader ) return } fmt . fprint ( w , repoheader ) } 
func printrepoinfo ( w io . writer , repoinfo * pfs . repoinfo , fulltimestamps bool ) { fmt . fprintf ( w , " \ t " , repoinfo . repo . name ) if fulltimestamps { fmt . fprintf ( w , " \ t " , repoinfo . created . string ( ) ) } else { fmt . fprintf ( w , " \ t " , pretty . ago ( repoinfo . created ) ) } fmt . fprintf ( w , " \ t " , units . bytessize ( float64 ( repoinfo . sizebytes ) ) ) if repoinfo . authinfo ! = nil { fmt . fprintf ( w , " \ t " , repoinfo . authinfo . accesslevel . string ( ) ) } fmt . fprintln ( w ) } 
func printdetailedrepoinfo ( repoinfo * printablerepoinfo ) error { template , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( ) if err ! = nil { return err } err = template . execute ( os . stdout , repoinfo ) if err ! = nil { return err } return nil } 
func printbranch ( w io . writer , branchinfo * pfs . branchinfo ) { fmt . fprintf ( w , " \ t " , branchinfo . branch . name ) if branchinfo . head ! = nil { fmt . fprintf ( w , " \ t \n " , branchinfo . head . id ) } else { fmt . fprintf ( w , " \ t \n " ) } } 
func printcommitinfo ( w io . writer , commitinfo * pfs . commitinfo , fulltimestamps bool ) { fmt . fprintf ( w , " \ t " , commitinfo . commit . repo . name ) fmt . fprintf ( w , " \ t " , commitinfo . branch . name ) fmt . fprintf ( w , " \ t " , commitinfo . commit . id ) if commitinfo . parentcommit ! = nil { fmt . fprintf ( w , " \ t " , commitinfo . parentcommit . id ) } else { fmt . fprint ( w , " \ t " ) } if fulltimestamps { fmt . fprintf ( w , " \ t " , commitinfo . started . string ( ) ) } else { fmt . fprintf ( w , " \ t " , pretty . ago ( commitinfo . started ) ) } if commitinfo . finished ! = nil { fmt . fprintf ( w , fmt . sprintf ( " \ t " , pretty . timedifference ( commitinfo . started , commitinfo . finished ) ) ) fmt . fprintf ( w , " \ t \n " , units . bytessize ( float64 ( commitinfo . sizebytes ) ) ) } else { fmt . fprintf ( w , " \ t " ) fmt . fprintf ( w , " \ t \n " ) } } 
func printdetailedcommitinfo ( commitinfo * printablecommitinfo ) error { template , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( ) if err ! = nil { return err } err = template . execute ( os . stdout , commitinfo ) if err ! = nil { return err } return nil } 
func printfileinfo ( w io . writer , fileinfo * pfs . fileinfo , fulltimestamps bool ) { fmt . fprintf ( w , " \ t " , fileinfo . file . commit . id ) fmt . fprintf ( w , " \ t " , fileinfo . file . path ) if fileinfo . filetype == pfs . filetype file { fmt . fprint ( w , " \ t " ) } else { fmt . fprint ( w , " \ t " ) } if fileinfo . committed == nil { fmt . fprintf ( w , " \ t " ) } else if fulltimestamps { fmt . fprintf ( w , " \ t " , fileinfo . committed . string ( ) ) } else { fmt . fprintf ( w , " \ t " , pretty . ago ( fileinfo . committed ) ) } fmt . fprintf ( w , " \ t \n " , units . bytessize ( float64 ( fileinfo . sizebytes ) ) ) } 
func printdetailedfileinfo ( fileinfo * pfs . fileinfo ) error { template , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( ) if err ! = nil { return err } return template . execute ( os . stdout , fileinfo ) } 
func compactprintbranch ( b * pfs . branch ) string { return fmt . sprintf ( " " , b . repo . name , b . name ) } 
func compactprintcommit ( c * pfs . commit ) string { return fmt . sprintf ( " " , c . repo . name , c . id ) } 
func compactprintfile ( f * pfs . file ) string { return fmt . sprintf ( " " , f . commit . repo . name , f . commit . id , f . path ) } 
func parse ( s string ) ( string , int ) { sepindex : = strings . indexany ( s , " " ) if sepindex == - 1 { return s , 0 } sep : = s [ sepindex ] straftersep : = s [ sepindex + 1 : ] intaftersep , err : = strconv . atoi ( straftersep ) if err == nil { return s [ : sepindex ] , intaftersep } for i : = sepindex + 1 ; i < len ( s ) ; i ++ { if s [ i ] ! = sep { return s , 0 } } return s [ : sepindex ] , len ( s ) - sepindex } 
func add ( s string , ancestors int ) string { return fmt . sprintf ( " " , s , ancestors ) } 
func retrynotify ( operation operation , b backoff , notify notify ) error { var err error var next time . duration b . reset ( ) for { if err = operation ( ) ; err == nil { return nil } if next = b . nextbackoff ( ) ; next == stop { return err } if notify ! = nil { if err : = notify ( err , next ) ; err ! = nil { return err } } time . sleep ( next ) } } 
func newcache ( size int ) ( * cache , error ) { c , err : = lru . newwithevict ( size , func ( key interface { } , value interface { } ) { go func ( ) { tree , ok : = value . ( * dbhashtree ) if ! ok { logrus . infof ( " " , reflect . typeof ( value ) ) return } if err : = tree . destroy ( ) ; err ! = nil { logrus . infof ( " " , err ) } } ( ) } ) if err ! = nil { return nil , err } return & cache { c } , nil } 
func ( c * mergecache ) put ( id int64 , tree io . reader ) ( reterr error ) { return c . cache . put ( fmt . sprint ( id ) , tree ) } 
func ( c * mergecache ) get ( id int64 , w io . writer , filter filter ) ( reterr error ) { r , err : = c . cache . get ( fmt . sprint ( id ) ) if err ! = nil { return err } defer func ( ) { if err : = r . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) return newwriter ( w ) . copy ( newreader ( r , filter ) ) } 
func ( c * mergecache ) delete ( id int64 ) error { return c . cache . delete ( fmt . sprint ( id ) ) } 
func ( c * mergecache ) merge ( w * writer , base io . reader , filter filter ) ( reterr error ) { var trees [ ] * reader if base ! = nil { trees = append ( trees , newreader ( base , filter ) ) } for , key : = range c . keys ( ) { r , err : = c . cache . get ( key ) if err ! = nil { return err } defer func ( ) { if err : = r . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) trees = append ( trees , newreader ( r , filter ) ) } return merge ( w , trees ) } 
func printpipelineinfo ( w io . writer , pipelineinfo * ppsclient . pipelineinfo , fulltimestamps bool ) { fmt . fprintf ( w , " \ t " , pipelineinfo . pipeline . name ) fmt . fprintf ( w , " \ t " , shorthandinput ( pipelineinfo . input ) ) if fulltimestamps { fmt . fprintf ( w , " \ t " , pipelineinfo . createdat . string ( ) ) } else { fmt . fprintf ( w , " \ t " , pretty . ago ( pipelineinfo . createdat ) ) } fmt . fprintf ( w , " \ t \n " , pipelinestate ( pipelineinfo . state ) , jobstate ( pipelineinfo . lastjobstate ) ) } 
func printworkerstatus ( w io . writer , workerstatus * ppsclient . workerstatus , fulltimestamps bool ) { fmt . fprintf ( w , " \ t " , workerstatus . workerid ) fmt . fprintf ( w , " \ t " , workerstatus . jobid ) for , datum : = range workerstatus . data { fmt . fprintf ( w , datum . path ) } fmt . fprintf ( w , " \ t " ) if fulltimestamps { fmt . fprintf ( w , " \ t " , workerstatus . started . string ( ) ) } else { fmt . fprintf ( w , " \ t " , pretty . ago ( workerstatus . started ) ) } fmt . fprintf ( w , " \ t \n " , workerstatus . queuesize ) } 
func printdetailedjobinfo ( jobinfo * printablejobinfo ) error { template , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( ) if err ! = nil { return err } err = template . execute ( os . stdout , jobinfo ) if err ! = nil { return err } return nil } 
func printdetailedpipelineinfo ( pipelineinfo * printablepipelineinfo ) error { template , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( ) if err ! = nil { return err } err = template . execute ( os . stdout , pipelineinfo ) if err ! = nil { return err } return nil } 
func printdatuminfo ( w io . writer , datuminfo * ppsclient . datuminfo ) { totaltime : = " " if datuminfo . stats ! = nil { totaltime = units . humanduration ( client . getdatumtotaltime ( datuminfo . stats ) ) } fmt . fprintf ( w , " \ t \ t \n " , datuminfo . datum . id , datumstate ( datuminfo . state ) , totaltime ) } 
func printfile ( w io . writer , file * pfsclient . file ) { fmt . fprintf ( w , " \ t \ t \ t \n " , file . commit . repo . name , file . commit . id , file . path ) } 
func shorthandinput ( input * ppsclient . input ) string { switch { case input == nil : return " " case input . pfs ! = nil : return fmt . sprintf ( " " , input . pfs . repo , input . pfs . glob ) case input . cross ! = nil : var subinput [ ] string for , input : = range input . cross { subinput = append ( subinput , shorthandinput ( input ) ) } return " " + strings . join ( subinput , " + " " case input . union ! = nil : var subinput [ ] string for , input : = range input . union { subinput = append ( subinput , shorthandinput ( input ) ) } return " " + strings . join ( subinput , " + " " case input . cron ! = nil : return fmt . sprintf ( " " , input . cron . name , input . cron . spec ) } return " " } 
func ( v * vaultcredentialsprovider ) updatelease ( secret * vault . secret ) { v . leasemu . lock ( ) defer v . leasemu . unlock ( ) v . leaseid = secret . leaseid v . leaselastrenew = time . now ( ) v . leaseduration = time . duration ( secret . leaseduration ) * time . second } 
func ( v * vaultcredentialsprovider ) retrieve ( ) ( credentials . value , error ) { var emptycreds , result credentials . value vaultsecret , err : = v . vaultclient . logical ( ) . read ( path . join ( " " , " " , v . vaultrole ) ) if err ! = nil { return emptycreds , fmt . errorf ( " " , err ) } accesskeyiface , accesskeyok : = vaultsecret . data [ " " ] awssecretiface , awssecretok : = vaultsecret . data [ " " ] if ! accesskeyok | | ! awssecretok { return emptycreds , fmt . errorf ( " " ) } result . accesskeyid , accesskeyok = accesskeyiface . ( string ) result . secretaccesskey , awssecretok = awssecretiface . ( string ) if ! accesskeyok | | ! awssecretok { return emptycreds , fmt . errorf ( " " , accesskeyiface , awssecretiface ) } v . updatelease ( vaultsecret ) go func ( ) { for { renewinterval : = v . getleaseduration ( ) if renewinterval . seconds ( ) < onedayinseconds { renewinterval = onedayinseconds * time . second } time . sleep ( renewinterval ) backoff . retrynotify ( func ( ) error { vaultsecret , err : = v . vaultclient . sys ( ) . renew ( v . leaseid , twodaysinseconds ) if err ! = nil { return err } v . updatelease ( vaultsecret ) return nil } , backoff . newexponentialbackoff ( ) , func ( err error , time . duration ) error { log . errorf ( " " , err ) return nil } ) } } ( ) time . sleep ( 10 * time . second ) return result , nil } 
func ( v * vaultcredentialsprovider ) isexpired ( ) bool { v . leasemu . lock ( ) defer v . leasemu . unlock ( ) return time . now ( ) . after ( v . leaselastrenew . add ( v . leaseduration ) ) } 
func newbranch ( reponame string , branchname string ) * pfs . branch { return & pfs . branch { repo : newrepo ( reponame ) , name : branchname , } } 
func newcommit ( reponame string , commitid string ) * pfs . commit { return & pfs . commit { repo : newrepo ( reponame ) , id : commitid , } } 
func newcommitprovenance ( reponame string , branchname string , commitid string ) * pfs . commitprovenance { return & pfs . commitprovenance { commit : newcommit ( reponame , commitid ) , branch : newbranch ( reponame , branchname ) , } } 
func newfile ( reponame string , commitid string , path string ) * pfs . file { return & pfs . file { commit : newcommit ( reponame , commitid ) , path : path , } } 
func ( c apiclient ) createrepo ( reponame string ) error { , err : = c . pfsapiclient . createrepo ( c . ctx ( ) , & pfs . createreporequest { repo : newrepo ( reponame ) , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) inspectrepo ( reponame string ) ( * pfs . repoinfo , error ) { resp , err : = c . pfsapiclient . inspectrepo ( c . ctx ( ) , & pfs . inspectreporequest { repo : newrepo ( reponame ) , } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return resp , nil } 
func ( c apiclient ) listrepo ( ) ( [ ] * pfs . repoinfo , error ) { request : = & pfs . listreporequest { } repoinfos , err : = c . pfsapiclient . listrepo ( c . ctx ( ) , request , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return repoinfos . repoinfo , nil } 
func ( c apiclient ) deleterepo ( reponame string , force bool ) error { , err : = c . pfsapiclient . deleterepo ( c . ctx ( ) , & pfs . deletereporequest { repo : newrepo ( reponame ) , force : force , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) buildcommit ( reponame string , branch string , parent string , treeobject string ) ( * pfs . commit , error ) { commit , err : = c . pfsapiclient . buildcommit ( c . ctx ( ) , & pfs . buildcommitrequest { parent : newcommit ( reponame , parent ) , branch : branch , tree : & pfs . object { hash : treeobject } , } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return commit , nil } 
func ( c apiclient ) startcommitparent ( reponame string , branch string , parentcommit string ) ( * pfs . commit , error ) { commit , err : = c . pfsapiclient . startcommit ( c . ctx ( ) , & pfs . startcommitrequest { parent : & pfs . commit { repo : & pfs . repo { name : reponame , } , id : parentcommit , } , branch : branch , } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return commit , nil } 
func ( c apiclient ) finishcommit ( reponame string , commitid string ) error { , err : = c . pfsapiclient . finishcommit ( c . ctx ( ) , & pfs . finishcommitrequest { commit : newcommit ( reponame , commitid ) , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) inspectcommit ( reponame string , commitid string ) ( * pfs . commitinfo , error ) { return c . inspectcommit ( reponame , commitid , pfs . commitstate started ) } 
func ( c apiclient ) blockcommit ( reponame string , commitid string ) ( * pfs . commitinfo , error ) { return c . inspectcommit ( reponame , commitid , pfs . commitstate finished ) } 
func ( c apiclient ) listcommit ( reponame string , to string , from string , number uint64 ) ( [ ] * pfs . commitinfo , error ) { var result [ ] * pfs . commitinfo if err : = c . listcommitf ( reponame , to , from , number , func ( ci * pfs . commitinfo ) error { result = append ( result , ci ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c apiclient ) listcommitf ( reponame string , to string , from string , number uint64 , f func ( * pfs . commitinfo ) error ) error { req : = & pfs . listcommitrequest { repo : newrepo ( reponame ) , number : number , } if from ! = " " { req . from = newcommit ( reponame , from ) } if to ! = " " { req . to = newcommit ( reponame , to ) } stream , err : = c . pfsapiclient . listcommitstream ( c . ctx ( ) , req ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { ci , err : = stream . recv ( ) if err == io . eof { break } else if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = f ( ci ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } } return nil } 
func ( c apiclient ) listcommitbyrepo ( reponame string ) ( [ ] * pfs . commitinfo , error ) { return c . listcommit ( reponame , " " , " " , 0 ) } 
func ( c apiclient ) createbranch ( reponame string , branch string , commit string , provenance [ ] * pfs . branch ) error { var head * pfs . commit if commit ! = " " { head = newcommit ( reponame , commit ) } , err : = c . pfsapiclient . createbranch ( c . ctx ( ) , & pfs . createbranchrequest { branch : newbranch ( reponame , branch ) , head : head , provenance : provenance , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) inspectbranch ( reponame string , branch string ) ( * pfs . branchinfo , error ) { branchinfo , err : = c . pfsapiclient . inspectbranch ( c . ctx ( ) , & pfs . inspectbranchrequest { branch : newbranch ( reponame , branch ) , } , ) return branchinfo , grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) listbranch ( reponame string ) ( [ ] * pfs . branchinfo , error ) { branchinfos , err : = c . pfsapiclient . listbranch ( c . ctx ( ) , & pfs . listbranchrequest { repo : newrepo ( reponame ) , } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return branchinfos . branchinfo , nil } 
func ( c apiclient ) setbranch ( reponame string , commit string , branch string ) error { return c . createbranch ( reponame , branch , commit , nil ) } 
func ( c apiclient ) deletebranch ( reponame string , branch string , force bool ) error { , err : = c . pfsapiclient . deletebranch ( c . ctx ( ) , & pfs . deletebranchrequest { branch : newbranch ( reponame , branch ) , force : force , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) deletecommit ( reponame string , commitid string ) error { , err : = c . pfsapiclient . deletecommit ( c . ctx ( ) , & pfs . deletecommitrequest { commit : newcommit ( reponame , commitid ) , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) flushcommit ( commits [ ] * pfs . commit , torepos [ ] * pfs . repo ) ( commitinfoiterator , error ) { ctx , cancel : = context . withcancel ( c . ctx ( ) ) stream , err : = c . pfsapiclient . flushcommit ( ctx , & pfs . flushcommitrequest { commits : commits , torepos : torepos , } , ) if err ! = nil { cancel ( ) return nil , grpcutil . scrubgrpc ( err ) } return & commitinfoiterator { stream , cancel } , nil } 
func ( c apiclient ) flushcommitf ( commits [ ] * pfs . commit , torepos [ ] * pfs . repo , f func ( * pfs . commitinfo ) error ) error { stream , err : = c . pfsapiclient . flushcommit ( c . ctx ( ) , & pfs . flushcommitrequest { commits : commits , torepos : torepos , } , ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { ci , err : = stream . recv ( ) if err ! = nil { if err == io . eof { return nil } return grpcutil . scrubgrpc ( err ) } if err : = f ( ci ) ; err ! = nil { return err } } } 
func ( c apiclient ) flushcommitall ( commits [ ] * pfs . commit , torepos [ ] * pfs . repo ) ( [ ] * pfs . commitinfo , error ) { var result [ ] * pfs . commitinfo if err : = c . flushcommitf ( commits , torepos , func ( ci * pfs . commitinfo ) error { result = append ( result , ci ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c apiclient ) subscribecommit ( repo string , branch string , from string , state pfs . commitstate ) ( commitinfoiterator , error ) { ctx , cancel : = context . withcancel ( c . ctx ( ) ) req : = & pfs . subscribecommitrequest { repo : newrepo ( repo ) , branch : branch , state : state , } if from ! = " " { req . from = newcommit ( repo , from ) } stream , err : = c . pfsapiclient . subscribecommit ( ctx , req ) if err ! = nil { cancel ( ) return nil , grpcutil . scrubgrpc ( err ) } return & commitinfoiterator { stream , cancel } , nil } 
func ( c apiclient ) subscribecommitf ( repo , branch , from string , state pfs . commitstate , f func ( * pfs . commitinfo ) error ) error { req : = & pfs . subscribecommitrequest { repo : newrepo ( repo ) , branch : branch , state : state , } if from ! = " " { req . from = newcommit ( repo , from ) } stream , err : = c . pfsapiclient . subscribecommit ( c . ctx ( ) , req ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { ci , err : = stream . recv ( ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = f ( ci ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } } } 
func ( c apiclient ) putobjectasync ( tags [ ] * pfs . tag ) ( * putobjectwritecloserasync , error ) { w , err : = c . newputobjectwritecloserasync ( tags ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return w , nil } 
func ( c apiclient ) putobject ( r io . reader , tags ... string ) ( object * pfs . object , int64 , reterr error ) { r : = grpcutil . readerwrapper { r } w , err : = c . newputobjectwritecloser ( tags ... ) if err ! = nil { return nil , 0 , grpcutil . scrubgrpc ( err ) } defer func ( ) { if err : = w . close ( ) ; err ! = nil && reterr == nil { reterr = grpcutil . scrubgrpc ( err ) } if reterr == nil { object = w . object } } ( ) buf : = grpcutil . getbuffer ( ) defer grpcutil . putbuffer ( buf ) written , err : = io . copybuffer ( w , r , buf ) if err ! = nil { return nil , 0 , grpcutil . scrubgrpc ( err ) } return nil , written , nil } 
func ( c apiclient ) putobjectsplit ( r io . reader ) ( objects [ ] * pfs . object , int64 , reterr error ) { r : = grpcutil . readerwrapper { r } w , err : = c . newputobjectsplitwritecloser ( ) if err ! = nil { return nil , 0 , grpcutil . scrubgrpc ( err ) } defer func ( ) { if err : = w . close ( ) ; err ! = nil && reterr == nil { reterr = grpcutil . scrubgrpc ( err ) } if reterr == nil { objects = w . objects } } ( ) buf : = grpcutil . getbuffer ( ) defer grpcutil . putbuffer ( buf ) written , err : = io . copybuffer ( w , r , buf ) if err ! = nil { return nil , 0 , grpcutil . scrubgrpc ( err ) } return nil , written , nil } 
func ( c apiclient ) getobject ( hash string , writer io . writer ) error { getobjectclient , err : = c . objectapiclient . getobject ( c . ctx ( ) , & pfs . object { hash : hash } , ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = grpcutil . writefromstreamingbytesclient ( getobjectclient , writer ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } return nil } 
func ( c apiclient ) getobjectreader ( hash string ) ( io . readcloser , error ) { ctx , cancel : = context . withcancel ( c . ctx ( ) ) getobjectclient , err : = c . objectapiclient . getobject ( ctx , & pfs . object { hash : hash } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return grpcutil . newstreamingbytesreader ( getobjectclient , cancel ) , nil } 
func ( c apiclient ) readobject ( hash string ) ( [ ] byte , error ) { var buffer bytes . buffer if err : = c . getobject ( hash , & buffer ) ; err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return buffer . bytes ( ) , nil } 
func ( c apiclient ) getobjects ( hashes [ ] string , offset uint64 , size uint64 , totalsize uint64 , writer io . writer ) error { var objects [ ] * pfs . object for , hash : = range hashes { objects = append ( objects , & pfs . object { hash : hash } ) } getobjectsclient , err : = c . objectapiclient . getobjects ( c . ctx ( ) , & pfs . getobjectsrequest { objects : objects , offsetbytes : offset , sizebytes : size , totalsize : totalsize , } , ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = grpcutil . writefromstreamingbytesclient ( getobjectsclient , writer ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } return nil } 
func ( c apiclient ) readobjects ( hashes [ ] string , offset uint64 , size uint64 ) ( [ ] byte , error ) { var buffer bytes . buffer if err : = c . getobjects ( hashes , offset , size , 0 , & buffer ) ; err ! = nil { return nil , err } return buffer . bytes ( ) , nil } 
func ( c apiclient ) tagobject ( hash string , tags ... string ) error { var tags [ ] * pfs . tag for , tag : = range tags { tags = append ( tags , & pfs . tag { name : tag } ) } if , err : = c . objectapiclient . tagobject ( c . ctx ( ) , & pfs . tagobjectrequest { object : & pfs . object { hash : hash } , tags : tags , } , ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } return nil } 
func ( c apiclient ) listobject ( f func ( * pfs . object ) error ) error { listobjectclient , err : = c . objectapiclient . listobjects ( c . ctx ( ) , & pfs . listobjectsrequest { } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { object , err : = listobjectclient . recv ( ) if err ! = nil { if err == io . eof { return nil } return grpcutil . scrubgrpc ( err ) } if err : = f ( object ) ; err ! = nil { return err } } } 
func ( c apiclient ) inspectobject ( hash string ) ( * pfs . objectinfo , error ) { value , err : = c . objectapiclient . inspectobject ( c . ctx ( ) , & pfs . object { hash : hash } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return value , nil } 
func ( c apiclient ) gettag ( tag string , writer io . writer ) error { gettagclient , err : = c . objectapiclient . gettag ( c . ctx ( ) , & pfs . tag { name : tag } , ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = grpcutil . writefromstreamingbytesclient ( gettagclient , writer ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } return nil } 
func ( c apiclient ) gettagreader ( tag string ) ( io . readcloser , error ) { ctx , cancel : = context . withcancel ( c . ctx ( ) ) gettagclient , err : = c . objectapiclient . gettag ( ctx , & pfs . tag { name : tag } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return grpcutil . newstreamingbytesreader ( gettagclient , cancel ) , nil } 
func ( c apiclient ) readtag ( tag string ) ( [ ] byte , error ) { var buffer bytes . buffer if err : = c . gettag ( tag , & buffer ) ; err ! = nil { return nil , err } return buffer . bytes ( ) , nil } 
func ( c apiclient ) listtag ( f func ( * pfs . listtagsresponse ) error ) error { listtagclient , err : = c . objectapiclient . listtags ( c . ctx ( ) , & pfs . listtagsrequest { includeobject : true } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { listtagresponse , err : = listtagclient . recv ( ) if err ! = nil { if err == io . eof { return nil } return grpcutil . scrubgrpc ( err ) } if err : = f ( listtagresponse ) ; err ! = nil { return err } } } 
func ( c apiclient ) compact ( ) error { , err : = c . objectapiclient . compact ( c . ctx ( ) , & types . empty { } , ) return err } 
func ( c apiclient ) newputfileclient ( ) ( putfileclient , error ) { pfc , err : = c . pfsapiclient . putfile ( c . ctx ( ) ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return & putfileclient { c : pfc } , nil } 
func ( c * putfileclient ) putfilewriter ( reponame , commitid , path string ) ( io . writecloser , error ) { return c . newputfilewritecloser ( reponame , commitid , path , pfs . delimiter none , 0 , 0 , 0 , nil ) } 
func ( c * putfileclient ) putfilesplitwriter ( reponame string , commitid string , path string , delimiter pfs . delimiter , targetfiledatums int64 , targetfilebytes int64 , headerrecords int64 , overwrite bool ) ( io . writecloser , error ) { var overwriteindex * pfs . overwriteindex if overwrite { overwriteindex = & pfs . overwriteindex { } } return c . newputfilewritecloser ( reponame , commitid , path , delimiter , targetfiledatums , targetfilebytes , headerrecords , overwriteindex ) } 
func ( c * putfileclient ) putfile ( reponame string , commitid string , path string , reader io . reader ) ( int , reterr error ) { return c . putfilesplit ( reponame , commitid , path , pfs . delimiter none , 0 , 0 , 0 , false , reader ) } 
func ( c * putfileclient ) putfileoverwrite ( reponame string , commitid string , path string , reader io . reader , overwriteindex int64 ) ( int , reterr error ) { writer , err : = c . newputfilewritecloser ( reponame , commitid , path , pfs . delimiter none , 0 , 0 , 0 , & pfs . overwriteindex { index : overwriteindex } ) if err ! = nil { return 0 , grpcutil . scrubgrpc ( err ) } defer func ( ) { if err : = writer . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) written , err : = io . copy ( writer , reader ) return int ( written ) , grpcutil . scrubgrpc ( err ) } 
func ( c * putfileclient ) putfilesplit ( reponame string , commitid string , path string , delimiter pfs . delimiter , targetfiledatums int64 , targetfilebytes int64 , headerrecords int64 , overwrite bool , reader io . reader ) ( int , reterr error ) { writer , err : = c . putfilesplitwriter ( reponame , commitid , path , delimiter , targetfiledatums , targetfilebytes , headerrecords , overwrite ) if err ! = nil { return 0 , grpcutil . scrubgrpc ( err ) } defer func ( ) { if err : = writer . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) buf : = grpcutil . getbuffer ( ) defer grpcutil . putbuffer ( buf ) written , err : = io . copybuffer ( writer , reader , buf ) return int ( written ) , grpcutil . scrubgrpc ( err ) } 
func ( c * putfileclient ) putfileurl ( reponame string , commitid string , path string , url string , recursive bool , overwrite bool ) ( reterr error ) { c . mu . lock ( ) defer c . mu . unlock ( ) var overwriteindex * pfs . overwriteindex if overwrite { overwriteindex = & pfs . overwriteindex { } } if c . oneoff { defer func ( ) { if err : = grpcutil . scrubgrpc ( c . close ( ) ) ; err ! = nil && reterr == nil { reterr = err } } ( ) } if err : = c . c . send ( & pfs . putfilerequest { file : newfile ( reponame , commitid , path ) , url : url , recursive : recursive , overwriteindex : overwriteindex , } ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } return nil } 
func ( c * putfileclient ) close ( ) error { , err : = c . c . closeandrecv ( ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) putfilewriter ( reponame string , commitid string , path string ) ( io . writecloser , error ) { pfc , err : = c . newoneoffputfileclient ( ) if err ! = nil { return nil , err } return pfc . putfilewriter ( reponame , commitid , path ) } 
func ( c apiclient ) putfilesplitwriter ( reponame string , commitid string , path string , delimiter pfs . delimiter , targetfiledatums int64 , targetfilebytes int64 , headerrecords int64 , overwrite bool ) ( io . writecloser , error ) { pfc , err : = c . newoneoffputfileclient ( ) if err ! = nil { return nil , err } return pfc . putfilesplitwriter ( reponame , commitid , path , delimiter , targetfiledatums , targetfilebytes , headerrecords , overwrite ) } 
func ( c apiclient ) putfile ( reponame string , commitid string , path string , reader io . reader ) ( int , reterr error ) { pfc , err : = c . newoneoffputfileclient ( ) if err ! = nil { return 0 , err } return pfc . putfile ( reponame , commitid , path , reader ) } 
func ( c apiclient ) putfilesplit ( reponame string , commitid string , path string , delimiter pfs . delimiter , targetfiledatums int64 , targetfilebytes int64 , headerrecords int64 , overwrite bool , reader io . reader ) ( int , reterr error ) { pfc , err : = c . newoneoffputfileclient ( ) if err ! = nil { return 0 , err } return pfc . putfilesplit ( reponame , commitid , path , delimiter , targetfiledatums , targetfilebytes , headerrecords , overwrite , reader ) } 
func ( c apiclient ) putfileurl ( reponame string , commitid string , path string , url string , recursive bool , overwrite bool ) ( reterr error ) { pfc , err : = c . newoneoffputfileclient ( ) if err ! = nil { return err } return pfc . putfileurl ( reponame , commitid , path , url , recursive , overwrite ) } 
func ( c apiclient ) copyfile ( srcrepo , srccommit , srcpath , dstrepo , dstcommit , dstpath string , overwrite bool ) error { if , err : = c . pfsapiclient . copyfile ( c . ctx ( ) , & pfs . copyfilerequest { src : newfile ( srcrepo , srccommit , srcpath ) , dst : newfile ( dstrepo , dstcommit , dstpath ) , overwrite : overwrite , } ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } return nil } 
func ( c apiclient ) getfilereadseeker ( reponame string , commitid string , path string ) ( io . readseeker , error ) { fileinfo , err : = c . inspectfile ( reponame , commitid , path ) if err ! = nil { return nil , err } reader , err : = c . getfilereader ( reponame , commitid , path , 0 , 0 ) if err ! = nil { return nil , err } return & getfilereadseeker { reader : reader , file : newfile ( reponame , commitid , path ) , offset : 0 , size : int64 ( fileinfo . sizebytes ) , c : c , } , nil } 
func ( c apiclient ) inspectfile ( reponame string , commitid string , path string ) ( * pfs . fileinfo , error ) { return c . inspectfile ( reponame , commitid , path ) } 
func ( c apiclient ) listfile ( reponame string , commitid string , path string ) ( [ ] * pfs . fileinfo , error ) { var result [ ] * pfs . fileinfo if err : = c . listfilef ( reponame , commitid , path , 0 , func ( fi * pfs . fileinfo ) error { result = append ( result , fi ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c apiclient ) listfilehistory ( reponame string , commitid string , path string , history int64 ) ( [ ] * pfs . fileinfo , error ) { var result [ ] * pfs . fileinfo if err : = c . listfilef ( reponame , commitid , path , history , func ( fi * pfs . fileinfo ) error { result = append ( result , fi ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c apiclient ) listfilef ( reponame string , commitid string , path string , history int64 , f func ( fi * pfs . fileinfo ) error ) error { fs , err : = c . pfsapiclient . listfilestream ( c . ctx ( ) , & pfs . listfilerequest { file : newfile ( reponame , commitid , path ) , history : history , } , ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { fi , err : = fs . recv ( ) if err == io . eof { return nil } else if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = f ( fi ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } } } 
func ( c apiclient ) difffile ( newreponame , newcommitid , newpath , oldreponame , oldcommitid , oldpath string , shallow bool ) ( [ ] * pfs . fileinfo , [ ] * pfs . fileinfo , error ) { var oldfile * pfs . file if oldreponame ! = " " { oldfile = newfile ( oldreponame , oldcommitid , oldpath ) } resp , err : = c . pfsapiclient . difffile ( c . ctx ( ) , & pfs . difffilerequest { newfile : newfile ( newreponame , newcommitid , newpath ) , oldfile : oldfile , shallow : shallow , } , ) if err ! = nil { return nil , nil , grpcutil . scrubgrpc ( err ) } return resp . newfiles , resp . oldfiles , nil } 
func ( c apiclient ) walk ( reponame string , commitid string , path string , f walkfn ) error { fs , err : = c . pfsapiclient . walkfile ( c . ctx ( ) , & pfs . walkfilerequest { file : newfile ( reponame , commitid , path ) } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { fi , err : = fs . recv ( ) if err == io . eof { return nil } else if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = f ( fi ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } } } 
func ( c apiclient ) deletefile ( reponame string , commitid string , path string ) error { , err : = c . pfsapiclient . deletefile ( c . ctx ( ) , & pfs . deletefilerequest { file : newfile ( reponame , commitid , path ) , } , ) return err } 
func ( w * putobjectwritecloserasync ) write ( p [ ] byte ) ( int , error ) { select { case err : = < - w . errchan : if err ! = nil { return 0 , grpcutil . scrubgrpc ( err ) } default : for len ( w . buf ) + len ( p ) > cap ( w . buf ) { i : = cap ( w . buf ) - len ( w . buf ) w . buf = append ( w . buf , p [ : i ] ... ) p = p [ i : ] w . writechan < - w . buf w . buf = grpcutil . getbuffer ( ) [ : 0 ] } w . buf = append ( w . buf , p ... ) } return len ( p ) , nil } 
func ( w * putobjectwritecloserasync ) close ( ) error { w . writechan < - w . buf close ( w . writechan ) err : = < - w . errchan if err ! = nil { return grpcutil . scrubgrpc ( err ) } w . object , err = w . client . closeandrecv ( ) return grpcutil . scrubgrpc ( err ) } 
func ( w * putobjectwritecloserasync ) object ( ) ( * pfs . object , error ) { select { case err : = < - w . errchan : if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return w . object , nil default : return nil , fmt . errorf ( " " ) } } 
func prettyprintversion ( version * pb . version ) string { result : = prettyprintversionnoadditional ( version ) if version . additional ! = " " { result += fmt . sprintf ( " " , version . additional ) } return result } 
func prettyprintversionnoadditional ( version * pb . version ) string { return fmt . sprintf ( " " , version . major , version . minor , version . micro ) } 
func recursiveblockquoteexamples ( parent * cobra . command ) { if parent . example ! = " " { parent . example = fmt . sprintf ( " \n \n " , parent . example ) } for , cmd : = range parent . commands ( ) { recursiveblockquoteexamples ( cmd ) } } 
func errmissingfield ( field string ) * logical . response { return logical . errorresponse ( fmt . sprintf ( " " , field ) ) } 
func validatefields ( req * logical . request , data * framework . fielddata ) error { var unknownfields [ ] string for k : = range req . data { if , ok : = data . schema [ k ] ; ! ok { unknownfields = append ( unknownfields , k ) } } if len ( unknownfields ) > 0 { return fmt . errorf ( " " , unknownfields ) } return nil } 
func putconfig ( ctx context . context , s logical . storage , cfg * config ) error { entry , err : = logical . storageentryjson ( " " , cfg ) if err ! = nil { return fmt . errorf ( " " , err ) } if err : = s . put ( ctx , entry ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func getconfig ( ctx context . context , s logical . storage ) ( * config , error ) { entry , err : = s . get ( ctx , " " ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if entry == nil | | len ( entry . value ) == 0 { return nil , errors . new ( " " ) } var result config if err : = entry . decodejson ( & result ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } return & result , nil } 
func getstringfield ( data * framework . fielddata , key string ) ( string , * logical . response ) { valueiface , ok , err : = data . getokerr ( key ) if err ! = nil { return " " , logical . errorresponse ( fmt . sprintf ( " " , err , key ) ) } if ! ok { return " " , errmissingfield ( key ) } value , ok : = valueiface . ( string ) if ! ok { return " " , logical . errorresponse ( fmt . sprintf ( " " , key , valueiface ) ) } return value , nil } 
func newpuller ( ) * puller { return & puller { errch : make ( chan error , 1 ) , pipes : make ( map [ string ] bool ) , } } 
func ( p * puller ) pulltree ( client * pachclient . apiclient , root string , tree hashtree . hashtree , pipes bool , concurrency int ) error { limiter : = limit . new ( concurrency ) var eg errgroup . group if err : = tree . walk ( " " , func ( path string , node * hashtree . nodeproto ) error { if node . filenode ! = nil { path : = filepath . join ( root , path ) var hashes [ ] string for , object : = range node . filenode . objects { hashes = append ( hashes , object . hash ) } if pipes { return p . makepipe ( path , func ( w io . writer ) error { return client . getobjects ( hashes , 0 , 0 , uint64 ( node . subtreesize ) , w ) } ) } limiter . acquire ( ) eg . go ( func ( ) ( reterr error ) { defer limiter . release ( ) return p . makefile ( path , func ( w io . writer ) error { return client . getobjects ( hashes , 0 , 0 , uint64 ( node . subtreesize ) , w ) } ) } ) } return nil } ) ; err ! = nil { return err } return eg . wait ( ) } 
func ( p * puller ) cleanup ( ) ( int64 , error ) { var result error select { case result = < - p . errch : default : } var pipes [ ] io . closer func ( ) { p . lock ( ) defer p . unlock ( ) p . cleaned = true for path : = range p . pipes { f , err : = os . openfile ( path , syscall . o nonblock + os . o rdonly , os . modenamedpipe ) if err ! = nil && result == nil { result = err } pipes = append ( pipes , f ) } p . pipes = make ( map [ string ] bool ) } ( ) p . wg . wait ( ) for , pipe : = range pipes { if err : = pipe . close ( ) ; err ! = nil && result == nil { result = err } } size : = p . size p . size = 0 return size , result } 
func push ( client * pachclient . apiclient , root string , commit * pfs . commit , overwrite bool ) error { var g errgroup . group if err : = filepath . walk ( root , func ( path string , info os . fileinfo , err error ) error { g . go ( func ( ) ( reterr error ) { if path == root | | info . isdir ( ) { return nil } f , err : = os . open ( path ) if err ! = nil { return err } defer func ( ) { if err : = f . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) relpath , err : = filepath . rel ( root , path ) if err ! = nil { return err } if overwrite { if err : = client . deletefile ( commit . repo . name , commit . id , relpath ) ; err ! = nil { return err } } , err = client . putfile ( commit . repo . name , commit . id , relpath , f ) return err } ) return nil } ) ; err ! = nil { return err } return g . wait ( ) } 
func pushobj ( pachclient * pachclient . apiclient , commit * pfs . commit , objclient obj . client , root string ) error { var eg errgroup . group sem : = make ( chan struct { } , 200 ) if err : = pachclient . walk ( commit . repo . name , commit . id , " " , func ( fileinfo * pfs . fileinfo ) error { if fileinfo . filetype ! = pfs . filetype file { return nil } eg . go ( func ( ) ( reterr error ) { sem < - struct { } { } defer func ( ) { < - sem } ( ) w , err : = objclient . writer ( pachclient . ctx ( ) , filepath . join ( root , fileinfo . file . path ) ) if err ! = nil { return err } defer func ( ) { if err : = w . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) return pachclient . getfile ( commit . repo . name , commit . id , fileinfo . file . path , 0 , 0 , w ) } ) return nil } ) ; err ! = nil { return err } return eg . wait ( ) } 
func pushfile ( c * pachclient . apiclient , pfc pachclient . putfileclient , pfsfile * pfs . file , osfile io . readseeker ) error { fileinfo , err : = c . inspectfile ( pfsfile . commit . repo . name , pfsfile . commit . id , pfsfile . path ) if err ! = nil && ! isnotexist ( err ) { return err } var i int var object * pfs . object if fileinfo ! = nil { for i , object = range fileinfo . objects { hash : = pfs . newhash ( ) if , err : = io . copyn ( hash , osfile , pfs . chunksize ) ; err ! = nil { if err == io . eof { break } return err } if object . hash ! = pfs . encodehash ( hash . sum ( nil ) ) { break } } } if , err : = osfile . seek ( int64 ( i ) * pfs . chunksize , 0 ) ; err ! = nil { return err } , err = pfc . putfileoverwrite ( pfsfile . commit . repo . name , pfsfile . commit . id , pfsfile . path , osfile , int64 ( i ) ) return err } 
func ( c apiclient ) dump ( w io . writer ) error { goroclient , err : = c . debugclient . dump ( c . ctx ( ) , & debug . dumprequest { } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } return grpcutil . scrubgrpc ( grpcutil . writefromstreamingbytesclient ( goroclient , w ) ) } 
func ( c apiclient ) profile ( profile string , duration time . duration , w io . writer ) error { var d * types . duration if duration ! = 0 { d = types . durationproto ( duration ) } profileclient , err : = c . debugclient . profile ( c . ctx ( ) , & debug . profilerequest { profile : profile , duration : d , } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } return grpcutil . scrubgrpc ( grpcutil . writefromstreamingbytesclient ( profileclient , w ) ) } 
func ( c apiclient ) binary ( w io . writer ) error { binaryclient , err : = c . debugclient . binary ( c . ctx ( ) , & debug . binaryrequest { } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } return grpcutil . scrubgrpc ( grpcutil . writefromstreamingbytesclient ( binaryclient , w ) ) } 
func registercachestats ( cachename string , groupcachestats * groupcache . stats ) { c : = & cachestats { cachename : cachename , descriptions : make ( map [ string ] * prometheus . desc ) , stats : groupcachestats , } if err : = prometheus . register ( c ) ; err ! = nil { if , ok : = err . ( prometheus . alreadyregisterederror ) ; ! ok { logrus . infof ( " " , err ) } } } 
func ( c * counter ) wait ( n int64 ) { c . mu . lock ( ) defer c . mu . unlock ( ) for c . n < n { c . cond . wait ( ) } } 
func ( c * counter ) cancel ( ) { c . mu . lock ( ) defer c . mu . unlock ( ) c . n = math . maxint64 } 
func runworkload ( client * client . apiclient , rand * rand . rand , size int , ) error { worker : = newworker ( rand ) for i : = 0 ; i < size ; i ++ { if err : = worker . work ( client ) ; err ! = nil { return err } } for , job : = range worker . startedjobs { jobinfo , err : = client . inspectjob ( job . id , true ) if err ! = nil { return err } if jobinfo . state ! = pps . jobstate job success { return fmt . errorf ( " " , job . id ) } } return nil } 
func ( w * worker ) createrepo ( c * client . apiclient ) error { reponame : = w . randstring ( 10 ) if err : = c . createrepo ( reponame ) ; err ! = nil { return err } w . repos = append ( w . repos , & pfs . repo { name : reponame } ) commit , err : = c . startcommit ( reponame , " " ) if err ! = nil { return err } w . started = append ( w . started , commit ) return nil } 
func ( w * worker ) advancecommit ( c * client . apiclient ) error { if len ( w . started ) >= maxstartedcommits | | len ( w . finished ) == 0 { if len ( w . started ) == 0 { return nil } i : = w . rand . intn ( len ( w . started ) ) commit : = w . started [ i ] if , err : = c . putfile ( commit . repo . name , commit . id , w . randstring ( 10 ) , w . reader ( ) ) ; err ! = nil { return err } if err : = c . finishcommit ( commit . repo . name , commit . id ) ; err ! = nil { return err } w . started = append ( w . started [ : i ] , w . started [ i + 1 : ] ... ) w . finished = append ( w . finished , commit ) } else { commit : = w . finished [ w . rand . intn ( len ( w . finished ) ) ] commit , err : = c . startcommitparent ( commit . repo . name , " " , commit . id ) if err ! = nil { return err } w . started = append ( w . started , commit ) } return nil } 
func ( w * worker ) putfile ( c * client . apiclient ) error { if len ( w . started ) == 0 { return nil } commit : = w . started [ w . rand . intn ( len ( w . started ) ) ] if , err : = c . putfile ( commit . repo . name , commit . id , w . randstring ( 10 ) , w . reader ( ) ) ; err ! = nil { return err } return nil } 
func randstring ( r * rand . rand , n int ) string { b : = make ( [ ] byte , n ) for i : = range b { b [ i ] = letters [ r . intn ( len ( letters ) ) ] } return string ( b ) } 
func newreader ( rand * rand . rand , bytes int64 ) io . reader { return & reader { rand : rand , bytes : bytes , } } 
func newdbhashtree ( storageroot string ) ( hashtree , error ) { file : = dbfile ( storageroot ) if err : = os . mkdirall ( pathlib . dir ( file ) , 0777 ) ; err ! = nil { return nil , err } result , err : = newdbhashtree ( file ) if err ! = nil { return nil , err } if err : = result . putdir ( " " ) ; err ! = nil { return nil , err } return result , err } 
func deserializedbhashtree ( storageroot string , r io . reader ) ( hashtree , reterr error ) { result , err : = newdbhashtree ( storageroot ) if err ! = nil { return nil , err } if err : = result . deserialize ( r ) ; err ! = nil { return nil , err } return result , nil } 
func ( h * dbhashtree ) get ( path string ) ( * nodeproto , error ) { path = clean ( path ) var node * nodeproto if err : = h . view ( func ( tx * bolt . tx ) error { var err error node , err = get ( tx , path ) return err } ) ; err ! = nil { return nil , err } return node , nil } 
func get ( rs [ ] io . readcloser , filepath string ) ( * nodeproto , error ) { filepath = clean ( filepath ) var filenode * nodeproto if err : = nodes ( rs , func ( path string , node * nodeproto ) error { if path == filepath { filenode = node } return nil } ) ; err ! = nil { return nil , err } if filenode == nil { return nil , errorf ( pathnotfound , " " " " , filepath ) } return filenode , nil } 
func iterdir ( tx * bolt . tx , path string , f func ( k , v [ ] byte , c * bolt . cursor ) error ) error { node , err : = get ( tx , path ) if err ! = nil { return err } if node . dirnode == nil { return errorf ( pathconflict , " " " " , path ) } c : = newchildcursor ( tx , path ) for k , v : = c . k ( ) , c . v ( ) ; k ! = nil ; k , v = c . next ( ) { if err : = f ( k , v , c . c ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } } return nil } 
func ( h * dbhashtree ) list ( path string , f func ( * nodeproto ) error ) error { path = clean ( path ) return h . view ( func ( tx * bolt . tx ) error { return list ( tx , path , f ) } ) } 
func ( h * dbhashtree ) listall ( path string ) ( [ ] * nodeproto , error ) { var result [ ] * nodeproto if err : = h . list ( path , func ( node * nodeproto ) error { result = append ( result , node ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func list ( rs [ ] io . readcloser , pattern string , f func ( string , * nodeproto ) error ) ( reterr error ) { pattern = clean ( pattern ) if pattern == " " { pattern = " " } g , err : = globlib . compile ( pattern , ' / ' ) if err ! = nil { return errorf ( malformedglob , err . error ( ) ) } return nodes ( rs , func ( path string , node * nodeproto ) error { if ( g . match ( path ) && node . dirnode == nil ) | | ( g . match ( pathlib . dir ( path ) ) ) { return f ( path , node ) } return nil } ) } 
func ( h * dbhashtree ) glob ( pattern string , f func ( string , * nodeproto ) error ) error { pattern = clean ( pattern ) return h . view ( func ( tx * bolt . tx ) error { return glob ( tx , pattern , f ) } ) } 
func glob ( rs [ ] io . readcloser , pattern string , f func ( string , * nodeproto ) error ) ( reterr error ) { pattern = clean ( pattern ) g , err : = globlib . compile ( pattern , ' / ' ) if err ! = nil { return errorf ( malformedglob , err . error ( ) ) } return nodes ( rs , func ( path string , node * nodeproto ) error { if g . match ( path ) { return f ( externaldefault ( path ) , node ) } return nil } ) } 
func ( h * dbhashtree ) fssize ( ) int64 { rootnode , err : = h . get ( " " ) if err ! = nil { return 0 } return rootnode . subtreesize } 
func ( h * dbhashtree ) walk ( path string , f func ( path string , node * nodeproto ) error ) error { path = clean ( path ) return h . view ( func ( tx * bolt . tx ) error { c : = fs ( tx ) . cursor ( ) for k , v : = c . seek ( b ( path ) ) ; k ! = nil && strings . hasprefix ( s ( k ) , path ) ; k , v = c . next ( ) { node : = & nodeproto { } if err : = node . unmarshal ( v ) ; err ! = nil { return err } nodepath : = s ( k ) if nodepath == " " { nodepath = " " } if nodepath ! = path && ! strings . hasprefix ( nodepath , path + " " ) { continue } if err : = f ( nodepath , node ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } } return nil } ) } 
func walk ( rs [ ] io . readcloser , walkpath string , f func ( path string , node * nodeproto ) error ) error { walkpath = clean ( walkpath ) return nodes ( rs , func ( path string , node * nodeproto ) error { if path == " " { path = " " } if path ! = walkpath && ! strings . hasprefix ( path , walkpath + " " ) { return nil } if err : = f ( path , node ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } return nil } ) } 
func ( h * dbhashtree ) diff ( oldhashtree hashtree , newpath string , oldpath string , recursivedepth int64 , f func ( path string , node * nodeproto , new bool ) error ) ( reterr error ) { old : = oldhashtree . ( * dbhashtree ) if old == nil { return fmt . errorf ( " " ) } rollback : = func ( tx * bolt . tx ) { if err : = tx . rollback ( ) ; err ! = nil && reterr == nil { reterr = err } } var newtx * bolt . tx var oldtx * bolt . tx if h == oldhashtree { tx , err : = h . begin ( false ) if err ! = nil { return err } newtx = tx oldtx = tx defer rollback ( tx ) } else { var err error newtx , err = h . begin ( false ) if err ! = nil { return err } defer rollback ( newtx ) oldtx , err = old . begin ( false ) if err ! = nil { return err } defer rollback ( oldtx ) } return diff ( newtx , oldtx , newpath , oldpath , recursivedepth , f ) } 
func ( h * dbhashtree ) serialize ( w io . writer ) error { w : = pbutil . newwriter ( w ) return h . view ( func ( tx * bolt . tx ) error { for , bucket : = range buckets { b : = tx . bucket ( b ( bucket ) ) if , err : = w . write ( & bucketheader { bucket : bucket , } ) ; err ! = nil { return err } if err : = b . foreach ( func ( k , v [ ] byte ) error { if , err : = w . writebytes ( k ) ; err ! = nil { return err } , err : = w . writebytes ( v ) return err } ) ; err ! = nil { return err } if , err : = w . writebytes ( sentinelbyte ) ; err ! = nil { return err } } return nil } ) } 
func ( h * dbhashtree ) copy ( ) ( hashtree , error ) { if err : = h . hash ( ) ; err ! = nil { return nil , err } r , w : = io . pipe ( ) var eg errgroup . group eg . go ( func ( ) ( reterr error ) { defer func ( ) { if err : = w . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) return h . serialize ( w ) } ) var result hashtree eg . go ( func ( ) error { var err error result , err = deserializedbhashtree ( pathlib . dir ( h . path ( ) ) , r ) return err } ) if err : = eg . wait ( ) ; err ! = nil { return nil , err } return result , nil } 
func ( h * dbhashtree ) destroy ( ) error { path : = h . path ( ) if err : = h . close ( ) ; err ! = nil { return err } return os . remove ( path ) } 
func visit ( tx * bolt . tx , path string , update updatefn ) error { for path ! = " " { parent , child : = split ( path ) pnode , err : = get ( tx , parent ) if err ! = nil && code ( err ) ! = pathnotfound { return err } if pnode ! = nil && pnode . nodetype ( ) ! = directory { return errorf ( pathconflict , " " " " + " " , path ) } if pnode == nil { pnode = & nodeproto { } } if err : = update ( pnode , parent , child ) ; err ! = nil { return err } if err : = put ( tx , parent , pnode ) ; err ! = nil { return err } path = parent } return nil } 
func ( h * dbhashtree ) putfile ( path string , objects [ ] * pfs . object , size int64 ) error { return h . putfile ( path , objects , nil , size , false ) } 
func ( h * dbhashtree ) putfileoverwrite ( path string , objects [ ] * pfs . object , overwriteindex * pfs . overwriteindex , sizedelta int64 ) error { return h . putfile ( path , objects , overwriteindex , sizedelta , false ) } 
func ( h * dbhashtree ) putdirheaderfooter ( path string , header , footer * pfs . object , headersize , footersize int64 ) error { path = clean ( path ) return h . batch ( func ( tx * bolt . tx ) error { node , err : = get ( tx , path ) if err ! = nil && code ( err ) ! = pathnotfound { return errorf ( internal , " " , path , err ) } if node ! = nil && node . nodetype ( ) ! = directory { return errorf ( pathconflict , " " + " " , path , node . nodetype ( ) ) } var newnode bool if node == nil { newnode = true node = & nodeproto { name : base ( path ) , dirnode : & directorynodeproto { shared : & shared { } , } , subtreesize : headersize + footersize , } } headersame : = ( node . dirnode . shared . header == nil && header == nil ) | | ( node . dirnode . shared . header ! = nil && node . dirnode . shared . header . hash == header . hash ) footersame : = ( node . dirnode . shared . footer == nil && footer == nil ) | | ( node . dirnode . shared . footer ! = nil && node . dirnode . shared . footer . hash == footer . hash ) if newnode | | ! headersame | | ! footersame { node . dirnode . shared = & shared { header : header , footer : footer , headersize : headersize , footersize : footersize , } return put ( tx , path , node ) } return nil } ) } 
func ( h * dbhashtree ) putfileheaderfooter ( path string , objects [ ] * pfs . object , size int64 ) error { return h . putfile ( path , objects , nil , size , true ) } 
func ( h * dbhashtree ) putdir ( path string ) error { path = clean ( path ) return h . batch ( func ( tx * bolt . tx ) error { node , err : = get ( tx , path ) if err ! = nil && code ( err ) ! = pathnotfound { return err } if node ! = nil { if node . nodetype ( ) == directory { return nil } else if node . nodetype ( ) ! = none { return errorf ( pathconflict , " " " " + " " , path , node . nodetype ( ) ) } } node = & nodeproto { name : base ( path ) , dirnode : & directorynodeproto { } , } if err : = put ( tx , path , node ) ; err ! = nil { return err } return visit ( tx , path , func ( node * nodeproto , parent , child string ) error { if node . dirnode == nil { node . name = base ( parent ) node . dirnode = & directorynodeproto { } } return nil } ) } ) } 
func deletedir ( tx * bolt . tx , path string ) error { c : = fs ( tx ) . cursor ( ) prefix : = append ( b ( path ) , nullbyte [ 0 ] ) for k , : = c . seek ( prefix ) ; bytes . hasprefix ( k , prefix ) ; k , = c . next ( ) { if err : = c . delete ( ) ; err ! = nil { return err } } return fs ( tx ) . delete ( b ( path ) ) } 
func ( h * dbhashtree ) deletefile ( path string ) error { path = clean ( path ) if path == " " { path = " " } return h . batch ( func ( tx * bolt . tx ) error { if err : = glob ( tx , path , func ( path string , node * nodeproto ) error { if , err : = get ( tx , path ) ; err ! = nil && code ( err ) == pathnotfound { return nil } if err : = deletedir ( tx , path ) ; err ! = nil { return err } size : = node . subtreesize parent , : = split ( path ) pnode , err : = get ( tx , parent ) if err ! = nil { if code ( err ) == pathnotfound { return errorf ( internal , " " " " , path ) } return err } if pnode . dirnode == nil { return errorf ( internal , " " " " " " + " " , path , pnode . dirnode ) } put ( tx , parent , pnode ) if err : = visit ( tx , path , func ( node * nodeproto , parent , child string ) error { if node . dirnode == nil { return errorf ( internal , " " " " " " , path , join ( parent , child ) ) } node . subtreesize - = size return nil } ) ; err ! = nil { return err } return nil } ) ; err ! = nil && code ( err ) ! = pathnotfound { return err } return nil } ) } 
func newreader ( r io . reader , filter filter ) * reader { return & reader { pbr : pbutil . newreader ( r ) , filter : filter , } } 
func ( r * reader ) read ( ) ( * mergenode , error ) { k , err : = r . pbr . readbytes ( ) if err ! = nil { return nil , err } if r . filter ! = nil { for { if r . filter ( k ) { break } , err = r . pbr . readbytes ( ) if err ! = nil { return nil , err } k , err = r . pbr . readbytes ( ) if err ! = nil { return nil , err } } } k : = make ( [ ] byte , len ( k ) ) copy ( k , k ) v , err : = r . pbr . readbytes ( ) if err ! = nil { return nil , err } v : = make ( [ ] byte , len ( v ) ) copy ( v , v ) return & mergenode { k : k , v : v , } , nil } 
func newwriter ( w io . writer ) * writer { return & writer { pbw : pbutil . newwriter ( w ) , } } 
func ( w * writer ) write ( n * mergenode ) error { if n . nodeproto ! = nil { var err error n . v , err = n . nodeproto . marshal ( ) if err ! = nil { return err } } if bytes . equal ( n . k , nullbyte ) { if n . nodeproto == nil { n . nodeproto = & nodeproto { } if err : = n . nodeproto . unmarshal ( n . v ) ; err ! = nil { return err } } w . size = uint64 ( n . nodeproto . subtreesize ) } if w . offset > uint64 ( len ( w . idxs ) + 1 ) * indexsize { w . idxs = append ( w . idxs , & index { k : n . k , offset : w . offset , } ) } b , err : = w . pbw . writebytes ( n . k ) if err ! = nil { return err } w . offset += uint64 ( b ) b , err = w . pbw . writebytes ( n . v ) if err ! = nil { return err } w . offset += uint64 ( b ) return nil } 
func ( w * writer ) copy ( r * reader ) error { for { n , err : = r . read ( ) if err ! = nil { if err == io . eof { return nil } return err } if err : = w . write ( n ) ; err ! = nil { return err } } } 
func ( w * writer ) index ( ) ( [ ] byte , error ) { buf : = & bytes . buffer { } pbw : = pbutil . newwriter ( buf ) for , idx : = range w . idxs { if , err : = pbw . write ( idx ) ; err ! = nil { return nil , err } } return buf . bytes ( ) , nil } 
func getrangefromindex ( r io . reader , prefix string ) ( uint64 , uint64 , error ) { prefix = clean ( prefix ) pbr : = pbutil . newreader ( r ) idx : = & index { } k : = b ( prefix ) var lower , upper uint64 iter : = func ( f func ( int ) bool ) error { for { if err : = pbr . read ( idx ) ; err ! = nil { if err == io . eof { break } return err } var cmp int if len ( k ) < len ( idx . k ) { cmp = bytes . compare ( k , idx . k [ : len ( k ) ] ) } else { cmp = bytes . compare ( k [ : len ( idx . k ) ] , idx . k ) } if f ( cmp ) { break } } return nil } low : = func ( cmp int ) bool { if cmp > 0 { lower = idx . offset return false } else if cmp < 0 { upper = idx . offset } return true } up : = func ( cmp int ) bool { if cmp < 0 { upper = idx . offset return true } return false } iter ( low ) if upper <= 0 { iter ( up ) } if upper <= 0 { return lower , 0 , nil } return lower , upper - lower , nil } 
func newfilter ( numtrees int64 , tree int64 ) filter { return func ( k [ ] byte ) bool { if pathtotree ( k , numtrees ) == uint64 ( tree ) { return true } return false } } 
func pathtotree ( path string , numtrees int64 ) uint64 { path = clean ( path ) return pathtotree ( b ( path ) , numtrees ) } 
func merge ( w * writer , rs [ ] * reader ) error { if len ( rs ) == 0 { return nil } mq : = & mergepq { q : make ( [ ] * nodestream , len ( rs ) + 1 ) } for , r : = range rs { if err : = mq . insert ( & nodestream { r : r } ) ; err ! = nil { return err } } for mq . q [ 1 ] ! = nil { ns , err : = mq . next ( ) if err ! = nil { return err } n , err : = merge ( ns ) if err ! = nil { return err } if err : = w . write ( n ) ; err ! = nil { return err } } return nil } 
func hashfilenode ( n * filenodeproto ) [ ] byte { hash : = sha256 . new ( ) for , object : = range n . objects { hash . write ( [ ] byte ( object . hash ) ) } return hash . sum ( nil ) } 
func ( h * dbhashtree ) hash ( ) error { return h . batch ( func ( tx * bolt . tx ) error { return canonicalize ( tx , " " ) } ) } 
func isglob ( pattern string ) bool { pattern = clean ( pattern ) return globregex . match ( [ ] byte ( pattern ) ) } 
func globliteralprefix ( pattern string ) string { pattern = clean ( pattern ) idx : = globregex . findstringindex ( pattern ) if idx == nil { return pattern } return pattern [ : idx [ 0 ] ] } 
func gethashtreeobject ( pachclient * client . apiclient , storageroot string , treeref * pfs . object ) ( hashtree , error ) { return gethashtree ( storageroot , func ( w io . writer ) error { return pachclient . getobject ( treeref . hash , w ) } ) } 
func gethashtreetag ( pachclient * client . apiclient , storageroot string , treeref * pfs . tag ) ( hashtree , error ) { return gethashtree ( storageroot , func ( w io . writer ) error { return pachclient . gettag ( treeref . name , w ) } ) } 
func puthashtree ( pachclient * client . apiclient , tree hashtree , tags ... string ) ( * pfs . object , error ) { r , w : = io . pipe ( ) var eg errgroup . group eg . go ( func ( ) ( reterr error ) { defer func ( ) { if err : = w . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) return tree . serialize ( w ) } ) var treeref * pfs . object eg . go ( func ( ) error { var err error treeref , , err = pachclient . putobject ( r , tags ... ) return err } ) if err : = eg . wait ( ) ; err ! = nil { return nil , err } return treeref , nil } 
func newchildcursor ( tx * bolt . tx , path string ) * childcursor { path = clean ( path ) c : = fs ( tx ) . cursor ( ) dir : = b ( path ) k , v : = c . seek ( append ( dir , nullbyte [ 0 ] ) ) if ! bytes . equal ( dir , nullbyte ) { dir = append ( dir , nullbyte [ 0 ] ) } if ! bytes . hasprefix ( k , dir ) { k , v = nil , nil } return & childcursor { c : c , dir : dir , k : k , v : v , } } 
func ( d * childcursor ) next ( ) ( [ ] byte , [ ] byte ) { if d . k == nil { return nil , nil } k , v : = d . c . seek ( append ( d . k , 1 ) ) if ! bytes . hasprefix ( k , d . dir ) { k , v = nil , nil } d . k , d . v = k , v return k , v } 
func newordered ( root string ) * ordered { root = clean ( root ) o : = & ordered { } n : = & node { path : " " , nodeproto : & nodeproto { name : " " , dirnode : & directorynodeproto { } , } , hash : sha256 . new ( ) , } o . fs = append ( o . fs , n ) o . dirstack = append ( o . dirstack , n ) o . mkdirall ( root ) o . root = root return o } 
func ( o * ordered ) mkdirall ( path string ) { var paths [ ] string for path ! = " " { paths = append ( paths , path ) path , = split ( path ) } for i : = len ( paths ) - 1 ; i >= 0 ; i -- { o . putdir ( paths [ i ] ) } } 
func ( o * ordered ) putdir ( path string ) { path = clean ( path ) if path == " " { return } nodeproto : = & nodeproto { name : base ( path ) , dirnode : & directorynodeproto { } , } o . putdir ( path , nodeproto ) } 
func ( o * ordered ) putfile ( path string , hash [ ] byte , size int64 , filenodeproto * filenodeproto ) { path = clean ( path ) nodeproto : = & nodeproto { name : base ( path ) , hash : hash , subtreesize : size , filenode : filenodeproto , } o . putfile ( path , nodeproto ) } 
func ( o * ordered ) serialize ( w io . writer ) error { w : = newwriter ( w ) for len ( o . dirstack ) > 1 { child : = o . dirstack [ len ( o . dirstack ) - 1 ] child . nodeproto . hash = child . hash . sum ( nil ) o . dirstack = o . dirstack [ : len ( o . dirstack ) - 1 ] parent : = o . dirstack [ len ( o . dirstack ) - 1 ] parent . hash . write ( [ ] byte ( fmt . sprintf ( " " , child . nodeproto . name , child . nodeproto . hash ) ) ) parent . nodeproto . subtreesize += child . nodeproto . subtreesize } o . fs [ 0 ] . nodeproto . hash = o . fs [ 0 ] . hash . sum ( nil ) for , n : = range o . fs { if err : = w . write ( & mergenode { k : b ( n . path ) , nodeproto : n . nodeproto , } ) ; err ! = nil { return err } } return nil } 
func newunordered ( root string ) * unordered { return & unordered { fs : make ( map [ string ] * nodeproto ) , root : clean ( root ) , } } 
func ( u * unordered ) putfile ( path string , hash [ ] byte , size int64 , blockrefs ... * pfs . blockref ) { path = join ( u . root , path ) nodeproto : = & nodeproto { name : base ( path ) , hash : hash , subtreesize : size , filenode : & filenodeproto { blockrefs : blockrefs , } , } u . fs [ path ] = nodeproto u . createparents ( path ) } 
func ( u * unordered ) ordered ( ) * ordered { paths : = make ( [ ] string , len ( u . fs ) ) i : = 0 for path : = range u . fs { paths [ i ] = path i ++ } sort . strings ( paths ) o : = newordered ( " " ) for i : = 1 ; i < len ( paths ) ; i ++ { path : = paths [ i ] n : = u . fs [ path ] if n . dirnode ! = nil { o . putdir ( path , n ) } else { o . putfile ( path , n ) } } return o } 
func ( b * backend ) revoke ( ctx context . context , req * logical . request , data * framework . fielddata ) ( resp * logical . response , reterr error ) { b . logger ( ) . debug ( fmt . sprintf ( " " , req . id , req . operation , req . path ) ) defer func ( ) { b . logger ( ) . debug ( fmt . sprintf ( " " , req . id , req . operation , req . path , reterr == nil && ! resp . iserror ( ) ) ) } ( ) tokeniface , ok : = req . secret . internaldata [ " " ] if ! ok { return nil , fmt . errorf ( " " ) } usertoken , ok : = tokeniface . ( string ) if ! ok { return nil , fmt . errorf ( " " , tokeniface ) } config , err : = getconfig ( ctx , req . storage ) if err ! = nil { return nil , err } if len ( config . admintoken ) == 0 { return nil , errors . new ( " " ) } if len ( config . pachdaddress ) == 0 { return nil , errors . new ( " " ) } err = revokeusercredentials ( ctx , config . pachdaddress , usertoken , config . admintoken ) if err ! = nil { return nil , err } return & logical . response { } , nil } 
func revokeusercredentials ( ctx context . context , pachdaddress string , usertoken string , admintoken string ) error { client , err : = pclient . newfromaddress ( pachdaddress ) if err ! = nil { return err } defer client . close ( ) client = client . withctx ( ctx ) client . setauthtoken ( admintoken ) , err = client . authapiclient . revokeauthtoken ( client . ctx ( ) , & auth . revokeauthtokenrequest { token : usertoken , } ) return err } 
func newapiserver ( version * pb . version , options apiserveroptions ) pb . apiserver { return newapiserver ( version , options ) } 
func getserverversion ( clientconn * grpc . clientconn ) ( * pb . version , error ) { return pb . newapiclient ( clientconn ) . getversion ( context . background ( ) , & types . empty { } , ) } 
func string ( v * pb . version ) string { return fmt . sprintf ( " " , v . major , v . minor , v . micro , v . additional ) } 
func getpipelineinfo ( pachclient * client . apiclient , env * serviceenv . serviceenv ) ( * pps . pipelineinfo , error ) { ctx , cancel : = context . withtimeout ( context . background ( ) , 30 * time . second ) defer cancel ( ) resp , err : = env . getetcdclient ( ) . get ( ctx , path . join ( env . ppsetcdprefix , " " , env . ppspipelinename ) ) if err ! = nil { return nil , err } if len ( resp . kvs ) ! = 1 { return nil , fmt . errorf ( " " , env . ppspipelinename , len ( resp . kvs ) , resp ) } var pipelineptr pps . etcdpipelineinfo if err : = pipelineptr . unmarshal ( resp . kvs [ 0 ] . value ) ; err ! = nil { return nil , err } pachclient . setauthtoken ( pipelineptr . authtoken ) pipelineptr . speccommit . id = env . ppsspeccommitid return ppsutil . getpipelineinfo ( pachclient , & pipelineptr , true ) } 
func insertstr ( ss * [ ] string , news string ) bool { sz : = cap ( * ss ) idx : = sort . searchstrings ( * ss , news ) if idx >= len ( * ss ) | | ( * ss ) [ idx ] ! = news { if sz >= ( len ( * ss ) + 1 ) { * ss = ( * ss ) [ : len ( * ss ) + 1 ] copy ( ( * ss ) [ idx + 1 : ] , ( * ss ) [ idx : ] ) ( * ss ) [ idx ] = news } else { cap1 , cap2 : = int ( float64 ( sz ) * 1 . 33 ) , sz + 10 newss : = make ( [ ] string , len ( * ss ) + 1 , max ( cap1 , cap2 ) ) copy ( newss , ( * ss ) [ : idx ] ) copy ( newss [ idx + 1 : ] , ( * ss ) [ idx : ] ) newss [ idx ] = news * ss = newss } return true } return false } 
func removestr ( ss * [ ] string , s string ) bool { idx : = sort . searchstrings ( * ss , s ) if idx == len ( * ss ) { return false } copy ( ( * ss ) [ idx : ] , ( * ss ) [ idx + 1 : ] ) * ss = ( * ss ) [ : len ( * ss ) - 1 ] return true } 
func publiccerttopem ( cert * tls . certificate ) [ ] byte { return pem . encodetomemory ( & pem . block { type : " " , bytes : cert . certificate [ 0 ] , } ) } 
func keytopem ( cert * tls . certificate ) [ ] byte { switch k : = cert . privatekey . ( type ) { case * rsa . privatekey : return pem . encodetomemory ( & pem . block { type : " " , bytes : x509 . marshalpkcs1privatekey ( k ) , } ) default : return nil } } 
func activatecmd ( nometrics , noportforwarding * bool ) * cobra . command { var initialadmin string activate : = & cobra . command { short : " " , long : [ 1 : ] , run : cmdutil . run ( func ( args [ ] string ) error { var token string var err error if ! strings . hasprefix ( initialadmin , auth . robotprefix ) { token , err = githublogin ( ) if err ! = nil { return err } } fmt . println ( " " ) c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) resp , err : = c . activate ( c . ctx ( ) , & auth . activaterequest { githubtoken : token , subject : initialadmin , } ) if err ! = nil { return fmt . errorf ( " " , grpcutil . scrubgrpc ( err ) ) } if err : = writepachtokentocfg ( resp . pachtoken ) ; err ! = nil { return err } if strings . hasprefix ( initialadmin , auth . robotprefix ) { fmt . println ( " " + " \n " + " " ) fmt . printf ( " " " \n \n " , initialadmin , resp . pachtoken ) } return nil } ) , } activate . persistentflags ( ) . stringvar ( & initialadmin , " " , " " , [ 1 : ] ) return cmdutil . createalias ( activate , " " ) } 
func deactivatecmd ( nometrics , noportforwarding * bool ) * cobra . command { deactivate : = & cobra . command { short : " " , long : " " + " " + " " , run : cmdutil . run ( func ( args [ ] string ) error { fmt . println ( " " + " " ) confirm , err : = bufio . newreader ( os . stdin ) . readstring ( ' \n ' ) if ! strings . contains ( " " , confirm [ : 1 ] ) { return fmt . errorf ( " " ) } c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) , err = c . deactivate ( c . ctx ( ) , & auth . deactivaterequest { } ) return grpcutil . scrubgrpc ( err ) } ) , } return cmdutil . createalias ( deactivate , " " ) } 
func logoutcmd ( ) * cobra . command { logout : = & cobra . command { short : " " , long : " " + " " + " " + " " , run : cmdutil . run ( func ( [ ] string ) error { cfg , err : = config . read ( ) if err ! = nil { return fmt . errorf ( " " + " " , err ) } if cfg . v1 == nil { return nil } cfg . v1 . sessiontoken = " " return cfg . write ( ) } ) , } return cmdutil . createalias ( logout , " " ) } 
func whoamicmd ( nometrics , noportforwarding * bool ) * cobra . command { whoami : = & cobra . command { short : " " , long : " " , run : cmdutil . run ( func ( [ ] string ) error { c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) resp , err : = c . whoami ( c . ctx ( ) , & auth . whoamirequest { } ) if err ! = nil { return fmt . errorf ( " " , grpcutil . scrubgrpc ( err ) ) } fmt . printf ( " " " \n " , resp . username ) if resp . ttl > 0 { fmt . printf ( " \n " , time . now ( ) . add ( time . duration ( resp . ttl ) * time . second ) . format ( time . rfc822 ) ) } if resp . isadmin { fmt . println ( " " ) } return nil } ) , } return cmdutil . createalias ( whoami , " " ) } 
func checkcmd ( nometrics , noportforwarding * bool ) * cobra . command { check : = & cobra . command { use : " " , short : " " , long : " " + " " " " + " " " " + " " " " + " " + " " , run : cmdutil . runfixedargs ( 2 , func ( args [ ] string ) error { scope , err : = auth . parsescope ( args [ 0 ] ) if err ! = nil { return err } repo : = args [ 1 ] c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) resp , err : = c . authorize ( c . ctx ( ) , & auth . authorizerequest { repo : repo , scope : scope , } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } fmt . printf ( " \n " , resp . authorized ) return nil } ) , } return cmdutil . createalias ( check , " " ) } 
func setscopecmd ( nometrics , noportforwarding * bool ) * cobra . command { setscope : = & cobra . command { use : " " , short : " " , long : " " + " " + " " " " " " + " " + " " " " " " + " " + " " + " " , run : cmdutil . runfixedargs ( 3 , func ( args [ ] string ) error { scope , err : = auth . parsescope ( args [ 1 ] ) if err ! = nil { return err } username , repo : = args [ 0 ] , args [ 2 ] c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) , err = c . setscope ( c . ctx ( ) , & auth . setscoperequest { repo : repo , scope : scope , username : username , } ) return grpcutil . scrubgrpc ( err ) } ) , } return cmdutil . createalias ( setscope , " " ) } 
func listadminscmd ( nometrics , noportforwarding * bool ) * cobra . command { listadmins : = & cobra . command { short : " " , long : " " , run : cmdutil . run ( func ( [ ] string ) error { c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return err } defer c . close ( ) resp , err : = c . getadmins ( c . ctx ( ) , & auth . getadminsrequest { } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for , user : = range resp . admins { fmt . println ( user ) } return nil } ) , } return cmdutil . createalias ( listadmins , " " ) } 
func modifyadminscmd ( nometrics , noportforwarding * bool ) * cobra . command { var add [ ] string var remove [ ] string modifyadmins : = & cobra . command { short : " " , long : " " + " " + " " , run : cmdutil . run ( func ( [ ] string ) error { c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return err } defer c . close ( ) , err = c . modifyadmins ( c . ctx ( ) , & auth . modifyadminsrequest { add : add , remove : remove , } ) if auth . iserrpartiallyactivated ( err ) { return fmt . errorf ( " " + " " + " " , err ) } return grpcutil . scrubgrpc ( err ) } ) , } modifyadmins . persistentflags ( ) . stringslicevar ( & add , " " , [ ] string { } , " " ) modifyadmins . persistentflags ( ) . stringslicevar ( & remove , " " , [ ] string { } , " " ) return cmdutil . createalias ( modifyadmins , " " ) } 
func getauthtokencmd ( nometrics , noportforwarding * bool ) * cobra . command { var quiet bool getauthtoken : = & cobra . command { use : " " , short : " " " " , long : " " " " + " " , run : cmdutil . runfixedargs ( 1 , func ( args [ ] string ) error { subject : = args [ 0 ] c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err ) } defer c . close ( ) resp , err : = c . getauthtoken ( c . ctx ( ) , & auth . getauthtokenrequest { subject : subject , } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } if quiet { fmt . println ( resp . token ) } else { fmt . printf ( " \n \n \n " , resp . subject , resp . token ) } return nil } ) , } getauthtoken . persistentflags ( ) . boolvarp ( & quiet , " " , " " , false , " " + " " + " " ) return cmdutil . createalias ( getauthtoken , " " ) } 
func useauthtokencmd ( ) * cobra . command { useauthtoken : = & cobra . command { short : " " + " " , long : " " + " " , run : cmdutil . runfixedargs ( 0 , func ( args [ ] string ) error { fmt . println ( " " ) token , err : = bufio . newreader ( os . stdin ) . readstring ( ' \n ' ) if err ! = nil { return fmt . errorf ( " " , err ) } writepachtokentocfg ( strings . trimspace ( token ) ) return nil } ) , } return cmdutil . createalias ( useauthtoken , " " ) } 
func cmds ( nometrics , noportforwarding * bool ) [ ] * cobra . command { var commands [ ] * cobra . command auth : = & cobra . command { short : " " , long : " " , } commands = append ( commands , cmdutil . createalias ( auth , " " ) ) commands = append ( commands , activatecmd ( nometrics , noportforwarding ) ) commands = append ( commands , deactivatecmd ( nometrics , noportforwarding ) ) commands = append ( commands , logincmd ( nometrics , noportforwarding ) ) commands = append ( commands , logoutcmd ( ) ) commands = append ( commands , whoamicmd ( nometrics , noportforwarding ) ) commands = append ( commands , checkcmd ( nometrics , noportforwarding ) ) commands = append ( commands , setscopecmd ( nometrics , noportforwarding ) ) commands = append ( commands , getcmd ( nometrics , noportforwarding ) ) commands = append ( commands , listadminscmd ( nometrics , noportforwarding ) ) commands = append ( commands , modifyadminscmd ( nometrics , noportforwarding ) ) commands = append ( commands , getauthtokencmd ( nometrics , noportforwarding ) ) commands = append ( commands , useauthtokencmd ( ) ) commands = append ( commands , getconfigcmd ( noportforwarding ) ) commands = append ( commands , setconfigcmd ( noportforwarding ) ) return commands } 
func parsescope ( s string ) ( scope , error ) { for name , value : = range scope value { if strings . equalfold ( s , name ) { return scope ( value ) , nil } } return scope none , fmt . errorf ( " " , s ) } 
func iserrnotactivated ( err error ) bool { if err == nil { return false } return strings . contains ( err . error ( ) , status . convert ( errnotactivated ) . message ( ) ) } 
func iserrpartiallyactivated ( err error ) bool { if err == nil { return false } return strings . contains ( err . error ( ) , status . convert ( errpartiallyactivated ) . message ( ) ) } 
func iserrnotsignedin ( err error ) bool { if err == nil { return false } return strings . contains ( err . error ( ) , status . convert ( errnotsignedin ) . message ( ) ) } 
func iserrnometadata ( err error ) bool { if err == nil { return false } return strings . contains ( err . error ( ) , status . convert ( errnometadata ) . message ( ) ) } 
func iserrbadtoken ( err error ) bool { if err == nil { return false } return strings . contains ( err . error ( ) , status . convert ( errbadtoken ) . message ( ) ) } 
func iserrnotauthorized ( err error ) bool { if err == nil { return false } return strings . contains ( err . error ( ) , errnotauthorizedmsg ) } 
func iserrinvalidprincipal ( err error ) bool { if err == nil { return false } return strings . contains ( err . error ( ) , " " " ) && strings . contains ( err . error ( ) , " " " " " " " " " " " ) } 
func iserrtooshortttl ( err error ) bool { if err == nil { return false } errmsg : = err . error ( ) return strings . contains ( errmsg , " " ) && strings . contains ( errmsg , " " ) && strings . contains ( errmsg , " " ) } 
func newdatumfactory ( pachclient * client . apiclient , input * pps . input ) ( datumfactory , error ) { switch { case input . pfs ! = nil : return newpfsdatumfactory ( pachclient , input . pfs ) case input . union ! = nil : return newuniondatumfactory ( pachclient , input . union ) case input . cross ! = nil : return newcrossdatumfactory ( pachclient , input . cross ) case input . cron ! = nil : return newcrondatumfactory ( pachclient , input . cron ) case input . git ! = nil : return newgitdatumfactory ( pachclient , input . git ) } return nil , fmt . errorf ( " " ) } 
func newcollection ( etcdclient * etcd . client , prefix string , indexes [ ] * index , template proto . message , keycheck func ( string ) error , valcheck func ( proto . message ) error ) collection { if len ( prefix ) > 0 && prefix [ len ( prefix ) - 1 ] ! = ' / ' { prefix = prefix + " " } return & collection { prefix : prefix , etcdclient : etcdclient , indexes : indexes , limit : defaultlimit , template : template , keycheck : keycheck , valcheck : valcheck , } } 
func ( c * collection ) path ( key string ) string { return path . join ( c . prefix , key ) } 
func ( c * collection ) indexdir ( index * index , indexval interface { } ) string { var indexvalstr string if marshaller , ok : = indexval . ( proto . marshaler ) ; ok { if indexvalbytes , err : = marshaller . marshal ( ) ; err == nil { indexvalstr = string ( indexvalbytes ) } else { log . printf ( " " , err ) indexvalstr = fmt . sprintf ( " " , indexval ) } } else { indexvalstr = fmt . sprintf ( " " , indexval ) } return path . join ( c . indexroot ( index ) , indexvalstr ) } 
func ( c * collection ) indexpath ( index * index , indexval interface { } , key string ) string { return path . join ( c . indexdir ( index , indexval ) , key ) } 
func ( c * readwritecollection ) getindexpath ( val interface { } , index * index , key string ) string { reflval : = reflect . valueof ( val ) field : = reflect . indirect ( reflval ) . fieldbyname ( index . field ) . interface ( ) return c . indexpath ( index , field , key ) } 
func ( c * readwritecollection ) getmultiindexpaths ( val interface { } , index * index , key string ) [ ] string { var indexpaths [ ] string field : = reflect . indirect ( reflect . valueof ( val ) ) . fieldbyname ( index . field ) for i : = 0 ; i < field . len ( ) ; i ++ { indexpaths = append ( indexpaths , c . indexpath ( index , field . index ( i ) . interface ( ) , key ) ) } return indexpaths } 
func ( c * readwritecollection ) upsert ( key string , val proto . message , f func ( ) error ) error { if err : = watch . checktype ( c . template , val ) ; err ! = nil { return err } if err : = c . get ( key , val ) ; err ! = nil && ! iserrnotfound ( err ) { return err } if err : = f ( ) ; err ! = nil { return err } return c . put ( key , val ) } 
func ( c * readonlycollection ) get ( key string , opts ... etcd . opoption ) ( * etcd . getresponse , error ) { span , ctx : = tracing . addspantoanyexisting ( c . ctx , " " ) defer tracing . finishanyspan ( span ) resp , err : = c . etcdclient . get ( ctx , key , opts ... ) return resp , err } 
func ( c * readonlycollection ) listprefix ( prefix string , val proto . message , opts * options , f func ( string ) error ) error { queryprefix : = c . prefix if prefix ! = " " { queryprefix = filepath . join ( c . prefix , prefix ) } return c . list ( queryprefix , & c . limit , opts , func ( kv * mvccpb . keyvalue ) error { if err : = proto . unmarshal ( kv . value , val ) ; err ! = nil { return err } return f ( strings . trimprefix ( string ( kv . key ) , queryprefix ) ) } ) } 
func ( c * readonlycollection ) list ( val proto . message , opts * options , f func ( string ) error ) error { if err : = watch . checktype ( c . template , val ) ; err ! = nil { return err } return c . list ( c . prefix , & c . limit , opts , func ( kv * mvccpb . keyvalue ) error { if err : = proto . unmarshal ( kv . value , val ) ; err ! = nil { return err } return f ( strings . trimprefix ( string ( kv . key ) , c . prefix ) ) } ) } 
func ( c * readonlycollection ) watch ( opts ... watch . opoption ) ( watch . watcher , error ) { return watch . newwatcher ( c . ctx , c . etcdclient , c . prefix , c . prefix , c . template , opts ... ) } 
func ( c * readonlycollection ) watchone ( key string ) ( watch . watcher , error ) { return watch . newwatcher ( c . ctx , c . etcdclient , c . prefix , c . path ( key ) , c . template ) } 
func ( c * readonlycollection ) watchonef ( key string , f func ( e * watch . event ) error ) error { watcher , err : = watch . newwatcher ( c . ctx , c . etcdclient , c . prefix , c . path ( key ) , c . template ) if err ! = nil { return err } defer watcher . close ( ) for { select { case e : = < - watcher . watch ( ) : if err : = f ( e ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } case < - c . ctx . done ( ) : return c . ctx . err ( ) } } } 
func generateusercredentials ( ctx context . context , pachdaddress string , admintoken string , username string , ttl time . duration ) ( string , error ) { client , err : = pclient . newfromaddress ( pachdaddress ) if err ! = nil { return " " , err } defer client . close ( ) client = client . withctx ( ctx ) client . setauthtoken ( admintoken ) resp , err : = client . authapiclient . getauthtoken ( client . ctx ( ) , & auth . getauthtokenrequest { subject : username , ttl : int64 ( ttl . seconds ( ) ) , } ) if err ! = nil { return " " , err } return resp . token , nil } 
func newcache ( root string ) * cache { return & cache { root : root , keys : make ( map [ string ] bool ) , } } 
func ( c * cache ) put ( key string , value io . reader ) ( reterr error ) { c . mu . lock ( ) defer c . mu . unlock ( ) f , err : = os . create ( filepath . join ( c . root , key ) ) if err ! = nil { return err } defer func ( ) { if err : = f . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) buf : = grpcutil . getbuffer ( ) defer grpcutil . putbuffer ( buf ) if , err : = io . copybuffer ( f , value , buf ) ; err ! = nil { return err } c . keys [ key ] = true return nil } 
func ( c * cache ) get ( key string ) ( io . readcloser , error ) { c . mu . lock ( ) defer c . mu . unlock ( ) if ! c . keys [ key ] { return nil , fmt . errorf ( " " , key ) } f , err : = os . open ( filepath . join ( c . root , key ) ) if err ! = nil { return nil , err } return f , nil } 
func ( c * cache ) keys ( ) [ ] string { c . mu . lock ( ) defer c . mu . unlock ( ) var keys [ ] string for key : = range c . keys { keys = append ( keys , key ) } sort . strings ( keys ) return keys } 
func ( c * cache ) delete ( key string ) error { c . mu . lock ( ) defer c . mu . unlock ( ) if ! c . keys [ key ] { return nil } delete ( c . keys , key ) return os . remove ( filepath . join ( c . root , key ) ) } 
func ( c * cache ) clear ( ) error { c . mu . lock ( ) defer c . mu . unlock ( ) defer func ( ) { c . keys = make ( map [ string ] bool ) } ( ) for key : = range c . keys { if err : = os . remove ( filepath . join ( c . root , key ) ) ; err ! = nil { return err } } return nil } 
func newdeployserver ( kubeclient * kube . clientset , kubenamespace string ) deploy . apiserver { return & apiserver { kubeclient : kubeclient , kubenamespace : kubenamespace , } } 
func export ( opts * assets . assetopts , out io . writer ) error { client , err : = docker . newclientfromenv ( ) if err ! = nil { return err } authconfigs , err : = docker . newauthconfigurationsfromdockercfg ( ) if err ! = nil { return fmt . errorf ( " " , err . error ( ) ) } if len ( authconfigs . configs ) == 0 { return fmt . errorf ( " " ) } images : = assets . images ( opts ) for , image : = range images { repository , tag : = docker . parserepositorytag ( image ) pulled : = false var looperr [ ] error for registry , authconfig : = range authconfigs . configs { if err : = client . pullimage ( docker . pullimageoptions { repository : repository , tag : tag , inactivitytimeout : 5 * time . second , } , authconfig , ) ; err ! = nil { looperr = append ( looperr , fmt . errorf ( " " , registry , err ) ) continue } pulled = true break } if ! pulled { errstr : = " " for , err : = range looperr { errstr += err . error ( ) + " \n " } return fmt . errorf ( " \n " , repository , tag , errstr ) } } return client . exportimages ( docker . exportimagesoptions { names : images , outputstream : out , } ) } 
func datumtagprefix ( salt string ) string { h : = sha256 . new ( ) h . write ( [ ] byte ( salt ) ) return hex . encodetostring ( h . sum ( nil ) ) [ : 4 ] } 
func newpfsinput ( repo string , glob string ) * pps . input { return & pps . input { pfs : & pps . pfsinput { repo : repo , glob : glob , } , } } 
func newpfsinputopts ( name string , repo string , branch string , glob string , lazy bool ) * pps . input { return & pps . input { pfs : & pps . pfsinput { name : name , repo : repo , branch : branch , glob : glob , lazy : lazy , } , } } 
func newcrossinput ( input ... * pps . input ) * pps . input { return & pps . input { cross : input , } } 
func newunioninput ( input ... * pps . input ) * pps . input { return & pps . input { union : input , } } 
func newcroninput ( name string , spec string ) * pps . input { return & pps . input { cron : & pps . croninput { name : name , spec : spec , } , } } 
func newjobinput ( reponame string , commitid string , glob string ) * pps . jobinput { return & pps . jobinput { commit : newcommit ( reponame , commitid ) , glob : glob , } } 
func newpipelineinput ( reponame string , glob string ) * pps . pipelineinput { return & pps . pipelineinput { repo : newrepo ( reponame ) , glob : glob , } } 
func ( c apiclient ) createjob ( pipeline string , outputcommit * pfs . commit ) ( * pps . job , error ) { job , err : = c . ppsapiclient . createjob ( c . ctx ( ) , & pps . createjobrequest { pipeline : newpipeline ( pipeline ) , outputcommit : outputcommit , } , ) return job , grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) inspectjob ( jobid string , blockstate bool ) ( * pps . jobinfo , error ) { jobinfo , err : = c . ppsapiclient . inspectjob ( c . ctx ( ) , & pps . inspectjobrequest { job : newjob ( jobid ) , blockstate : blockstate , } ) return jobinfo , grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) inspectjoboutputcommit ( reponame , commitid string , blockstate bool ) ( * pps . jobinfo , error ) { jobinfo , err : = c . ppsapiclient . inspectjob ( c . ctx ( ) , & pps . inspectjobrequest { outputcommit : newcommit ( reponame , commitid ) , blockstate : blockstate , } ) return jobinfo , grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) listjob ( pipelinename string , inputcommit [ ] * pfs . commit , outputcommit * pfs . commit ) ( [ ] * pps . jobinfo , error ) { var result [ ] * pps . jobinfo if err : = c . listjobf ( pipelinename , inputcommit , outputcommit , func ( ji * pps . jobinfo ) error { result = append ( result , ji ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c apiclient ) listjobf ( pipelinename string , inputcommit [ ] * pfs . commit , outputcommit * pfs . commit , f func ( * pps . jobinfo ) error ) error { var pipeline * pps . pipeline if pipelinename ! = " " { pipeline = newpipeline ( pipelinename ) } client , err : = c . ppsapiclient . listjobstream ( c . ctx ( ) , & pps . listjobrequest { pipeline : pipeline , inputcommit : inputcommit , outputcommit : outputcommit , } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { ji , err : = client . recv ( ) if err == io . eof { return nil } else if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = f ( ji ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } } } 
func ( c apiclient ) flushjob ( commits [ ] * pfs . commit , topipelines [ ] string , f func ( * pps . jobinfo ) error ) error { req : = & pps . flushjobrequest { commits : commits , } for , pipeline : = range topipelines { req . topipelines = append ( req . topipelines , newpipeline ( pipeline ) ) } client , err : = c . ppsapiclient . flushjob ( c . ctx ( ) , req ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { jobinfo , err : = client . recv ( ) if err ! = nil { if err == io . eof { return nil } return grpcutil . scrubgrpc ( err ) } if err : = f ( jobinfo ) ; err ! = nil { return err } } } 
func ( c apiclient ) flushjoball ( commits [ ] * pfs . commit , topipelines [ ] string ) ( [ ] * pps . jobinfo , error ) { var result [ ] * pps . jobinfo if err : = c . flushjob ( commits , topipelines , func ( ji * pps . jobinfo ) error { result = append ( result , ji ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c apiclient ) deletejob ( jobid string ) error { , err : = c . ppsapiclient . deletejob ( c . ctx ( ) , & pps . deletejobrequest { job : newjob ( jobid ) , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) stopjob ( jobid string ) error { , err : = c . ppsapiclient . stopjob ( c . ctx ( ) , & pps . stopjobrequest { job : newjob ( jobid ) , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) restartdatum ( jobid string , datumfilter [ ] string ) error { , err : = c . ppsapiclient . restartdatum ( c . ctx ( ) , & pps . restartdatumrequest { job : newjob ( jobid ) , datafilters : datumfilter , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) listdatum ( jobid string , pagesize int64 , page int64 ) ( * pps . listdatumresponse , error ) { client , err : = c . ppsapiclient . listdatumstream ( c . ctx ( ) , & pps . listdatumrequest { job : newjob ( jobid ) , pagesize : pagesize , page : page , } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } resp : = & pps . listdatumresponse { } first : = true for { r , err : = client . recv ( ) if err == io . eof { break } else if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } if first { resp . totalpages = r . totalpages resp . page = r . page first = false } resp . datuminfos = append ( resp . datuminfos , r . datuminfo ) } return resp , nil } 
func ( c apiclient ) listdatumf ( jobid string , pagesize int64 , page int64 , f func ( di * pps . datuminfo ) error ) error { client , err : = c . ppsapiclient . listdatumstream ( c . ctx ( ) , & pps . listdatumrequest { job : newjob ( jobid ) , pagesize : pagesize , page : page , } , ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { resp , err : = client . recv ( ) if err == io . eof { return nil } else if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = f ( resp . datuminfo ) ; err ! = nil { if err == errutil . errbreak { return nil } return err } } } 
func ( c apiclient ) inspectdatum ( jobid string , datumid string ) ( * pps . datuminfo , error ) { datuminfo , err : = c . ppsapiclient . inspectdatum ( c . ctx ( ) , & pps . inspectdatumrequest { datum : & pps . datum { id : datumid , job : newjob ( jobid ) , } , } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return datuminfo , nil } 
func ( l * logsiter ) next ( ) bool { if l . err ! = nil { l . msg = nil return false } l . msg , l . err = l . logsclient . recv ( ) if l . err ! = nil { return false } return true } 
func ( l * logsiter ) err ( ) error { if l . err == io . eof { return nil } return grpcutil . scrubgrpc ( l . err ) } 
func ( c apiclient ) getlogs ( pipelinename string , jobid string , data [ ] string , datumid string , master bool , follow bool , tail int64 , ) * logsiter { request : = pps . getlogsrequest { master : master , follow : follow , tail : tail , } resp : = & logsiter { } if pipelinename ! = " " { request . pipeline = newpipeline ( pipelinename ) } if jobid ! = " " { request . job = newjob ( jobid ) } request . datafilters = data if datumid ! = " " { request . datum = & pps . datum { job : newjob ( jobid ) , id : datumid , } } resp . logsclient , resp . err = c . ppsapiclient . getlogs ( c . ctx ( ) , & request ) resp . err = grpcutil . scrubgrpc ( resp . err ) return resp } 
func ( c apiclient ) createpipeline ( name string , image string , cmd [ ] string , stdin [ ] string , parallelismspec * pps . parallelismspec , input * pps . input , outputbranch string , update bool , ) error { , err : = c . ppsapiclient . createpipeline ( c . ctx ( ) , & pps . createpipelinerequest { pipeline : newpipeline ( name ) , transform : & pps . transform { image : image , cmd : cmd , stdin : stdin , } , parallelismspec : parallelismspec , input : input , outputbranch : outputbranch , update : update , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) inspectpipeline ( pipelinename string ) ( * pps . pipelineinfo , error ) { pipelineinfo , err : = c . ppsapiclient . inspectpipeline ( c . ctx ( ) , & pps . inspectpipelinerequest { pipeline : newpipeline ( pipelinename ) , } , ) return pipelineinfo , grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) listpipeline ( ) ( [ ] * pps . pipelineinfo , error ) { pipelineinfos , err : = c . ppsapiclient . listpipeline ( c . ctx ( ) , & pps . listpipelinerequest { } , ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return pipelineinfos . pipelineinfo , nil } 
func ( c apiclient ) deletepipeline ( name string , force bool ) error { , err : = c . ppsapiclient . deletepipeline ( c . ctx ( ) , & pps . deletepipelinerequest { pipeline : newpipeline ( name ) , force : force , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) startpipeline ( name string ) error { , err : = c . ppsapiclient . startpipeline ( c . ctx ( ) , & pps . startpipelinerequest { pipeline : newpipeline ( name ) , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) stoppipeline ( name string ) error { , err : = c . ppsapiclient . stoppipeline ( c . ctx ( ) , & pps . stoppipelinerequest { pipeline : newpipeline ( name ) , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) rerunpipeline ( name string , include [ ] * pfs . commit , exclude [ ] * pfs . commit ) error { , err : = c . ppsapiclient . rerunpipeline ( c . ctx ( ) , & pps . rerunpipelinerequest { pipeline : newpipeline ( name ) , include : include , exclude : exclude , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) createpipelineservice ( name string , image string , cmd [ ] string , stdin [ ] string , parallelismspec * pps . parallelismspec , input * pps . input , update bool , internalport int32 , externalport int32 , ) error { , err : = c . ppsapiclient . createpipeline ( c . ctx ( ) , & pps . createpipelinerequest { pipeline : newpipeline ( name ) , transform : & pps . transform { image : image , cmd : cmd , stdin : stdin , } , parallelismspec : parallelismspec , input : input , update : update , service : & pps . service { internalport : internalport , externalport : externalport , } , } , ) return grpcutil . scrubgrpc ( err ) } 
func ( c apiclient ) garbagecollect ( memorybytes int64 ) error { , err : = c . ppsapiclient . garbagecollect ( c . ctx ( ) , & pps . garbagecollectrequest { memorybytes : memorybytes } , ) return grpcutil . scrubgrpc ( err ) } 
func getdatumtotaltime ( s * pps . processstats ) time . duration { totalduration : = time . duration ( 0 ) duration , : = types . durationfromproto ( s . downloadtime ) totalduration += duration duration , = types . durationfromproto ( s . processtime ) totalduration += duration duration , = types . durationfromproto ( s . uploadtime ) totalduration += duration return totalduration } 
func mount ( c * client . apiclient , mountpoint string , opts * options ) error { nfs : = pathfs . newpathnodefs ( newfilesystem ( c , opts . getcommits ( ) ) , nil ) server , , err : = nodefs . mountroot ( mountpoint , nfs . root ( ) , opts . getfuse ( ) ) if err ! = nil { return fmt . errorf ( " " , err ) } sigchan : = make ( chan os . signal , 1 ) signal . notify ( sigchan , os . interrupt ) go func ( ) { select { case < - sigchan : case < - opts . getunmount ( ) : } server . unmount ( ) } ( ) server . serve ( ) return nil } 
func newbufpool ( size int ) * bufpool { return & bufpool { sync . pool { new : func ( ) interface { } { return make ( [ ] byte , size ) } , } } } 
func storagerootfromenv ( ) ( string , error ) { storageroot , ok : = os . lookupenv ( pachrootenvvar ) if ! ok { return " " , fmt . errorf ( " " , pachrootenvvar ) } storagebackend , ok : = os . lookupenv ( storagebackendenvvar ) if ! ok { return " " , fmt . errorf ( " " , storagebackendenvvar ) } switch storagebackend { case amazon : fallthrough case minio : if len ( storageroot ) > 0 && storageroot [ 0 ] == ' / ' { storageroot = storageroot [ 1 : ] } } return storageroot , nil } 
func blockpathfromenv ( block * pfs . block ) ( string , error ) { storageroot , err : = storagerootfromenv ( ) if err ! = nil { return " " , err } return filepath . join ( storageroot , " " , block . hash ) , nil } 
func newgoogleclient ( bucket string , opts [ ] option . clientoption ) ( client , error ) { return newgoogleclient ( bucket , opts ) } 
func newgoogleclientfromsecret ( bucket string ) ( client , error ) { var err error if bucket == " " { bucket , err = readsecretfile ( " " ) if err ! = nil { return nil , fmt . errorf ( " " ) } } cred , err : = readsecretfile ( " " ) if err ! = nil { return nil , fmt . errorf ( " " ) } var opts [ ] option . clientoption if cred ! = " " { opts = append ( opts , option . withcredentialsfile ( secretfile ( " " ) ) ) } else { opts = append ( opts , option . withtokensource ( google . computetokensource ( " " ) ) ) } return newgoogleclient ( bucket , opts ) } 
func newgoogleclientfromenv ( ) ( client , error ) { bucket , ok : = os . lookupenv ( googlebucketenvvar ) if ! ok { return nil , fmt . errorf ( " " , googlebucketenvvar ) } creds , ok : = os . lookupenv ( googlecredenvvar ) if ! ok { return nil , fmt . errorf ( " " , googlecredenvvar ) } opts : = [ ] option . clientoption { option . withcredentialsjson ( [ ] byte ( creds ) ) } return newgoogleclient ( bucket , opts ) } 
func newmicrosoftclient ( container string , accountname string , accountkey string ) ( client , error ) { return newmicrosoftclient ( container , accountname , accountkey ) } 
func newmicrosoftclientfromsecret ( container string ) ( client , error ) { var err error if container == " " { container , err = readsecretfile ( " " ) if err ! = nil { return nil , fmt . errorf ( " " ) } } id , err : = readsecretfile ( " " ) if err ! = nil { return nil , fmt . errorf ( " " ) } secret , err : = readsecretfile ( " " ) if err ! = nil { return nil , fmt . errorf ( " " ) } return newmicrosoftclient ( container , id , secret ) } 
func newmicrosoftclientfromenv ( ) ( client , error ) { container , ok : = os . lookupenv ( microsoftcontainerenvvar ) if ! ok { return nil , fmt . errorf ( " " , microsoftcontainerenvvar ) } id , ok : = os . lookupenv ( microsoftidenvvar ) if ! ok { return nil , fmt . errorf ( " " , microsoftidenvvar ) } secret , ok : = os . lookupenv ( microsoftsecretenvvar ) if ! ok { return nil , fmt . errorf ( " " , microsoftsecretenvvar ) } return newmicrosoftclient ( container , id , secret ) } 
func newminioclient ( endpoint , bucket , id , secret string , secure , iss3v2 bool ) ( client , error ) { if iss3v2 { return newminioclientv2 ( endpoint , bucket , id , secret , secure ) } return newminioclient ( endpoint , bucket , id , secret , secure ) } 
func newamazonclient ( region , bucket string , creds * amazoncreds , distribution string , reversed ... bool ) ( client , error ) { return newamazonclient ( region , bucket , creds , distribution , reversed ... ) } 
func newminioclientfromsecret ( bucket string ) ( client , error ) { var err error if bucket == " " { bucket , err = readsecretfile ( " " ) if err ! = nil { return nil , err } } endpoint , err : = readsecretfile ( " " ) if err ! = nil { return nil , err } id , err : = readsecretfile ( " " ) if err ! = nil { return nil , err } secret , err : = readsecretfile ( " " ) if err ! = nil { return nil , err } secure , err : = readsecretfile ( " " ) if err ! = nil { return nil , err } iss3v2 , err : = readsecretfile ( " " ) if err ! = nil { return nil , err } return newminioclient ( endpoint , bucket , id , secret , secure == " " , iss3v2 == " " ) } 
func newminioclientfromenv ( ) ( client , error ) { bucket , ok : = os . lookupenv ( miniobucketenvvar ) if ! ok { return nil , fmt . errorf ( " " , miniobucketenvvar ) } endpoint , ok : = os . lookupenv ( minioendpointenvvar ) if ! ok { return nil , fmt . errorf ( " " , minioendpointenvvar ) } id , ok : = os . lookupenv ( minioidenvvar ) if ! ok { return nil , fmt . errorf ( " " , minioidenvvar ) } secret , ok : = os . lookupenv ( miniosecretenvvar ) if ! ok { return nil , fmt . errorf ( " " , miniosecretenvvar ) } secure , ok : = os . lookupenv ( miniosecureenvvar ) if ! ok { return nil , fmt . errorf ( " " , miniosecureenvvar ) } iss3v2 , ok : = os . lookupenv ( miniosignatureenvvar ) if ! ok { return nil , fmt . errorf ( " " , miniosignatureenvvar ) } return newminioclient ( endpoint , bucket , id , secret , secure == " " , iss3v2 == " " ) } 
func newamazonclientfromsecret ( bucket string , reversed ... bool ) ( client , error ) { region , err : = readsecretfile ( " " ) if err ! = nil { return nil , fmt . errorf ( " " ) } if bucket == " " { bucket , err = readsecretfile ( " " ) if err ! = nil { return nil , err } } var creds amazoncreds creds . id , err = readsecretfile ( " " ) if err ! = nil && ! os . isnotexist ( err ) { return nil , err } creds . secret , err = readsecretfile ( " " ) if err ! = nil && ! os . isnotexist ( err ) { return nil , err } creds . token , err = readsecretfile ( " " ) if err ! = nil && ! os . isnotexist ( err ) { return nil , err } creds . vaultaddress , err = readsecretfile ( " " ) if err ! = nil && ! os . isnotexist ( err ) { return nil , err } creds . vaultrole , err = readsecretfile ( " " ) if err ! = nil && ! os . isnotexist ( err ) { return nil , err } creds . vaulttoken , err = readsecretfile ( " " ) if err ! = nil && ! os . isnotexist ( err ) { return nil , err } distribution , err : = readsecretfile ( " " ) return newamazonclient ( region , bucket , & creds , distribution , reversed ... ) } 
func newamazonclientfromenv ( ) ( client , error ) { region , ok : = os . lookupenv ( amazonregionenvvar ) if ! ok { return nil , fmt . errorf ( " " , amazonregionenvvar ) } bucket , ok : = os . lookupenv ( amazonbucketenvvar ) if ! ok { return nil , fmt . errorf ( " " , amazonbucketenvvar ) } var creds amazoncreds creds . id , = os . lookupenv ( amazonidenvvar ) creds . secret , = os . lookupenv ( amazonsecretenvvar ) creds . token , = os . lookupenv ( amazontokenenvvar ) creds . vaultaddress , = os . lookupenv ( amazonvaultaddrenvvar ) creds . vaultrole , = os . lookupenv ( amazonvaultroleenvvar ) creds . vaulttoken , = os . lookupenv ( amazonvaulttokenenvvar ) distribution , : = os . lookupenv ( amazondistributionenvvar ) return newamazonclient ( region , bucket , & creds , distribution ) } 
func newclientfromurlandsecret ( url * objectstoreurl , reversed ... bool ) ( c client , err error ) { switch url . store { case " " : c , err = newamazonclientfromsecret ( url . bucket , reversed ... ) case " " : fallthrough case " " : c , err = newgoogleclientfromsecret ( url . bucket ) case " " : fallthrough case " " : c , err = newmicrosoftclientfromsecret ( url . bucket ) case " " : c , err = newlocalclient ( " " + url . bucket ) } switch { case err ! = nil : return nil , err case c ! = nil : return tracingobjclient ( url . store , c ) , nil default : return nil , fmt . errorf ( " " , url . bucket ) } } 
func parseurl ( urlstr string ) ( * objectstoreurl , error ) { url , err : = url . parse ( urlstr ) if err ! = nil { return nil , fmt . errorf ( " " , urlstr , err ) } switch url . scheme { case " " , " " , " " , " " : return & objectstoreurl { store : url . scheme , bucket : url . host , object : strings . trim ( url . path , " " ) , } , nil case " " , " " : parts : = strings . split ( strings . trim ( url . path , " " ) , " " ) if len ( parts ) < 1 { return nil , fmt . errorf ( " " , urlstr ) } return & objectstoreurl { store : url . scheme , bucket : parts [ 0 ] , object : strings . trim ( path . join ( parts [ 1 : ] ... ) , " " ) , } , nil } return nil , fmt . errorf ( " " , url . scheme ) } 
func newclientfromenv ( storageroot string ) ( c client , err error ) { storagebackend , ok : = os . lookupenv ( storagebackendenvvar ) if ! ok { return nil , fmt . errorf ( " " ) } switch storagebackend { case amazon : c , err = newamazonclientfromenv ( ) case google : c , err = newgoogleclientfromenv ( ) case microsoft : c , err = newmicrosoftclientfromenv ( ) case minio : c , err = newminioclientfromenv ( ) case local : c , err = newlocalclient ( storageroot ) } switch { case err ! = nil : return nil , err case c ! = nil : return tracingobjclient ( storagebackend , c ) , nil default : return nil , fmt . errorf ( " " , storagebackend ) } } 
func newexponentialbackoffconfig ( ) * backoff . exponentialbackoff { config : = backoff . newexponentialbackoff ( ) config . initialinterval = 1 * time . second config . multiplier = 2 config . maxinterval = 15 * time . minute return config } 
func ( b * backoffreadcloser ) close ( ) error { span , : = tracing . addspantoanyexisting ( b . ctx , " " ) defer tracing . finishanyspan ( span ) return b . reader . close ( ) } 
func ( b * backoffwritecloser ) close ( ) error { span , : = tracing . addspantoanyexisting ( b . ctx , " " ) defer tracing . finishanyspan ( span ) err : = b . writer . close ( ) if b . client . isignorable ( err ) { return nil } return err } 
func isretryable ( client client , err error ) bool { return isnetretryable ( err ) | | client . isretryable ( err ) } 
func runstdin ( stdin io . reader , args ... string ) error { return runio ( io { stdin : stdin } , args ... ) } 
func runiodirpath ( ioobj io , dirpath string , args ... string ) error { var debugstderr io . readwriter = bytes . newbuffer ( nil ) var stderr io . writer = debugstderr if ioobj . stderr ! = nil { stderr = io . multiwriter ( debugstderr , ioobj . stderr ) } cmd : = exec . command ( args [ 0 ] , args [ 1 : ] ... ) cmd . stdin = ioobj . stdin cmd . stdout = ioobj . stdout cmd . stderr = stderr cmd . dir = dirpath if err : = cmd . run ( ) ; err ! = nil { data , : = ioutil . readall ( debugstderr ) if data ! = nil && len ( data ) > 0 { return fmt . errorf ( " \n " , strings . join ( args , " " ) , err . error ( ) , string ( data ) ) } return fmt . errorf ( " " , strings . join ( args , " " ) , err . error ( ) ) } return nil } 
func ( a * apiserver ) logreq ( request interface { } ) { a . pachlogger . log ( request , nil , nil , 0 ) } 
func ( a * apiserver ) logresp ( request interface { } , response interface { } , err error , duration time . duration ) { if err == nil { a . pachlogger . logatlevelfromdepth ( request , response , err , duration , logrus . infolevel , 4 ) } else if authclient . iserrnotactivated ( err ) { a . pachlogger . logatlevelfromdepth ( request , response , err , duration , logrus . debuglevel , 4 ) } else { a . pachlogger . logatlevelfromdepth ( request , response , err , duration , logrus . errorlevel , 4 ) } } 
func ( a * apiserver ) activationstate ( ) activationstate { a . adminmu . lock ( ) defer a . adminmu . unlock ( ) if len ( a . admincache ) == 0 { return none } if , magicuserisadmin : = a . admincache [ magicuser ] ; magicuserisadmin { return partial } return full } 
func ( a * apiserver ) retrieveorgenerateppstoken ( ) { var tokenproto types . stringvalue ctx , cancel : = context . withtimeout ( context . background ( ) , 2 * time . minute ) defer cancel ( ) b : = backoff . newexponentialbackoff ( ) b . maxelapsedtime = 60 * time . second b . maxinterval = 5 * time . second if err : = backoff . retry ( func ( ) error { if , err : = col . newstm ( ctx , a . env . getetcdclient ( ) , func ( stm col . stm ) error { superusertokencol : = col . newcollection ( a . env . getetcdclient ( ) , ppsconsts . ppstokenkey , nil , & types . stringvalue { } , nil , nil ) . readwrite ( stm ) err : = superusertokencol . get ( " " , & tokenproto ) if err == nil { return nil } if col . iserrnotfound ( err ) { token : = uuid . newwithoutdashes ( ) tokenproto . value = token if err : = superusertokencol . create ( " " , & tokenproto ) ; err ! = nil { return err } } return nil } ) ; err ! = nil { return err } a . ppstoken = tokenproto . value return nil } , b ) ; err ! = nil { panic ( fmt . sprintf ( " " , err ) ) } } 
func githubtokentousername ( ctx context . context , oauthtoken string ) ( string , error ) { if ! githubtokenregex . matchstring ( oauthtoken ) && os . getenv ( disableauthenticationenvvar ) == " " { logrus . warnf ( " " + " " + " " " " , oauthtoken ) return authclient . githubprefix + oauthtoken , nil } ts : = oauth2 . statictokensource ( & oauth2 . token { accesstoken : oauthtoken , } , ) tc : = oauth2 . newclient ( ctx , ts ) gclient : = github . newclient ( tc ) user , , err : = gclient . users . get ( ctx , " " ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } verifiedusername : = user . getlogin ( ) return authclient . githubprefix + verifiedusername , nil } 
func ( a * apiserver ) expiredclusteradmincheck ( ctx context . context , username string ) error { state , err : = a . getenterprisetokenstate ( ) if err ! = nil { return fmt . errorf ( " " , err ) } isadmin , err : = a . isadmin ( ctx , username ) if err ! = nil { return err } if state ! = enterpriseclient . state active && ! isadmin { return errors . new ( " " + " " + " " ) } return nil } 
func ( a * apiserver ) getonetimepassword ( ctx context . context , username string , expiration time . time ) ( code string , err error ) { otpinfo : = & authclient . otpinfo { subject : username , } if ! expiration . iszero ( ) { expirationproto , err : = types . timestampproto ( expiration ) if err ! = nil { return " " , fmt . errorf ( " " , expiration . string ( ) , err ) } otpinfo . sessionexpiration = expirationproto } code = " " + uuid . newwithoutdashes ( ) if , err = col . newstm ( ctx , a . env . getetcdclient ( ) , func ( stm col . stm ) error { return a . authenticationcodes . readwrite ( stm ) . putttl ( hashtoken ( code ) , otpinfo , defaultauthcodettlsecs ) } ) ; err ! = nil { return " " , err } return code , nil } 
func ( a * apiserver ) getscope ( ctx context . context , subject string , acl * authclient . acl ) ( authclient . scope , error ) { scope : = acl . entries [ subject ] groups , err : = a . getgroups ( ctx , subject ) if err ! = nil { return authclient . scope none , fmt . errorf ( " " + " " , err ) } for , g : = range groups { groupscope : = acl . entries [ g ] if scope < groupscope { scope = groupscope } } return scope , nil } 
func ( a * apiserver ) setgroupsforuserinternal ( ctx context . context , subject string , groups [ ] string ) error { , err : = col . newstm ( ctx , a . env . getetcdclient ( ) , func ( stm col . stm ) error { members : = a . members . readwrite ( stm ) var removegroups authclient . groups addgroups : = addtoset ( nil , groups ... ) if err : = members . get ( subject , & removegroups ) ; err == nil { for , group : = range groups { if removegroups . groups [ group ] { removegroups . groups = removefromset ( removegroups . groups , group ) addgroups = removefromset ( addgroups , group ) } } } if err : = members . put ( subject , & authclient . groups { groups : addtoset ( nil , groups ... ) , } ) ; err ! = nil { return err } groups : = a . groups . readwrite ( stm ) var membersproto authclient . users for group : = range removegroups . groups { if err : = groups . upsert ( group , & membersproto , func ( ) error { membersproto . usernames = removefromset ( membersproto . usernames , subject ) return nil } ) ; err ! = nil { return err } } for group : = range addgroups { if err : = groups . upsert ( group , & membersproto , func ( ) error { membersproto . usernames = addtoset ( membersproto . usernames , subject ) return nil } ) ; err ! = nil { return err } } return nil } ) return err } 
func ( a * apiserver ) getgroups ( ctx context . context , subject string ) ( [ ] string , error ) { members : = a . members . readonly ( ctx ) var groupsproto authclient . groups if err : = members . get ( subject , & groupsproto ) ; err ! = nil { if col . iserrnotfound ( err ) { return [ ] string { } , nil } return nil , err } return settolist ( groupsproto . groups ) , nil } 
func hashtoken ( token string ) string { sum : = sha256 . sum256 ( [ ] byte ( token ) ) return fmt . sprintf ( " " , sum ) } 
func getauthtoken ( ctx context . context ) ( string , error ) { md , ok : = metadata . fromincomingcontext ( ctx ) if ! ok { return " " , authclient . errnometadata } if len ( md [ authclient . contexttokenkey ] ) > 1 { return " " , fmt . errorf ( " " ) } else if len ( md [ authclient . contexttokenkey ] ) == 0 { return " " , authclient . errnotsignedin } return md [ authclient . contexttokenkey ] [ 0 ] , nil } 
func ( a * apiserver ) canonicalizesubjects ( ctx context . context , subjects [ ] string ) ( [ ] string , error ) { if subjects == nil { return [ ] string { } , nil } eg : = & errgroup . group { } canonicalizedsubjects : = make ( [ ] string , len ( subjects ) ) for i , subject : = range subjects { i , subject : = i , subject eg . go ( func ( ) error { subject , err : = a . canonicalizesubject ( ctx , subject ) if err ! = nil { return err } canonicalizedsubjects [ i ] = subject return nil } ) } if err : = eg . wait ( ) ; err ! = nil { return nil , err } return canonicalizedsubjects , nil } 
func ( a * apiserver ) canonicalizesubject ( ctx context . context , subject string ) ( string , error ) { colonidx : = strings . index ( subject , " " ) if colonidx < 0 { subject = authclient . githubprefix + subject colonidx = len ( authclient . githubprefix ) - 1 } prefix : = subject [ : colonidx ] a . configmu . lock ( ) defer a . configmu . unlock ( ) if a . configcache ! = nil { if prefix == a . configcache . idp . name { return subject , nil } if prefix == path . join ( " " , a . configcache . idp . name ) { return subject , nil } } prefix += " " switch prefix { case authclient . githubprefix : var err error subject , err = canonicalizegithubusername ( ctx , subject [ len ( authclient . githubprefix ) : ] ) if err ! = nil { return " " , err } case authclient . pipelineprefix , authclient . robotprefix : break default : return " " , fmt . errorf ( " " , subject [ : colonidx + 1 ] ) } return subject , nil } 
func canonicalizegithubusername ( ctx context . context , user string ) ( string , error ) { if strings . index ( user , " " ) >= 0 { return " " , fmt . errorf ( " " , authclient . githubprefix , user ) } if os . getenv ( disableauthenticationenvvar ) == " " { return authclient . githubprefix + user , nil } gclient : = github . newclient ( http . defaultclient ) u , , err : = gclient . users . get ( ctx , strings . tolower ( user ) ) if err ! = nil { return " " , fmt . errorf ( " " " " , user , err ) } return authclient . githubprefix + u . getlogin ( ) , nil } 
func matches ( tb testing . tb , expectedmatch string , actual string , msgandargs ... interface { } ) { tb . helper ( ) r , err : = regexp . compile ( expectedmatch ) if err ! = nil { fatal ( tb , msgandargs , " " , expectedmatch ) } if ! r . matchstring ( actual ) { fatal ( tb , msgandargs , " " , actual , expectedmatch ) } } 
func oneofmatches ( tb testing . tb , expectedmatch string , actuals [ ] string , msgandargs ... interface { } ) { tb . helper ( ) r , err : = regexp . compile ( expectedmatch ) if err ! = nil { fatal ( tb , msgandargs , " " , expectedmatch ) } for , actual : = range actuals { if r . matchstring ( actual ) { return } } fatal ( tb , msgandargs , " " , actuals , expectedmatch ) } 
func equal ( tb testing . tb , expected interface { } , actual interface { } , msgandargs ... interface { } ) { tb . helper ( ) ev , av : = reflect . valueof ( expected ) , reflect . valueof ( actual ) if ev . type ( ) ! = av . type ( ) { fatal ( tb , msgandargs , " \n " + " " , expected , expected , actual , actual ) } if ! reflect . deepequal ( expected , actual ) { fatal ( tb , msgandargs , " \n " + " " , expected , actual ) } } 
func elementsequal ( tb testing . tb , expecteds interface { } , actuals interface { } , msgandargs ... interface { } ) { tb . helper ( ) if err : = elementsequalorerr ( expecteds , actuals ) ; err ! = nil { fatal ( tb , msgandargs , err . error ( ) ) } } 
func oneofequals ( slicename string , slice interface { } , elem interface { } ) ( bool , error ) { e : = reflect . valueof ( elem ) sl : = reflect . valueof ( slice ) if slice == nil | | sl . isnil ( ) { sl = reflect . makeslice ( reflect . sliceof ( e . type ( ) ) , 0 , 0 ) } if sl . kind ( ) ! = reflect . slice { return false , fmt . errorf ( " " " " , slicename , sl . type ( ) . string ( ) ) } if e . type ( ) ! = sl . type ( ) . elem ( ) { return false , nil } areptrs : = e . kind ( ) == reflect . ptr for i : = 0 ; i < sl . len ( ) ; i ++ { if ! areptrs && reflect . deepequal ( e . interface ( ) , sl . index ( i ) . interface ( ) ) { return true , nil } else if areptrs && reflect . deepequal ( e . elem ( ) . interface ( ) , sl . index ( i ) . elem ( ) . interface ( ) ) { return true , nil } } return false , nil } 
func equaloneof ( tb testing . tb , expecteds interface { } , actual interface { } , msgandargs ... interface { } ) { tb . helper ( ) equal , err : = oneofequals ( " " , expecteds , actual ) if err ! = nil { fatal ( tb , msgandargs , err . error ( ) ) } if ! equal { fatal ( tb , msgandargs , " \n " + " " , expecteds , actual ) } } 
func noneequals ( tb testing . tb , expected interface { } , actuals interface { } , msgandargs ... interface { } ) { tb . helper ( ) equal , err : = oneofequals ( " " , actuals , expected ) if err ! = nil { fatal ( tb , msgandargs , err . error ( ) ) } if equal { fatal ( tb , msgandargs , " \n " , expected , actuals ) } } 
func noerror ( tb testing . tb , err error , msgandargs ... interface { } ) { tb . helper ( ) if err ! = nil { fatal ( tb , msgandargs , " " , err . error ( ) ) } } 
func noerrorwithint ( tb testing . tb , t time . duration , f func ( ) error , msgandargs ... interface { } ) { tb . helper ( ) errch : = make ( chan error ) go func ( ) { errch < - f ( ) } ( ) select { case err : = < - errch : if err ! = nil { fatal ( tb , msgandargs , " " , err . error ( ) ) } case < - time . after ( t ) : fatal ( tb , msgandargs , " " , t . string ( ) ) } } 
func noerrorwithintretry ( tb testing . tb , t time . duration , f func ( ) error , msgandargs ... interface { } ) { tb . helper ( ) donech : = make ( chan struct { } ) timeout : = false var err error go func ( ) { for ! timeout { if err = f ( ) ; err == nil { close ( donech ) break } } } ( ) select { case < - donech : case < - time . after ( t ) : timeout = true fatal ( tb , msgandargs , " " , t . string ( ) , err ) } } 
func yeserror ( tb testing . tb , err error , msgandargs ... interface { } ) { tb . helper ( ) if err == nil { fatal ( tb , msgandargs , " " , err ) } } 
func notnil ( tb testing . tb , object interface { } , msgandargs ... interface { } ) { tb . helper ( ) success : = true if object == nil { success = false } else { value : = reflect . valueof ( object ) kind : = value . kind ( ) if kind >= reflect . chan && kind <= reflect . slice && value . isnil ( ) { success = false } } if ! success { fatal ( tb , msgandargs , " " ) } } 
func nil ( tb testing . tb , object interface { } , msgandargs ... interface { } ) { tb . helper ( ) if object == nil { return } value : = reflect . valueof ( object ) kind : = value . kind ( ) if kind >= reflect . chan && kind <= reflect . slice && value . isnil ( ) { return } fatal ( tb , msgandargs , " " , object ) } 
func false ( tb testing . tb , value bool , msgandargs ... interface { } ) { tb . helper ( ) if value { fatal ( tb , msgandargs , " " ) } } 
func newstm ( ctx context . context , c * v3 . client , apply func ( stm ) error ) ( * v3 . txnresponse , error ) { return newstmserializable ( ctx , c , apply , false ) } 
func newdryrunstm ( ctx context . context , c * v3 . client , apply func ( stm ) error ) error { , err : = newstmserializable ( ctx , c , apply , true ) return err } 
func newstmrepeatable ( ctx context . context , c * v3 . client , apply func ( stm ) error ) ( * v3 . txnresponse , error ) { s : = & stm { client : c , ctx : ctx , getopts : [ ] v3 . opoption { v3 . withserializable ( ) } } return runstm ( s , apply , false ) } 
func newstmserializable ( ctx context . context , c * v3 . client , apply func ( stm ) error , dryrun bool ) ( * v3 . txnresponse , error ) { s : = & stmserializable { stm : stm { client : c , ctx : ctx } , prefetch : make ( map [ string ] * v3 . getresponse ) , } return runstm ( s , apply , dryrun ) } 
func newstmreadcommitted ( ctx context . context , c * v3 . client , apply func ( stm ) error ) ( * v3 . txnresponse , error ) { s : = & stmreadcommitted { stm { client : c , ctx : ctx , getopts : [ ] v3 . opoption { v3 . withserializable ( ) } } } return runstm ( s , apply , true ) } 
func ( s * stm ) cmps ( ) [ ] v3 . cmp { cmps : = make ( [ ] v3 . cmp , 0 , len ( s . rset ) ) for k , rk : = range s . rset { cmps = append ( cmps , iskeycurrent ( k , rk ) ) } return cmps } 
func ( s * stm ) puts ( ) [ ] v3 . op { puts : = make ( [ ] v3 . op , 0 , len ( s . wset ) ) for , v : = range s . wset { puts = append ( puts , v . op ) } return puts } 
func ( s * stmreadcommitted ) commit ( ) * v3 . txnresponse { s . rset = nil return s . stm . commit ( ) } 
func ( s * stm ) fetchttl ( iface stm , key string ) ( int64 , error ) { if wv , ok : = s . wset [ key ] ; ok { return wv . ttl , nil } if ttl , ok : = s . ttlset [ key ] ; ok { return ttl , nil } getresp : = iface . fetch ( key ) if len ( getresp . kvs ) == 0 { return 0 , errnotfound { key : key } } leaseid : = v3 . leaseid ( getresp . kvs [ 0 ] . lease ) if leaseid == 0 { s . ttlset [ key ] = 0 return 0 , nil } span , ctx : = tracing . addspantoanyexisting ( s . ctx , " " ) defer tracing . finishanyspan ( span ) leaseresp , err : = s . client . timetolive ( ctx , leaseid ) if err ! = nil { panic ( stmerror { err } ) } s . ttlset [ key ] = leaseresp . ttl for , key : = range leaseresp . keys { s . ttlset [ string ( key ) ] = leaseresp . ttl } return leaseresp . ttl , nil } 
func pipelines ( etcdclient * etcd . client , etcdprefix string ) col . collection { return col . newcollection ( etcdclient , path . join ( etcdprefix , pipelinesprefix ) , nil , & pps . etcdpipelineinfo { } , nil , nil , ) } 
func jobs ( etcdclient * etcd . client , etcdprefix string ) col . collection { return col . newcollection ( etcdclient , path . join ( etcdprefix , jobsprefix ) , [ ] * col . index { jobspipelineindex , jobsoutputindex } , & pps . etcdjobinfo { } , nil , nil , ) } 
func newticker ( b backoff ) * ticker { c : = make ( chan time . time ) t : = & ticker { c : c , c : c , b : b , stop : make ( chan struct { } ) , } go t . run ( ) runtime . setfinalizer ( t , ( * ticker ) . stop ) return t } 
func customcheckretry ( cluster * etcd . cluster , numreqs int , lastresp http . response , err error ) error { maxretries : = 2 * len ( cluster . machines ) if 600 > maxretries { maxretries = 600 } if numreqs > maxretries { errstr : = fmt . sprintf ( " " , cluster . machines , err ) return & etcd . etcderror { errorcode : etcd . errcodeetcdnotreachable , message : " " , cause : errstr , index : 0 , } } if lastresp . statuscode == 0 { return nil } if lastresp . statuscode ! = http . statusinternalservererror { body : = [ ] byte ( " " ) if lastresp . body ! = nil { if b , err : = ioutil . readall ( lastresp . body ) ; err == nil { body = b } } errstr : = fmt . sprintf ( " " , http . statustext ( lastresp . statuscode ) , body ) return & etcd . etcderror { errorcode : etcd . errcodeunhandledhttpstatus , message : " " , cause : errstr , index : 0 , } } time . sleep ( time . millisecond * 500 ) fmt . println ( " " , lastresp . statuscode ) return nil } 
func nodetomap ( node * etcd . node , out map [ string ] string ) bool { key : = strings . trimprefix ( node . key , " " ) if ! node . dir { if node . value == " " { if , ok : = out [ key ] ; ok { delete ( out , key ) return true } return false } if value , ok : = out [ key ] ; ! ok | | value ! = node . value { out [ key ] = node . value return true } return false } changed : = false for , node : = range node . nodes { changed = nodetomap ( node , out ) | | changed } return changed } 
func filldefaultresourcerequests ( opts * assetopts , persistentdiskbackend backend ) { if persistentdiskbackend == localbackend { if opts . blockcachesize == " " { opts . blockcachesize = " " } if opts . pachdnoncachememrequest == " " { opts . pachdnoncachememrequest = " " } if opts . pachdcpurequest == " " { opts . pachdcpurequest = " " } if opts . etcdmemrequest == " " { opts . etcdmemrequest = " " } if opts . etcdcpurequest == " " { opts . etcdcpurequest = " " } } else { if opts . blockcachesize == " " { opts . blockcachesize = " " } if opts . pachdnoncachememrequest == " " { opts . pachdnoncachememrequest = " " } if opts . pachdcpurequest == " " { opts . pachdcpurequest = " " } if opts . etcdmemrequest == " " { opts . etcdmemrequest = " " } if opts . etcdcpurequest == " " { opts . etcdcpurequest = " " } } } 
func serviceaccount ( opts * assetopts ) * v1 . serviceaccount { return & v1 . serviceaccount { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( serviceaccountname , labels ( " " ) , nil , opts . namespace ) , } } 
func clusterrole ( opts * assetopts ) * rbacv1 . clusterrole { return & rbacv1 . clusterrole { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( rolename , labels ( " " ) , nil , opts . namespace ) , rules : rolepolicyrules , } } 
func rolebinding ( opts * assetopts ) * rbacv1 . rolebinding { return & rbacv1 . rolebinding { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( rolebindingname , labels ( " " ) , nil , opts . namespace ) , subjects : [ ] rbacv1 . subject { { kind : " " , name : serviceaccountname , namespace : opts . namespace , } } , roleref : rbacv1 . roleref { kind : " " , name : rolename , } , } } 
func getbackendsecretvolumeandmount ( backend string ) ( v1 . volume , v1 . volumemount ) { return v1 . volume { name : client . storagesecretname , volumesource : v1 . volumesource { secret : & v1 . secretvolumesource { secretname : client . storagesecretname , } , } , } , v1 . volumemount { name : client . storagesecretname , mountpath : " " + client . storagesecretname , } } 
func getsecretenvvars ( storagebackend string ) [ ] v1 . envvar { var envvars [ ] v1 . envvar if storagebackend ! = " " { envvars = append ( envvars , v1 . envvar { name : obj . storagebackendenvvar , value : storagebackend , } ) } trueval : = true for envvar , secretkey : = range obj . envvartosecretkey { envvars = append ( envvars , v1 . envvar { name : envvar , valuefrom : & v1 . envvarsource { secretkeyref : & v1 . secretkeyselector { localobjectreference : v1 . localobjectreference { name : client . storagesecretname , } , key : secretkey , optional : & trueval , } , } , } ) } return envvars } 
func pachdservice ( opts * assetopts ) * v1 . service { prometheusannotations : = map [ string ] string { " " : " " , " " : strconv . itoa ( prometheusport ) , } return & v1 . service { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( pachdname , labels ( pachdname ) , prometheusannotations , opts . namespace ) , spec : v1 . servicespec { type : v1 . servicetypenodeport , selector : map [ string ] string { " " : pachdname , } , ports : [ ] v1 . serviceport { { port : 600 , name : " " , nodeport : 30600 , } , { port : 650 , name : " " , nodeport : 30650 , } , { port : 651 , name : " " , nodeport : 30651 , } , { port : 652 , name : " " , nodeport : 30652 , } , { port : auth . samlport , name : " " , nodeport : 30000 + auth . samlport , } , { port : githook . githookport , name : " " , nodeport : githook . nodeport ( ) , } , } , } , } } 
func githookservice ( namespace string ) * v1 . service { name : = " " return & v1 . service { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( name , labels ( name ) , nil , namespace ) , spec : v1 . servicespec { type : v1 . servicetypeloadbalancer , selector : map [ string ] string { " " : pachdname , } , ports : [ ] v1 . serviceport { { targetport : intstr . fromint ( githook . githookport ) , name : " " , port : githook . externalport ( ) , } , } , } , } } 
func etcdstorageclass ( opts * assetopts , backend backend ) ( interface { } , error ) { sc : = map [ string ] interface { } { " " : " " , " " : " " , " " : map [ string ] interface { } { " " : defaultetcdstorageclassname , " " : labels ( etcdname ) , " " : opts . namespace , } , } switch backend { case googlebackend : sc [ " " ] = " " sc [ " " ] = map [ string ] string { " " : " " , } case amazonbackend : sc [ " " ] = " " sc [ " " ] = map [ string ] string { " " : " " , } default : return nil , nil } return sc , nil } 
func etcdvolumeclaim ( size int , opts * assetopts ) * v1 . persistentvolumeclaim { return & v1 . persistentvolumeclaim { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( etcdvolumeclaimname , labels ( etcdname ) , nil , opts . namespace ) , spec : v1 . persistentvolumeclaimspec { resources : v1 . resourcerequirements { requests : map [ v1 . resourcename ] resource . quantity { " " : resource . mustparse ( fmt . sprintf ( " " , size ) ) , } , } , accessmodes : [ ] v1 . persistentvolumeaccessmode { v1 . readwriteonce } , volumename : etcdvolumename , } , } } 
func etcdnodeportservice ( local bool , opts * assetopts ) * v1 . service { var clientnodeport int32 if local { clientnodeport = 32379 } return & v1 . service { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( etcdname , labels ( etcdname ) , nil , opts . namespace ) , spec : v1 . servicespec { type : v1 . servicetypenodeport , selector : map [ string ] string { " " : etcdname , } , ports : [ ] v1 . serviceport { { port : 2379 , name : " " , nodeport : clientnodeport , } , } , } , } } 
func etcdheadlessservice ( opts * assetopts ) * v1 . service { return & v1 . service { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( etcdheadlessservicename , labels ( etcdname ) , nil , opts . namespace ) , spec : v1 . servicespec { selector : map [ string ] string { " " : etcdname , } , clusterip : " " , ports : [ ] v1 . serviceport { { name : " " , port : 2380 , } , } , } , } } 
func dashdeployment ( opts * assetopts ) * apps . deployment { return & apps . deployment { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( dashname , labels ( dashname ) , nil , opts . namespace ) , spec : apps . deploymentspec { selector : & metav1 . labelselector { matchlabels : labels ( dashname ) , } , template : v1 . podtemplatespec { objectmeta : objectmeta ( dashname , labels ( dashname ) , nil , opts . namespace ) , spec : v1 . podspec { containers : [ ] v1 . container { { name : dashname , image : addregistry ( opts . registry , opts . dashimage ) , ports : [ ] v1 . containerport { { containerport : 8080 , name : " " , } , } , imagepullpolicy : " " , } , { name : grpcproxyname , image : addregistry ( opts . registry , grpcproxyimage ) , ports : [ ] v1 . containerport { { containerport : 8081 , name : " " , } , } , imagepullpolicy : " " , } , } , imagepullsecrets : imagepullsecrets ( opts ) , } , } , } , } } 
func dashservice ( opts * assetopts ) * v1 . service { return & v1 . service { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( dashname , labels ( dashname ) , nil , opts . namespace ) , spec : v1 . servicespec { type : v1 . servicetypenodeport , selector : labels ( dashname ) , ports : [ ] v1 . serviceport { { port : 8080 , name : " " , nodeport : 30080 , } , { port : 8081 , name : " " , nodeport : 30081 , } , } , } , } } 
func miniosecret ( bucket string , id string , secret string , endpoint string , secure , iss3v2 bool ) map [ string ] [ ] byte { securev : = " " if secure { securev = " " } s3v2 : = " " if iss3v2 { s3v2 = " " } return map [ string ] [ ] byte { " " : [ ] byte ( bucket ) , " " : [ ] byte ( id ) , " " : [ ] byte ( secret ) , " " : [ ] byte ( endpoint ) , " " : [ ] byte ( securev ) , " " : [ ] byte ( s3v2 ) , } } 
func writesecret ( encoder encoder , data map [ string ] [ ] byte , opts * assetopts ) error { if opts . dashonly { return nil } secret : = & v1 . secret { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( client . storagesecretname , labels ( client . storagesecretname ) , nil , opts . namespace ) , data : data , } return encoder . encode ( secret ) } 
func amazonsecret ( region , bucket , id , secret , token , distribution string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( region ) , " " : [ ] byte ( bucket ) , " " : [ ] byte ( id ) , " " : [ ] byte ( secret ) , " " : [ ] byte ( token ) , " " : [ ] byte ( distribution ) , } } 
func amazonvaultsecret ( region , bucket , vaultaddress , vaultrole , vaulttoken , distribution string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( region ) , " " : [ ] byte ( bucket ) , " " : [ ] byte ( vaultaddress ) , " " : [ ] byte ( vaultrole ) , " " : [ ] byte ( vaulttoken ) , " " : [ ] byte ( distribution ) , } } 
func amazoniamrolesecret ( region , bucket , distribution string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( region ) , " " : [ ] byte ( bucket ) , " " : [ ] byte ( distribution ) , } } 
func googlesecret ( bucket string , cred string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( bucket ) , " " : [ ] byte ( cred ) , } } 
func microsoftsecret ( container string , id string , secret string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( container ) , " " : [ ] byte ( id ) , " " : [ ] byte ( secret ) , } } 
func writedashboardassets ( encoder encoder , opts * assetopts ) error { if err : = encoder . encode ( dashservice ( opts ) ) ; err ! = nil { return err } return encoder . encode ( dashdeployment ( opts ) ) } 
func writetlssecret ( encoder encoder , opts * assetopts ) error { if opts . dashonly { return nil } if opts . tls == nil { return fmt . errorf ( " " ) } if opts . tls . serverkey == " " { return fmt . errorf ( " " " " ) } if opts . tls . servercert == " " { return fmt . errorf ( " " " " ) } certbytes , err : = ioutil . readfile ( opts . tls . servercert ) if err ! = nil { return fmt . errorf ( " " " " , opts . tls . servercert , err ) } keybytes , err : = ioutil . readfile ( opts . tls . serverkey ) if err ! = nil { return fmt . errorf ( " " " " , opts . tls . serverkey , err ) } secret : = & v1 . secret { typemeta : metav1 . typemeta { kind : " " , apiversion : " " , } , objectmeta : objectmeta ( tlssecretname , labels ( tlssecretname ) , nil , opts . namespace ) , data : map [ string ] [ ] byte { grpcutil . tlscertfile : certbytes , grpcutil . tlskeyfile : keybytes , } , } return encoder . encode ( secret ) } 
func writelocalassets ( encoder encoder , opts * assetopts , hostpath string ) error { if err : = writeassets ( encoder , opts , localbackend , localbackend , 1 / * = volume size ( gb ) * / , hostpath ) ; err ! = nil { return err } if secreterr : = writesecret ( encoder , localsecret ( ) , opts ) ; secreterr ! = nil { return secreterr } return nil } 
func writecustomassets ( encoder encoder , opts * assetopts , args [ ] string , objectstorebackend string , persistentdiskbackend string , secure , iss3v2 bool ) error { switch objectstorebackend { case " " : if len ( args ) ! = s3customargs { return fmt . errorf ( " " , s3customargs ) } volumesize , err : = strconv . atoi ( args [ 1 ] ) if err ! = nil { return fmt . errorf ( " " , args [ 1 ] ) } switch persistentdiskbackend { case " " : if err : = writeassets ( encoder , opts , miniobackend , amazonbackend , volumesize , " " ) ; err ! = nil { return err } case " " : if err : = writeassets ( encoder , opts , miniobackend , googlebackend , volumesize , " " ) ; err ! = nil { return err } case " " : if err : = writeassets ( encoder , opts , miniobackend , microsoftbackend , volumesize , " " ) ; err ! = nil { return err } default : return fmt . errorf ( " " ) } return writesecret ( encoder , miniosecret ( args [ 2 ] , args [ 3 ] , args [ 4 ] , args [ 5 ] , secure , iss3v2 ) , opts ) default : return fmt . errorf ( " " ) } } 
func writeamazonassets ( encoder encoder , opts * assetopts , region string , bucket string , volumesize int , creds * amazoncreds , cloudfrontdistro string ) error { if err : = writeassets ( encoder , opts , amazonbackend , amazonbackend , volumesize , " " ) ; err ! = nil { return err } var secret map [ string ] [ ] byte if creds == nil { secret = amazoniamrolesecret ( region , bucket , cloudfrontdistro ) } else if creds . id ! = " " { secret = amazonsecret ( region , bucket , creds . id , creds . secret , creds . token , cloudfrontdistro ) } else if creds . vaultaddress ! = " " { secret = amazonvaultsecret ( region , bucket , creds . vaultaddress , creds . vaultrole , creds . vaulttoken , cloudfrontdistro ) } return writesecret ( encoder , secret , opts ) } 
func writegoogleassets ( encoder encoder , opts * assetopts , bucket string , cred string , volumesize int ) error { if err : = writeassets ( encoder , opts , googlebackend , googlebackend , volumesize , " " ) ; err ! = nil { return err } return writesecret ( encoder , googlesecret ( bucket , cred ) , opts ) } 
func writemicrosoftassets ( encoder encoder , opts * assetopts , container string , id string , secret string , volumesize int ) error { if err : = writeassets ( encoder , opts , microsoftbackend , microsoftbackend , volumesize , " " ) ; err ! = nil { return err } return writesecret ( encoder , microsoftsecret ( container , id , secret ) , opts ) } 
func images ( opts * assetopts ) [ ] string { return [ ] string { versionedworkerimage ( opts ) , etcdimage , grpcproxyimage , pauseimage , versionedpachdimage ( opts ) , opts . dashimage , } } 
func addregistry ( registry string , imagename string ) string { if registry == " " { return imagename } parts : = strings . split ( imagename , " " ) if len ( parts ) == 3 { parts = parts [ 1 : ] } return path . join ( registry , parts [ 0 ] , parts [ 1 ] ) } 
func ( b * exponentialbackoff ) withcanonicalrandomizationfactor ( ) * exponentialbackoff { if b . randomizationfactor < 0 { b . randomizationfactor = 0 } else if b . randomizationfactor > 1 { b . randomizationfactor = 1 } return b } 
func new10sbackoff ( ) * exponentialbackoff { b : = & exponentialbackoff { initialinterval : 100 * time . millisecond , randomizationfactor : defaultrandomizationfactor , multiplier : defaultmultiplier , maxinterval : 2 * time . second , maxelapsedtime : 10 * time . second , clock : systemclock , } return b . withcanonicalrandomizationfactor ( ) . withreset ( ) } 
func ( b * exponentialbackoff ) reset ( ) { b . currentinterval = b . initialinterval b . starttime = b . clock . now ( ) } 
func ( b * exponentialbackoff ) nextbackoff ( ) time . duration { if b . maxelapsedtime ! = 0 && b . getelapsedtime ( ) > b . maxelapsedtime { return stop } defer b . incrementcurrentinterval ( ) return getrandomvaluefrominterval ( b . randomizationfactor , rand . float64 ( ) , b . currentinterval ) } 
func ( b * exponentialbackoff ) getelapsedtime ( ) time . duration { return b . clock . now ( ) . sub ( b . starttime ) } 
func ( b * exponentialbackoff ) incrementcurrentinterval ( ) { if float64 ( b . currentinterval ) >= float64 ( b . maxinterval ) / b . multiplier { b . currentinterval = b . maxinterval } else { b . currentinterval = time . duration ( float64 ( b . currentinterval ) * b . multiplier ) } } 
func getrandomvaluefrominterval ( randomizationfactor , random float64 , currentinterval time . duration ) time . duration { var delta = randomizationfactor * float64 ( currentinterval ) var mininterval = float64 ( currentinterval ) - delta var maxinterval = float64 ( currentinterval ) + delta return time . duration ( mininterval + ( random * ( maxinterval - mininterval + 1 ) ) ) } 
func factory ( ctx context . context , c * logical . backendconfig ) ( logical . backend , error ) { result : = & backend { } result . backend = & framework . backend { backendtype : logical . typelogical , pathsspecial : & logical . paths { unauthenticated : [ ] string { " " } , } , paths : [ ] * framework . path { result . configpath ( ) , result . loginpath ( ) , result . versionpath ( ) , } , secrets : [ ] * framework . secret { { type : " " , fields : map [ string ] * framework . fieldschema { " " : & framework . fieldschema { type : framework . typestring , description : " " , } , } , renew : result . renew , revoke : result . revoke , } } , } if err : = result . setup ( ctx , c ) ; err ! = nil { return nil , err } return result , nil } 
func newapiserver ( env * serviceenv . serviceenv , etcdprefix string , treecache * hashtree . cache , storageroot string , memoryrequest int64 ) ( apiserver , error ) { return newapiserver ( env , etcdprefix , treecache , storageroot , memoryrequest ) } 
func newblockapiserver ( dir string , cachebytes int64 , backend string , etcdaddress string ) ( blockapiserver , error ) { switch backend { case miniobackendenvvar : if len ( dir ) > 0 && dir [ 0 ] == ' / ' { dir = dir [ 1 : ] } blockapiserver , err : = newminioblockapiserver ( dir , cachebytes , etcdaddress ) if err ! = nil { return nil , err } return blockapiserver , nil case amazonbackendenvvar : if len ( dir ) > 0 && dir [ 0 ] == ' / ' { dir = dir [ 1 : ] } blockapiserver , err : = newamazonblockapiserver ( dir , cachebytes , etcdaddress ) if err ! = nil { return nil , err } return blockapiserver , nil case googlebackendenvvar : blockapiserver , err : = newgoogleblockapiserver ( dir , cachebytes , etcdaddress ) if err ! = nil { return nil , err } return blockapiserver , nil case microsoftbackendenvvar : blockapiserver , err : = newmicrosoftblockapiserver ( dir , cachebytes , etcdaddress ) if err ! = nil { return nil , err } return blockapiserver , nil case localbackendenvvar : fallthrough default : blockapiserver , err : = newlocalblockapiserver ( dir , cachebytes , etcdaddress ) if err ! = nil { return nil , err } return blockapiserver , nil } } 
func localstorage ( tb testing . tb ) ( obj . client , * storage ) { wd , err : = os . getwd ( ) require . noerror ( tb , err ) objc , err : = obj . newlocalclient ( wd ) require . noerror ( tb , err ) return objc , newstorage ( objc , prefix ) } 
func ( a * apiserver ) deletejob ( stm col . stm , jobptr * pps . etcdjobinfo ) error { pipelineptr : = & pps . etcdpipelineinfo { } if err : = a . pipelines . readwrite ( stm ) . update ( jobptr . pipeline . name , pipelineptr , func ( ) error { if pipelineptr . jobcounts == nil { pipelineptr . jobcounts = make ( map [ int32 ] int32 ) } if pipelineptr . jobcounts [ int32 ( jobptr . state ) ] ! = 0 { pipelineptr . jobcounts [ int32 ( jobptr . state ) ] -- } return nil } ) ; err ! = nil { return err } return a . jobs . readwrite ( stm ) . delete ( jobptr . job . id ) } 
func writexml ( w http . responsewriter , r * http . request , code int , v interface { } ) { w . header ( ) . set ( " " , " " ) w . writeheader ( code ) encoder : = xml . newencoder ( w ) if err : = encoder . encode ( v ) ; err ! = nil { requestlogger ( r ) . errorf ( " " , err ) } } 
func clean1 7hashtreepath ( p string ) string { if ! strings . hasprefix ( p , " " ) { p = " " + p } return default1 7hashtreeroot ( pathlib . clean ( p ) ) } 
func newfromaddress ( addr string , options ... option ) ( * apiclient , error ) { settings : = clientsettings { maxconcurrentstreams : defaultmaxconcurrentstreams , dialtimeout : defaultdialtimeout , } for , option : = range options { if err : = option ( & settings ) ; err ! = nil { return nil , err } } c : = & apiclient { addr : addr , cacerts : settings . cacerts , limiter : limit . new ( settings . maxconcurrentstreams ) , } if err : = c . connect ( settings . dialtimeout ) ; err ! = nil { return nil , err } return c , nil } 
func withmaxconcurrentstreams ( streams int ) option { return func ( settings * clientsettings ) error { settings . maxconcurrentstreams = streams return nil } } 
func withrootcas ( path string ) option { return func ( settings * clientsettings ) error { settings . cacerts = x509 . newcertpool ( ) return addcertfromfile ( settings . cacerts , path ) } } 
func withadditionalrootcas ( pembytes [ ] byte ) option { return func ( settings * clientsettings ) error { if settings . cacerts == nil { settings . cacerts = x509 . newcertpool ( ) } if ok : = settings . cacerts . appendcertsfrompem ( pembytes ) ; ! ok { return fmt . errorf ( " " ) } return nil } } 
func withdialtimeout ( t time . duration ) option { return func ( settings * clientsettings ) error { settings . dialtimeout = t return nil } } 
func withadditionalpachdcert ( ) option { return func ( settings * clientsettings ) error { if , err : = os . stat ( grpcutil . tlsvolumepath ) ; err == nil { if settings . cacerts == nil { settings . cacerts = x509 . newcertpool ( ) } return addcertfromfile ( settings . cacerts , path . join ( grpcutil . tlsvolumepath , grpcutil . tlscertfile ) ) } return nil } } 
func getusermachineaddrandopts ( cfg * config . config ) ( string , [ ] option , error ) { if envaddr , ok : = os . lookupenv ( " " ) ; ok { if ! strings . contains ( envaddr , " " ) { envaddr = fmt . sprintf ( " " , envaddr , defaultpachdnodeport ) } options , err : = getcertoptionsfromenv ( ) if err ! = nil { return " " , nil , err } return envaddr , options , nil } if cfg ! = nil && cfg . v1 ! = nil && cfg . v1 . pachdaddress ! = " " { if cfg . v1 . servercas ! = " " { pembytes , err : = base64 . stdencoding . decodestring ( cfg . v1 . servercas ) if err ! = nil { return " " , nil , fmt . errorf ( " " , err ) } return cfg . v1 . pachdaddress , [ ] option { withadditionalrootcas ( pembytes ) } , nil } return cfg . v1 . pachdaddress , nil , nil } options , err : = getcertoptionsfromenv ( ) if err ! = nil { return " " , nil , err } return " " , options , nil } 
func newincluster ( options ... option ) ( * apiclient , error ) { host , ok : = os . lookupenv ( " " ) if ! ok { return nil , fmt . errorf ( " " ) } port , ok : = os . lookupenv ( " " ) if ! ok { return nil , fmt . errorf ( " " ) } return newfromaddress ( fmt . sprintf ( " " , host , port ) , options ... ) } 
func ( c * apiclient ) close ( ) error { if err : = c . clientconn . close ( ) ; err ! = nil { return err } if c . portforwarder ! = nil { c . portforwarder . close ( ) } return nil } 
func ( c apiclient ) deleteall ( ) error { if , err : = c . authapiclient . deactivate ( c . ctx ( ) , & auth . deactivaterequest { } , ) ; err ! = nil && ! auth . iserrnotactivated ( err ) { return grpcutil . scrubgrpc ( err ) } if , err : = c . ppsapiclient . deleteall ( c . ctx ( ) , & types . empty { } , ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } if , err : = c . pfsapiclient . deleteall ( c . ctx ( ) , & types . empty { } , ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } return nil } 
func ( c apiclient ) setmaxconcurrentstreams ( n int ) { c . limiter = limit . new ( n ) } 
func defaultdialoptions ( ) [ ] grpc . dialoption { return [ ] grpc . dialoption { grpc . withblock ( ) , grpc . withtimeout ( 30 * time . second ) , grpc . withdefaultcalloptions ( grpc . maxcallrecvmsgsize ( grpcutil . maxmsgsize ) , grpc . maxcallsendmsgsize ( grpcutil . maxmsgsize ) , ) , } } 
func ( c * apiclient ) addmetadata ( ctx context . context ) context . context { clientdata : = make ( map [ string ] string ) if c . authenticationtoken ! = " " { clientdata [ auth . contexttokenkey ] = c . authenticationtoken } if c . metricsuserid ! = " " { clientdata [ " " ] = c . metricsuserid clientdata [ " " ] = c . metricsprefix } incomingmd , : = metadata . fromincomingcontext ( ctx ) outgoingmd , : = metadata . fromoutgoingcontext ( ctx ) clientmd : = metadata . new ( clientdata ) finalmd : = make ( metadata . md ) for , md : = range [ ] metadata . md { incomingmd , outgoingmd , clientmd } { for k , v : = range md { finalmd [ k ] = v } } return metadata . newoutgoingcontext ( ctx , finalmd ) } 
func ( c * apiclient ) ctx ( ) context . context { if c . ctx == nil { return c . addmetadata ( context . background ( ) ) } return c . addmetadata ( c . ctx ) } 
func ( c * apiclient ) withctx ( ctx context . context ) * apiclient { result : = * c result . ctx = ctx return & result } 
func newdlock ( client * etcd . client , prefix string ) dlock { return & etcdimpl { client : client , prefix : prefix , } } 
func ( a * apiserver ) datumid ( data [ ] * input ) string { hash : = sha256 . new ( ) for , d : = range data { hash . write ( [ ] byte ( d . fileinfo . file . path ) ) hash . write ( d . fileinfo . hash ) } return hex . encodetostring ( hash . sum ( nil ) ) } 
func ( logger * taggedlogger ) logf ( formatstring string , args ... interface { } ) { logger . template . message = fmt . sprintf ( formatstring , args ... ) if ts , err : = types . timestampproto ( time . now ( ) ) ; err == nil { logger . template . ts = ts } else { logger . stderrlog . printf ( " \n " , err ) return } msg , err : = logger . marshaler . marshaltostring ( & logger . template ) if err ! = nil { logger . stderrlog . printf ( " \n " , & logger . template , err ) return } fmt . println ( msg ) if logger . putobjclient ! = nil { logger . msgch < - msg + " \n " } } 
func hashdatum ( pipelinename string , pipelinesalt string , data [ ] * input ) string { hash : = sha256 . new ( ) for , datum : = range data { hash . write ( [ ] byte ( datum . name ) ) hash . write ( [ ] byte ( datum . fileinfo . file . path ) ) hash . write ( datum . fileinfo . hash ) } hash . write ( [ ] byte ( pipelinename ) ) hash . write ( [ ] byte ( pipelinesalt ) ) return client . datumtagprefix ( pipelinesalt ) + hex . encodetostring ( hash . sum ( nil ) ) } 
func hashdatum15 ( pipelineinfo * pps . pipelineinfo , data [ ] * input ) ( string , error ) { hash : = sha256 . new ( ) for , datum : = range data { hash . write ( [ ] byte ( datum . name ) ) hash . write ( [ ] byte ( datum . fileinfo . file . path ) ) hash . write ( datum . fileinfo . hash ) } env : = pipelineinfo . transform . env pipelineinfo . transform . env = nil defer func ( ) { pipelineinfo . transform . env = env } ( ) bytes , err : = pipelineinfo . transform . marshal ( ) if err ! = nil { return " " , err } hash . write ( bytes ) hash . write ( [ ] byte ( pipelineinfo . pipeline . name ) ) hash . write ( [ ] byte ( pipelineinfo . id ) ) hash . write ( [ ] byte ( strconv . itoa ( int ( pipelineinfo . version ) ) ) ) return client . datumtagprefix ( pipelineinfo . id ) + hex . encodetostring ( hash . sum ( nil ) ) , nil } 
func ( a * apiserver ) status ( ctx context . context , * types . empty ) ( * pps . workerstatus , error ) { a . statusmu . lock ( ) defer a . statusmu . unlock ( ) started , err : = types . timestampproto ( a . started ) if err ! = nil { return nil , err } result : = & pps . workerstatus { jobid : a . jobid , workerid : a . workername , started : started , data : a . datum ( ) , queuesize : atomic . loadint64 ( & a . queuesize ) , } return result , nil } 
func ( a * apiserver ) cancel ( ctx context . context , request * cancelrequest ) ( * cancelresponse , error ) { a . statusmu . lock ( ) defer a . statusmu . unlock ( ) if request . jobid ! = a . jobid { return & cancelresponse { success : false } , nil } if ! matchdatum ( request . datafilters , a . datum ( ) ) { return & cancelresponse { success : false } , nil } a . cancel ( ) a . jobid = " " a . data = nil a . started = time . time { } a . cancel = nil return & cancelresponse { success : true } , nil } 
func ( a * apiserver ) getchunk ( request * getchunkrequest , server worker getchunkserver ) error { filter : = hashtree . newfilter ( a . numshards , request . shard ) if request . stats { return a . chunkstatscache . get ( request . id , grpcutil . newstreamingbyteswriter ( server ) , filter ) } return a . chunkcache . get ( request . id , grpcutil . newstreamingbyteswriter ( server ) , filter ) } 
func ( a * apiserver ) cancelctxifjobfails ( jobctx context . context , jobcancel func ( ) , jobid string ) { logger : = a . getworkerlogger ( ) backoff . retrynotify ( func ( ) error { if isdone ( jobctx ) { return nil } watcher , err : = a . jobs . readonly ( jobctx ) . watchone ( jobid ) if err ! = nil { if col . iserrnotfound ( err ) { jobcancel ( ) return nil } return fmt . errorf ( " " , jobid , err ) } for { select { case e : = < - watcher . watch ( ) : switch e . type { case watch . eventput : var jobid string jobptr : = & pps . etcdjobinfo { } if err : = e . unmarshal ( & jobid , jobptr ) ; err ! = nil { return fmt . errorf ( " " , err ) } if ppsutil . isterminal ( jobptr . state ) { jobcancel ( ) } case watch . eventdelete : jobcancel ( ) case watch . eventerror : return fmt . errorf ( " " , e . err ) } case < - jobctx . done ( ) : break } } } , backoff . newinfinitebackoff ( ) , func ( err error , d time . duration ) error { if jobctx . err ( ) == context . canceled { return err } logger . logf ( " " , jobid , err , d ) return nil } ) } 
func mergestats ( x , y * pps . processstats ) error { var err error if x . downloadtime , err = plusduration ( x . downloadtime , y . downloadtime ) ; err ! = nil { return err } if x . processtime , err = plusduration ( x . processtime , y . processtime ) ; err ! = nil { return err } if x . uploadtime , err = plusduration ( x . uploadtime , y . uploadtime ) ; err ! = nil { return err } x . downloadbytes += y . downloadbytes x . uploadbytes += y . uploadbytes return nil } 
func ( a * apiserver ) mergechunk ( logger * taggedlogger , high int64 , result * processresult ) ( reterr error ) { logger . logf ( " " ) defer func ( start time . time ) { if reterr ! = nil { logger . logf ( " " , time . since ( start ) , reterr ) } else { logger . logf ( " " , time . since ( start ) ) } } ( time . now ( ) ) buf : = & bytes . buffer { } if result . datumsfailed <= 0 { if err : = a . datumcache . merge ( hashtree . newwriter ( buf ) , nil , nil ) ; err ! = nil { return err } } if err : = a . chunkcache . put ( high , buf ) ; err ! = nil { return err } if a . pipelineinfo . enablestats { buf . reset ( ) if err : = a . datumstatscache . merge ( hashtree . newwriter ( buf ) , nil , nil ) ; err ! = nil { return err } return a . chunkstatscache . put ( high , buf ) } return nil } 
func lookupdockeruser ( userarg string ) ( * user . user , reterr error ) { userparts : = strings . split ( userarg , " " ) useroruid : = userparts [ 0 ] grouporgid : = " " if len ( userparts ) > 1 { grouporgid = userparts [ 1 ] } passwd , err : = os . open ( " " ) if err ! = nil { return nil , err } defer func ( ) { if err : = passwd . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) scanner : = bufio . newscanner ( passwd ) for scanner . scan ( ) { parts : = strings . split ( scanner . text ( ) , " " ) if parts [ 0 ] == useroruid | | parts [ 2 ] == useroruid { result : = & user . user { username : parts [ 0 ] , uid : parts [ 2 ] , gid : parts [ 3 ] , name : parts [ 4 ] , homedir : parts [ 5 ] , } if grouporgid ! = " " { if parts [ 0 ] == useroruid { group , err : = lookupgroup ( grouporgid ) if err ! = nil { return nil , err } result . gid = group . gid } else { result . gid = grouporgid } } return result , nil } } if err : = scanner . err ( ) ; err ! = nil { log . fatal ( err ) } return nil , fmt . errorf ( " " , userarg ) } 
func iscommitnotfounderr ( err error ) bool { if err == nil { return false } return commitnotfoundre . matchstring ( grpcutil . scrubgrpc ( err ) . error ( ) ) } 
func iscommitdeletederr ( err error ) bool { if err == nil { return false } return commitdeletedre . matchstring ( grpcutil . scrubgrpc ( err ) . error ( ) ) } 
func iscommitfinishederr ( err error ) bool { if err == nil { return false } return commitfinishedre . matchstring ( grpcutil . scrubgrpc ( err ) . error ( ) ) } 
func isreponotfounderr ( err error ) bool { if err == nil { return false } return reponotfoundre . matchstring ( err . error ( ) ) } 
func isbranchnotfounderr ( err error ) bool { if err == nil { return false } return branchnotfoundre . matchstring ( err . error ( ) ) } 
func isfilenotfounderr ( err error ) bool { if err == nil { return false } return filenotfoundre . matchstring ( err . error ( ) ) } 
func ( c apiclient ) version ( ) ( string , error ) { v , err : = c . versionapiclient . getversion ( c . ctx ( ) , & types . empty { } ) if err ! = nil { return " " , grpcutil . scrubgrpc ( err ) } return version . prettyprintversion ( v ) , nil } 
func validatereponame ( name string ) error { match , : = regexp . matchstring ( " " , name ) if ! match { return fmt . errorf ( " " , name ) } return nil } 
func newdriver ( env * serviceenv . serviceenv , etcdprefix string , treecache * hashtree . cache , storageroot string , memoryrequest int64 ) ( * driver , error ) { if treecache == nil { return nil , fmt . errorf ( " " ) } etcdclient : = env . getetcdclient ( ) d : = & driver { etcdclient : etcdclient , prefix : etcdprefix , repos : pfsdb . repos ( etcdclient , etcdprefix ) , putfilerecords : pfsdb . putfilerecords ( etcdclient , etcdprefix ) , commits : func ( repo string ) col . collection { return pfsdb . commits ( etcdclient , etcdprefix , repo ) } , branches : func ( repo string ) col . collection { return pfsdb . branches ( etcdclient , etcdprefix , repo ) } , opencommits : pfsdb . opencommits ( etcdclient , etcdprefix ) , treecache : treecache , storageroot : storageroot , memorylimiter : semaphore . newweighted ( memoryrequest / 3 ) , } repo : = client . newrepo ( ppsconsts . specrepo ) repoinfo : = & pfs . repoinfo { repo : repo , created : now ( ) , } if , err : = col . newstm ( context . background ( ) , etcdclient , func ( stm col . stm ) error { repos : = d . repos . readwrite ( stm ) return repos . create ( repo . name , repoinfo ) } ) ; err ! = nil && ! col . iserrexists ( err ) { return nil , err } return d , nil } 
func ( d * driver ) checkisauthorized ( pachclient * client . apiclient , r * pfs . repo , s auth . scope ) error { ctx : = pachclient . ctx ( ) me , err : = pachclient . whoami ( ctx , & auth . whoamirequest { } ) if auth . iserrnotactivated ( err ) { return nil } resp , err : = pachclient . authapiclient . authorize ( ctx , & auth . authorizerequest { repo : r . name , scope : s , } ) if err ! = nil { return fmt . errorf ( " " " " , r . name , grpcutil . scrubgrpc ( err ) ) } if ! resp . authorized { return & auth . errnotauthorized { subject : me . username , repo : r . name , required : s } } return nil } 
func ( d * driver ) writefinishedcommit ( ctx context . context , commit * pfs . commit , commitinfo * pfs . commitinfo ) error { , err : = col . newstm ( ctx , d . etcdclient , func ( stm col . stm ) error { commits : = d . commits ( commit . repo . name ) . readwrite ( stm ) if err : = commits . put ( commit . id , commitinfo ) ; err ! = nil { return err } if err : = d . opencommits . readwrite ( stm ) . delete ( commit . id ) ; err ! = nil { return fmt . errorf ( " " , commit . id , err ) } repos : = d . repos . readwrite ( stm ) repoinfo : = new ( pfs . repoinfo ) if err : = repos . get ( commit . repo . name , repoinfo ) ; err ! = nil { return err } for , branch : = range repoinfo . branches { if branch . name == " " { branchinfo : = & pfs . branchinfo { } if err : = d . branches ( commit . repo . name ) . readwrite ( stm ) . get ( branch . name , branchinfo ) ; err ! = nil { return err } if branchinfo . head ! = nil && branchinfo . head . id == commit . id { repoinfo . sizebytes = commitinfo . sizebytes if err : = repos . put ( commit . repo . name , repoinfo ) ; err ! = nil { return err } } } } return nil } ) return err } 
func ( d * driver ) scratchcommitprefix ( commit * pfs . commit ) string { return path . join ( commit . repo . name , commit . id ) } 
func ( d * driver ) scratchfileprefix ( file * pfs . file ) ( string , error ) { return path . join ( d . scratchcommitprefix ( file . commit ) , file . path ) , nil } 
func headerdirtoputfilerecords ( tree hashtree . hashtree , path string , node * hashtree . nodeproto ) ( * pfs . putfilerecords , error ) { if node . dirnode == nil | | node . dirnode . shared == nil { return nil , fmt . errorf ( " " ) } s : = node . dirnode . shared pfr : = & pfs . putfilerecords { split : true , } if s . header ! = nil { pfr . header = & pfs . putfilerecord { sizebytes : s . headersize , objecthash : s . header . hash , } } if s . footer ! = nil { pfr . footer = & pfs . putfilerecord { sizebytes : s . footersize , objecthash : s . footer . hash , } } if err : = tree . list ( path , func ( child * hashtree . nodeproto ) error { if child . filenode == nil { return fmt . errorf ( " " + " " ) } for i , o : = range child . filenode . objects { var size int64 if i == 0 { size = child . subtreesize } pfr . records = append ( pfr . records , & pfs . putfilerecord { sizebytes : size , objecthash : o . hash , } ) } return nil } ) ; err ! = nil { return nil , err } return pfr , nil } 
func ( d * driver ) gettreeforfile ( pachclient * client . apiclient , file * pfs . file ) ( hashtree . hashtree , error ) { if file . commit == nil { t , err : = hashtree . newdbhashtree ( d . storageroot ) if err ! = nil { return nil , err } return t , nil } commitinfo , err : = d . inspectcommit ( pachclient , file . commit , pfs . commitstate started ) if err ! = nil { return nil , err } if commitinfo . finished ! = nil { tree , err : = d . gettreeforcommit ( pachclient , file . commit ) if err ! = nil { return nil , err } return tree , nil } parenttree , err : = d . gettreeforcommit ( pachclient , commitinfo . parentcommit ) if err ! = nil { return nil , err } return d . gettreeforopencommit ( pachclient , file , parenttree ) } 
func provenantoninput ( provenance [ ] * pfs . commitprovenance ) bool { provenancecount : = len ( provenance ) for , p : = range provenance { if p . commit . repo . name == ppsconsts . specrepo { provenancecount -- break } } return provenancecount > 0 } 
func nodetofileinfo ( ci * pfs . commitinfo , path string , node * hashtree . nodeproto , full bool ) * pfs . fileinfo { fileinfo : = & pfs . fileinfo { file : & pfs . file { commit : ci . commit , path : path , } , sizebytes : uint64 ( node . subtreesize ) , hash : node . hash , committed : ci . finished , } if node . filenode ! = nil { fileinfo . filetype = pfs . filetype file if full { fileinfo . objects = node . filenode . objects fileinfo . blockrefs = node . filenode . blockrefs } } else if node . dirnode ! = nil { fileinfo . filetype = pfs . filetype dir if full { fileinfo . children = node . dirnode . children } } return fileinfo } 
func ( d * driver ) filehistory ( pachclient * client . apiclient , file * pfs . file , history int64 , f func ( * pfs . fileinfo ) error ) error { var fi * pfs . fileinfo for { fi , err : = d . inspectfile ( pachclient , file ) if err ! = nil { if , ok : = err . ( pfsserver . errfilenotfound ) ; ok { return f ( fi ) } return err } if fi ! = nil && bytes . compare ( fi . hash , fi . hash ) ! = 0 { if err : = f ( fi ) ; err ! = nil { return err } if history > 0 { history -- if history == 0 { return nil } } } fi = fi ci , err : = d . inspectcommit ( pachclient , file . commit , pfs . commitstate started ) if err ! = nil { return err } if ci . parentcommit == nil { return f ( fi ) } file . commit = ci . parentcommit } } 
func ( d * driver ) upsertputfilerecords ( pachclient * client . apiclient , file * pfs . file , newrecords * pfs . putfilerecords ) error { prefix , err : = d . scratchfileprefix ( file ) if err ! = nil { return err } ctx : = pachclient . ctx ( ) , err = col . newstm ( ctx , d . etcdclient , func ( stm col . stm ) error { commitscol : = d . opencommits . readonly ( ctx ) var commit pfs . commit err : = commitscol . get ( file . commit . id , & commit ) if err ! = nil { return err } if commit . id ! = file . commit . id { return fmt . errorf ( " " , file . commit . id ) } recordscol : = d . putfilerecords . readwrite ( stm ) var existingrecords pfs . putfilerecords return recordscol . upsert ( prefix , & existingrecords , func ( ) error { if newrecords . tombstone { existingrecords . tombstone = true existingrecords . records = nil } existingrecords . split = newrecords . split existingrecords . records = append ( existingrecords . records , newrecords . records ... ) existingrecords . header = newrecords . header existingrecords . footer = newrecords . footer return nil } ) } ) if err ! = nil { return err } return err } 
func ( r * pgdumpreader ) readrow ( ) ( [ ] byte , error ) { if len ( r . header ) == 0 { err : = r . readheader ( ) if err ! = nil { return nil , err } } endline : = " \ \ \n " row , err : = r . rd . readbytes ( ' \n ' ) if err ! = nil && err ! = io . eof { return nil , fmt . errorf ( " " , err ) } if len ( row ) >= 2 && row [ len ( row ) - 2 ] == ' ' { row [ len ( row ) - 2 ] = ' \n ' row = row [ : len ( row ) - 1 ] } if string ( row ) == endline { r . footer = append ( r . footer , row ... ) err = r . readfooter ( ) row = nil } if err == io . eof && len ( r . footer ) == 0 { return nil , fmt . errorf ( " " ) } return row , err } 
func newreporter ( clusterid string , kubeclient * kube . clientset ) * reporter { reporter : = & reporter { segmentclient : newpersistentclient ( ) , clusterid : clusterid , kubeclient : kubeclient , } go reporter . reportclustermetrics ( ) return reporter } 
func reportuseraction ( ctx context . context , r * reporter , action string ) func ( time . time , error ) { if r == nil { return func ( time . time , error ) { } } r . reportuseraction ( ctx , fmt . sprintf ( " " , action ) , 1 ) return func ( start time . time , err error ) { if err == nil { r . reportuseraction ( ctx , fmt . sprintf ( " " , action ) , time . since ( start ) . seconds ( ) ) } else { r . reportuseraction ( ctx , fmt . sprintf ( " " , action ) , err . error ( ) ) } } } 
func reportandflushuseraction ( action string , value interface { } ) func ( ) { metricsdone : = make ( chan struct { } ) go func ( ) { client : = newsegmentclient ( ) defer client . close ( ) cfg , err : = config . read ( ) if err ! = nil | | cfg == nil | | cfg . userid == " " { log . errorf ( " " , err ) return } reportusermetricstosegment ( client , cfg . userid , " " , action , value , " " ) close ( metricsdone ) } ( ) return func ( ) { select { case < - metricsdone : return case < - time . after ( time . second * 5 ) : return } } } 
func finishreportandflushuseraction ( action string , err error , start time . time ) func ( ) { var wait func ( ) if err ! = nil { wait = reportandflushuseraction ( fmt . sprintf ( " " , action ) , err ) } else { wait = reportandflushuseraction ( fmt . sprintf ( " " , action ) , time . since ( start ) . seconds ( ) ) } return wait } 
func ( r * reader ) read ( data [ ] byte ) ( int , error ) { var totalread int for len ( data ) > 0 { n , err : = r . r . read ( data ) data = data [ n : ] totalread += n if err ! = nil { if len ( r . datarefs ) == 0 { return totalread , io . eof } if r . curr == nil | | r . curr . chunk . hash ! = r . datarefs [ 0 ] . chunk . hash { if err : = r . readchunk ( r . datarefs [ 0 ] . chunk ) ; err ! = nil { return totalread , err } } r . curr = r . datarefs [ 0 ] r . datarefs = r . datarefs [ 1 : ] r . r = bytes . newreader ( r . buf . bytes ( ) [ r . curr . offsetbytes : r . curr . offsetbytes + r . curr . sizebytes ] ) } } return totalread , nil } 
func parseiso8601 ( s string ) ( time . time , error ) { t , err : = time . parse ( time . rfc3339 , s ) if err == nil { return t , nil } t , err = time . parse ( " " , s ) if err == nil { return t , nil } return time . time { } , fmt . errorf ( " " " " , s , [ ] string { time . rfc3339 , " " } ) } 
func getstatecmd ( nometrics , noportforwarding * bool ) * cobra . command { getstate : = & cobra . command { short : " " + " " , long : " " + " " , run : cmdutil . run ( func ( args [ ] string ) error { c , err : = client . newonusermachine ( ! * nometrics , ! * noportforwarding , " " ) if err ! = nil { return fmt . errorf ( " " , err . error ( ) ) } defer c . close ( ) resp , err : = c . enterprise . getstate ( c . ctx ( ) , & enterprise . getstaterequest { } ) if err ! = nil { return err } if resp . state == enterprise . state none { fmt . println ( " " ) return nil } ts , err : = types . timestampfromproto ( resp . info . expires ) if err ! = nil { return fmt . errorf ( " " + " " , err . error ( ) ) } fmt . printf ( " \n \n " , resp . state . string ( ) , ts . string ( ) ) return nil } ) , } return cmdutil . createalias ( getstate , " " ) } 
func cmds ( nometrics , noportforwarding * bool ) [ ] * cobra . command { var commands [ ] * cobra . command enterprise : = & cobra . command { short : " " , long : " " , } commands = append ( commands , cmdutil . createalias ( enterprise , " " ) ) commands = append ( commands , activatecmd ( nometrics , noportforwarding ) ) commands = append ( commands , getstatecmd ( nometrics , noportforwarding ) ) return commands } 
func newconfiguration ( config interface { } ) * configuration { configuration : = & configuration { } switch config . ( type ) { case * globalconfiguration : configuration . globalconfiguration = config . ( * globalconfiguration ) return configuration case * pachdfullconfiguration : configuration . globalconfiguration = & config . ( * pachdfullconfiguration ) . globalconfiguration configuration . pachdspecificconfiguration = & config . ( * pachdfullconfiguration ) . pachdspecificconfiguration return configuration case * workerfullconfiguration : configuration . globalconfiguration = & config . ( * workerfullconfiguration ) . globalconfiguration configuration . workerspecificconfiguration = & config . ( * workerfullconfiguration ) . workerspecificconfiguration return configuration default : return nil } } 
func repos ( etcdclient * etcd . client , etcdprefix string ) col . collection { return col . newcollection ( etcdclient , path . join ( etcdprefix , reposprefix ) , nil , & pfs . repoinfo { } , nil , nil , ) } 
func putfilerecords ( etcdclient * etcd . client , etcdprefix string ) col . collection { return col . newcollection ( etcdclient , path . join ( etcdprefix , putfilerecordsprefix ) , nil , & pfs . putfilerecords { } , nil , nil , ) } 
func commits ( etcdclient * etcd . client , etcdprefix string , repo string ) col . collection { return col . newcollection ( etcdclient , path . join ( etcdprefix , commitsprefix , repo ) , [ ] * col . index { provenanceindex } , & pfs . commitinfo { } , nil , nil , ) } 
func branches ( etcdclient * etcd . client , etcdprefix string , repo string ) col . collection { return col . newcollection ( etcdclient , path . join ( etcdprefix , branchesprefix , repo ) , nil , & pfs . branchinfo { } , func ( key string ) error { if uuid . isuuidwithoutdashes ( key ) { return fmt . errorf ( " " ) } return nil } , nil , ) } 
func opencommits ( etcdclient * etcd . client , etcdprefix string ) col . collection { return col . newcollection ( etcdclient , path . join ( etcdprefix , opencommitsprefix ) , nil , & pfs . commit { } , nil , nil , ) } 
func newdag ( nodes map [ string ] [ ] string ) * dag { result : = & dag { parents : make ( map [ string ] [ ] string ) , children : make ( map [ string ] [ ] string ) , leaves : make ( map [ string ] bool ) , } for id , parents : = range nodes { result . newnode ( id , parents ) } return result } 
func ( d * dag ) newnode ( id string , parents [ ] string ) { d . parents [ id ] = parents for , parentid : = range parents { d . children [ parentid ] = append ( d . children [ parentid ] , id ) d . leaves [ parentid ] = false } if , ok : = d . leaves [ id ] ; ! ok { d . leaves [ id ] = true } } 
func ( d * dag ) sorted ( ) [ ] string { seen : = make ( map [ string ] bool ) var result [ ] string for id : = range d . parents { result = append ( result , dfs ( id , d . parents , seen ) ... ) } return result } 
func ( d * dag ) leaves ( ) [ ] string { var result [ ] string for id , isleaf : = range d . leaves { if isleaf { result = append ( result , id ) } } return result } 
func ( d * dag ) ancestors ( id string , from [ ] string ) [ ] string { seen : = make ( map [ string ] bool ) for , fromid : = range from { seen [ fromid ] = true } return dfs ( id , d . parents , seen ) } 
func ( d * dag ) descendants ( id string , to [ ] string ) [ ] string { seen : = make ( map [ string ] bool ) for , toid : = range to { seen [ toid ] = true } return bfs ( id , d . children , seen ) } 
func ( d * dag ) ghosts ( ) [ ] string { var result [ ] string for id : = range d . children { if , ok : = d . parents [ id ] ; ! ok { result = append ( result , id ) } } return result } 
func newportforwarder ( namespace string ) ( * portforwarder , error ) { if namespace == " " { namespace = " " } rules : = clientcmd . newdefaultclientconfigloadingrules ( ) overrides : = & clientcmd . configoverrides { } kubeconfig : = clientcmd . newnoninteractivedeferredloadingclientconfig ( rules , overrides ) config , err : = kubeconfig . clientconfig ( ) if err ! = nil { return nil , err } client , err : = kubernetes . newforconfig ( config ) if err ! = nil { return nil , err } core : = client . corev1 ( ) return & portforwarder { core : core , client : core . restclient ( ) , config : config , namespace : namespace , logger : log . standardlogger ( ) . writer ( ) , stopchanslock : & sync . mutex { } , stopchans : [ ] chan struct { } { } , shutdown : false , } , nil } 
func ( f * portforwarder ) runfordaemon ( localport , remoteport uint16 ) error { if localport == 0 { localport = pachdlocalport } if remoteport == 0 { remoteport = pachdremoteport } return f . run ( " " , localport , remoteport ) } 
func ( f * portforwarder ) runforsamlacs ( localport uint16 ) error { if localport == 0 { localport = samlacslocalport } return f . run ( " " , localport , 654 ) } 
func ( f * portforwarder ) runfordashui ( localport uint16 ) error { if localport == 0 { localport = dashuilocalport } return f . run ( " " , localport , 8080 ) } 
func ( f * portforwarder ) runfordashwebsocket ( localport uint16 ) error { if localport == 0 { localport = dashwebsocketlocalport } return f . run ( " " , localport , 8081 ) } 
func ( f * portforwarder ) runfors3gateway ( localport uint16 ) error { if localport == 0 { localport = s3gatewaylocalport } return f . run ( " " , localport , 600 ) } 
func ( f * portforwarder ) lock ( ) error { pidfile . setpidfilepath ( path . join ( os . getenv ( " " ) , " " ) ) return pidfile . write ( ) } 
func ( f * portforwarder ) close ( ) { defer f . logger . close ( ) f . stopchanslock . lock ( ) defer f . stopchanslock . unlock ( ) if f . shutdown { panic ( " " ) } f . shutdown = true for , stopchan : = range f . stopchans { close ( stopchan ) } } 
func ( e * event ) unmarshal ( key * string , val proto . message ) error { if err : = checktype ( e . template , val ) ; err ! = nil { return err } * key = string ( e . key ) return proto . unmarshal ( e . value , val ) } 
func ( e * event ) unmarshalprev ( key * string , val proto . message ) error { if err : = checktype ( e . template , val ) ; err ! = nil { return err } * key = string ( e . prevkey ) return proto . unmarshal ( e . prevvalue , val ) } 
func makewatcher ( eventch chan * event , done chan struct { } ) watcher { return & watcher { eventch : eventch , done : done , } } 
func checktype ( template proto . message , val interface { } ) error { if template ! = nil { valtype , templatetype : = reflect . typeof ( val ) , reflect . typeof ( template ) if valtype ! = templatetype { return fmt . errorf ( " " , valtype , templatetype ) } } return nil } 
func newpool ( kubeclient * kube . clientset , namespace string , servicename string , port int , queuesize int64 , opts ... grpc . dialoption ) ( * pool , error ) { endpointsinterface : = kubeclient . corev1 ( ) . endpoints ( namespace ) watch , err : = endpointsinterface . watch ( metav1 . listoptions { labelselector : metav1 . formatlabelselector ( metav1 . setaslabelselector ( map [ string ] string { " " : servicename } , ) ) , watch : true , } ) if err ! = nil { return nil , err } pool : = & pool { port : port , endpointswatch : watch , opts : opts , done : make ( chan struct { } ) , queuesize : queuesize , } pool . connscond = sync . newcond ( & pool . connslock ) go pool . watchendpoints ( ) return pool , nil } 
func ( p * pool ) do ( ctx context . context , f func ( cc * grpc . clientconn ) error ) error { var conn * conncount if err : = func ( ) error { p . connslock . lock ( ) defer p . connslock . unlock ( ) for { for addr , mapconn : = range p . conns { if mapconn . cc == nil { cc , err : = grpc . dialcontext ( ctx , addr , p . opts ... ) if err ! = nil { return fmt . errorf ( " " , addr , err ) } mapconn . cc = cc conn = mapconn break } else { mapconncount : = atomic . loadint64 ( & mapconn . count ) if mapconncount < p . queuesize && ( conn == nil | | mapconncount < atomic . loadint64 ( & conn . count ) ) { conn = mapconn } } } if conn == nil { p . connscond . wait ( ) } else { atomic . addint64 ( & conn . count , 1 ) break } } return nil } ( ) ; err ! = nil { return err } defer p . connscond . broadcast ( ) defer atomic . addint64 ( & conn . count , - 1 ) return f ( conn . cc ) } 
func ( p * pool ) close ( ) error { close ( p . done ) var reterr error for , conn : = range p . conns { if conn . cc ! = nil { if err : = conn . cc . close ( ) ; err ! = nil { reterr = err } } } return reterr } 
func buildimage ( client * docker . client , repo string , contextdir string , dockerfile string , desttag string ) error { destimage : = fmt . sprintf ( " " , repo , desttag ) fmt . printf ( " \n " , destimage ) err : = client . buildimage ( docker . buildimageoptions { name : destimage , contextdir : contextdir , dockerfile : dockerfile , outputstream : os . stdout , } ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func pushimage ( client * docker . client , authconfig docker . authconfiguration , repo string , sourcetag string , desttag string ) ( string , error ) { sourceimage : = fmt . sprintf ( " " , repo , sourcetag ) destimage : = fmt . sprintf ( " " , repo , desttag ) fmt . printf ( " \n " , destimage ) if err : = client . tagimage ( sourceimage , docker . tagimageoptions { repo : repo , tag : desttag , context : context . background ( ) , } ) ; err ! = nil { err = fmt . errorf ( " " , err ) return " " , err } if err : = client . pushimage ( docker . pushimageoptions { name : repo , tag : desttag , } , authconfig , ) ; err ! = nil { err = fmt . errorf ( " " , err ) return " " , err } return destimage , nil } 
func newminioclient ( endpoint , bucket , id , secret string , secure bool ) ( * minioclient , error ) { mclient , err : = minio . new ( endpoint , id , secret , secure ) if err ! = nil { return nil , err } return & minioclient { bucket : bucket , client : mclient , } , nil } 
func newminioclientv2 ( endpoint , bucket , id , secret string , secure bool ) ( * minioclient , error ) { mclient , err : = minio . newv2 ( endpoint , id , secret , secure ) if err ! = nil { return nil , err } return & minioclient { bucket : bucket , client : mclient , } , nil } 
func newminiowriter ( ctx context . context , client * minioclient , name string ) * miniowriter { reader , writer : = io . pipe ( ) w : = & miniowriter { ctx : ctx , errchan : make ( chan error ) , pipe : writer , } go func ( ) { , err : = client . putobject ( client . bucket , name , reader , " " ) if err ! = nil { reader . closewitherror ( err ) } w . errchan < - err } ( ) return w } 
func ( w * miniowriter ) close ( ) error { span , : = tracing . addspantoanyexisting ( w . ctx , " " ) defer tracing . finishanyspan ( span ) if err : = w . pipe . close ( ) ; err ! = nil { return err } return < - w . errchan } 
func pipelinerepo ( pipeline * ppsclient . pipeline ) * pfs . repo { return & pfs . repo { name : pipeline . name } } 
func pipelinercname ( name string , version uint64 ) string { name = strings . replace ( name , " " , " " , - 1 ) return fmt . sprintf ( " " , strings . tolower ( name ) , version ) } 
func getrequestsresourcelistfrompipeline ( pipelineinfo * pps . pipelineinfo ) ( * v1 . resourcelist , error ) { return getresourcelistfromspec ( pipelineinfo . resourcerequests , pipelineinfo . cachesize ) } 
func getlimitsresourcelistfrompipeline ( pipelineinfo * pps . pipelineinfo ) ( * v1 . resourcelist , error ) { return getresourcelistfromspec ( pipelineinfo . resourcelimits , pipelineinfo . cachesize ) } 
func getnumnodes ( kubeclient * kube . clientset ) ( int , error ) { nodelist , err : = kubeclient . corev1 ( ) . nodes ( ) . list ( metav1 . listoptions { } ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } if len ( nodelist . items ) == 0 { return 0 , fmt . errorf ( " " ) } return len ( nodelist . items ) , nil } 
func getexpectednumworkers ( kubeclient * kube . clientset , spec * ppsclient . parallelismspec ) ( int , error ) { if spec == nil | | ( spec . constant == 0 && spec . coefficient == 0 ) { return 1 , nil } else if spec . constant > 0 && spec . coefficient == 0 { return int ( spec . constant ) , nil } else if spec . constant == 0 && spec . coefficient > 0 { numnodes , err : = getnumnodes ( kubeclient ) if err ! = nil { return 0 , err } result : = math . floor ( spec . coefficient * float64 ( numnodes ) ) return int ( math . max ( result , 1 ) ) , nil } return 0 , fmt . errorf ( " " , spec ) } 
func getexpectednumhashtrees ( spec * ppsclient . hashtreespec ) ( int64 , error ) { if spec == nil | | spec . constant == 0 { return 1 , nil } else if spec . constant > 0 { return int64 ( spec . constant ) , nil } return 0 , fmt . errorf ( " " , spec ) } 
func getpipelineinfo ( pachclient * client . apiclient , ptr * pps . etcdpipelineinfo , full bool ) ( * pps . pipelineinfo , error ) { result : = & pps . pipelineinfo { } if full { buf : = bytes . buffer { } if err : = pachclient . getfile ( ppsconsts . specrepo , ptr . speccommit . id , ppsconsts . specfile , 0 , 0 , & buf ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } if err : = result . unmarshal ( buf . bytes ( ) ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } } result . state = ptr . state result . reason = ptr . reason result . jobcounts = ptr . jobcounts result . lastjobstate = ptr . lastjobstate result . speccommit = ptr . speccommit return result , nil } 
func failpipeline ( ctx context . context , etcdclient * etcd . client , pipelinescollection col . collection , pipelinename string , reason string ) error { , err : = col . newstm ( ctx , etcdclient , func ( stm col . stm ) error { pipelines : = pipelinescollection . readwrite ( stm ) pipelineptr : = new ( pps . etcdpipelineinfo ) if err : = pipelines . get ( pipelinename , pipelineptr ) ; err ! = nil { return err } pipelineptr . state = pps . pipelinestate pipeline failure pipelineptr . reason = reason pipelines . put ( pipelinename , pipelineptr ) return nil } ) return err } 
func jobinput ( pipelineinfo * pps . pipelineinfo , outputcommitinfo * pfs . commitinfo ) * pps . input { branchtocommit : = make ( map [ string ] * pfs . commit ) key : = path . join for , prov : = range outputcommitinfo . provenance { branchtocommit [ key ( prov . commit . repo . name , prov . branch . name ) ] = prov . commit } jobinput : = proto . clone ( pipelineinfo . input ) . ( * pps . input ) pps . visitinput ( jobinput , func ( input * pps . input ) { if input . pfs ! = nil { if commit , ok : = branchtocommit [ key ( input . pfs . repo , input . pfs . branch ) ] ; ok { input . pfs . commit = commit . id } } if input . cron ! = nil { if commit , ok : = branchtocommit [ key ( input . cron . repo , " " ) ] ; ok { input . cron . commit = commit . id } } if input . git ! = nil { if commit , ok : = branchtocommit [ key ( input . git . name , input . git . branch ) ] ; ok { input . git . commit = commit . id } } } ) return jobinput } 
func pipelinereqfrominfo ( pipelineinfo * ppsclient . pipelineinfo ) * ppsclient . createpipelinerequest { return & ppsclient . createpipelinerequest { pipeline : pipelineinfo . pipeline , transform : pipelineinfo . transform , parallelismspec : pipelineinfo . parallelismspec , hashtreespec : pipelineinfo . hashtreespec , egress : pipelineinfo . egress , outputbranch : pipelineinfo . outputbranch , scaledownthreshold : pipelineinfo . scaledownthreshold , resourcerequests : pipelineinfo . resourcerequests , resourcelimits : pipelineinfo . resourcelimits , input : pipelineinfo . input , description : pipelineinfo . description , cachesize : pipelineinfo . cachesize , enablestats : pipelineinfo . enablestats , batch : pipelineinfo . batch , maxqueuesize : pipelineinfo . maxqueuesize , service : pipelineinfo . service , chunkspec : pipelineinfo . chunkspec , datumtimeout : pipelineinfo . datumtimeout , jobtimeout : pipelineinfo . jobtimeout , salt : pipelineinfo . salt , } } 
func newpipelinemanifestreader ( path string ) ( result * pipelinemanifestreader , reterr error ) { result = & pipelinemanifestreader { } var pipelinereader io . reader if path == " " { pipelinereader = io . teereader ( os . stdin , & result . buf ) fmt . print ( " \n " ) } else if url , err : = url . parse ( path ) ; err == nil && url . scheme ! = " " { resp , err : = http . get ( url . string ( ) ) if err ! = nil { return nil , err } defer func ( ) { if err : = resp . body . close ( ) ; err ! = nil && reterr == nil { reterr = err } } ( ) rawbytes , err : = ioutil . readall ( resp . body ) if err ! = nil { return nil , err } pipelinereader = io . teereader ( strings . newreader ( string ( rawbytes ) ) , & result . buf ) } else { rawbytes , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } pipelinereader = io . teereader ( strings . newreader ( string ( rawbytes ) ) , & result . buf ) } result . decoder = json . newdecoder ( pipelinereader ) return result , nil } 
func ( r * pipelinemanifestreader ) nextcreatepipelinerequest ( ) ( * ppsclient . createpipelinerequest , error ) { var result ppsclient . createpipelinerequest if err : = jsonpb . unmarshalnext ( r . decoder , & result ) ; err ! = nil { if err == io . eof { return nil , err } return nil , fmt . errorf ( " " , err ) } return & result , nil } 
func describesyntaxerror ( originalerr error , parsedbuffer bytes . buffer ) error { serr , ok : = originalerr . ( * json . syntaxerror ) if ! ok { return originalerr } buffer : = make ( [ ] byte , serr . offset ) parsedbuffer . read ( buffer ) lineoffset : = strings . lastindex ( string ( buffer [ : len ( buffer ) - 1 ] ) , " \n " ) if lineoffset == - 1 { lineoffset = 0 } lines : = strings . split ( string ( buffer [ : len ( buffer ) - 1 ] ) , " \n " ) linenumber : = len ( lines ) descriptiveerrorstring : = fmt . sprintf ( " \n \n \n \n " , linenumber , string ( buffer [ lineoffset : ] ) , strings . repeat ( " " , int ( serr . offset ) - 2 - lineoffset ) , originalerr , ) return errors . new ( descriptiveerrorstring ) } 
func isterminal ( state pps . jobstate ) bool { switch state { case pps . jobstate job success , pps . jobstate job failure , pps . jobstate job killed : return true case pps . jobstate job starting , pps . jobstate job running , pps . jobstate job merging : return false default : panic ( fmt . sprintf ( " " , state ) ) } } 
func updatejobstate ( pipelines col . readwritecollection , jobs col . readwritecollection , jobptr * pps . etcdjobinfo , state pps . jobstate , reason string ) error { pipelineptr : = & pps . etcdpipelineinfo { } if err : = pipelines . get ( jobptr . pipeline . name , pipelineptr ) ; err ! = nil { return err } if pipelineptr . jobcounts == nil { pipelineptr . jobcounts = make ( map [ int32 ] int32 ) } if pipelineptr . jobcounts [ int32 ( jobptr . state ) ] ! = 0 { pipelineptr . jobcounts [ int32 ( jobptr . state ) ] -- } pipelineptr . jobcounts [ int32 ( state ) ] ++ pipelineptr . lastjobstate = state if err : = pipelines . put ( jobptr . pipeline . name , pipelineptr ) ; err ! = nil { return err } var err error if state == pps . jobstate job starting { jobptr . started , err = types . timestampproto ( time . now ( ) ) } else if isterminal ( state ) { jobptr . finished , err = types . timestampproto ( time . now ( ) ) } if err ! = nil { return err } jobptr . state = state jobptr . reason = reason return jobs . put ( jobptr . job . id , jobptr ) } 
func fetchrawidpmetadata ( name string , mdurl * url . url ) ( [ ] byte , error ) { c : = http . defaultclient req , err : = http . newrequest ( " " , mdurl . string ( ) , nil ) if err ! = nil { return nil , fmt . errorf ( " " , name , err ) } req . header . set ( " " , " " ) var rawmetadata [ ] byte b : = backoff . newinfinitebackoff ( ) b . maxelapsedtime = 30 * time . second b . maxinterval = 2 * time . second if err : = backoff . retrynotify ( func ( ) error { resp , err : = c . do ( req ) if err ! = nil { return err } if resp . statuscode ! = http . statusok { return fmt . errorf ( " " , resp . statuscode , resp . status ) } rawmetadata , err = ioutil . readall ( resp . body ) resp . body . close ( ) if err ! = nil { return fmt . errorf ( " " , err ) } if len ( rawmetadata ) == 0 { return fmt . errorf ( " " ) } return nil } , b , func ( err error , d time . duration ) error { logrus . printf ( " " , err , d ) return nil } ) ; err ! = nil { return nil , err } return rawmetadata , nil } 
func ( a * apiserver ) updateconfig ( config * auth . authconfig ) error { if config == nil { config = & auth . authconfig { } } newconfig , err : = validateconfig ( config , internal ) if err ! = nil { return err } if newconfig . idp . name ! = " " { a . configcache = newconfig a . samlsp = & saml . serviceprovider { logger : logrus . new ( ) , idpmetadata : a . configcache . idp . metadata , acsurl : * a . configcache . samlsvc . acsurl , metadataurl : * a . configcache . samlsvc . metadataurl , } a . redirectaddress = a . configcache . samlsvc . dashurl } else { a . configcache = nil a . samlsp = nil a . redirectaddress = nil } return nil } 
func new ( ) string { var result string backoff . retrynotify ( func ( ) error { uuid , err : = uuid . newv4 ( ) if err ! = nil { return err } result = uuid . string ( ) return nil } , backoff . newinfinitebackoff ( ) , func ( err error , d time . duration ) error { fmt . printf ( " " , err ) return nil } ) return result } 
func prettyprintcode ( h * httperror ) string { codenumber : = h . code ( ) codetext : = http . statustext ( h . code ( ) ) return fmt . sprintf ( " " , codenumber , codetext ) } 
func newstorage ( objc obj . client , prefix string ) * storage { return & storage { objc : objc , prefix : prefix , } } 
func ( s * storage ) newreader ( ctx context . context , datarefs [ ] * dataref ) io . readcloser { if len ( datarefs ) == 0 { return ioutil . nopcloser ( & bytes . buffer { } ) } return newreader ( ctx , s . objc , s . prefix , datarefs ) } 
func ( s * storage ) newwriter ( ctx context . context ) * writer { return newwriter ( ctx , s . objc , s . prefix ) } 
func ( s * storage ) deleteall ( ctx context . context ) error { return s . objc . walk ( ctx , s . prefix , func ( hash string ) error { return s . objc . delete ( ctx , hash ) } ) } 
func chunk ( data [ ] byte , chunksize int ) [ ] [ ] byte { var result [ ] [ ] byte for i : = 0 ; i < len ( data ) ; i += chunksize { end : = i + chunksize if end > len ( data ) { end = len ( data ) } result = append ( result , data [ i : end ] ) } return result } 
func chunkreader ( r io . reader , f func ( [ ] byte ) error ) ( int , error ) { var total int buf : = getbuffer ( ) defer putbuffer ( buf ) for { n , err : = r . read ( buf ) if n == 0 && err ! = nil { if err == io . eof { return total , nil } return total , err } if err : = f ( buf [ : n ] ) ; err ! = nil { return total , err } total += n } } 
func newstreamingbytesreader ( streamingbytesclient streamingbytesclient , cancel context . cancelfunc ) io . readcloser { return & streamingbytesreader { streamingbytesclient : streamingbytesclient , cancel : cancel } } 
func writetostreamingbytesserver ( reader io . reader , streamingbytesserver streamingbytesserver ) error { buf : = getbuffer ( ) defer putbuffer ( buf ) , err : = io . copybuffer ( newstreamingbyteswriter ( streamingbytesserver ) , readerwrapper { reader } , buf ) return err } 
func writefromstreamingbytesclient ( streamingbytesclient streamingbytesclient , writer io . writer ) error { for bytesvalue , err : = streamingbytesclient . recv ( ) ; err ! = io . eof ; bytesvalue , err = streamingbytesclient . recv ( ) { if err ! = nil { return err } if , err = writer . write ( bytesvalue . value ) ; err ! = nil { return err } } return nil } 
func newapiserver ( env * serviceenv . serviceenv , etcdprefix string , namespace string , workerimage string , workersidecarimage string , workerimagepullpolicy string , storageroot string , storagebackend string , storagehostpath string , iamrole string , imagepullsecret string , noexposedockersocket bool , reporter * metrics . reporter , workerusesroot bool , workergrpcport uint16 , port uint16 , pprofport uint16 , httpport uint16 , peerport uint16 , ) ( ppsclient . apiserver , error ) { apiserver : = & apiserver { logger : log . newlogger ( " " ) , env : env , etcdprefix : etcdprefix , namespace : namespace , workerimage : workerimage , workersidecarimage : workersidecarimage , workerimagepullpolicy : workerimagepullpolicy , storageroot : storageroot , storagebackend : storagebackend , storagehostpath : storagehostpath , iamrole : iamrole , imagepullsecret : imagepullsecret , noexposedockersocket : noexposedockersocket , reporter : reporter , workerusesroot : workerusesroot , pipelines : ppsdb . pipelines ( env . getetcdclient ( ) , etcdprefix ) , jobs : ppsdb . jobs ( env . getetcdclient ( ) , etcdprefix ) , monitorcancels : make ( map [ string ] func ( ) ) , workergrpcport : workergrpcport , port : port , pprofport : pprofport , httpport : httpport , peerport : peerport , } apiserver . validatekube ( ) go apiserver . master ( ) return apiserver , nil } 
func newsidecarapiserver ( env * serviceenv . serviceenv , etcdprefix string , iamrole string , reporter * metrics . reporter , workergrpcport uint16 , pprofport uint16 , httpport uint16 , peerport uint16 , ) ( ppsclient . apiserver , error ) { apiserver : = & apiserver { logger : log . newlogger ( " " ) , env : env , etcdprefix : etcdprefix , iamrole : iamrole , reporter : reporter , workerusesroot : true , pipelines : ppsdb . pipelines ( env . getetcdclient ( ) , etcdprefix ) , jobs : ppsdb . jobs ( env . getetcdclient ( ) , etcdprefix ) , workergrpcport : workergrpcport , pprofport : pprofport , httpport : httpport , peerport : peerport , } return apiserver , nil } 
func newenterpriseserver ( env * serviceenv . serviceenv , etcdprefix string ) ( ec . apiserver , error ) { s : = & apiserver { pachlogger : log . newlogger ( " " ) , env : env , enterprisetoken : col . newcollection ( env . getetcdclient ( ) , etcdprefix , nil , & ec . enterpriserecord { } , nil , nil , ) , } s . enterpriseexpiration . store ( time . time { } ) go s . watchenterprisetoken ( etcdprefix ) return s , nil } 
func ( a * apiserver ) getstate ( ctx context . context , req * ec . getstaterequest ) ( resp * ec . getstateresponse , reterr error ) { a . logreq ( req ) defer func ( start time . time ) { a . pachlogger . log ( req , resp , reterr , time . since ( start ) ) } ( time . now ( ) ) expiration , ok : = a . enterpriseexpiration . load ( ) . ( time . time ) if ! ok { return nil , fmt . errorf ( " " ) } if expiration . iszero ( ) { return & ec . getstateresponse { state : ec . state none } , nil } expirationproto , err : = types . timestampproto ( expiration ) if err ! = nil { return nil , fmt . errorf ( " " " " , expiration . string ( ) , err . error ( ) ) } resp = & ec . getstateresponse { info : & ec . tokeninfo { expires : expirationproto , } , } if time . now ( ) . after ( expiration ) { resp . state = ec . state expired } else { resp . state = ec . state active } return resp , nil } 
func ( a * apiserver ) deactivate ( ctx context . context , req * ec . deactivaterequest ) ( resp * ec . deactivateresponse , reterr error ) { a . logreq ( req ) defer func ( start time . time ) { a . pachlogger . log ( req , resp , reterr , time . since ( start ) ) } ( time . now ( ) ) pachclient : = a . env . getpachclient ( ctx ) if err : = pachclient . deleteall ( ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } if , err : = col . newstm ( ctx , a . env . getetcdclient ( ) , func ( stm col . stm ) error { return a . enterprisetoken . readwrite ( stm ) . delete ( enterprisetokenkey ) } ) ; err ! = nil { return nil , err } if err : = backoff . retry ( func ( ) error { if t : = a . enterpriseexpiration . load ( ) . ( time . time ) ; ! t . iszero ( ) { return fmt . errorf ( " " ) } return nil } , backoff . retryevery ( time . second ) ) ; err ! = nil { return nil , err } time . sleep ( time . second ) return & ec . deactivateresponse { } , nil } 
func command ( name string , arg ... string ) * cmd { cmd : = & cmd { path : name , args : append ( [ ] string { name } , arg ... ) , } if filepath . base ( name ) == name { if lp , err : = exec . lookpath ( name ) ; err ! = nil { cmd . lookpatherr = err } else { cmd . path = lp } } return cmd } 
func commandcontext ( ctx context . context , name string , arg ... string ) * cmd { if ctx == nil { panic ( " " ) } cmd : = command ( name , arg ... ) cmd . ctx = ctx return cmd } 
func ( c * cmd ) run ( ) error { if err : = c . start ( ) ; err ! = nil { return err } return c . wait ( ) } 
func lookextensions ( path , dir string ) ( string , error ) { if filepath . base ( path ) == path { path = filepath . join ( " " , path ) } if dir == " " { return exec . lookpath ( path ) } if filepath . volumename ( path ) ! = " " { return exec . lookpath ( path ) } if len ( path ) > 1 && os . ispathseparator ( path [ 0 ] ) { return exec . lookpath ( path ) } dirandpath : = filepath . join ( dir , path ) lp , err : = exec . lookpath ( dirandpath ) if err ! = nil { return " " , err } ext : = strings . trimprefix ( lp , dirandpath ) return path + ext , nil } 
func ( c * cmd ) wait ( ) error { if c . process == nil { return errors . new ( " " ) } if c . finished { return errors . new ( " " ) } c . finished = true state , err : = c . process . wait ( ) return c . waitio ( state , err ) } 
func ( c * cmd ) waitio ( state * os . processstate , err error ) ( reterr error ) { if c . waitdone ! = nil { close ( c . waitdone ) } c . processstate = state if err ! = nil { return err } else if ! state . success ( ) { return & exiterror { processstate : state } } for range c . goroutine { if err : = < - c . errch ; err ! = nil && reterr == nil { reterr = err } } c . closedescriptors ( c . closeafterwait ) return reterr } 
func ( c * cmd ) output ( ) ( [ ] byte , error ) { if c . stdout ! = nil { return nil , errors . new ( " " ) } var stdout bytes . buffer c . stdout = & stdout captureerr : = c . stderr == nil if captureerr { c . stderr = & prefixsuffixsaver { n : 32 < < 10 } } err : = c . run ( ) if err ! = nil && captureerr { if ee , ok : = err . ( * exiterror ) ; ok { ee . stderr = c . stderr . ( * prefixsuffixsaver ) . bytes ( ) } } return stdout . bytes ( ) , err } 
func ( c * cmd ) combinedoutput ( ) ( [ ] byte , error ) { if c . stdout ! = nil { return nil , errors . new ( " " ) } if c . stderr ! = nil { return nil , errors . new ( " " ) } var b bytes . buffer c . stdout = & b c . stderr = & b err : = c . run ( ) return b . bytes ( ) , err } 
func ( c * cmd ) stdinpipe ( ) ( io . writecloser , error ) { if c . stdin ! = nil { return nil , errors . new ( " " ) } if c . process ! = nil { return nil , errors . new ( " " ) } pr , pw , err : = os . pipe ( ) if err ! = nil { return nil , err } c . stdin = pr c . closeafterstart = append ( c . closeafterstart , pr ) wc : = & closeonce { file : pw } c . closeafterwait = append ( c . closeafterwait , closerfunc ( wc . safeclose ) ) return wc , nil } 
func ( c * closeonce ) safeclose ( ) error { c . writers . lock ( ) err : = c . close ( ) c . writers . unlock ( ) return err } 
func ( c * cmd ) stdoutpipe ( ) ( io . readcloser , error ) { if c . stdout ! = nil { return nil , errors . new ( " " ) } if c . process ! = nil { return nil , errors . new ( " " ) } pr , pw , err : = os . pipe ( ) if err ! = nil { return nil , err } c . stdout = pw c . closeafterstart = append ( c . closeafterstart , pw ) c . closeafterwait = append ( c . closeafterwait , pr ) return pr , nil } 
func dedupenvcase ( caseinsensitive bool , env [ ] string ) [ ] string { out : = make ( [ ] string , 0 , len ( env ) ) saw : = map [ string ] int { } for , kv : = range env { eq : = strings . index ( kv , " " ) if eq < 0 { out = append ( out , kv ) continue } k : = kv [ : eq ] if caseinsensitive { k = strings . tolower ( k ) } if dupidx , isdup : = saw [ k ] ; isdup { out [ dupidx ] = kv continue } saw [ k ] = len ( out ) out = append ( out , kv ) } return out } 
func visitinput ( input * input , f func ( * input ) ) { switch { case input == nil : return case input . cross ! = nil : for , input : = range input . cross { visitinput ( input , f ) } case input . union ! = nil : for , input : = range input . union { visitinput ( input , f ) } } f ( input ) } 
func inputname ( input * input ) string { switch { case input == nil : return " " case input . pfs ! = nil : return input . pfs . name case input . cross ! = nil : if len ( input . cross ) > 0 { return inputname ( input . cross [ 0 ] ) } case input . union ! = nil : if len ( input . union ) > 0 { return inputname ( input . union [ 0 ] ) } } return " " } 
func sortinput ( input * input ) { visitinput ( input , func ( input * input ) { sortinputs : = func ( inputs [ ] * input ) { sort . slicestable ( inputs , func ( i , j int ) bool { return inputname ( inputs [ i ] ) < inputname ( inputs [ j ] ) } ) } switch { case input . cross ! = nil : sortinputs ( input . cross ) case input . union ! = nil : sortinputs ( input . union ) } } ) } 
func inputbranches ( input * input ) [ ] * pfs . branch { var result [ ] * pfs . branch visitinput ( input , func ( input * input ) { if input . pfs ! = nil { result = append ( result , & pfs . branch { repo : & pfs . repo { name : input . pfs . repo } , name : input . pfs . branch , } ) } if input . cron ! = nil { result = append ( result , & pfs . branch { repo : & pfs . repo { name : input . cron . repo } , name : " " , } ) } if input . git ! = nil { result = append ( result , & pfs . branch { repo : & pfs . repo { name : input . git . name } , name : input . git . branch , } ) } } ) return result } 
func validategitcloneurl ( url string ) error { exampleurl : = " " if url == " " { return fmt . errorf ( " " , exampleurl ) } o : = & git . cloneoptions { url : url , } if err : = o . validate ( ) ; err ! = nil { return err } invaliderr : = fmt . errorf ( " " , exampleurl ) if ! strings . hassuffix ( url , " " ) { return invaliderr } if ! strings . hasprefix ( url , " " ) { return invaliderr } return nil } 
func containsempty ( vals [ ] string ) bool { for , val : = range vals { if val == " " { return true } } return false } 
func main ( do func ( interface { } ) error , appenv interface { } , decoders ... decoder ) { if err : = populate ( appenv , decoders ... ) ; err ! = nil { mainerror ( err ) } if err : = do ( appenv ) ; err ! = nil { mainerror ( err ) } os . exit ( 0 ) } 
func newapiserver ( address string , storageroot string , clusterinfo * admin . clusterinfo ) apiserver { return & apiserver { logger : log . newlogger ( " " ) , address : address , storageroot : storageroot , clusterinfo : clusterinfo , } } 
func unescapehtml ( s string ) string { s = strings . replace ( s , " \ \ " , " " , - 1 ) s = strings . replace ( s , " \ \ " , " " , - 1 ) return s } 
func ago ( timestamp * types . timestamp ) string { t , : = types . timestampfromproto ( timestamp ) if t . equal ( time . time { } ) { return " " } return fmt . sprintf ( " " , units . humanduration ( time . since ( t ) ) ) } 
func timedifference ( from * types . timestamp , to * types . timestamp ) string { tfrom , : = types . timestampfromproto ( from ) tto , : = types . timestampfromproto ( to ) return units . humanduration ( tto . sub ( tfrom ) ) } 
func duration ( d * types . duration ) string { duration , : = types . durationfromproto ( d ) return units . humanduration ( duration ) } 
func ( c apiclient ) inspectcluster ( ) ( * admin . clusterinfo , error ) { clusterinfo , err : = c . adminapiclient . inspectcluster ( c . ctx ( ) , & types . empty { } ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } return clusterinfo , nil } 
func ( c apiclient ) extract ( objects bool , f func ( op * admin . op ) error ) error { extractclient , err : = c . adminapiclient . extract ( c . ctx ( ) , & admin . extractrequest { noobjects : ! objects } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } for { op , err : = extractclient . recv ( ) if err == io . eof { break } if err ! = nil { return grpcutil . scrubgrpc ( err ) } if err : = f ( op ) ; err ! = nil { return err } } return nil } 
func ( c apiclient ) extractall ( objects bool ) ( [ ] * admin . op , error ) { var result [ ] * admin . op if err : = c . extract ( objects , func ( op * admin . op ) error { result = append ( result , op ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c apiclient ) extractwriter ( objects bool , w io . writer ) error { writer : = pbutil . newwriter ( w ) return c . extract ( objects , func ( op * admin . op ) error { , err : = writer . write ( op ) return err } ) } 
func ( c apiclient ) extracturl ( url string ) error { extractclient , err : = c . adminapiclient . extract ( c . ctx ( ) , & admin . extractrequest { url : url } ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } resp , err : = extractclient . recv ( ) if err == nil { return fmt . errorf ( " " , resp ) } if err ! = io . eof { return err } return nil } 
func ( c apiclient ) extractpipeline ( pipelinename string ) ( * pps . createpipelinerequest , error ) { op , err : = c . adminapiclient . extractpipeline ( c . ctx ( ) , & admin . extractpipelinerequest { pipeline : newpipeline ( pipelinename ) } ) if err ! = nil { return nil , grpcutil . scrubgrpc ( err ) } if op . op1 9 == nil | | op . op1 9 . pipeline == nil { return nil , fmt . errorf ( " " ) } return op . op1 9 . pipeline , nil } 
func ( c apiclient ) restore ( ops [ ] * admin . op ) ( reterr error ) { restoreclient , err : = c . adminapiclient . restore ( c . ctx ( ) ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } defer func ( ) { if , err : = restoreclient . closeandrecv ( ) ; err ! = nil && reterr == nil { reterr = grpcutil . scrubgrpc ( err ) } } ( ) for , op : = range ops { if err : = restoreclient . send ( & admin . restorerequest { op : op } ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } } return nil } 
func ( c apiclient ) restorereader ( r io . reader ) ( reterr error ) { restoreclient , err : = c . adminapiclient . restore ( c . ctx ( ) ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } defer func ( ) { if , err : = restoreclient . closeandrecv ( ) ; err ! = nil && reterr == nil { reterr = grpcutil . scrubgrpc ( err ) } } ( ) reader : = pbutil . newreader ( r ) op : = & admin . op { } for { if err : = reader . read ( op ) ; err ! = nil { if err == io . eof { break } return err } if err : = restoreclient . send ( & admin . restorerequest { op : op } ) ; err ! = nil { return grpcutil . scrubgrpc ( err ) } } return nil } 
func ( c apiclient ) restorefrom ( objects bool , otherc * apiclient ) ( reterr error ) { restoreclient , err : = c . adminapiclient . restore ( c . ctx ( ) ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } defer func ( ) { if , err : = restoreclient . closeandrecv ( ) ; err ! = nil && reterr == nil { reterr = grpcutil . scrubgrpc ( err ) } } ( ) return otherc . extract ( objects , func ( op * admin . op ) error { return restoreclient . send ( & admin . restorerequest { op : op } ) } ) } 
func ( c apiclient ) restoreurl ( url string ) ( reterr error ) { restoreclient , err : = c . adminapiclient . restore ( c . ctx ( ) ) if err ! = nil { return grpcutil . scrubgrpc ( err ) } defer func ( ) { if , err : = restoreclient . closeandrecv ( ) ; err ! = nil && reterr == nil { reterr = grpcutil . scrubgrpc ( err ) } } ( ) return grpcutil . scrubgrpc ( restoreclient . send ( & admin . restorerequest { url : url } ) ) } 
func newevaluableexpression ( expression string ) ( * evaluableexpression , error ) { functions : = make ( map [ string ] expressionfunction ) return newevaluableexpressionwithfunctions ( expression , functions ) } 
func newevaluableexpressionfromtokens ( tokens [ ] expressiontoken ) ( * evaluableexpression , error ) { var ret * evaluableexpression var err error ret = new ( evaluableexpression ) ret . querydateformat = isodateformat err = checkbalance ( tokens ) if err ! = nil { return nil , err } err = checkexpressionsyntax ( tokens ) if err ! = nil { return nil , err } ret . tokens , err = optimizetokens ( tokens ) if err ! = nil { return nil , err } ret . evaluationstages , err = planstages ( ret . tokens ) if err ! = nil { return nil , err } ret . checkstypes = true return ret , nil } 
func newevaluableexpressionwithfunctions ( expression string , functions map [ string ] expressionfunction ) ( * evaluableexpression , error ) { var ret * evaluableexpression var err error ret = new ( evaluableexpression ) ret . querydateformat = isodateformat ret . inputexpression = expression ret . tokens , err = parsetokens ( expression , functions ) if err ! = nil { return nil , err } err = checkbalance ( ret . tokens ) if err ! = nil { return nil , err } err = checkexpressionsyntax ( ret . tokens ) if err ! = nil { return nil , err } ret . tokens , err = optimizetokens ( ret . tokens ) if err ! = nil { return nil , err } ret . evaluationstages , err = planstages ( ret . tokens ) if err ! = nil { return nil , err } ret . checkstypes = true return ret , nil } 
func ( this evaluableexpression ) evaluate ( parameters map [ string ] interface { } ) ( interface { } , error ) { if parameters == nil { return this . eval ( nil ) } return this . eval ( mapparameters ( parameters ) ) } 
func ( this evaluableexpression ) eval ( parameters parameters ) ( interface { } , error ) { if this . evaluationstages == nil { return nil , nil } if parameters ! = nil { parameters = & sanitizedparameters { parameters } } else { parameters = dummy parameters } return this . evaluatestage ( this . evaluationstages , parameters ) } 
func ( this evaluableexpression ) vars ( ) [ ] string { var varlist [ ] string for , val : = range this . tokens ( ) { if val . kind == variable { varlist = append ( varlist , val . value . ( string ) ) } } return varlist } 
func ( this operatorsymbol ) ismodifiertype ( candidate [ ] operatorsymbol ) bool { for , symboltype : = range candidate { if this == symboltype { return true } } return false } 
func ( this operatorsymbol ) string ( ) string { switch this { case noop : return " " case value : return " " case eq : return " " case neq : return " " case gt : return " " case lt : return " " case gte : return " " case lte : return " " case req : return " " case nreq : return " " case and : return " " case or : return " " case in : return " " case bitwise and : return " " case bitwise or : return " " case bitwise xor : return " " case bitwise lshift : return " " case bitwise rshift : return " " case plus : return " " case minus : return " " case multiply : return " " case divide : return " " case modulus : return " " case exponent : return " " case negate : return " " case invert : return " " case bitwise not : return " " case ternary true : return " " case ternary false : return " " case coalesce : return " " } return " " } 
func ( this evaluableexpression ) tosqlquery ( ) ( string , error ) { var stream * tokenstream var transactions * expressionoutputstream var transaction string var err error stream = newtokenstream ( this . tokens ) transactions = new ( expressionoutputstream ) for stream . hasnext ( ) { transaction , err = this . findnextsqlstring ( stream , transactions ) if err ! = nil { return " " , err } transactions . add ( transaction ) } return transactions . createstring ( " " ) , nil } 
func ( kind tokenkind ) string ( ) string { switch kind { case prefix : return " " case numeric : return " " case boolean : return " " case string : return " " case pattern : return " " case time : return " " case variable : return " " case function : return " " case separator : return " " case comparator : return " " case logicalop : return " " case modifier : return " " case clause : return " " case clause close : return " " case ternary : return " " case accessor : return " " } return " " } 
func readuntilfalse ( stream * lexerstream , includewhitespace bool , breakwhitespace bool , allowescaping bool , condition func ( rune ) bool ) ( string , bool ) { var tokenbuffer bytes . buffer var character rune var conditioned bool conditioned = false for stream . canread ( ) { character = stream . readcharacter ( ) if allowescaping && character == ' \ \ ' { character = stream . readcharacter ( ) tokenbuffer . writestring ( string ( character ) ) continue } if unicode . isspace ( character ) { if breakwhitespace && tokenbuffer . len ( ) > 0 { conditioned = true break } if ! includewhitespace { continue } } if condition ( character ) { tokenbuffer . writestring ( string ( character ) ) } else { conditioned = true stream . rewind ( 1 ) break } } return tokenbuffer . string ( ) , conditioned } 
func optimizetokens ( tokens [ ] expressiontoken ) ( [ ] expressiontoken , error ) { var token expressiontoken var symbol operatorsymbol var err error var index int for index , token = range tokens { if token . kind ! = comparator { continue } symbol = comparatorsymbols [ token . value . ( string ) ] if symbol ! = req && symbol ! = nreq { continue } index ++ token = tokens [ index ] if token . kind == string { token . kind = pattern token . value , err = regexp . compile ( token . value . ( string ) ) if err ! = nil { return tokens , err } tokens [ index ] = token } } return tokens , nil } 
func checkbalance ( tokens [ ] expressiontoken ) error { var stream * tokenstream var token expressiontoken var parens int stream = newtokenstream ( tokens ) for stream . hasnext ( ) { token = stream . next ( ) if token . kind == clause { parens ++ continue } if token . kind == clause close { parens -- continue } } if parens ! = 0 { return errors . new ( " " ) } return nil } 
func tryparsetime ( candidate string ) ( time . time , bool ) { var ret time . time var found bool timeformats : = [ ... ] string { time . ansic , time . unixdate , time . rubydate , time . kitchen , time . rfc3339 , time . rfc3339nano , " " , " " , " " , " " , " " , " " , " " , " " , } for , format : = range timeformats { ret , found = tryparseexacttime ( candidate , format ) if found { return ret , true } } return time . now ( ) , false } 
func makeprecedentfromplanner ( planner * precedenceplanner ) precedent { var generated precedent var nextright precedent generated = func ( stream * tokenstream ) ( * evaluationstage , error ) { return planprecedencelevel ( stream , planner . typeerrorformat , planner . validsymbols , planner . validkinds , nextright , planner . next , ) } if planner . nextright ! = nil { nextright = planner . nextright } else { nextright = generated } return generated } 
func planstages ( tokens [ ] expressiontoken ) ( * evaluationstage , error ) { stream : = newtokenstream ( tokens ) stage , err : = plantokens ( stream ) if err ! = nil { return nil , err } reorderstages ( stage ) stage = elideliterals ( stage ) return stage , nil } 
func planprecedencelevel ( stream * tokenstream , typeerrorformat string , validsymbols map [ string ] operatorsymbol , validkinds [ ] tokenkind , rightprecedent precedent , leftprecedent precedent ) ( * evaluationstage , error ) { var token expressiontoken var symbol operatorsymbol var leftstage , rightstage * evaluationstage var checks typechecks var err error var keyfound bool if leftprecedent ! = nil { leftstage , err = leftprecedent ( stream ) if err ! = nil { return nil , err } } for stream . hasnext ( ) { token = stream . next ( ) if len ( validkinds ) > 0 { keyfound = false for , kind : = range validkinds { if kind == token . kind { keyfound = true break } } if ! keyfound { break } } if validsymbols ! = nil { if ! isstring ( token . value ) { break } symbol , keyfound = validsymbols [ token . value . ( string ) ] if ! keyfound { break } } if rightprecedent ! = nil { rightstage , err = rightprecedent ( stream ) if err ! = nil { return nil , err } } checks = findtypechecks ( symbol ) return & evaluationstage { symbol : symbol , leftstage : leftstage , rightstage : rightstage , operator : stagesymbolmap [ symbol ] , lefttypecheck : checks . left , righttypecheck : checks . right , typecheck : checks . combined , typeerrorformat : typeerrorformat , } , nil } stream . rewind ( ) return leftstage , nil } 
func planfunction ( stream * tokenstream ) ( * evaluationstage , error ) { var token expressiontoken var rightstage * evaluationstage var err error token = stream . next ( ) if token . kind ! = function { stream . rewind ( ) return planaccessor ( stream ) } rightstage , err = planaccessor ( stream ) if err ! = nil { return nil , err } return & evaluationstage { symbol : functional , rightstage : rightstage , operator : makefunctionstage ( token . value . ( expressionfunction ) ) , typeerrorformat : " " , } , nil } 
func planvalue ( stream * tokenstream ) ( * evaluationstage , error ) { var token expressiontoken var symbol operatorsymbol var ret * evaluationstage var operator evaluationoperator var err error if ! stream . hasnext ( ) { return nil , nil } token = stream . next ( ) switch token . kind { case clause : ret , err = plantokens ( stream ) if err ! = nil { return nil , err } stream . next ( ) ret = & evaluationstage { rightstage : ret , operator : noopstageright , symbol : noop , } return ret , nil case clause close : stream . rewind ( ) return nil , nil case variable : operator = makeparameterstage ( token . value . ( string ) ) case numeric : fallthrough case string : fallthrough case pattern : fallthrough case boolean : symbol = literal operator = makeliteralstage ( token . value ) case time : symbol = literal operator = makeliteralstage ( float64 ( token . value . ( time . time ) . unix ( ) ) ) case prefix : stream . rewind ( ) return planprefix ( stream ) } if operator == nil { errormsg : = fmt . sprintf ( " " , token . kind . string ( ) , token . value ) return nil , errors . new ( errormsg ) } return & evaluationstage { symbol : symbol , operator : operator , } , nil } 
func findtypechecks ( symbol operatorsymbol ) typechecks { switch symbol { case gt : fallthrough case lt : fallthrough case gte : fallthrough case lte : return typechecks { combined : comparatortypecheck , } case req : fallthrough case nreq : return typechecks { left : isstring , right : isregexorstring , } case and : fallthrough case or : return typechecks { left : isbool , right : isbool , } case in : return typechecks { right : isarray , } case bitwise lshift : fallthrough case bitwise rshift : fallthrough case bitwise or : fallthrough case bitwise and : fallthrough case bitwise xor : return typechecks { left : isfloat64 , right : isfloat64 , } case plus : return typechecks { combined : additiontypecheck , } case minus : fallthrough case multiply : fallthrough case divide : fallthrough case modulus : fallthrough case exponent : return typechecks { left : isfloat64 , right : isfloat64 , } case negate : return typechecks { right : isfloat64 , } case invert : return typechecks { right : isbool , } case bitwise not : return typechecks { right : isfloat64 , } case ternary true : return typechecks { left : isbool , } case eq : fallthrough case neq : return typechecks { } case ternary false : fallthrough case coalesce : fallthrough default : return typechecks { } } } 
func reorderstages ( rootstage * evaluationstage ) { var identicalprecedences [ ] * evaluationstage var currentstage , nextstage * evaluationstage var precedence , currentprecedence operatorprecedence nextstage = rootstage precedence = findoperatorprecedenceforsymbol ( rootstage . symbol ) for nextstage ! = nil { currentstage = nextstage nextstage = currentstage . rightstage if currentstage . leftstage ! = nil { reorderstages ( currentstage . leftstage ) } currentprecedence = findoperatorprecedenceforsymbol ( currentstage . symbol ) if currentprecedence == precedence { identicalprecedences = append ( identicalprecedences , currentstage ) continue } if len ( identicalprecedences ) > 1 { mirrorstagesubtree ( identicalprecedences ) } identicalprecedences = [ ] * evaluationstage { currentstage } precedence = currentprecedence } if len ( identicalprecedences ) > 1 { mirrorstagesubtree ( identicalprecedences ) } } 
func mirrorstagesubtree ( stages [ ] * evaluationstage ) { var rootstage , inversestage , carrystage , frontstage * evaluationstage stageslength : = len ( stages ) for , frontstage = range stages { carrystage = frontstage . rightstage frontstage . rightstage = frontstage . leftstage frontstage . leftstage = carrystage } rootstage = stages [ 0 ] frontstage = stages [ stageslength - 1 ] carrystage = frontstage . leftstage frontstage . leftstage = rootstage . rightstage rootstage . rightstage = carrystage for i : = 0 ; i < ( stageslength - 2 ) / 2 + 1 ; i ++ { frontstage = stages [ i + 1 ] inversestage = stages [ stageslength - i - 1 ] carrystage = frontstage . rightstage frontstage . rightstage = inversestage . rightstage inversestage . rightstage = carrystage } for i : = 0 ; i < stageslength / 2 ; i ++ { frontstage = stages [ i ] inversestage = stages [ stageslength - i - 1 ] frontstage . swapwith ( inversestage ) } } 
func elideliterals ( root * evaluationstage ) * evaluationstage { if root . leftstage ! = nil { root . leftstage = elideliterals ( root . leftstage ) } if root . rightstage ! = nil { root . rightstage = elideliterals ( root . rightstage ) } return elidestage ( root ) } 
func elidestage ( root * evaluationstage ) * evaluationstage { var leftvalue , rightvalue , result interface { } var err error if root . rightstage == nil | | root . rightstage . symbol ! = literal | | root . leftstage == nil | | root . leftstage . symbol ! = literal { return root } switch root . symbol { case separate : fallthrough case in : return root } leftvalue , err = root . leftstage . operator ( nil , nil , nil ) if err ! = nil { return root } rightvalue , err = root . rightstage . operator ( nil , nil , nil ) if err ! = nil { return root } err = typecheck ( root . lefttypecheck , leftvalue , root . symbol , root . typeerrorformat ) if err ! = nil { return root } err = typecheck ( root . righttypecheck , rightvalue , root . symbol , root . typeerrorformat ) if err ! = nil { return root } if root . typecheck ! = nil && ! root . typecheck ( leftvalue , rightvalue ) { return root } result , err = root . operator ( leftvalue , rightvalue , nil ) if err ! = nil { return root } return & evaluationstage { symbol : literal , operator : makeliteralstage ( result ) , } } 
func additiontypecheck ( left interface { } , right interface { } ) bool { if isfloat64 ( left ) && isfloat64 ( right ) { return true } if ! isstring ( left ) && ! isstring ( right ) { return false } return true } 
func comparatortypecheck ( left interface { } , right interface { } ) bool { if isfloat64 ( left ) && isfloat64 ( right ) { return true } if isstring ( left ) && isstring ( right ) { return true } return false } 
func ignorefields ( typ interface { } , names ... string ) cmp . option { sf : = newstructfilter ( typ , names ... ) return cmp . filterpath ( sf . filter , cmp . ignore ( ) ) } 
func ignoretypes ( typs ... interface { } ) cmp . option { tf : = newtypefilter ( typs ... ) return cmp . filterpath ( tf . filter , cmp . ignore ( ) ) } 
func ignoreinterfaces ( ifaces interface { } ) cmp . option { tf : = newifacefilter ( ifaces ) return cmp . filterpath ( tf . filter , cmp . ignore ( ) ) } 
func ignoreunexported ( typs ... interface { } ) cmp . option { ux : = newunexportedfilter ( typs ... ) return cmp . filterpath ( ux . filter , cmp . ignore ( ) ) } 
func ignoresliceelements ( discardfunc interface { } ) cmp . option { vf : = reflect . valueof ( discardfunc ) if ! function . istype ( vf . type ( ) , function . valuepredicate ) | | vf . isnil ( ) { panic ( fmt . sprintf ( " " , discardfunc ) ) } return cmp . filterpath ( func ( p cmp . path ) bool { si , ok : = p . index ( - 1 ) . ( cmp . sliceindex ) if ! ok { return false } if ! si . type ( ) . assignableto ( vf . type ( ) . in ( 0 ) ) { return false } vx , vy : = si . values ( ) if vx . isvalid ( ) && vf . call ( [ ] reflect . value { vx } ) [ 0 ] . bool ( ) { return true } if vy . isvalid ( ) && vf . call ( [ ] reflect . value { vy } ) [ 0 ] . bool ( ) { return true } return false } , cmp . ignore ( ) ) } 
func ignoremapentries ( discardfunc interface { } ) cmp . option { vf : = reflect . valueof ( discardfunc ) if ! function . istype ( vf . type ( ) , function . keyvaluepredicate ) | | vf . isnil ( ) { panic ( fmt . sprintf ( " " , discardfunc ) ) } return cmp . filterpath ( func ( p cmp . path ) bool { mi , ok : = p . index ( - 1 ) . ( cmp . mapindex ) if ! ok { return false } if ! mi . key ( ) . type ( ) . assignableto ( vf . type ( ) . in ( 0 ) ) | | ! mi . type ( ) . assignableto ( vf . type ( ) . in ( 1 ) ) { return false } k : = mi . key ( ) vx , vy : = mi . values ( ) if vx . isvalid ( ) && vf . call ( [ ] reflect . value { k , vx } ) [ 0 ] . bool ( ) { return true } if vy . isvalid ( ) && vf . call ( [ ] reflect . value { k , vy } ) [ 0 ] . bool ( ) { return true } return false } , cmp . ignore ( ) ) } 
func ( s * textlist ) appendellipsis ( ds diffstats ) { hasstats : = ds ! = diffstats { } if len ( * s ) == 0 | | ! ( * s ) [ len ( * s ) - 1 ] . value . equal ( textellipsis ) { if hasstats { * s = append ( * s , textrecord { value : textellipsis , comment : ds } ) } else { * s = append ( * s , textrecord { value : textellipsis } ) } return } if hasstats { ( * s ) [ len ( * s ) - 1 ] . comment = ( * s ) [ len ( * s ) - 1 ] . comment . ( diffstats ) . append ( ds ) } } 
func ( s diffstats ) string ( ) string { var ss [ ] string var sum int labels : = [ ... ] string { " " , " " , " " , " " , " " } counts : = [ ... ] int { s . numignored , s . numidentical , s . numremoved , s . numinserted , s . nummodified } for i , n : = range counts { if n > 0 { ss = append ( ss , fmt . sprintf ( " " , n , labels [ i ] ) ) } sum += n } name : = s . name if sum > 1 { name = name + " " if strings . hassuffix ( name , " " ) { name = name [ : len ( name ) - 2 ] + " " } } switch n : = len ( ss ) ; n { case 0 : return " " case 1 , 2 : return strings . join ( ss , " " ) + " " + name default : return strings . join ( ss [ : n - 1 ] , " " ) + " " + ss [ n - 1 ] + " " + name } } 
func istype ( t reflect . type , ft functype ) bool { if t == nil | | t . kind ( ) ! = reflect . func | | t . isvariadic ( ) { return false } ni , no : = t . numin ( ) , t . numout ( ) switch ft { case tbfunc : if ni == 1 && no == 1 && t . out ( 0 ) == booltype { return true } case ttbfunc : if ni == 2 && no == 1 && t . in ( 0 ) == t . in ( 1 ) && t . out ( 0 ) == booltype { return true } case trbfunc : if ni == 2 && no == 1 && t . out ( 0 ) == booltype { return true } case tibfunc : if ni == 2 && no == 1 && t . in ( 0 ) . assignableto ( t . in ( 1 ) ) && t . out ( 0 ) == booltype { return true } case trfunc : if ni == 1 && no == 1 { return true } } return false } 
func nameof ( v reflect . value ) string { fnc : = runtime . funcforpc ( v . pointer ( ) ) if fnc == nil { return " " } fullname : = fnc . name ( ) fullname = strings . trimsuffix ( fullname , " " ) var name string for len ( fullname ) > 0 { inparen : = strings . hassuffix ( fullname , " " ) fullname = strings . trimsuffix ( fullname , " " ) s : = lastidentrx . findstring ( fullname ) if s == " " { break } name = s + " " + name fullname = strings . trimsuffix ( fullname , s ) if i : = strings . lastindexbyte ( fullname , ' ( ' ) ; inparen && i >= 0 { fullname = fullname [ : i ] } fullname = strings . trimsuffix ( fullname , " " ) } return strings . trimsuffix ( name , " " ) } 
func pointerof ( v reflect . value ) pointer { return pointer { unsafe . pointer ( v . pointer ( ) ) , v . type ( ) } } 
func sortslices ( lessfunc interface { } ) cmp . option { vf : = reflect . valueof ( lessfunc ) if ! function . istype ( vf . type ( ) , function . less ) | | vf . isnil ( ) { panic ( fmt . sprintf ( " " , lessfunc ) ) } ss : = slicesorter { vf . type ( ) . in ( 0 ) , vf } return cmp . filtervalues ( ss . filter , cmp . transformer ( " " , ss . sort ) ) } 
func sortmaps ( lessfunc interface { } ) cmp . option { vf : = reflect . valueof ( lessfunc ) if ! function . istype ( vf . type ( ) , function . less ) | | vf . isnil ( ) { panic ( fmt . sprintf ( " " , lessfunc ) ) } ms : = mapsorter { vf . type ( ) . in ( 0 ) , vf } return cmp . filtervalues ( ms . filter , cmp . transformer ( " " , ms . sort ) ) } 
func ( es editscript ) string ( ) string { b : = make ( [ ] byte , len ( es ) ) for i , e : = range es { switch e { case identity : b [ i ] = ' . ' case uniquex : b [ i ] = ' x ' case uniquey : b [ i ] = ' y ' case modified : b [ i ] = ' m ' default : panic ( " " ) } } return string ( b ) } 
func ( es editscript ) stats ( ) ( s struct { ni , nx , ny , nm int } ) { for , e : = range es { switch e { case identity : s . ni ++ case uniquex : s . nx ++ case uniquey : s . ny ++ case modified : s . nm ++ default : panic ( " " ) } } return } 
func ( p * path ) connect ( dst point , f equalfunc ) { if p . dir > 0 { for dst . x > p . x && dst . y > p . y { switch r : = f ( p . x , p . y ) ; { case r . equal ( ) : p . append ( identity ) case r . similar ( ) : p . append ( modified ) case dst . x - p . x >= dst . y - p . y : p . append ( uniquex ) default : p . append ( uniquey ) } } for dst . x > p . x { p . append ( uniquex ) } for dst . y > p . y { p . append ( uniquey ) } } else { for p . x > dst . x && p . y > dst . y { switch r : = f ( p . x - 1 , p . y - 1 ) ; { case r . equal ( ) : p . append ( identity ) case r . similar ( ) : p . append ( modified ) case p . y - dst . y >= p . x - dst . x : p . append ( uniquey ) default : p . append ( uniquex ) } } for p . x > dst . x { p . append ( uniquex ) } for p . y > dst . y { p . append ( uniquey ) } } } 
func equateapprox ( fraction , margin float64 ) cmp . option { if margin < 0 | | fraction < 0 | | math . isnan ( margin ) | | math . isnan ( fraction ) { panic ( " " ) } a : = approximator { fraction , margin } return cmp . options { cmp . filtervalues ( arerealf64s , cmp . comparer ( a . comparef64 ) ) , cmp . filtervalues ( arerealf32s , cmp . comparer ( a . comparef32 ) ) , } } 
func equatenans ( ) cmp . option { return cmp . options { cmp . filtervalues ( arenansf64s , cmp . comparer ( equatealways ) ) , cmp . filtervalues ( arenansf32s , cmp . comparer ( equatealways ) ) , } } 
func ( pa path ) index ( i int ) pathstep { if i < 0 { i = len ( pa ) + i } if i < 0 | | i >= len ( pa ) { return pathstep { } } return pa [ i ] } 
func ( pa path ) string ( ) string { var ss [ ] string for , s : = range pa { if , ok : = s . ( structfield ) ; ok { ss = append ( ss , s . string ( ) ) } } return strings . trimprefix ( strings . join ( ss , " " ) , " " ) } 
func ( pa path ) gostring ( ) string { var sspre , sspost [ ] string var numindirect int for i , s : = range pa { var nextstep pathstep if i + 1 < len ( pa ) { nextstep = pa [ i + 1 ] } switch s : = s . ( type ) { case indirect : numindirect ++ ppre , ppost : = " " , " " switch nextstep . ( type ) { case indirect : continue case structfield : numindirect -- case nil : ppre , ppost = " " , " " } if numindirect > 0 { sspre = append ( sspre , ppre + strings . repeat ( " " , numindirect ) ) sspost = append ( sspost , ppost ) } numindirect = 0 continue case transform : sspre = append ( sspre , s . trans . name + " " ) sspost = append ( sspost , " " ) continue } sspost = append ( sspost , s . string ( ) ) } for i , j : = 0 , len ( sspre ) - 1 ; i < j ; i , j = i + 1 , j - 1 { sspre [ i ] , sspre [ j ] = sspre [ j ] , sspre [ i ] } return strings . join ( sspre , " " ) + strings . join ( sspost , " " ) } 
func ( si sliceindex ) key ( ) int { if si . xkey ! = si . ykey { return - 1 } return si . xkey } 
func ( r * defaultreporter ) string ( ) string { assert ( r . root ! = nil && r . curr == nil ) if r . root . numdiff == 0 { return " " } return formatoptions { } . formatdiff ( r . root ) . string ( ) } 
func ( opts formatoptions ) formattype ( t reflect . type , s textnode ) textnode { switch opts . typemode { case autotype : switch t . kind ( ) { case reflect . struct , reflect . slice , reflect . array , reflect . map : if s . equal ( textnil ) { return s } default : return s } case elidetype : return s } typename : = t . string ( ) if t . name ( ) == " " { switch t . kind ( ) { case reflect . chan , reflect . func , reflect . ptr : typename = " " + typename + " " } typename = strings . replace ( typename , " " , " " , - 1 ) typename = strings . replace ( typename , " " , " " , - 1 ) } if s , ok : = s . ( textwrap ) ; ok { hasparens : = strings . hasprefix ( s . prefix , " " ) && strings . hassuffix ( s . suffix , " " ) hasbraces : = strings . hasprefix ( s . prefix , " " ) && strings . hassuffix ( s . suffix , " " ) if hasparens | | hasbraces { return textwrap { typename , s , " " } } } return textwrap { typename + " " , s , " " } } 
func formatmapkey ( v reflect . value ) string { var opts formatoptions opts . typemode = elidetype opts . avoidstringer = true opts . shallowpointers = true s : = opts . formatvalue ( v , visitedpointers { } ) . string ( ) return strings . trimspace ( s ) } 
func formatstring ( s string ) string { qs : = strconv . quote ( s ) if len ( qs ) == 1 + len ( s ) + 1 { return qs } rawinvalid : = func ( r rune ) bool { return r == ' ' ' | | r == ' \n ' | | ! ( unicode . isprint ( r ) | | r == ' \ t ' ) } if strings . indexfunc ( s , rawinvalid ) < 0 { return " " + s + " " } return qs } 
func formathex ( u uint64 ) string { var f string switch { case u <= 0xff : f = " " case u <= 0xffff : f = " " case u <= 0xffffff : f = " " case u <= 0xffffffff : f = " " case u <= 0xffffffffff : f = " " case u <= 0xffffffffffff : f = " " case u <= 0xffffffffffffff : f = " " case u <= 0xffffffffffffffff : f = " " } return fmt . sprintf ( f , u ) } 
func formatpointer ( v reflect . value ) string { p : = v . pointer ( ) if flags . deterministic { p = 0xdeadf00f } return fmt . sprintf ( " ) } 
func ( m visitedpointers ) visit ( v reflect . value ) bool { p : = value . pointerof ( v ) , visited : = m [ p ] m [ p ] = struct { } { } return visited } 
func acyclictransformer ( name string , xformfunc interface { } ) cmp . option { xf : = xformfilter { cmp . transformer ( name , xformfunc ) } return cmp . filterpath ( xf . filter , xf . xform ) } 
func retrieveunexportedfield ( v reflect . value , f reflect . structfield ) reflect . value { return reflect . newat ( f . type , unsafe . pointer ( v . unsafeaddr ( ) + f . offset ) ) . elem ( ) } 
func filterfield ( typ interface { } , name string , opt cmp . option ) cmp . option { sf : = newstructfilter ( typ , name ) return cmp . filterpath ( sf . filter , opt ) } 
func ( ft * fieldtree ) insert ( cname [ ] string ) { if ft . sub == nil { ft . sub = make ( map [ string ] fieldtree ) } if len ( cname ) == 0 { ft . ok = true return } sub : = ft . sub [ cname [ 0 ] ] sub . insert ( cname [ 1 : ] ) ft . sub [ cname [ 0 ] ] = sub } 
func ( ft fieldtree ) matchprefix ( p cmp . path ) bool { for , ps : = range p { switch ps : = ps . ( type ) { case cmp . structfield : ft = ft . sub [ ps . name ( ) ] if ft . ok { return true } if len ( ft . sub ) == 0 { return false } case cmp . indirect : default : return false } } return false } 
func canonicalname ( t reflect . type , sel string ) ( [ ] string , error ) { var name string sel = strings . trimprefix ( sel , " " ) if sel == " " { return nil , fmt . errorf ( " " ) } if i : = strings . indexbyte ( sel , ' . ' ) ; i < 0 { name , sel = sel , " " } else { name , sel = sel [ : i ] , sel [ i : ] } if t . kind ( ) == reflect . ptr { t = t . elem ( ) } if t . kind ( ) ! = reflect . struct { return nil , fmt . errorf ( " " , t ) } if ! isexported ( name ) { return [ ] string { name } , fmt . errorf ( " " ) } sf , ok : = t . fieldbyname ( name ) if ! ok { return [ ] string { name } , fmt . errorf ( " " ) } var ss [ ] string for i : = range sf . index { ss = append ( ss , t . fieldbyindex ( sf . index [ : i + 1 ] ) . name ) } if sel == " " { return ss , nil } sspost , err : = canonicalname ( sf . type , sel ) return append ( ss , sspost ... ) , err } 
func filterpath ( f func ( path ) bool , opt option ) option { if f == nil { panic ( " " ) } if opt : = normalizeoption ( opt ) ; opt ! = nil { return & pathfilter { fnc : f , opt : opt } } return nil } 
func filtervalues ( f interface { } , opt option ) option { v : = reflect . valueof ( f ) if ! function . istype ( v . type ( ) , function . valuefilter ) | | v . isnil ( ) { panic ( fmt . sprintf ( " " , f ) ) } if opt : = normalizeoption ( opt ) ; opt ! = nil { vf : = & valuesfilter { fnc : v , opt : opt } if ti : = v . type ( ) . in ( 0 ) ; ti . kind ( ) ! = reflect . interface | | ti . nummethod ( ) > 0 { vf . typ = ti } return vf } return nil } 
func transformer ( name string , f interface { } ) option { v : = reflect . valueof ( f ) if ! function . istype ( v . type ( ) , function . transformer ) | | v . isnil ( ) { panic ( fmt . sprintf ( " " , f ) ) } if name == " " { name = function . nameof ( v ) if ! identsrx . matchstring ( name ) { name = " / lambda - symbol as placeholder name } } else if ! identsrx . matchstring ( name ) { panic ( fmt . sprintf ( " " , name ) ) } tr : = & transformer { name : name , fnc : reflect . valueof ( f ) } if ti : = v . type ( ) . in ( 0 ) ; ti . kind ( ) ! = reflect . interface | | ti . nummethod ( ) > 0 { tr . typ = ti } return tr } 
func comparer ( f interface { } ) option { v : = reflect . valueof ( f ) if ! function . istype ( v . type ( ) , function . equal ) | | v . isnil ( ) { panic ( fmt . sprintf ( " " , f ) ) } cm : = & comparer { fnc : v } if ti : = v . type ( ) . in ( 0 ) ; ti . kind ( ) ! = reflect . interface | | ti . nummethod ( ) > 0 { cm . typ = ti } return cm } 
func allowunexported ( types ... interface { } ) option { if ! supportallowunexported { panic ( " " ) } m : = make ( map [ reflect . type ] bool ) for , typ : = range types { t : = reflect . typeof ( typ ) if t . kind ( ) ! = reflect . struct { panic ( fmt . sprintf ( " " , typ ) ) } m [ t ] = true } return visiblestructs ( m ) } 
func reporter ( r interface { pushstep ( pathstep ) report ( result ) popstep ( ) } ) option { return reporter { r } } 
func normalizeoption ( src option ) option { switch opts : = flattenoptions ( nil , options { src } ) ; len ( opts ) { case 0 : return nil case 1 : return opts [ 0 ] default : return opts } } 
func flattenoptions ( dst , src options ) options { for , opt : = range src { switch opt : = opt . ( type ) { case nil : continue case options : dst = flattenoptions ( dst , opt ) case coreoption : dst = append ( dst , opt ) default : panic ( fmt . sprintf ( " " , opt ) ) } } return dst } 
func ( opts formatoptions ) canformatdiffslice ( v * valuenode ) bool { switch { case opts . diffmode ! = diffunknown : return false case v . numdiff == 0 : return false case v . numignored + v . numcompared + v . numtransformed > 0 : return false case ! v . valuex . isvalid ( ) | | ! v . valuey . isvalid ( ) : return false } switch t : = v . type ; t . kind ( ) { case reflect . string : case reflect . array , reflect . slice : switch t . elem ( ) . kind ( ) { case reflect . int , reflect . int8 , reflect . int16 , reflect . int32 , reflect . int64 , reflect . uint , reflect . uint8 , reflect . uint16 , reflect . uint32 , reflect . uint64 , reflect . uintptr , reflect . bool , reflect . float32 , reflect . float64 , reflect . complex64 , reflect . complex128 : default : return false } if v . numdiff > v . numsame { return true } default : return false } const minlength = 64 return v . valuex . len ( ) >= minlength && v . valuey . len ( ) >= minlength } 
func formatascii ( s string ) string { b : = bytes . repeat ( [ ] byte { ' . ' } , len ( s ) ) for i : = 0 ; i < len ( s ) ; i ++ { if ' ' <= s [ i ] && s [ i ] <= ' ~ ' { b [ i ] = s [ i ] } } return string ( b ) } 
func coalesceadjacentedits ( name string , es diff . editscript ) ( groups [ ] diffstats ) { var prevcase int laststats : = func ( i int ) * diffstats { if prevcase ! = i { groups = append ( groups , diffstats { name : name } ) prevcase = i } return & groups [ len ( groups ) - 1 ] } for , e : = range es { switch e { case diff . identity : laststats ( 1 ) . numidentical ++ case diff . uniquex : laststats ( 2 ) . numremoved ++ case diff . uniquey : laststats ( 2 ) . numinserted ++ case diff . modified : laststats ( 2 ) . nummodified ++ } } return groups } 
func coalesceinterveningidentical ( groups [ ] diffstats , windowsize int ) [ ] diffstats { groups , groupsorig : = groups [ : 0 ] , groups for i , ds : = range groupsorig { if len ( groups ) >= 2 && ds . numdiff ( ) > 0 { prev : = & groups [ len ( groups ) - 2 ] curr : = & groups [ len ( groups ) - 1 ] next : = & groupsorig [ i ] hadx , hady : = prev . numremoved > 0 , prev . numinserted > 0 hasx , hasy : = next . numremoved > 0 , next . numinserted > 0 if ( ( hadx | | hasx ) && ( hady | | hasy ) ) && curr . numidentical <= windowsize { * prev = ( * prev ) . append ( * curr ) . append ( * next ) groups = groups [ : len ( groups ) - 1 ] continue } } groups = append ( groups , ds ) } return groups } 
func sortkeys ( vs [ ] reflect . value ) [ ] reflect . value { if len ( vs ) == 0 { return vs } sort . slice ( vs , func ( i , j int ) bool { return isless ( vs [ i ] , vs [ j ] ) } ) vs2 : = vs [ : 1 ] for , v : = range vs [ 1 : ] { if isless ( vs2 [ len ( vs2 ) - 1 ] , v ) { vs2 = append ( vs2 , v ) } } return vs2 } 
func coalesceadjacentrecords ( name string , recs [ ] reportrecord ) ( groups [ ] diffstats ) { var prevcase int laststats : = func ( i int ) * diffstats { if prevcase ! = i { groups = append ( groups , diffstats { name : name } ) prevcase = i } return & groups [ len ( groups ) - 1 ] } for , r : = range recs { switch rv : = r . value ; { case rv . numignored > 0 && rv . numsame + rv . numdiff == 0 : laststats ( 1 ) . numignored ++ case rv . numdiff == 0 : laststats ( 1 ) . numidentical ++ case rv . numdiff > 0 && ! rv . valuey . isvalid ( ) : laststats ( 2 ) . numremoved ++ case rv . numdiff > 0 && ! rv . valuex . isvalid ( ) : laststats ( 2 ) . numinserted ++ default : laststats ( 2 ) . nummodified ++ } } return groups } 
func diff ( x , y interface { } , opts ... option ) string { r : = new ( defaultreporter ) eq : = equal ( x , y , options ( opts ) , reporter ( r ) ) d : = r . string ( ) if ( d == " " ) ! = eq { panic ( " " ) } return d } 
func ( s * state ) statelesscompare ( step pathstep ) diff . result { oldresult , oldreporters : = s . result , s . reporters s . result = diff . result { } s . reporters = nil s . compareany ( step ) res : = s . result s . result , s . reporters = oldresult , oldreporters return res } 
func sanitizevalue ( v reflect . value , t reflect . type ) reflect . value { if ! flags . atleastgo110 { if v . kind ( ) == reflect . interface && v . isnil ( ) && v . type ( ) ! = t { return reflect . new ( t ) . elem ( ) } } return v } 
func ( rc * recchecker ) check ( p path ) { const minlen = 1 < < 16 if rc . next == 0 { rc . next = minlen } if len ( p ) < rc . next { return } rc . next < <= 1 var ss [ ] string m : = map [ option ] int { } for , ps : = range p { if t , ok : = ps . ( transform ) ; ok { t : = t . option ( ) if m [ t ] == 1 { tf : = t . ( * transformer ) . fnc . type ( ) ss = append ( ss , fmt . sprintf ( " " , t , tf . in ( 0 ) , tf . out ( 0 ) ) ) } m [ t ] ++ } } if len ( ss ) > 0 { const warning = " " const help = " " set : = strings . join ( ss , " \n \ t " ) panic ( fmt . sprintf ( " \n \ t \n " , warning , set , help ) ) } } 
func makeaddressable ( v reflect . value ) reflect . value { if v . canaddr ( ) { return v } vc : = reflect . new ( v . type ( ) ) . elem ( ) vc . set ( v ) return vc } 
func string ( key , val string ) field { return field { key : key , fieldtype : stringtype , stringval : val , } } 
func bool ( key string , val bool ) field { var numericval int64 if val { numericval = 1 } return field { key : key , fieldtype : booltype , numericval : numericval , } } 
func int ( key string , val int ) field { return field { key : key , fieldtype : inttype , numericval : int64 ( val ) , } } 
func int32 ( key string , val int32 ) field { return field { key : key , fieldtype : int32type , numericval : int64 ( val ) , } } 
func int64 ( key string , val int64 ) field { return field { key : key , fieldtype : int64type , numericval : val , } } 
func uint32 ( key string , val uint32 ) field { return field { key : key , fieldtype : uint32type , numericval : int64 ( val ) , } } 
func uint64 ( key string , val uint64 ) field { return field { key : key , fieldtype : uint64type , numericval : int64 ( val ) , } } 
func float32 ( key string , val float32 ) field { return field { key : key , fieldtype : float32type , numericval : int64 ( math . float32bits ( val ) ) , } } 
func float64 ( key string , val float64 ) field { return field { key : key , fieldtype : float64type , numericval : int64 ( math . float64bits ( val ) ) , } } 
func error ( err error ) field { return field { key : " " , fieldtype : errortype , interfaceval : err , } } 
func object ( key string , obj interface { } ) field { return field { key : key , fieldtype : objecttype , interfaceval : obj , } } 
func ( lf field ) marshal ( visitor encoder ) { switch lf . fieldtype { case stringtype : visitor . emitstring ( lf . key , lf . stringval ) case booltype : visitor . emitbool ( lf . key , lf . numericval ! = 0 ) case inttype : visitor . emitint ( lf . key , int ( lf . numericval ) ) case int32type : visitor . emitint32 ( lf . key , int32 ( lf . numericval ) ) case int64type : visitor . emitint64 ( lf . key , int64 ( lf . numericval ) ) case uint32type : visitor . emituint32 ( lf . key , uint32 ( lf . numericval ) ) case uint64type : visitor . emituint64 ( lf . key , uint64 ( lf . numericval ) ) case float32type : visitor . emitfloat32 ( lf . key , math . float32frombits ( uint32 ( lf . numericval ) ) ) case float64type : visitor . emitfloat64 ( lf . key , math . float64frombits ( uint64 ( lf . numericval ) ) ) case errortype : if err , ok : = lf . interfaceval . ( error ) ; ok { visitor . emitstring ( lf . key , err . error ( ) ) } else { visitor . emitstring ( lf . key , " " ) } case objecttype : visitor . emitobject ( lf . key , lf . interfaceval ) case lazyloggertype : visitor . emitlazylogger ( lf . interfaceval . ( lazylogger ) ) case nooptype : } } 
func ( lf field ) value ( ) interface { } { switch lf . fieldtype { case stringtype : return lf . stringval case booltype : return lf . numericval ! = 0 case inttype : return int ( lf . numericval ) case int32type : return int32 ( lf . numericval ) case int64type : return int64 ( lf . numericval ) case uint32type : return uint32 ( lf . numericval ) case uint64type : return uint64 ( lf . numericval ) case float32type : return math . float32frombits ( uint32 ( lf . numericval ) ) case float64type : return math . float64frombits ( uint64 ( lf . numericval ) ) case errortype , objecttype , lazyloggertype : return lf . interfaceval case nooptype : return nil default : return nil } } 
func ( lf field ) string ( ) string { return fmt . sprint ( lf . key , " " , lf . value ( ) ) } 
func ( r spanreference ) apply ( o * startspanoptions ) { if r . referencedcontext ! = nil { o . references = append ( o . references , r ) } } 
func ( t starttime ) apply ( o * startspanoptions ) { o . starttime = time . time ( t ) } 
func ( t tags ) apply ( o * startspanoptions ) { if o . tags == nil { o . tags = make ( map [ string ] interface { } ) } for k , v : = range t { o . tags [ k ] = v } } 
func ( t tag ) apply ( o * startspanoptions ) { if o . tags == nil { o . tags = make ( map [ string ] interface { } ) } o . tags [ t . key ] = t . value } 
func ( t tag ) set ( s span ) { s . settag ( t . key , t . value ) } 
func ( t * textmappropagator ) inject ( spancontext mockspancontext , carrier interface { } ) error { writer , ok : = carrier . ( opentracing . textmapwriter ) if ! ok { return opentracing . errinvalidcarrier } writer . set ( mocktextmapidsprefix + " " , strconv . itoa ( spancontext . traceid ) ) writer . set ( mocktextmapidsprefix + " " , strconv . itoa ( spancontext . spanid ) ) writer . set ( mocktextmapidsprefix + " " , fmt . sprint ( spancontext . sampled ) ) for baggagekey , baggageval : = range spancontext . baggage { safeval : = baggageval if t . httpheaders { safeval = url . queryescape ( baggageval ) } writer . set ( mocktextmapbaggageprefix + baggagekey , safeval ) } return nil } 
func ( t * textmappropagator ) extract ( carrier interface { } ) ( mockspancontext , error ) { reader , ok : = carrier . ( opentracing . textmapreader ) if ! ok { return emptycontext , opentracing . errinvalidcarrier } rval : = mockspancontext { 0 , 0 , true , nil } err : = reader . foreachkey ( func ( key , val string ) error { lowerkey : = strings . tolower ( key ) switch { case lowerkey == mocktextmapidsprefix + " " : i , err : = strconv . atoi ( val ) if err ! = nil { return err } rval . traceid = i case lowerkey == mocktextmapidsprefix + " " : i , err : = strconv . atoi ( val ) if err ! = nil { return err } rval . spanid = i case lowerkey == mocktextmapidsprefix + " " : b , err : = strconv . parsebool ( val ) if err ! = nil { return err } rval . sampled = b case strings . hasprefix ( lowerkey , mocktextmapbaggageprefix ) : if rval . baggage == nil { rval . baggage = make ( map [ string ] string ) } safeval : = val if t . httpheaders { if rawval , err : = url . queryunescape ( val ) ; err == nil { safeval = rawval } } rval . baggage [ lowerkey [ len ( mocktextmapbaggageprefix ) : ] ] = safeval } return nil } ) if rval . traceid == 0 | | rval . spanid == 0 { return emptycontext , opentracing . errspancontextnotfound } if err ! = nil { return emptycontext , err } return rval , nil } 
func ( ld * logdata ) tologrecord ( ) logrecord { var literaltimestamp time . time if ld . timestamp . iszero ( ) { literaltimestamp = time . now ( ) } else { literaltimestamp = ld . timestamp } rval : = logrecord { timestamp : literaltimestamp , } if ld . payload == nil { rval . fields = [ ] log . field { log . string ( " " , ld . event ) , } } else { rval . fields = [ ] log . field { log . string ( " " , ld . event ) , log . object ( " " , ld . payload ) , } } return rval } 
func new ( ) * mocktracer { t : = & mocktracer { finishedspans : [ ] * mockspan { } , injectors : make ( map [ interface { } ] injector ) , extractors : make ( map [ interface { } ] extractor ) , } textpropagator : = new ( textmappropagator ) t . registerinjector ( opentracing . textmap , textpropagator ) t . registerextractor ( opentracing . textmap , textpropagator ) httppropagator : = & textmappropagator { httpheaders : true } t . registerinjector ( opentracing . httpheaders , httppropagator ) t . registerextractor ( opentracing . httpheaders , httppropagator ) return t } 
func ( t * mocktracer ) finishedspans ( ) [ ] * mockspan { t . rlock ( ) defer t . runlock ( ) spans : = make ( [ ] * mockspan , len ( t . finishedspans ) ) copy ( spans , t . finishedspans ) return spans } 
func ( t * mocktracer ) reset ( ) { t . lock ( ) defer t . unlock ( ) t . finishedspans = [ ] * mockspan { } } 
func ( t * mocktracer ) startspan ( operationname string , opts ... opentracing . startspanoption ) opentracing . span { sso : = opentracing . startspanoptions { } for , o : = range opts { o . apply ( & sso ) } return newmockspan ( t , operationname , sso ) } 
func ( t * mocktracer ) registerinjector ( format interface { } , injector injector ) { t . injectors [ format ] = injector } 
func ( t * mocktracer ) registerextractor ( format interface { } , extractor extractor ) { t . extractors [ format ] = extractor } 
func ( t * mocktracer ) inject ( sm opentracing . spancontext , format interface { } , carrier interface { } ) error { spancontext , ok : = sm . ( mockspancontext ) if ! ok { return opentracing . errinvalidcarrier } injector , ok : = t . injectors [ format ] if ! ok { return opentracing . errunsupportedformat } return injector . inject ( spancontext , carrier ) } 
func ( t * mocktracer ) extract ( format interface { } , carrier interface { } ) ( opentracing . spancontext , error ) { extractor , ok : = t . extractors [ format ] if ! ok { return nil , opentracing . errunsupportedformat } return extractor . extract ( carrier ) } 
func contextwithspan ( ctx context . context , span span ) context . context { return context . withvalue ( ctx , activespankey , span ) } 
func spanfromcontext ( ctx context . context ) span { val : = ctx . value ( activespankey ) if sp , ok : = val . ( span ) ; ok { return sp } return nil } 
func startspanfromcontext ( ctx context . context , operationname string , opts ... startspanoption ) ( span , context . context ) { return startspanfromcontextwithtracer ( ctx , globaltracer ( ) , operationname , opts ... ) } 
func ( tag spankindtagname ) set ( span opentracing . span , value spankindenum ) { span . settag ( string ( tag ) , value ) } 
func ( tag stringtagname ) set ( span opentracing . span , value string ) { span . settag ( string ( tag ) , value ) } 
func ( tag uint32tagname ) set ( span opentracing . span , value uint32 ) { span . settag ( string ( tag ) , value ) } 
func ( tag uint16tagname ) set ( span opentracing . span , value uint16 ) { span . settag ( string ( tag ) , value ) } 
func ( tag booltagname ) set ( span opentracing . span , value bool ) { span . settag ( string ( tag ) , value ) } 
func ( tag ipv4tag ) setstring ( span opentracing . span , value string ) { span . settag ( string ( tag ) , value ) } 
func startspan ( operationname string , opts ... startspanoption ) span { return globaltracer . tracer . startspan ( operationname , opts ... ) } 
func ( c textmapcarrier ) foreachkey ( handler func ( key , val string ) error ) error { for k , v : = range c { if err : = handler ( k , v ) ; err ! = nil { return err } } return nil } 
func ( m * mockkeyvalue ) emitstring ( key , value string ) { m . key = key m . valuekind = reflect . typeof ( value ) . kind ( ) m . valuestring = fmt . sprint ( value ) } 
func ( m * mockkeyvalue ) emitlazylogger ( value log . lazylogger ) { var meta mockkeyvalue value ( & meta ) m . key = meta . key m . valuekind = meta . valuekind m . valuestring = meta . valuestring } 
func runapichecks ( t * testing . t , newtracer func ( ) ( tracer opentracing . tracer , closer func ( ) ) , opts ... apicheckoption , ) { s : = & apichecksuite { newtracer : newtracer } for , opt : = range opts { opt ( s ) } suite . run ( t , s ) } 
func checkbaggagevalues ( val bool ) apicheckoption { return func ( s * apichecksuite ) { s . opts . checkbaggagevalues = val } } 
func checkextract ( val bool ) apicheckoption { return func ( s * apichecksuite ) { s . opts . checkextract = val } } 
func checkinject ( val bool ) apicheckoption { return func ( s * apichecksuite ) { s . opts . checkinject = val } } 
func checkeverything ( ) apicheckoption { return func ( s * apichecksuite ) { s . opts . checkbaggagevalues = true s . opts . checkextract = true s . opts . checkinject = true } } 
func useprobe ( probe apicheckprobe ) apicheckoption { return func ( s * apichecksuite ) { s . opts . probe = probe } } 
func ( c mockspancontext ) withbaggageitem ( key , value string ) mockspancontext { var newbaggage map [ string ] string if c . baggage == nil { newbaggage = map [ string ] string { key : value } } else { newbaggage = make ( map [ string ] string , len ( c . baggage ) + 1 ) for k , v : = range c . baggage { newbaggage [ k ] = v } newbaggage [ key ] = value } return mockspancontext { c . traceid , c . spanid , c . sampled , newbaggage } } 
func ( s * mockspan ) tags ( ) map [ string ] interface { } { s . rlock ( ) defer s . runlock ( ) tags : = make ( map [ string ] interface { } ) for k , v : = range s . tags { tags [ k ] = v } return tags } 
func ( s * mockspan ) tag ( k string ) interface { } { s . rlock ( ) defer s . runlock ( ) return s . tags [ k ] } 
func ( s * mockspan ) logs ( ) [ ] mocklogrecord { s . rlock ( ) defer s . runlock ( ) logs : = make ( [ ] mocklogrecord , len ( s . logs ) ) copy ( logs , s . logs ) return logs } 
func ( s * mockspan ) context ( ) opentracing . spancontext { s . lock ( ) defer s . unlock ( ) return s . spancontext } 
func ( s * mockspan ) settag ( key string , value interface { } ) opentracing . span { s . lock ( ) defer s . unlock ( ) if key == string ( ext . samplingpriority ) { if v , ok : = value . ( uint16 ) ; ok { s . spancontext . sampled = v > 0 return s } if v , ok : = value . ( int ) ; ok { s . spancontext . sampled = v > 0 return s } } s . tags [ key ] = value return s } 
func ( s * mockspan ) setbaggageitem ( key , val string ) opentracing . span { s . lock ( ) defer s . unlock ( ) s . spancontext = s . spancontext . withbaggageitem ( key , val ) return s } 
func ( s * mockspan ) baggageitem ( key string ) string { s . rlock ( ) defer s . runlock ( ) return s . spancontext . baggage [ key ] } 
func ( s * mockspan ) finish ( ) { s . lock ( ) s . finishtime = time . now ( ) s . unlock ( ) s . tracer . recordspan ( s ) } 
func ( s * mockspan ) finishwithoptions ( opts opentracing . finishoptions ) { s . lock ( ) s . finishtime = opts . finishtime s . unlock ( ) for , lr : = range opts . logrecords { s . logfieldswithtimestamp ( lr . timestamp , lr . fields ... ) } for , ld : = range opts . bulklogdata { if ld . payload ! = nil { s . logfieldswithtimestamp ( ld . timestamp , log . string ( " " , ld . event ) , log . object ( " " , ld . payload ) ) } else { s . logfieldswithtimestamp ( ld . timestamp , log . string ( " " , ld . event ) ) } } s . tracer . recordspan ( s ) } 
func ( s * mockspan ) string ( ) string { return fmt . sprintf ( " " , s . spancontext . traceid , s . spancontext . spanid , s . parentid , s . spancontext . sampled , s . operationname ) } 
func ( s * mockspan ) logfields ( fields ... log . field ) { s . logfieldswithtimestamp ( time . now ( ) , fields ... ) } 
func ( s * mockspan ) logfieldswithtimestamp ( ts time . time , fields ... log . field ) { lr : = mocklogrecord { timestamp : ts , fields : make ( [ ] mockkeyvalue , len ( fields ) ) , } for i , f : = range fields { outfield : = & ( lr . fields [ i ] ) f . marshal ( outfield ) } s . lock ( ) defer s . unlock ( ) s . logs = append ( s . logs , lr ) } 
func ( s * mockspan ) logkv ( keyvalues ... interface { } ) { if len ( keyvalues ) % 2 ! = 0 { s . logfields ( log . error ( fmt . errorf ( " " , len ( keyvalues ) ) ) ) return } fields , err : = log . interleavedkvtofields ( keyvalues ... ) if err ! = nil { s . logfields ( log . error ( err ) , log . string ( " " , " " ) ) return } s . logfields ( fields ... ) } 
func ( s * mockspan ) logevent ( event string ) { s . logfields ( log . string ( " " , event ) ) } 
func ( s * mockspan ) logeventwithpayload ( event string , payload interface { } ) { s . logfields ( log . string ( " " , event ) , log . object ( " " , payload ) ) } 
func ( s * mockspan ) setoperationname ( operationname string ) opentracing . span { s . lock ( ) defer s . unlock ( ) s . operationname = operationname return s } 
func newopenshiftclientconfigloadingrules ( ) * clientconfigloadingrules { chain : = [ ] string { } envvarfile : = os . getenv ( " " ) if len ( envvarfile ) ! = 0 { chain = append ( chain , filepath . splitlist ( envvarfile ) ... ) } else { chain = append ( chain , recommendedhomefile ) } return & clientconfigloadingrules { precedence : chain , } } 
func ( config * deferredloadingclientconfig ) clientconfig ( ) ( * restconfig , error ) { mergedclientconfig , err : = config . createclientconfig ( ) if err ! = nil { return nil , err } mergedconfig , err : = mergedclientconfig . clientconfig ( ) if err ! = nil { return nil , err } return mergedconfig , nil } 
func ( config * directclientconfig ) clientconfig ( ) ( * restconfig , error ) { if err : = config . confirmusable ( ) ; err ! = nil { return nil , err } configauthinfo : = config . getauthinfo ( ) configclusterinfo : = config . getcluster ( ) clientconfig : = & restconfig { } clientconfig . host = configclusterinfo . server if u , err : = url . parserequesturi ( clientconfig . host ) ; err == nil && u . opaque == " " && len ( u . path ) > 1 { u . rawquery = " " u . fragment = " " clientconfig . host = u . string ( ) } if isconfigtransporttls ( * clientconfig ) { var err error userauthpartialconfig , err : = getuseridentificationpartialconfig ( configauthinfo ) if err ! = nil { return nil , err } mergo . merge ( clientconfig , userauthpartialconfig ) serverauthpartialconfig , err : = getserveridentificationpartialconfig ( configauthinfo , configclusterinfo ) if err ! = nil { return nil , err } mergo . merge ( clientconfig , serverauthpartialconfig ) } return clientconfig , nil } 
func getserveridentificationpartialconfig ( configauthinfo clientcmdauthinfo , configclusterinfo clientcmdcluster ) ( * restconfig , error ) { mergedconfig : = & restconfig { } configclientconfig : = & restconfig { } configclientconfig . cafile = configclusterinfo . certificateauthority configclientconfig . cadata = configclusterinfo . certificateauthoritydata configclientconfig . insecure = configclusterinfo . insecureskiptlsverify mergo . merge ( mergedconfig , configclientconfig ) return mergedconfig , nil } 
func getuseridentificationpartialconfig ( configauthinfo clientcmdauthinfo ) ( * restconfig , error ) { mergedconfig : = & restconfig { } if len ( configauthinfo . token ) > 0 { mergedconfig . bearertoken = configauthinfo . token } if len ( configauthinfo . clientcertificate ) > 0 | | len ( configauthinfo . clientcertificatedata ) > 0 { mergedconfig . certfile = configauthinfo . clientcertificate mergedconfig . certdata = configauthinfo . clientcertificatedata mergedconfig . keyfile = configauthinfo . clientkey mergedconfig . keydata = configauthinfo . clientkeydata } if len ( configauthinfo . username ) > 0 | | len ( configauthinfo . password ) > 0 { mergedconfig . username = configauthinfo . username mergedconfig . password = configauthinfo . password } return mergedconfig , nil } 
func canidentifyuser ( config restconfig ) bool { return len ( config . username ) > 0 | | ( len ( config . certfile ) > 0 | | len ( config . certdata ) > 0 ) | | len ( config . bearertoken ) > 0 } 
func ( config * directclientconfig ) confirmusable ( ) error { var validationerrors [ ] error validationerrors = append ( validationerrors , validateauthinfo ( config . getauthinfoname ( ) , config . getauthinfo ( ) ) ... ) validationerrors = append ( validationerrors , validateclusterinfo ( config . getclustername ( ) , config . getcluster ( ) ) ... ) if len ( validationerrors ) == 1 && validationerrors [ 0 ] == erremptycluster { return newerrconfigurationinvalid ( [ ] error { erremptyconfig } ) } return newerrconfigurationinvalid ( validationerrors ) } 
func ( config * directclientconfig ) getcontext ( ) clientcmdcontext { contexts : = config . config . contexts contextname : = config . getcontextname ( ) var mergedcontext clientcmdcontext if configcontext , exists : = contexts [ contextname ] ; exists { mergo . merge ( & mergedcontext , configcontext ) } return mergedcontext } 
func validateclusterinfo ( clustername string , clusterinfo clientcmdcluster ) [ ] error { var validationerrors [ ] error if reflect . deepequal ( clientcmdcluster { } , clusterinfo ) { return [ ] error { erremptycluster } } if len ( clusterinfo . server ) == 0 { if len ( clustername ) == 0 { validationerrors = append ( validationerrors , errors . errorf ( " " ) ) } else { validationerrors = append ( validationerrors , errors . errorf ( " " , clustername ) ) } } if len ( clusterinfo . certificateauthority ) ! = 0 && len ( clusterinfo . certificateauthoritydata ) ! = 0 { validationerrors = append ( validationerrors , errors . errorf ( " " , clustername ) ) } if len ( clusterinfo . certificateauthority ) ! = 0 { clientcertca , err : = os . open ( clusterinfo . certificateauthority ) defer clientcertca . close ( ) if err ! = nil { validationerrors = append ( validationerrors , errors . errorf ( " " , clusterinfo . certificateauthority , clustername , err ) ) } } return validationerrors } 
func ( config * directclientconfig ) getauthinfo ( ) clientcmdauthinfo { authinfos : = config . config . authinfos authinfoname : = config . getauthinfoname ( ) var mergedauthinfo clientcmdauthinfo if configauthinfo , exists : = authinfos [ authinfoname ] ; exists { mergo . merge ( & mergedauthinfo , configauthinfo ) } return mergedauthinfo } 
func ( config * directclientconfig ) getcluster ( ) clientcmdcluster { clusterinfos : = config . config . clusters clusterinfoname : = config . getclustername ( ) var mergedclusterinfo clientcmdcluster mergo . merge ( & mergedclusterinfo , defaultcluster ) mergo . merge ( & mergedclusterinfo , envvarcluster ) if configclusterinfo , exists : = clusterinfos [ clusterinfoname ] ; exists { mergo . merge ( & mergedclusterinfo , configclusterinfo ) } return mergedclusterinfo } 
func newaggregate ( errlist [ ] error ) error { if len ( errlist ) == 0 { return nil } var errs [ ] error for , e : = range errlist { if e ! = nil { errs = append ( errs , e ) } } if len ( errs ) == 0 { return nil } return aggregateerr ( errs ) } 
func ( rules * clientconfigloadingrules ) load ( ) ( * clientcmdconfig , error ) { errlist : = [ ] error { } kubeconfigfiles : = [ ] string { } kubeconfigfiles = append ( kubeconfigfiles , rules . precedence ... ) kubeconfigs : = [ ] * clientcmdconfig { } for , filename : = range kubeconfigfiles { if len ( filename ) == 0 { continue } config , err : = loadfromfile ( filename ) if os . isnotexist ( err ) { continue } if err ! = nil { errlist = append ( errlist , errors . wrapf ( err , " " " " , filename ) ) continue } kubeconfigs = append ( kubeconfigs , config ) } mapconfig : = clientcmdnewconfig ( ) for , kubeconfig : = range kubeconfigs { mergo . merge ( mapconfig , kubeconfig ) } nonmapconfig : = clientcmdnewconfig ( ) for i : = len ( kubeconfigs ) - 1 ; i >= 0 ; i -- { kubeconfig : = kubeconfigs [ i ] mergo . merge ( nonmapconfig , kubeconfig ) } config : = clientcmdnewconfig ( ) mergo . merge ( config , mapconfig ) mergo . merge ( config , nonmapconfig ) if err : = resolvelocalpaths ( config ) ; err ! = nil { errlist = append ( errlist , err ) } return config , newaggregate ( errlist ) } 
func loadfromfile ( filename string ) ( * clientcmdconfig , error ) { kubeconfigbytes , err : = ioutil . readfile ( filename ) if err ! = nil { return nil , err } config , err : = load ( kubeconfigbytes ) if err ! = nil { return nil , err } for key , obj : = range config . authinfos { obj . locationoforigin = filename config . authinfos [ key ] = obj } for key , obj : = range config . clusters { obj . locationoforigin = filename config . clusters [ key ] = obj } for key , obj : = range config . contexts { obj . locationoforigin = filename config . contexts [ key ] = obj } if config . authinfos == nil { config . authinfos = map [ string ] * clientcmdauthinfo { } } if config . clusters == nil { config . clusters = map [ string ] * clientcmdcluster { } } if config . contexts == nil { config . contexts = map [ string ] * clientcmdcontext { } } return config , nil } 
func load ( data [ ] byte ) ( * clientcmdconfig , error ) { config : = clientcmdnewconfig ( ) if len ( data ) == 0 { return config , nil } data , err : = yaml . yamltojson ( data ) if err ! = nil { return nil , err } if err : = json . unmarshal ( data , config ) ; err ! = nil { return nil , err } return config , nil } 
func resolvelocalpaths ( config * clientcmdconfig ) error { for , cluster : = range config . clusters { if len ( cluster . locationoforigin ) == 0 { continue } base , err : = filepath . abs ( filepath . dir ( cluster . locationoforigin ) ) if err ! = nil { return errors . wrapf ( err , " " , cluster . locationoforigin ) } if err : = resolvepaths ( getclusterfilereferences ( cluster ) , base ) ; err ! = nil { return err } } for , authinfo : = range config . authinfos { if len ( authinfo . locationoforigin ) == 0 { continue } base , err : = filepath . abs ( filepath . dir ( authinfo . locationoforigin ) ) if err ! = nil { return errors . wrapf ( err , " " , authinfo . locationoforigin ) } if err : = resolvepaths ( getauthinfofilereferences ( authinfo ) , base ) ; err ! = nil { return err } } return nil } 
func resolvepaths ( refs [ ] * string , base string ) error { for , ref : = range refs { if len ( * ref ) > 0 { if ! filepath . isabs ( * ref ) { * ref = filepath . join ( base , * ref ) } } } return nil } 
func restclientfor ( config * restconfig ) ( * url . url , * http . client , error ) { baseurl , err : = defaultserverurlfor ( config ) if err ! = nil { return nil , nil , err } transport , err : = transportfor ( config ) if err ! = nil { return nil , nil , err } var httpclient * http . client if transport ! = http . defaulttransport { httpclient = & http . client { transport : transport } } return baseurl , httpclient , nil } 
func defaultserverurl ( host string , defaulttls bool ) ( * url . url , error ) { if host == " " { return nil , errors . errorf ( " " ) } base : = host hosturl , err : = url . parse ( base ) if err ! = nil { return nil , err } if hosturl . scheme == " " { scheme : = " " if defaulttls { scheme = " " } hosturl , err = url . parse ( scheme + base ) if err ! = nil { return nil , err } if hosturl . path ! = " " && hosturl . path ! = " " { return nil , errors . errorf ( " " , base ) } } return hosturl , nil } 
func defaultserverurlfor ( config * restconfig ) ( * url . url , error ) { hasca : = len ( config . cafile ) ! = 0 | | len ( config . cadata ) ! = 0 hascert : = len ( config . certfile ) ! = 0 | | len ( config . certdata ) ! = 0 defaulttls : = hasca | | hascert | | config . insecure host : = config . host if host == " " { host = " " } return defaultserverurl ( host , defaulttls ) } 
func isconfigtransporttls ( config restconfig ) bool { baseurl , err : = defaultserverurlfor ( & config ) if err ! = nil { return false } return baseurl . scheme == " " } 
func newproxierwithnoproxycidr ( delegate func ( req * http . request ) ( * url . url , error ) ) func ( req * http . request ) ( * url . url , error ) { noproxyenv : = os . getenv ( " " ) noproxyrules : = strings . split ( noproxyenv , " " ) cidrs : = [ ] * net . ipnet { } for , noproxyrule : = range noproxyrules { , cidr , : = net . parsecidr ( noproxyrule ) if cidr ! = nil { cidrs = append ( cidrs , cidr ) } } if len ( cidrs ) == 0 { return delegate } return func ( req * http . request ) ( * url . url , error ) { host : = req . url . host if net . parseip ( host ) == nil { var err error host , , err = net . splithostport ( req . url . host ) if err ! = nil { return delegate ( req ) } } ip : = net . parseip ( host ) if ip == nil { return delegate ( req ) } for , cidr : = range cidrs { if cidr . contains ( ip ) { return nil , nil } } return delegate ( req ) } } 
func tlscacheget ( config * restconfig ) ( http . roundtripper , error ) { tlsconfig , err : = tlsconfigfor ( config ) if err ! = nil { return nil , err } if tlsconfig == nil { return http . defaulttransport , nil } t : = & http . transport { proxy : newproxierwithnoproxycidr ( http . proxyfromenvironment ) , tlshandshaketimeout : 10 * time . second , tlsclientconfig : tlsconfig , dial : ( & net . dialer { timeout : 30 * time . second , keepalive : 30 * time . second , } ) . dial , } if s : = os . getenv ( " " ) ; len ( s ) == 0 { = http2 . configuretransport ( t ) } return t , nil } 
func loadtlsfiles ( c * restconfig ) error { var err error c . cadata , err = datafromsliceorfile ( c . cadata , c . cafile ) if err ! = nil { return err } c . certdata , err = datafromsliceorfile ( c . certdata , c . certfile ) if err ! = nil { return err } c . keydata , err = datafromsliceorfile ( c . keydata , c . keyfile ) if err ! = nil { return err } return nil } 
func ( c * restconfig ) hasca ( ) bool { return len ( c . cadata ) > 0 | | len ( c . cafile ) > 0 } 
func ( c * restconfig ) hascertauth ( ) bool { return len ( c . certdata ) ! = 0 | | len ( c . certfile ) ! = 0 } 
func clientcmdnewconfig ( ) * clientcmdconfig { return & clientcmdconfig { clusters : make ( map [ string ] * clientcmdcluster ) , authinfos : make ( map [ string ] * clientcmdauthinfo ) , contexts : make ( map [ string ] * clientcmdcontext ) , } } 
func newimagesource ( ctx context . context , sys * types . systemcontext , ref daemonreference ) ( types . imagesource , error ) { c , err : = newdockerclient ( sys ) if err ! = nil { return nil , errors . wrap ( err , " " ) } inputstream , err : = c . imagesave ( ctx , [ ] string { ref . stringwithintransport ( ) } ) if err ! = nil { return nil , errors . wrap ( err , " " ) } defer inputstream . close ( ) src , err : = tarfile . newsourcefromstream ( inputstream ) if err ! = nil { return nil , err } return & daemonimagesource { ref : ref , source : src , } , nil } 
func manifestschema2fromcomponents ( config manifest . schema2descriptor , src types . imagesource , configblob [ ] byte , layers [ ] manifest . schema2descriptor ) genericmanifest { return & manifestschema2 { src : src , configblob : configblob , m : manifest . schema2fromcomponents ( config , layers ) , } } 
func ( m * manifestschema2 ) ociconfig ( ctx context . context ) ( * imgspecv1 . image , error ) { configblob , err : = m . configblob ( ctx ) if err ! = nil { return nil , err } configoci : = & imgspecv1 . image { } if err : = json . unmarshal ( configblob , configoci ) ; err ! = nil { return nil , err } return configoci , nil } 
func ( m * manifestschema2 ) configblob ( ctx context . context ) ( [ ] byte , error ) { if m . configblob == nil { if m . src == nil { return nil , errors . errorf ( " " ) } stream , , err : = m . src . getblob ( ctx , manifest . blobinfofromschema2descriptor ( m . m . configdescriptor ) , none . nocache ) if err ! = nil { return nil , err } defer stream . close ( ) blob , err : = ioutil . readall ( stream ) if err ! = nil { return nil , err } computeddigest : = digest . frombytes ( blob ) if computeddigest ! = m . m . configdescriptor . digest { return nil , errors . errorf ( " " , computeddigest , m . m . configdescriptor . digest ) } m . configblob = blob } return m . configblob , nil } 
func ( m * manifestschema2 ) inspect ( ctx context . context ) ( * types . imageinspectinfo , error ) { getter : = func ( info types . blobinfo ) ( [ ] byte , error ) { if info . digest ! = m . configinfo ( ) . digest { return nil , errors . new ( " " ) } config , err : = m . configblob ( ctx ) if err ! = nil { return nil , err } return config , nil } return m . m . inspect ( getter ) } 
func ( m * manifestschema2 ) updatedimage ( ctx context . context , options types . manifestupdateoptions ) ( types . image , error ) { copy : = manifestschema2 { src : m . src , configblob : m . configblob , m : manifest . schema2clone ( m . m ) , } if options . layerinfos ! = nil { if err : = copy . m . updatelayerinfos ( options . layerinfos ) ; err ! = nil { return nil , err } } switch options . manifestmimetype { case " " : case manifest . dockerv2schema1signedmediatype , manifest . dockerv2schema1mediatype : return copy . converttomanifestschema1 ( ctx , options . informationonly . destination ) case imgspecv1 . mediatypeimagemanifest : return copy . converttomanifestoci1 ( ctx ) default : return nil , errors . errorf ( " " , manifest . dockerv2schema2mediatype , options . manifestmimetype ) } return memoryimagefrommanifest ( & copy ) , nil } 
func registriesdirpath ( sys * types . systemcontext ) string { if sys ! = nil { if sys . registriesdirpath ! = " " { return sys . registriesdirpath } if sys . rootforimplicitabsolutepaths ! = " " { return filepath . join ( sys . rootforimplicitabsolutepaths , systemregistriesdirpath ) } } return systemregistriesdirpath } 
func loadandmergeconfig ( dirpath string ) ( * registryconfiguration , error ) { mergedconfig : = registryconfiguration { docker : map [ string ] registrynamespace { } } dockerdefaultmergedfrom : = " " nsmergedfrom : = map [ string ] string { } dir , err : = os . open ( dirpath ) if err ! = nil { if os . isnotexist ( err ) { return & mergedconfig , nil } return nil , err } confignames , err : = dir . readdirnames ( 0 ) if err ! = nil { return nil , err } for , configname : = range confignames { if ! strings . hassuffix ( configname , " " ) { continue } configpath : = filepath . join ( dirpath , configname ) configbytes , err : = ioutil . readfile ( configpath ) if err ! = nil { return nil , err } var config registryconfiguration err = yaml . unmarshal ( configbytes , & config ) if err ! = nil { return nil , errors . wrapf ( err , " " , configpath ) } if config . defaultdocker ! = nil { if mergedconfig . defaultdocker ! = nil { return nil , errors . errorf ( ' error parsing signature storage configuration : " default - docker " defined both in " %s " and " %s " ' , dockerdefaultmergedfrom , configpath ) } mergedconfig . defaultdocker = config . defaultdocker dockerdefaultmergedfrom = configpath } for nsname , nsconfig : = range config . docker { if , ok : = mergedconfig . docker [ nsname ] ; ok { return nil , errors . errorf ( ' error parsing signature storage configuration : " docker " namespace " %s " defined both in " %s " and " %s " ' , nsname , nsmergedfrom [ nsname ] , configpath ) } mergedconfig . docker [ nsname ] = nsconfig nsmergedfrom [ nsname ] = configpath } } return & mergedconfig , nil } 
func signaturestorageurl ( base signaturestoragebase , manifestdigest digest . digest , index int ) * url . url { if base == nil { return nil } url : = * base url . path = fmt . sprintf ( " " , url . path , manifestdigest . algorithm ( ) , manifestdigest . hex ( ) , index + 1 ) return & url } 
func ( t openshifttransport ) parsereference ( reference string ) ( types . imagereference , error ) { return parsereference ( reference ) } 
func ( t openshifttransport ) validatepolicyconfigurationscope ( scope string ) error { if scoperegexp . findstringindex ( scope ) == nil { return errors . errorf ( " " , scope ) } return nil } 
func parsereference ( ref string ) ( types . imagereference , error ) { r , err : = reference . parsenormalizednamed ( ref ) if err ! = nil { return nil , errors . wrapf ( err , " " , ref ) } tagged , ok : = r . ( reference . namedtagged ) if ! ok { return nil , errors . errorf ( " " , ref ) } return newreference ( tagged ) } 
func newreference ( dockerref reference . namedtagged ) ( types . imagereference , error ) { r : = strings . splitn ( reference . path ( dockerref ) , " " , 3 ) if len ( r ) ! = 2 { return nil , errors . errorf ( " " , reference . familiarstring ( dockerref ) ) } return openshiftreference { namespace : r [ 0 ] , stream : r [ 1 ] , dockerreference : dockerref , } , nil } 
func ( ref openshiftreference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { src , err : = newimagesource ( sys , ref ) if err ! = nil { return nil , err } return genericimage . fromsource ( ctx , sys , src ) } 
func serverdefault ( ) * tls . config { return & tls . config { minversion : tls . versiontls10 , preferserverciphersuites : true , ciphersuites : tlsconfig . defaultserveracceptedciphers , } } 
func dockercertdir ( sys * types . systemcontext , hostport string ) ( string , error ) { if sys ! = nil && sys . dockercertpath ! = " " { return sys . dockercertpath , nil } if sys ! = nil && sys . dockerperhostcertdirpath ! = " " { return filepath . join ( sys . dockerperhostcertdirpath , hostport ) , nil } var ( hostcertdir string fullcertdirpath string ) for , systemperhostcertdirpath : = range systemperhostcertdirpaths { if sys ! = nil && sys . rootforimplicitabsolutepaths ! = " " { hostcertdir = filepath . join ( sys . rootforimplicitabsolutepaths , systemperhostcertdirpath ) } else { hostcertdir = systemperhostcertdirpath } fullcertdirpath = filepath . join ( hostcertdir , hostport ) , err : = os . stat ( fullcertdirpath ) if err == nil { break } if os . isnotexist ( err ) { continue } if os . ispermission ( err ) { logrus . debugf ( " " , err ) continue } if err ! = nil { return " " , err } } return fullcertdirpath , nil } 
func ( c * dockerclient ) detectproperties ( ctx context . context ) error { c . detectpropertiesonce . do ( func ( ) { c . detectpropertieserror = c . detectpropertieshelper ( ctx ) } ) return c . detectpropertieserror } 
func ( c * dockerclient ) getextensionssignatures ( ctx context . context , ref dockerreference , manifestdigest digest . digest ) ( * extensionsignaturelist , error ) { path : = fmt . sprintf ( extensionssignaturepath , reference . path ( ref . ref ) , manifestdigest ) res , err : = c . makerequest ( ctx , " " , path , nil , nil , v2auth , nil ) if err ! = nil { return nil , err } defer res . body . close ( ) if res . statuscode ! = http . statusok { return nil , errors . wrapf ( client . handleerrorresponse ( res ) , " " , manifestdigest , ref . ref . name ( ) ) } body , err : = ioutil . readall ( res . body ) if err ! = nil { return nil , err } var parsedbody extensionsignaturelist if err : = json . unmarshal ( body , & parsedbody ) ; err ! = nil { return nil , errors . wrapf ( err , " " ) } return & parsedbody , nil } 
func newtransport ( ) * http . transport { direct : = & net . dialer { timeout : 30 * time . second , keepalive : 30 * time . second , dualstack : true , } tr : = & http . transport { proxy : http . proxyfromenvironment , dial : direct . dial , tlshandshaketimeout : 10 * time . second , disablekeepalives : true , } proxydialer , err : = sockets . dialerfromenvironment ( direct ) if err == nil { tr . dial = proxydialer . dial } return tr } 
func normalizeregistries ( regs * registries ) { for i : = range regs . registries { regs . registries [ i ] = strings . trimright ( regs . registries [ i ] , " " ) } } 
func readregistryconf ( sys * types . systemcontext ) ( [ ] byte , error ) { return ioutil . readfile ( registriesconfpath ( sys ) ) } 
func loadregistryconf ( sys * types . systemcontext ) ( * tomlconfig , error ) { config : = & tomlconfig { } configbytes , err : = readconf ( sys ) if err ! = nil { return nil , err } err = toml . unmarshal ( configbytes , & config ) normalizeregistries ( & config . registries . search ) normalizeregistries ( & config . registries . insecure ) normalizeregistries ( & config . registries . block ) return config , err } 
func getregistries ( sys * types . systemcontext ) ( [ ] string , error ) { config , err : = loadregistryconf ( sys ) if err ! = nil { return nil , err } return config . registries . search . registries , nil } 
func getinsecureregistries ( sys * types . systemcontext ) ( [ ] string , error ) { config , err : = loadregistryconf ( sys ) if err ! = nil { return nil , err } return config . registries . insecure . registries , nil } 
func registriesconfpath ( ctx * types . systemcontext ) string { path : = systemregistriesconfpath if ctx ! = nil { if ctx . systemregistriesconfpath ! = " " { path = ctx . systemregistriesconfpath } else if ctx . rootforimplicitabsolutepaths ! = " " { path = filepath . join ( ctx . rootforimplicitabsolutepaths , systemregistriesconfpath ) } } return path } 
func newoptionalbool ( b bool ) optionalbool { o : = optionalboolfalse if b == true { o = optionalbooltrue } return o } 
func ( pc * policycontext ) changestate ( expected , new policycontextstate ) error { if pc . state ! = expected { return errors . errorf ( ' " invalid policycontext state , expected " %s " , found " %s " ' , expected , pc . state ) } pc . state = new return nil } 
func newpolicycontext ( policy * policy ) ( * policycontext , error ) { pc : = & policycontext { policy : policy , state : pcinitializing } if err : = pc . changestate ( pcinitializing , pcready ) ; err ! = nil { return nil , err } return pc , nil } 
func ( pc * policycontext ) destroy ( ) error { if err : = pc . changestate ( pcready , pcdestroying ) ; err ! = nil { return err } return pc . changestate ( pcdestroying , pcdestroyed ) } 
func policyidentitylogname ( ref types . imagereference ) string { return ref . transport ( ) . name ( ) + " " + ref . policyconfigurationidentity ( ) } 
func ( pc * policycontext ) requirementsforimageref ( ref types . imagereference ) policyrequirements { transportname : = ref . transport ( ) . name ( ) if transportscopes , ok : = pc . policy . transports [ transportname ] ; ok { identity : = ref . policyconfigurationidentity ( ) if req , ok : = transportscopes [ identity ] ; ok { logrus . debugf ( ' using transport " %s " policy section %s ' , transportname , identity ) return req } for , name : = range ref . policyconfigurationnamespaces ( ) { if req , ok : = transportscopes [ name ] ; ok { logrus . debugf ( ' using transport " %s " specific policy section %s ' , transportname , name ) return req } } if req , ok : = transportscopes [ " " ] ; ok { logrus . debugf ( ' using transport " %s " policy section " " ' , transportname ) return req } } logrus . debugf ( " " ) return pc . policy . default } 
func ( pc * policycontext ) isrunningimageallowed ( ctx context . context , image types . unparsedimage ) ( res bool , finalerr error ) { if err : = pc . changestate ( pcready , pcinuse ) ; err ! = nil { return false , err } defer func ( ) { if err : = pc . changestate ( pcinuse , pcready ) ; err ! = nil { res = false finalerr = err } } ( ) logrus . debugf ( " " , policyidentitylogname ( image . reference ( ) ) ) reqs : = pc . requirementsforimageref ( image . reference ( ) ) if len ( reqs ) == 0 { return false , policyrequirementerror ( " " ) } for reqnumber , req : = range reqs { allowed , err : = req . isrunningimageallowed ( ctx , image ) if ! allowed { logrus . debugf ( " " , reqnumber ) return false , err } logrus . debugf ( " " , reqnumber ) } logrus . debugf ( " " ) return true , nil } 
func parseimagename ( imgname string ) ( types . imagereference , error ) { parts : = strings . splitn ( imgname , " " , 2 ) if len ( parts ) ! = 2 { return nil , errors . errorf ( ' invalid image name " %s " , expected colon - separated transport : reference ' , imgname ) } transport : = transports . get ( parts [ 0 ] ) if transport == nil { return nil , errors . errorf ( ' invalid image name " %s " , unknown transport " %s " ' , imgname , parts [ 0 ] ) } return transport . parsereference ( parts [ 1 ] ) } 
func blobinfofromoci1descriptor ( desc imgspecv1 . descriptor ) types . blobinfo { return types . blobinfo { digest : desc . digest , size : desc . size , urls : desc . urls , annotations : desc . annotations , mediatype : desc . mediatype , } } 
func oci1frommanifest ( manifest [ ] byte ) ( * oci1 , error ) { oci1 : = oci1 { } if err : = json . unmarshal ( manifest , & oci1 ) ; err ! = nil { return nil , err } return & oci1 , nil } 
func oci1fromcomponents ( config imgspecv1 . descriptor , layers [ ] imgspecv1 . descriptor ) * oci1 { return & oci1 { imgspecv1 . manifest { versioned : specs . versioned { schemaversion : 2 } , config : config , layers : layers , } , } } 
func ( m * oci1 ) layerinfos ( ) [ ] layerinfo { blobs : = [ ] layerinfo { } for , layer : = range m . layers { blobs = append ( blobs , layerinfo { blobinfo : blobinfofromoci1descriptor ( layer ) , emptylayer : false , } ) } return blobs } 
func ( m * oci1 ) updatelayerinfos ( layerinfos [ ] types . blobinfo ) error { if len ( m . layers ) ! = len ( layerinfos ) { return errors . errorf ( " " , len ( m . layers ) , len ( layerinfos ) ) } original : = m . layers m . layers = make ( [ ] imgspecv1 . descriptor , len ( layerinfos ) ) for i , info : = range layerinfos { m . layers [ i ] . mediatype = original [ i ] . mediatype m . layers [ i ] . digest = info . digest m . layers [ i ] . size = info . size m . layers [ i ] . annotations = info . annotations m . layers [ i ] . urls = info . urls } return nil } 
func ( m * oci1 ) inspect ( configgetter func ( types . blobinfo ) ( [ ] byte , error ) ) ( * types . imageinspectinfo , error ) { config , err : = configgetter ( m . configinfo ( ) ) if err ! = nil { return nil , err } v1 : = & imgspecv1 . image { } if err : = json . unmarshal ( config , v1 ) ; err ! = nil { return nil , err } d1 : = & schema2v1image { } json . unmarshal ( config , d1 ) i : = & types . imageinspectinfo { tag : " " , created : v1 . created , dockerversion : d1 . dockerversion , labels : v1 . config . labels , architecture : v1 . architecture , os : v1 . os , layers : layerinfostostrings ( m . layerinfos ( ) ) , } return i , nil } 
func ( m * oci1 ) imageid ( [ ] digest . digest ) ( string , error ) { if err : = m . config . digest . validate ( ) ; err ! = nil { return " " , err } return m . config . digest . hex ( ) , nil } 
func ( t dockertransport ) parsereference ( reference string ) ( types . imagereference , error ) { return parsereference ( reference ) } 
func parsereference ( refstring string ) ( types . imagereference , error ) { if ! strings . hasprefix ( refstring , " " ) { return nil , errors . errorf ( " " , refstring ) } ref , err : = reference . parsenormalizednamed ( strings . trimprefix ( refstring , " " ) ) if err ! = nil { return nil , err } ref = reference . tagnameonly ( ref ) return newreference ( ref ) } 
func newreference ( ref reference . named ) ( dockerreference , error ) { if reference . isnameonly ( ref ) { return dockerreference { } , errors . errorf ( " " , reference . familiarstring ( ref ) ) } , istagged : = ref . ( reference . namedtagged ) , isdigested : = ref . ( reference . canonical ) if istagged && isdigested { return dockerreference { } , errors . errorf ( " " ) } return dockerreference { ref : ref , } , nil } 
func ( ref dockerreference ) policyconfigurationidentity ( ) string { res , err : = policyconfiguration . dockerreferenceidentity ( ref . ref ) if res == " " | | err ! = nil { panic ( fmt . sprintf ( " " , res , err ) ) } return res } 
func ( ref dockerreference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { return newimage ( ctx , sys , ref ) } 
func ( ref dockerreference ) deleteimage ( ctx context . context , sys * types . systemcontext ) error { return deleteimage ( ctx , sys , ref ) } 
func ( ref dockerreference ) tagordigest ( ) ( string , error ) { if ref , ok : = ref . ref . ( reference . canonical ) ; ok { return ref . digest ( ) . string ( ) , nil } if ref , ok : = ref . ref . ( reference . namedtagged ) ; ok { return ref . tag ( ) , nil } return " " , errors . errorf ( " " , reference . familiarstring ( ref . ref ) ) } 
func newdigestingreader ( source io . reader , expecteddigest digest . digest ) ( * digestingreader , error ) { if err : = expecteddigest . validate ( ) ; err ! = nil { return nil , errors . errorf ( " " , expecteddigest ) } digestalgorithm : = expecteddigest . algorithm ( ) if ! digestalgorithm . available ( ) { return nil , errors . errorf ( " " , expecteddigest , digestalgorithm ) } return & digestingreader { source : source , digester : digestalgorithm . digester ( ) , expecteddigest : expecteddigest , validationfailed : false , } , nil } 
func ( c * copier ) printf ( format string , a ... interface { } ) { fmt . fprintf ( c . reportwriter , format , a ... ) } 
func ( ic * imagecopier ) updateembeddeddockerreference ( ) error { if ic . c . dest . ignoresembeddeddockerreference ( ) { return nil } destref : = ic . c . dest . reference ( ) . dockerreference ( ) if destref == nil { return nil } if ! ic . src . embeddeddockerreferenceconflicts ( destref ) { return nil } if ! ic . canmodifymanifest { return errors . errorf ( " " , transports . imagename ( ic . c . dest . reference ( ) ) , destref . string ( ) ) } ic . manifestupdates . embeddeddockerreference = destref return nil } 
func istty ( w io . writer ) bool { if f , ok : = w . ( * os . file ) ; ok { return terminal . isterminal ( int ( f . fd ( ) ) ) } return false } 
func layerdigestsdiffer ( a , b [ ] types . blobinfo ) bool { if len ( a ) ! = len ( b ) { return true } for i : = range a { if a [ i ] . digest ! = b [ i ] . digest { return true } } return false } 
func ( ic * imagecopier ) copyupdatedconfigandmanifest ( ctx context . context ) ( [ ] byte , error ) { pendingimage : = ic . src if ! reflect . deepequal ( * ic . manifestupdates , types . manifestupdateoptions { informationonly : ic . manifestupdates . informationonly } ) { if ! ic . canmodifymanifest { return nil , errors . errorf ( " " ) } if ! ic . diffidsareneeded && ic . src . updatedimageneedslayerdiffids ( * ic . manifestupdates ) { return nil , errors . errorf ( " " , ic . manifestupdates . manifestmimetype ) } pi , err : = ic . src . updatedimage ( ctx , * ic . manifestupdates ) if err ! = nil { return nil , errors . wrap ( err , " " ) } pendingimage = pi } manifest , , err : = pendingimage . manifest ( ctx ) if err ! = nil { return nil , errors . wrap ( err , " " ) } if err : = ic . c . copyconfig ( ctx , pendingimage ) ; err ! = nil { return nil , err } ic . c . printf ( " \n " ) if err : = ic . c . dest . putmanifest ( ctx , manifest ) ; err ! = nil { return nil , errors . wrap ( err , " " ) } return manifest , nil } 
func ( c * copier ) newprogresspool ( ctx context . context ) ( * mpb . progress , func ( ) ) { ctx , cancel : = context . withcancel ( ctx ) pool : = mpb . new ( mpb . withwidth ( 40 ) , mpb . withoutput ( c . progressoutput ) , mpb . withcontext ( ctx ) ) return pool , func ( ) { cancel ( ) pool . wait ( ) } } 
func ( c * copier ) createprogressbar ( pool * mpb . progress , info types . blobinfo , kind string , oncomplete string ) * mpb . bar { const shortdigestlen = 12 prefix : = fmt . sprintf ( " " , kind , info . digest . encoded ( ) ) maxprefixlen : = len ( " " ) + shortdigestlen if len ( prefix ) > maxprefixlen { prefix = prefix [ : maxprefixlen ] } bar : = pool . addbar ( info . size , mpb . barclearoncomplete ( ) , mpb . prependdecorators ( decor . name ( prefix ) , ) , mpb . appenddecorators ( decor . oncomplete ( decor . counterskibibyte ( " " ) , " " + oncomplete ) , ) , ) if c . progressoutput == ioutil . discard { c . printf ( " \n " , kind , info . digest ) } return bar } 
func ( c * copier ) copyconfig ( ctx context . context , src types . image ) error { srcinfo : = src . configinfo ( ) if srcinfo . digest ! = " " { configblob , err : = src . configblob ( ctx ) if err ! = nil { return errors . wrapf ( err , " " , srcinfo . digest ) } destinfo , err : = func ( ) ( types . blobinfo , error ) { progresspool , progresscleanup : = c . newprogresspool ( ctx ) defer progresscleanup ( ) bar : = c . createprogressbar ( progresspool , srcinfo , " " , " " ) destinfo , err : = c . copyblobfromstream ( ctx , bytes . newreader ( configblob ) , srcinfo , nil , false , true , bar ) if err ! = nil { return types . blobinfo { } , err } bar . settotal ( int64 ( len ( configblob ) ) , true ) return destinfo , nil } ( ) if err ! = nil { return nil } if destinfo . digest ! = srcinfo . digest { return errors . errorf ( " " , srcinfo . digest , destinfo . digest ) } } return nil } 
func diffidcomputationgoroutine ( dest chan < - diffidresult , layerstream io . readcloser , decompressor compression . decompressorfunc ) { result : = diffidresult { digest : " " , err : errors . new ( " " ) , } defer func ( ) { dest < - result } ( ) defer layerstream . close ( ) result . digest , result . err = computediffid ( layerstream , decompressor ) } 
func computediffid ( stream io . reader , decompressor compression . decompressorfunc ) ( digest . digest , error ) { if decompressor ! = nil { s , err : = decompressor ( stream ) if err ! = nil { return " " , err } defer s . close ( ) stream = s } return digest . canonical . fromreader ( stream ) } 
func compressgoroutine ( dest * io . pipewriter , src io . reader ) { err : = errors . new ( " " ) defer func ( ) { dest . closewitherror ( err ) } ( ) zipper : = pgzip . newwriter ( dest ) defer zipper . close ( ) , err = io . copy ( zipper , src ) } 
func newdockerclient ( sys * types . systemcontext ) ( * dockerclient . client , error ) { host : = dockerclient . defaultdockerhost if sys ! = nil && sys . dockerdaemonhost ! = " " { host = sys . dockerdaemonhost } url , err : = dockerclient . parsehosturl ( host ) if err ! = nil { return nil , err } var httpclient * http . client if url . scheme ! = " " { if url . scheme == " " { httpclient = httpconfig ( ) } else { hc , err : = tlsconfig ( sys ) if err ! = nil { return nil , err } httpclient = hc } } return dockerclient . newclient ( host , defaultapiversion , httpclient , nil ) } 
func defaultpolicypath ( sys * types . systemcontext ) string { if sys ! = nil { if sys . signaturepolicypath ! = " " { return sys . signaturepolicypath } if sys . rootforimplicitabsolutepaths ! = " " { return filepath . join ( sys . rootforimplicitabsolutepaths , systemdefaultpolicypath ) } } return systemdefaultpolicypath } 
func newpolicyfromfile ( filename string ) ( * policy , error ) { contents , err : = ioutil . readfile ( filename ) if err ! = nil { return nil , err } policy , err : = newpolicyfrombytes ( contents ) if err ! = nil { return nil , errors . wrapf ( err , " " , filename ) } return policy , nil } 
func newpolicyfrombytes ( data [ ] byte ) ( * policy , error ) { p : = policy { } if err : = json . unmarshal ( data , & p ) ; err ! = nil { return nil , invalidpolicyformaterror ( err . error ( ) ) } return & p , nil } 
func ( p * policy ) unmarshaljson ( data [ ] byte ) error { * p = policy { } transports : = policytransportsmap { } if err : = paranoidunmarshaljsonobject ( data , func ( key string ) interface { } { switch key { case " " : return & p . default case " " : return & transports default : return nil } } ) ; err ! = nil { return err } if p . default == nil { return invalidpolicyformaterror ( " " ) } p . transports = map [ string ] policytransportscopes ( transports ) return nil } 
func ( m * policytransportsmap ) unmarshaljson ( data [ ] byte ) error { tmpmap : = map [ string ] * policytransportscopes { } if err : = paranoidunmarshaljsonobject ( data , func ( key string ) interface { } { transport : = transports . get ( key ) if , ok : = tmpmap [ key ] ; ok { return nil } ptswithtransport : = policytransportscopeswithtransport { transport : transport , dest : & policytransportscopes { } , } tmpmap [ key ] = ptswithtransport . dest return & ptswithtransport } ) ; err ! = nil { return err } for key , ptr : = range tmpmap { ( * m ) [ key ] = * ptr } return nil } 
func ( m * policytransportscopeswithtransport ) unmarshaljson ( data [ ] byte ) error { tmpmap : = map [ string ] * policyrequirements { } if err : = paranoidunmarshaljsonobject ( data , func ( key string ) interface { } { if , ok : = tmpmap [ key ] ; ok { return nil } if key ! = " " && m . transport ! = nil { if err : = m . transport . validatepolicyconfigurationscope ( key ) ; err ! = nil { return nil } } ptr : = & policyrequirements { } tmpmap [ key ] = ptr return ptr } ) ; err ! = nil { return err } for key , ptr : = range tmpmap { ( * m . dest ) [ key ] = * ptr } return nil } 
func ( m * policyrequirements ) unmarshaljson ( data [ ] byte ) error { reqjsons : = [ ] json . rawmessage { } if err : = json . unmarshal ( data , & reqjsons ) ; err ! = nil { return err } if len ( reqjsons ) == 0 { return invalidpolicyformaterror ( " " ) } res : = make ( [ ] policyrequirement , len ( reqjsons ) ) for i , reqjson : = range reqjsons { req , err : = newpolicyrequirementfromjson ( reqjson ) if err ! = nil { return err } res [ i ] = req } * m = res return nil } 
func newpolicyrequirementfromjson ( data [ ] byte ) ( policyrequirement , error ) { var typefield prcommon if err : = json . unmarshal ( data , & typefield ) ; err ! = nil { return nil , err } var res policyrequirement switch typefield . type { case prtypeinsecureacceptanything : res = & prinsecureacceptanything { } case prtypereject : res = & prreject { } case prtypesignedby : res = & prsignedby { } case prtypesignedbaselayer : res = & prsignedbaselayer { } default : return nil , invalidpolicyformaterror ( fmt . sprintf ( " " " " , typefield . type ) ) } if err : = json . unmarshal ( data , & res ) ; err ! = nil { return nil , err } return res , nil } 
func ( pr * prinsecureacceptanything ) unmarshaljson ( data [ ] byte ) error { * pr = prinsecureacceptanything { } var tmp prinsecureacceptanything if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , } ) ; err ! = nil { return err } if tmp . type ! = prtypeinsecureacceptanything { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } * pr = * newprinsecureacceptanything ( ) return nil } 
func ( pr * prreject ) unmarshaljson ( data [ ] byte ) error { * pr = prreject { } var tmp prreject if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , } ) ; err ! = nil { return err } if tmp . type ! = prtypereject { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } * pr = * newprreject ( ) return nil } 
func newprsignedby ( keytype sbkeytype , keypath string , keydata [ ] byte , signedidentity policyreferencematch ) ( * prsignedby , error ) { if ! keytype . isvalid ( ) { return nil , invalidpolicyformaterror ( fmt . sprintf ( " " " " , keytype ) ) } if len ( keypath ) > 0 && len ( keydata ) > 0 { return nil , invalidpolicyformaterror ( " " ) } if signedidentity == nil { return nil , invalidpolicyformaterror ( " " ) } return & prsignedby { prcommon : prcommon { type : prtypesignedby } , keytype : keytype , keypath : keypath , keydata : keydata , signedidentity : signedidentity , } , nil } 
func newprsignedbykeypath ( keytype sbkeytype , keypath string , signedidentity policyreferencematch ) ( * prsignedby , error ) { return newprsignedby ( keytype , keypath , nil , signedidentity ) } 
func newprsignedbykeypath ( keytype sbkeytype , keypath string , signedidentity policyreferencematch ) ( policyrequirement , error ) { return newprsignedbykeypath ( keytype , keypath , signedidentity ) } 
func newprsignedbykeydata ( keytype sbkeytype , keydata [ ] byte , signedidentity policyreferencematch ) ( * prsignedby , error ) { return newprsignedby ( keytype , " " , keydata , signedidentity ) } 
func newprsignedbykeydata ( keytype sbkeytype , keydata [ ] byte , signedidentity policyreferencematch ) ( policyrequirement , error ) { return newprsignedbykeydata ( keytype , keydata , signedidentity ) } 
func ( pr * prsignedby ) unmarshaljson ( data [ ] byte ) error { * pr = prsignedby { } var tmp prsignedby var gotkeypath , gotkeydata = false , false var signedidentity json . rawmessage if err : = paranoidunmarshaljsonobject ( data , func ( key string ) interface { } { switch key { case " " : return & tmp . type case " " : return & tmp . keytype case " " : gotkeypath = true return & tmp . keypath case " " : gotkeydata = true return & tmp . keydata case " " : return & signedidentity default : return nil } } ) ; err ! = nil { return err } if tmp . type ! = prtypesignedby { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } if signedidentity == nil { tmp . signedidentity = newprmmatchrepodigestorexact ( ) } else { si , err : = newpolicyreferencematchfromjson ( signedidentity ) if err ! = nil { return err } tmp . signedidentity = si } var res * prsignedby var err error switch { case gotkeypath && gotkeydata : return invalidpolicyformaterror ( " " ) case gotkeypath && ! gotkeydata : res , err = newprsignedbykeypath ( tmp . keytype , tmp . keypath , tmp . signedidentity ) case ! gotkeypath && gotkeydata : res , err = newprsignedbykeydata ( tmp . keytype , tmp . keydata , tmp . signedidentity ) case ! gotkeypath && ! gotkeydata : return invalidpolicyformaterror ( " " ) default : return errors . errorf ( " " ) } if err ! = nil { return err } * pr = * res return nil } 
func ( kt sbkeytype ) isvalid ( ) bool { switch kt { case sbkeytypegpgkeys , sbkeytypesignedbygpgkeys , sbkeytypex509certificates , sbkeytypesignedbyx509cas : return true default : return false } } 
func ( kt * sbkeytype ) unmarshaljson ( data [ ] byte ) error { * kt = sbkeytype ( " " ) var s string if err : = json . unmarshal ( data , & s ) ; err ! = nil { return err } if ! sbkeytype ( s ) . isvalid ( ) { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , s ) ) } * kt = sbkeytype ( s ) return nil } 
func newprsignedbaselayer ( baselayeridentity policyreferencematch ) ( * prsignedbaselayer , error ) { if baselayeridentity == nil { return nil , invalidpolicyformaterror ( " " ) } return & prsignedbaselayer { prcommon : prcommon { type : prtypesignedbaselayer } , baselayeridentity : baselayeridentity , } , nil } 
func ( pr * prsignedbaselayer ) unmarshaljson ( data [ ] byte ) error { * pr = prsignedbaselayer { } var tmp prsignedbaselayer var baselayeridentity json . rawmessage if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , " " : & baselayeridentity , } ) ; err ! = nil { return err } if tmp . type ! = prtypesignedbaselayer { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } bli , err : = newpolicyreferencematchfromjson ( baselayeridentity ) if err ! = nil { return err } res , err : = newprsignedbaselayer ( bli ) if err ! = nil { return err } * pr = * res return nil } 
func newpolicyreferencematchfromjson ( data [ ] byte ) ( policyreferencematch , error ) { var typefield prmcommon if err : = json . unmarshal ( data , & typefield ) ; err ! = nil { return nil , err } var res policyreferencematch switch typefield . type { case prmtypematchexact : res = & prmmatchexact { } case prmtypematchrepodigestorexact : res = & prmmatchrepodigestorexact { } case prmtypematchrepository : res = & prmmatchrepository { } case prmtypeexactreference : res = & prmexactreference { } case prmtypeexactrepository : res = & prmexactrepository { } default : return nil , invalidpolicyformaterror ( fmt . sprintf ( " " " " , typefield . type ) ) } if err : = json . unmarshal ( data , & res ) ; err ! = nil { return nil , err } return res , nil } 
func ( prm * prmmatchexact ) unmarshaljson ( data [ ] byte ) error { * prm = prmmatchexact { } var tmp prmmatchexact if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , } ) ; err ! = nil { return err } if tmp . type ! = prmtypematchexact { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } * prm = * newprmmatchexact ( ) return nil } 
func ( prm * prmmatchrepodigestorexact ) unmarshaljson ( data [ ] byte ) error { * prm = prmmatchrepodigestorexact { } var tmp prmmatchrepodigestorexact if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , } ) ; err ! = nil { return err } if tmp . type ! = prmtypematchrepodigestorexact { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } * prm = * newprmmatchrepodigestorexact ( ) return nil } 
func ( prm * prmmatchrepository ) unmarshaljson ( data [ ] byte ) error { * prm = prmmatchrepository { } var tmp prmmatchrepository if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , } ) ; err ! = nil { return err } if tmp . type ! = prmtypematchrepository { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } * prm = * newprmmatchrepository ( ) return nil } 
func newprmexactreference ( dockerreference string ) ( * prmexactreference , error ) { ref , err : = reference . parsenormalizednamed ( dockerreference ) if err ! = nil { return nil , invalidpolicyformaterror ( fmt . sprintf ( " " , dockerreference , err . error ( ) ) ) } if reference . isnameonly ( ref ) { return nil , invalidpolicyformaterror ( fmt . sprintf ( " " , dockerreference ) ) } return & prmexactreference { prmcommon : prmcommon { type : prmtypeexactreference } , dockerreference : dockerreference , } , nil } 
func ( prm * prmexactreference ) unmarshaljson ( data [ ] byte ) error { * prm = prmexactreference { } var tmp prmexactreference if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , " " : & tmp . dockerreference , } ) ; err ! = nil { return err } if tmp . type ! = prmtypeexactreference { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } res , err : = newprmexactreference ( tmp . dockerreference ) if err ! = nil { return err } * prm = * res return nil } 
func newprmexactrepository ( dockerrepository string ) ( * prmexactrepository , error ) { if , err : = reference . parsenormalizednamed ( dockerrepository ) ; err ! = nil { return nil , invalidpolicyformaterror ( fmt . sprintf ( " " , dockerrepository , err . error ( ) ) ) } return & prmexactrepository { prmcommon : prmcommon { type : prmtypeexactrepository } , dockerrepository : dockerrepository , } , nil } 
func ( prm * prmexactrepository ) unmarshaljson ( data [ ] byte ) error { * prm = prmexactrepository { } var tmp prmexactrepository if err : = paranoidunmarshaljsonobjectexactfields ( data , map [ string ] interface { } { " " : & tmp . type , " " : & tmp . dockerrepository , } ) ; err ! = nil { return err } if tmp . type ! = prmtypeexactrepository { return invalidpolicyformaterror ( fmt . sprintf ( " " " " , tmp . type ) ) } res , err : = newprmexactrepository ( tmp . dockerrepository ) if err ! = nil { return err } * prm = * res return nil } 
func newimagesource ( imageref storagereference ) ( * storageimagesource , error ) { img , err : = imageref . resolveimage ( ) if err ! = nil { return nil , err } image : = & storageimagesource { imageref : imageref , image : img , layerposition : make ( map [ digest . digest ] int ) , signaturesizes : [ ] int { } , } if img . metadata ! = " " { if err : = json . unmarshal ( [ ] byte ( img . metadata ) , image ) ; err ! = nil { return nil , errors . wrap ( err , " " ) } } return image , nil } 
func ( s * storageimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( manifestblob [ ] byte , mimetype string , err error ) { if instancedigest ! = nil { return nil , " " , errnomanifestlists } if len ( s . cachedmanifest ) == 0 { if s . imageref . named ! = nil { if digested , ok : = s . imageref . named . ( reference . digested ) ; ok { key : = manifestbigdatakey ( digested . digest ( ) ) blob , err : = s . imageref . transport . store . imagebigdata ( s . image . id , key ) if err ! = nil && ! os . isnotexist ( err ) { return nil , " " , err } if err == nil { s . cachedmanifest = blob } } } if len ( s . cachedmanifest ) == 0 { cachedblob , err : = s . imageref . transport . store . imagebigdata ( s . image . id , storage . imagedigestbigdatakey ) if err ! = nil { return nil , " " , err } s . cachedmanifest = cachedblob } } return s . cachedmanifest , manifest . guessmimetype ( s . cachedmanifest ) , err } 
func ( s * storageimagesource ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( signatures [ ] [ ] byte , err error ) { if instancedigest ! = nil { return nil , errnomanifestlists } var offset int sigslice : = [ ] [ ] byte { } signature : = [ ] byte { } if len ( s . signaturesizes ) > 0 { signatureblob , err : = s . imageref . transport . store . imagebigdata ( s . image . id , " " ) if err ! = nil { return nil , errors . wrapf ( err , " " , s . image . id ) } signature = signatureblob } for , length : = range s . signaturesizes { sigslice = append ( sigslice , signature [ offset : offset + length ] ) offset += length } if offset ! = len ( signature ) { return nil , errors . errorf ( " " , len ( signatures ) - offset ) } return sigslice , nil } 
func newimagedestination ( imageref storagereference ) ( * storageimagedestination , error ) { directory , err : = ioutil . tempdir ( tmpdir . temporarydirectoryforbigfiles ( ) , " " ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } image : = & storageimagedestination { imageref : imageref , directory : directory , blobdiffids : make ( map [ digest . digest ] digest . digest ) , filesizes : make ( map [ digest . digest ] int64 ) , filenames : make ( map [ digest . digest ] string ) , signaturesizes : [ ] int { } , } return image , nil } 
func ( s * storageimagedestination ) computeid ( m manifest . manifest ) string { var diffids [ ] digest . digest switch m : = m . ( type ) { case * manifest . schema1 : for i , compat : = range m . extractedv1compatibility { if compat . throwaway { continue } blobsum : = m . fslayers [ i ] . blobsum diffid , ok : = s . blobdiffids [ blobsum ] if ! ok { logrus . infof ( " " , blobsum . string ( ) ) return " " } diffids = append ( [ ] digest . digest { diffid } , diffids ... ) } case * manifest . schema2 , * manifest . oci1 : default : return " " } id , err : = m . imageid ( diffids ) if err ! = nil { return " " } return id } 
func ( s * storageimagedestination ) getconfigblob ( info types . blobinfo ) ( [ ] byte , error ) { if info . digest == " " { return nil , errors . errorf ( ' no digest supplied when reading blob ' ) } if err : = info . digest . validate ( ) ; err ! = nil { return nil , errors . wrapf ( err , ' invalid digest supplied when reading blob ' ) } if filename , ok : = s . filenames [ info . digest ] ; ok { contents , err2 : = ioutil . readfile ( filename ) if err2 ! = nil { return nil , errors . wrapf ( err2 , ' error reading blob from file % q ' , filename ) } return contents , nil } return nil , errors . new ( " " ) } 
func ( s * storageimagedestination ) putmanifest ( ctx context . context , manifestblob [ ] byte ) error { if s . imageref . named ! = nil { if digested , ok : = s . imageref . named . ( reference . digested ) ; ok { matches , err : = manifest . matchesdigest ( manifestblob , digested . digest ( ) ) if err ! = nil { return err } if ! matches { return fmt . errorf ( " " , digested . digest ( ) ) } } } s . manifest = make ( [ ] byte , len ( manifestblob ) ) copy ( s . manifest , manifestblob ) return nil } 
func ( s * storageimagedestination ) putsignatures ( ctx context . context , signatures [ ] [ ] byte ) error { sizes : = [ ] int { } sigblob : = [ ] byte { } for , sig : = range signatures { sizes = append ( sizes , len ( sig ) ) newblob : = make ( [ ] byte , len ( sigblob ) + len ( sig ) ) copy ( newblob , sigblob ) copy ( newblob [ len ( sigblob ) : ] , sig ) sigblob = newblob } s . signatures = sigblob s . signaturesizes = sizes return nil } 
func ( s * storageimagesource ) getsize ( ) ( int64 , error ) { var sum int64 datanames , err : = s . imageref . transport . store . listimagebigdata ( s . image . id ) if err ! = nil { return - 1 , errors . wrapf ( err , " " , s . image . id ) } for , dataname : = range datanames { bigsize , err : = s . imageref . transport . store . imagebigdatasize ( s . image . id , dataname ) if err ! = nil { return - 1 , errors . wrapf ( err , " " , dataname , s . image . id ) } sum += bigsize } for , sigsize : = range s . signaturesizes { sum += int64 ( sigsize ) } layerid : = s . image . toplayer for layerid ! = " " { layer , err : = s . imageref . transport . store . layer ( layerid ) if err ! = nil { return - 1 , err } if layer . uncompresseddigest == " " | | layer . uncompressedsize < 0 { return - 1 , errors . errorf ( " " , layerid ) } sum += layer . uncompressedsize if layer . parent == " " { break } layerid = layer . parent } return sum , nil } 
func newimage ( ctx context . context , sys * types . systemcontext , s storagereference ) ( types . imagecloser , error ) { src , err : = newimagesource ( s ) if err ! = nil { return nil , err } img , err : = image . fromsource ( ctx , sys , src ) if err ! = nil { return nil , err } size , err : = src . getsize ( ) if err ! = nil { return nil , err } return & storageimagecloser { imagecloser : img , size : size } , nil } 
func newimagesource ( ctx context . context , ref archivereference ) ( types . imagesource , error ) { if ref . destinationref ! = nil { logrus . warnf ( " " ) } src , err : = tarfile . newsourcefromfile ( ref . path ) if err ! = nil { return nil , err } return & archiveimagesource { source : src , ref : ref , } , nil } 
func ( nocache ) candidatelocations ( transport types . imagetransport , scope types . bictransportscope , digest digest . digest , cansubstitute bool ) [ ] types . bicreplacementcandidate { return nil } 
func newgpgsigningmechanismindirectory ( optionaldir string ) ( signingmechanism , error ) { m : = & openpgpsigningmechanism { keyring : openpgp . entitylist { } , } gpghome : = optionaldir if gpghome == " " { gpghome = os . getenv ( " " ) if gpghome == " " { gpghome = path . join ( homedir . get ( ) , " " ) } } pubring , err : = ioutil . readfile ( path . join ( gpghome , " " ) ) if err ! = nil { if ! os . isnotexist ( err ) { return nil , err } } else { , err : = m . importkeysfrombytes ( pubring ) if err ! = nil { return nil , err } } return m , nil } 
func newephemeralgpgsigningmechanism ( blob [ ] byte ) ( signingmechanism , [ ] string , error ) { m : = & openpgpsigningmechanism { keyring : openpgp . entitylist { } , } keyidentities , err : = m . importkeysfrombytes ( blob ) if err ! = nil { return nil , nil , err } return m , keyidentities , nil } 
func ( m * openpgpsigningmechanism ) importkeysfrombytes ( blob [ ] byte ) ( [ ] string , error ) { keyring , err : = openpgp . readkeyring ( bytes . newreader ( blob ) ) if err ! = nil { k , e2 : = openpgp . readarmoredkeyring ( bytes . newreader ( blob ) ) if e2 ! = nil { return nil , err } keyring = k } keyidentities : = [ ] string { } for , entity : = range keyring { if entity . primarykey == nil { continue } keyidentities = append ( keyidentities , strings . toupper ( fmt . sprintf ( " " , entity . primarykey . fingerprint ) ) ) m . keyring = append ( m . keyring , entity ) } return keyidentities , nil } 
func ( m * openpgpsigningmechanism ) sign ( input [ ] byte , keyidentity string ) ( [ ] byte , error ) { return nil , signingnotsupportederror ( " " ) } 
func ( m * openpgpsigningmechanism ) verify ( unverifiedsignature [ ] byte ) ( contents [ ] byte , keyidentity string , err error ) { md , err : = openpgp . readmessage ( bytes . newreader ( unverifiedsignature ) , m . keyring , nil , nil ) if err ! = nil { return nil , " " , err } if ! md . issigned { return nil , " " , errors . new ( " " ) } content , err : = ioutil . readall ( md . unverifiedbody ) if err ! = nil { return nil , " " , err } if md . signatureerror ! = nil { return nil , " " , fmt . errorf ( " " , md . signatureerror ) } if md . signedby == nil { return nil , " " , invalidsignatureerror { msg : fmt . sprintf ( " " , md . signature ) } } if md . signature ! = nil { if md . signature . siglifetimesecs ! = nil { expiry : = md . signature . creationtime . add ( time . duration ( * md . signature . siglifetimesecs ) * time . second ) if time . now ( ) . after ( expiry ) { return nil , " " , invalidsignatureerror { msg : fmt . sprintf ( " " , expiry ) } } } } else if md . signaturev3 == nil { return nil , " " , invalidsignatureerror { msg : " " } } return content , strings . toupper ( fmt . sprintf ( " " , md . signedby . publickey . fingerprint ) ) , nil } 
func ( m openpgpsigningmechanism ) untrustedsignaturecontents ( untrustedsignature [ ] byte ) ( untrustedcontents [ ] byte , shortkeyidentifier string , err error ) { return gpguntrustedsignaturecontents ( untrustedsignature ) } 
func newimagesource ( ctx context . context , sys * types . systemcontext , ref ociarchivereference ) ( types . imagesource , error ) { tempdirref , err : = createuntartempdir ( ref ) if err ! = nil { return nil , errors . wrap ( err , " " ) } unpackedsrc , err : = tempdirref . ocirefextracted . newimagesource ( ctx , sys ) if err ! = nil { if err : = tempdirref . deletetempdir ( ) ; err ! = nil { return nil , errors . wrapf ( err , " " , tempdirref . tempdirectory ) } return nil , err } return & ociarchiveimagesource { ref : ref , unpackedsrc : unpackedsrc , tempdirref : tempdirref } , nil } 
func loadmanifestdescriptor ( imgref types . imagereference ) ( imgspecv1 . descriptor , error ) { ociarchref , ok : = imgref . ( ociarchivereference ) if ! ok { return imgspecv1 . descriptor { } , errors . errorf ( " " ) } tempdirref , err : = createuntartempdir ( ociarchref ) if err ! = nil { return imgspecv1 . descriptor { } , errors . wrap ( err , " " ) } defer tempdirref . deletetempdir ( ) descriptor , err : = ocilayout . loadmanifestdescriptor ( tempdirref . ocirefextracted ) if err ! = nil { return imgspecv1 . descriptor { } , errors . wrap ( err , " " ) } return descriptor , nil } 
func ( s * ociarchiveimagesource ) close ( ) error { defer s . tempdirref . deletetempdir ( ) return s . unpackedsrc . close ( ) } 
func ( s * ociarchiveimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { return s . unpackedsrc . getmanifest ( ctx , instancedigest ) } 
func ( s * ociarchiveimagesource ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { return s . unpackedsrc . getsignatures ( ctx , instancedigest ) } 
func ( os * orderedset ) append ( s string ) { if , ok : = os . included [ s ] ; ! ok { os . list = append ( os . list , s ) os . included [ s ] = struct { } { } } } 
func ismultiimage ( ctx context . context , img types . unparsedimage ) ( bool , error ) { , mt , err : = img . manifest ( ctx ) if err ! = nil { return false , err } return manifest . mimetypeismultiimage ( mt ) , nil } 
func lockpath ( path string ) { pl : = func ( ) * pathlock { pathlocksmutex . lock ( ) defer pathlocksmutex . unlock ( ) pl , ok : = pathlocks [ path ] if ok { pl . refcount ++ } else { pl = & pathlock { refcount : 1 , mutex : sync . mutex { } } pathlocks [ path ] = pl } return pl } ( ) pl . mutex . lock ( ) } 
func unlockpath ( path string ) { pathlocksmutex . lock ( ) defer pathlocksmutex . unlock ( ) pl , ok : = pathlocks [ path ] if ! ok { panic ( fmt . sprintf ( " " , path ) ) } pl . mutex . unlock ( ) pl . refcount -- if pl . refcount == 0 { delete ( pathlocks , path ) } } 
func ( bdc * cache ) view ( fn func ( tx * bolt . tx ) error ) ( reterr error ) { if , err : = os . lstat ( bdc . path ) ; err ! = nil && os . isnotexist ( err ) { return err } lockpath ( bdc . path ) defer unlockpath ( bdc . path ) db , err : = bolt . open ( bdc . path , 0600 , & bolt . options { readonly : true } ) if err ! = nil { return err } defer func ( ) { if err : = db . close ( ) ; reterr == nil && err ! = nil { reterr = err } } ( ) return db . view ( fn ) } 
func ( bdc * cache ) update ( fn func ( tx * bolt . tx ) error ) ( reterr error ) { lockpath ( bdc . path ) defer unlockpath ( bdc . path ) db , err : = bolt . open ( bdc . path , 0600 , nil ) if err ! = nil { return err } defer func ( ) { if err : = db . close ( ) ; reterr == nil && err ! = nil { reterr = err } } ( ) return db . update ( fn ) } 
func ( bdc * cache ) uncompresseddigest ( tx * bolt . tx , anydigest digest . digest ) digest . digest { if b : = tx . bucket ( uncompresseddigestbucket ) ; b ! = nil { if uncompressedbytes : = b . get ( [ ] byte ( anydigest . string ( ) ) ) ; uncompressedbytes ! = nil { d , err : = digest . parse ( string ( uncompressedbytes ) ) if err == nil { return d } } } if b : = tx . bucket ( digestbyuncompressedbucket ) ; b ! = nil { if b = b . bucket ( [ ] byte ( anydigest . string ( ) ) ) ; b ! = nil { c : = b . cursor ( ) if k , : = c . first ( ) ; k ! = nil { return anydigest } } } return " " } 
func ( bdc * cache ) uncompresseddigest ( anydigest digest . digest ) digest . digest { var res digest . digest if err : = bdc . view ( func ( tx * bolt . tx ) error { res = bdc . uncompresseddigest ( tx , anydigest ) return nil } ) ; err ! = nil { return " " } return res } 
func ( bdc * cache ) recorddigestuncompressedpair ( anydigest digest . digest , uncompressed digest . digest ) { = bdc . update ( func ( tx * bolt . tx ) error { b , err : = tx . createbucketifnotexists ( uncompresseddigestbucket ) if err ! = nil { return err } key : = [ ] byte ( anydigest . string ( ) ) if previousbytes : = b . get ( key ) ; previousbytes ! = nil { previous , err : = digest . parse ( string ( previousbytes ) ) if err ! = nil { return err } if previous ! = uncompressed { logrus . warnf ( " " , anydigest , previous , uncompressed ) } } if err : = b . put ( key , [ ] byte ( uncompressed . string ( ) ) ) ; err ! = nil { return err } b , err = tx . createbucketifnotexists ( digestbyuncompressedbucket ) if err ! = nil { return err } b , err = b . createbucketifnotexists ( [ ] byte ( uncompressed . string ( ) ) ) if err ! = nil { return err } if err : = b . put ( [ ] byte ( anydigest . string ( ) ) , [ ] byte { } ) ; err ! = nil { return err } return nil } ) } 
func ( bdc * cache ) recordknownlocation ( transport types . imagetransport , scope types . bictransportscope , blobdigest digest . digest , location types . biclocationreference ) { = bdc . update ( func ( tx * bolt . tx ) error { b , err : = tx . createbucketifnotexists ( knownlocationsbucket ) if err ! = nil { return err } b , err = b . createbucketifnotexists ( [ ] byte ( transport . name ( ) ) ) if err ! = nil { return err } b , err = b . createbucketifnotexists ( [ ] byte ( scope . opaque ) ) if err ! = nil { return err } b , err = b . createbucketifnotexists ( [ ] byte ( blobdigest . string ( ) ) ) if err ! = nil { return err } value , err : = time . now ( ) . marshalbinary ( ) if err ! = nil { return err } if err : = b . put ( [ ] byte ( location . opaque ) , value ) ; err ! = nil { return err } return nil } ) } 
func ( bdc * cache ) appendreplacementcandidates ( candidates [ ] prioritize . candidatewithtime , scopebucket * bolt . bucket , digest digest . digest ) [ ] prioritize . candidatewithtime { b : = scopebucket . bucket ( [ ] byte ( digest . string ( ) ) ) if b == nil { return candidates } = b . foreach ( func ( k , v [ ] byte ) error { t : = time . time { } if err : = t . unmarshalbinary ( v ) ; err ! = nil { return err } candidates = append ( candidates , prioritize . candidatewithtime { candidate : types . bicreplacementcandidate { digest : digest , location : types . biclocationreference { opaque : string ( k ) } , } , lastseen : t , } ) return nil } ) return candidates } 
func temporarydirectoryforbigfiles ( ) string { var temporarydirectoryforbigfiles string if runtime . goos == " " { temporarydirectoryforbigfiles = os . tempdir ( ) } else { temporarydirectoryforbigfiles = unixtempdirforbigfiles } return temporarydirectoryforbigfiles } 
func gpguntrustedsignaturecontents ( untrustedsignature [ ] byte ) ( untrustedcontents [ ] byte , shortkeyidentifier string , err error ) { md , err : = openpgp . readmessage ( bytes . newreader ( untrustedsignature ) , openpgp . entitylist { } , nil , nil ) if err ! = nil { return nil , " " , err } if ! md . issigned { return nil , " " , errors . new ( " " ) } content , err : = ioutil . readall ( md . unverifiedbody ) if err ! = nil { return nil , " " , err } return content , strings . toupper ( fmt . sprintf ( " " , md . signedbykeyid ) ) , nil } 
func newimagedestination ( sys * types . systemcontext , ref ocireference ) ( types . imagedestination , error ) { var index * imgspecv1 . index if indexexists ( ref ) { var err error index , err = ref . getindex ( ) if err ! = nil { return nil , err } } else { index = & imgspecv1 . index { versioned : imgspec . versioned { schemaversion : 2 , } , } } d : = & ociimagedestination { ref : ref , index : * index } if sys ! = nil { d . sharedblobdir = sys . ocisharedblobdirpath d . acceptuncompressedlayers = sys . ociacceptuncompressedlayers } if err : = ensuredirectoryexists ( d . ref . dir ) ; err ! = nil { return nil , err } if err : = ensuredirectoryexists ( filepath . join ( d . ref . dir , " " ) ) ; err ! = nil { return nil , err } return d , nil } 
func ( d * ociimagedestination ) tryreusingblob ( ctx context . context , info types . blobinfo , cache types . blobinfocache , cansubstitute bool ) ( bool , types . blobinfo , error ) { if info . digest == " " { return false , types . blobinfo { } , errors . errorf ( ' " can not check for a blob with unknown digest ' ) } blobpath , err : = d . ref . blobpath ( info . digest , d . sharedblobdir ) if err ! = nil { return false , types . blobinfo { } , err } finfo , err : = os . stat ( blobpath ) if err ! = nil && os . isnotexist ( err ) { return false , types . blobinfo { } , nil } if err ! = nil { return false , types . blobinfo { } , err } return true , types . blobinfo { digest : info . digest , size : finfo . size ( ) } , nil } 
func ( d * ociimagedestination ) putmanifest ( ctx context . context , m [ ] byte ) error { digest , err : = manifest . digest ( m ) if err ! = nil { return err } desc : = imgspecv1 . descriptor { } desc . digest = digest desc . mediatype = imgspecv1 . mediatypeimagemanifest desc . size = int64 ( len ( m ) ) blobpath , err : = d . ref . blobpath ( digest , d . sharedblobdir ) if err ! = nil { return err } if err : = ensureparentdirectoryexists ( blobpath ) ; err ! = nil { return err } if err : = ioutil . writefile ( blobpath , m , 0644 ) ; err ! = nil { return err } if d . ref . image ! = " " { annotations : = make ( map [ string ] string ) annotations [ " " ] = d . ref . image desc . annotations = annotations } desc . platform = & imgspecv1 . platform { architecture : runtime . goarch , os : runtime . goos , } d . addmanifest ( & desc ) return nil } 
func ( d * ociimagedestination ) commit ( ctx context . context ) error { if err : = ioutil . writefile ( d . ref . ocilayoutpath ( ) , [ ] byte ( ' { " imagelayoutversion " : " 1 . 0 . 0 " } ' ) , 0644 ) ; err ! = nil { return err } indexjson , err : = json . marshal ( d . index ) if err ! = nil { return err } return ioutil . writefile ( d . ref . indexpath ( ) , indexjson , 0644 ) } 
func indexexists ( ref ocireference ) bool { , err : = os . stat ( ref . indexpath ( ) ) if err == nil { return true } if os . isnotexist ( err ) { return false } return true } 
func ( c * copier ) createsignature ( manifest [ ] byte , keyidentity string ) ( [ ] byte , error ) { mech , err : = signature . newgpgsigningmechanism ( ) if err ! = nil { return nil , errors . wrap ( err , " " ) } defer mech . close ( ) if err : = mech . supportssigning ( ) ; err ! = nil { return nil , errors . wrap ( err , " " ) } dockerreference : = c . dest . reference ( ) . dockerreference ( ) if dockerreference == nil { return nil , errors . errorf ( " " , transports . imagename ( c . dest . reference ( ) ) ) } c . printf ( " \n " ) newsig , err : = signature . signdockermanifest ( manifest , dockerreference . string ( ) , mech , keyidentity ) if err ! = nil { return nil , errors . wrap ( err , " " ) } return newsig , nil } 
func manifestinstancefromblob ( ctx context . context , sys * types . systemcontext , src types . imagesource , manblob [ ] byte , mt string ) ( genericmanifest , error ) { switch manifest . normalizedmimetype ( mt ) { case manifest . dockerv2schema1mediatype , manifest . dockerv2schema1signedmediatype : return manifestschema1frommanifest ( manblob ) case imgspecv1 . mediatypeimagemanifest : return manifestoci1frommanifest ( src , manblob ) case manifest . dockerv2schema2mediatype : return manifestschema2frommanifest ( src , manblob ) case manifest . dockerv2listmediatype : return manifestschema2frommanifestlist ( ctx , sys , src , manblob ) default : return nil , fmt . errorf ( " " , mt ) } } 
func manifestlayerinfostoblobinfos ( layers [ ] manifest . layerinfo ) [ ] types . blobinfo { blobs : = make ( [ ] types . blobinfo , len ( layers ) ) for i , layer : = range layers { blobs [ i ] = layer . blobinfo } return blobs } 
func ( d * archiveimagedestination ) commit ( ctx context . context ) error { return d . destination . commit ( ctx ) } 
func ( t ocitransport ) parsereference ( reference string ) ( types . imagereference , error ) { return parsereference ( reference ) } 
func parsereference ( reference string ) ( types . imagereference , error ) { dir , image : = internal . splitpathandimage ( reference ) return newreference ( dir , image ) } 
func newreference ( dir , image string ) ( types . imagereference , error ) { resolved , err : = explicitfilepath . resolvepathtofullyexplicit ( dir ) if err ! = nil { return nil , err } if err : = internal . validateocipath ( dir ) ; err ! = nil { return nil , err } if err = internal . validateimagename ( image ) ; err ! = nil { return nil , err } return ocireference { dir : dir , resolveddir : resolved , image : image } , nil } 
func ( ref ocireference ) stringwithintransport ( ) string { return fmt . sprintf ( " " , ref . dir , ref . image ) } 
func ( ref ocireference ) policyconfigurationnamespaces ( ) [ ] string { res : = [ ] string { } path : = ref . resolveddir for { lastslash : = strings . lastindex ( path , " " ) if lastslash == - 1 | | path == " " { break } res = append ( res , path ) path = path [ : lastslash ] } return res } 
func ( ref ocireference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { src , err : = newimagesource ( sys , ref ) if err ! = nil { return nil , err } return image . fromsource ( ctx , sys , src ) } 
func ( ref ocireference ) getindex ( ) ( * imgspecv1 . index , error ) { indexjson , err : = os . open ( ref . indexpath ( ) ) if err ! = nil { return nil , err } defer indexjson . close ( ) index : = & imgspecv1 . index { } if err : = json . newdecoder ( indexjson ) . decode ( index ) ; err ! = nil { return nil , err } return index , nil } 
func loadmanifestdescriptor ( imgref types . imagereference ) ( imgspecv1 . descriptor , error ) { ociref , ok : = imgref . ( ocireference ) if ! ok { return imgspecv1 . descriptor { } , errors . errorf ( " " ) } return ociref . getmanifestdescriptor ( ) } 
func ( ref ocireference ) blobpath ( digest digest . digest , sharedblobdir string ) ( string , error ) { if err : = digest . validate ( ) ; err ! = nil { return " " , errors . wrapf ( err , " " , digest ) } blobdir : = filepath . join ( ref . dir , " " ) if sharedblobdir ! = " " { blobdir = sharedblobdir } return filepath . join ( blobdir , digest . algorithm ( ) . string ( ) , digest . hex ( ) ) , nil } 
func signdockermanifest ( m [ ] byte , dockerreference string , mech signingmechanism , keyidentity string ) ( [ ] byte , error ) { manifestdigest , err : = manifest . digest ( m ) if err ! = nil { return nil , err } sig : = newuntrustedsignature ( manifestdigest , dockerreference ) return sig . sign ( mech , keyidentity ) } 
func verifydockermanifestsignature ( unverifiedsignature , unverifiedmanifest [ ] byte , expecteddockerreference string , mech signingmechanism , expectedkeyidentity string ) ( * signature , error ) { expectedref , err : = reference . parsenormalizednamed ( expecteddockerreference ) if err ! = nil { return nil , err } sig , err : = verifyandextractsignature ( mech , unverifiedsignature , signatureacceptancerules { validatekeyidentity : func ( keyidentity string ) error { if keyidentity ! = expectedkeyidentity { return invalidsignatureerror { msg : fmt . sprintf ( " " , keyidentity , expectedkeyidentity ) } } return nil } , validatesigneddockerreference : func ( signeddockerreference string ) error { signedref , err : = reference . parsenormalizednamed ( signeddockerreference ) if err ! = nil { return invalidsignatureerror { msg : fmt . sprintf ( " " , signeddockerreference ) } } if signedref . string ( ) ! = expectedref . string ( ) { return invalidsignatureerror { msg : fmt . sprintf ( " " , signeddockerreference , expecteddockerreference ) } } return nil } , validatesigneddockermanifestdigest : func ( signeddockermanifestdigest digest . digest ) error { matches , err : = manifest . matchesdigest ( unverifiedmanifest , signeddockermanifestdigest ) if err ! = nil { return err } if ! matches { return invalidsignatureerror { msg : fmt . sprintf ( " " , signeddockermanifestdigest ) } } return nil } , } ) if err ! = nil { return nil , err } return sig , nil } 
func newopenshiftclient ( ref openshiftreference ) ( * openshiftclient , error ) { cmdconfig : = defaultclientconfig ( ) logrus . debugf ( " " , cmdconfig ) restconfig , err : = cmdconfig . clientconfig ( ) if err ! = nil { return nil , err } logrus . debugf ( " " , restconfig ) baseurl , httpclient , err : = restclientfor ( restconfig ) if err ! = nil { return nil , err } logrus . debugf ( " " , * baseurl ) if httpclient == nil { httpclient = http . defaultclient } return & openshiftclient { ref : ref , baseurl : baseurl , httpclient : httpclient , bearertoken : restconfig . bearertoken , username : restconfig . username , password : restconfig . password , } , nil } 
func ( c * openshiftclient ) getimage ( ctx context . context , imagestreamimagename string ) ( * image , error ) { path : = fmt . sprintf ( " " , c . ref . namespace , c . ref . stream , imagestreamimagename ) body , err : = c . dorequest ( ctx , " " , path , nil ) if err ! = nil { return nil , err } var isi imagestreamimage if err : = json . unmarshal ( body , & isi ) ; err ! = nil { return nil , err } return & isi . image , nil } 
func ( c * openshiftclient ) convertdockerimagereference ( ref string ) ( string , error ) { parts : = strings . splitn ( ref , " " , 2 ) if len ( parts ) ! = 2 { return " " , errors . errorf ( " " , ref ) } return reference . domain ( c . ref . dockerreference ) + " " + parts [ 1 ] , nil } 
func newimagesource ( sys * types . systemcontext , ref openshiftreference ) ( types . imagesource , error ) { client , err : = newopenshiftclient ( ref ) if err ! = nil { return nil , err } return & openshiftimagesource { client : client , sys : sys , } , nil } 
func ( s * openshiftimagesource ) close ( ) error { if s . docker ! = nil { err : = s . docker . close ( ) s . docker = nil return err } return nil } 
func ( s * openshiftimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { if err : = s . ensureimageisresolved ( ctx ) ; err ! = nil { return nil , " " , err } return s . docker . getmanifest ( ctx , instancedigest ) } 
func ( s * openshiftimagesource ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { var imagename string if instancedigest == nil { if err : = s . ensureimageisresolved ( ctx ) ; err ! = nil { return nil , err } imagename = s . imagestreamimagename } else { imagename = instancedigest . string ( ) } image , err : = s . client . getimage ( ctx , imagename ) if err ! = nil { return nil , err } var sigs [ ] [ ] byte for , sig : = range image . signatures { if sig . type == imagesignaturetypeatomic { sigs = append ( sigs , sig . content ) } } return sigs , nil } 
func ( s * openshiftimagesource ) ensureimageisresolved ( ctx context . context ) error { if s . docker ! = nil { return nil } path : = fmt . sprintf ( " " , s . client . ref . namespace , s . client . ref . stream ) body , err : = s . client . dorequest ( ctx , " " , path , nil ) if err ! = nil { return err } var is imagestream if err : = json . unmarshal ( body , & is ) ; err ! = nil { return err } var te * tagevent for , tag : = range is . status . tags { if tag . tag ! = s . client . ref . dockerreference . tag ( ) { continue } if len ( tag . items ) > 0 { te = & tag . items [ 0 ] break } } if te == nil { return errors . errorf ( " " ) } logrus . debugf ( " " , te ) dockerrefstring , err : = s . client . convertdockerimagereference ( te . dockerimagereference ) if err ! = nil { return err } logrus . debugf ( " " , dockerrefstring ) dockerref , err : = docker . parsereference ( " " + dockerrefstring ) if err ! = nil { return err } d , err : = dockerref . newimagesource ( ctx , s . sys ) if err ! = nil { return err } s . docker = d s . imagestreamimagename = te . image return nil } 
func newimagedestination ( ctx context . context , sys * types . systemcontext , ref openshiftreference ) ( types . imagedestination , error ) { client , err : = newopenshiftclient ( ref ) if err ! = nil { return nil , err } dockerrefstring : = fmt . sprintf ( " " , reference . domain ( client . ref . dockerreference ) , client . ref . namespace , client . ref . stream , client . ref . dockerreference . tag ( ) ) dockerref , err : = docker . parsereference ( dockerrefstring ) if err ! = nil { return nil , err } docker , err : = dockerref . newimagedestination ( ctx , sys ) if err ! = nil { return nil , err } return & openshiftimagedestination { client : client , docker : docker , } , nil } 
func ( d * openshiftimagedestination ) tryreusingblob ( ctx context . context , info types . blobinfo , cache types . blobinfocache , cansubstitute bool ) ( bool , types . blobinfo , error ) { return d . docker . tryreusingblob ( ctx , info , cache , cansubstitute ) } 
func ( d * openshiftimagedestination ) putmanifest ( ctx context . context , m [ ] byte ) error { manifestdigest , err : = manifest . digest ( m ) if err ! = nil { return err } d . imagestreamimagename = manifestdigest . string ( ) return d . docker . putmanifest ( ctx , m ) } 
func ( d * openshiftimagedestination ) commit ( ctx context . context ) error { return d . docker . commit ( ctx ) } 
func newuntrustedsignature ( dockermanifestdigest digest . digest , dockerreference string ) untrustedsignature { creatorid : = " " + version . version timestamp : = time . now ( ) . unix ( ) return untrustedsignature { untrusteddockermanifestdigest : dockermanifestdigest , untrusteddockerreference : dockerreference , untrustedcreatorid : & creatorid , untrustedtimestamp : & timestamp , } } 
func ( s untrustedsignature ) marshaljson ( ) ( [ ] byte , error ) { if s . untrusteddockermanifestdigest == " " | | s . untrusteddockerreference == " " { return nil , errors . new ( " " ) } critical : = map [ string ] interface { } { " " : signaturetype , " " : map [ string ] string { " " : s . untrusteddockermanifestdigest . string ( ) } , " " : map [ string ] string { " " : s . untrusteddockerreference } , } optional : = map [ string ] interface { } { } if s . untrustedcreatorid ! = nil { optional [ " " ] = * s . untrustedcreatorid } if s . untrustedtimestamp ! = nil { optional [ " " ] = * s . untrustedtimestamp } signature : = map [ string ] interface { } { " " : critical , " " : optional , } return json . marshal ( signature ) } 
func ( s * untrustedsignature ) unmarshaljson ( data [ ] byte ) error { err : = s . strictunmarshaljson ( data ) if err ! = nil { if , ok : = err . ( jsonformaterror ) ; ok { err = invalidsignatureerror { msg : err . error ( ) } } } return err } 
func verifyandextractsignature ( mech signingmechanism , unverifiedsignature [ ] byte , rules signatureacceptancerules ) ( * signature , error ) { signed , keyidentity , err : = mech . verify ( unverifiedsignature ) if err ! = nil { return nil , err } if err : = rules . validatekeyidentity ( keyidentity ) ; err ! = nil { return nil , err } var unmatchedsignature untrustedsignature if err : = json . unmarshal ( signed , & unmatchedsignature ) ; err ! = nil { return nil , invalidsignatureerror { msg : err . error ( ) } } if err : = rules . validatesigneddockermanifestdigest ( unmatchedsignature . untrusteddockermanifestdigest ) ; err ! = nil { return nil , err } if err : = rules . validatesigneddockerreference ( unmatchedsignature . untrusteddockerreference ) ; err ! = nil { return nil , err } return & signature { dockermanifestdigest : unmatchedsignature . untrusteddockermanifestdigest , dockerreference : unmatchedsignature . untrusteddockerreference , } , nil } 
func getuntrustedsignatureinformationwithoutverifying ( untrustedsignaturebytes [ ] byte ) ( * untrustedsignatureinformation , error ) { mech , , err : = newephemeralgpgsigningmechanism ( [ ] byte { } ) if err ! = nil { return nil , err } defer mech . close ( ) untrustedcontents , shortkeyidentifier , err : = mech . untrustedsignaturecontents ( untrustedsignaturebytes ) if err ! = nil { return nil , err } var untrusteddecodedcontents untrustedsignature if err : = json . unmarshal ( untrustedcontents , & untrusteddecodedcontents ) ; err ! = nil { return nil , invalidsignatureerror { msg : err . error ( ) } } var timestamp * time . time if untrusteddecodedcontents . untrustedtimestamp ! = nil { ts : = time . unix ( * untrusteddecodedcontents . untrustedtimestamp , 0 ) timestamp = & ts } return & untrustedsignatureinformation { untrusteddockermanifestdigest : untrusteddecodedcontents . untrusteddockermanifestdigest , untrusteddockerreference : untrusteddecodedcontents . untrusteddockerreference , untrustedcreatorid : untrusteddecodedcontents . untrustedcreatorid , untrustedtimestamp : timestamp , untrustedshortkeyidentifier : shortkeyidentifier , } , nil } 
func ( t daemontransport ) parsereference ( reference string ) ( types . imagereference , error ) { return parsereference ( reference ) } 
func ( t daemontransport ) validatepolicyconfigurationscope ( scope string ) error { if , err : = digest . parse ( scope ) ; err == nil { return errors . errorf ( ' docker - daemon : can not use algo : digest value %s as a namespace ' , scope ) } return nil } 
func parsereference ( refstring string ) ( types . imagereference , error ) { if dgst , err : = digest . parse ( refstring ) ; err == nil { if dgst . algorithm ( ) ! = digest . canonical { return nil , errors . errorf ( " " , refstring , digest . canonical ) } return newreference ( dgst , nil ) } ref , err : = reference . parsenormalizednamed ( refstring ) if err ! = nil { return nil , err } if reference . familiarname ( ref ) == digest . canonical . string ( ) { return nil , errors . errorf ( " " , refstring , digest . canonical ) } return newreference ( " " , ref ) } 
func newreference ( id digest . digest , ref reference . named ) ( types . imagereference , error ) { if id ! = " " && ref ! = nil { return nil , errors . new ( " " ) } if ref ! = nil { if reference . isnameonly ( ref ) { return nil , errors . errorf ( " " , reference . familiarstring ( ref ) ) } , istagged : = ref . ( reference . namedtagged ) , isdigested : = ref . ( reference . canonical ) if istagged && isdigested { return nil , errors . errorf ( " " ) } } return daemonreference { id : id , ref : ref , } , nil } 
func ( ref daemonreference ) stringwithintransport ( ) string { switch { case ref . id ! = " " : return ref . id . string ( ) case ref . ref ! = nil : return reference . familiarstring ( ref . ref ) default : panic ( " " ) } } 
func ( ref daemonreference ) policyconfigurationidentity ( ) string { switch { case ref . id ! = " " : return " " case ref . ref ! = nil : res , err : = policyconfiguration . dockerreferenceidentity ( ref . ref ) if res == " " | | err ! = nil { panic ( fmt . sprintf ( " " , res , err ) ) } return res default : panic ( " " ) } } 
func ( ref daemonreference ) policyconfigurationnamespaces ( ) [ ] string { switch { case ref . id ! = " " : return [ ] string { } case ref . ref ! = nil : return policyconfiguration . dockerreferencenamespaces ( ref . ref ) default : panic ( " " ) } } 
func ( e * endpoint ) rewritereference ( ref reference . named , prefix string ) ( reference . named , error ) { if ref == nil { return nil , fmt . errorf ( " " ) } if prefix == " " { return ref , nil } refstring : = ref . string ( ) if refmatchesprefix ( refstring , prefix ) { newnamedref : = strings . replace ( refstring , prefix , e . location , 1 ) newparsedref , err : = reference . parsenamed ( newnamedref ) if newparsedref ! = nil { logrus . debugf ( " " , refstring , newparsedref . string ( ) ) } if err ! = nil { return nil , errors . wrapf ( err , " " ) } return newparsedref , nil } return nil , fmt . errorf ( " " , prefix , refstring ) } 
func getv1registries ( config * tomlconfig ) ( [ ] registry , error ) { regmap : = make ( map [ string ] * registry ) registryorder : = [ ] string { } getregistry : = func ( location string ) ( * registry , error ) { var err error location , err = parselocation ( location ) if err ! = nil { return nil , err } reg , exists : = regmap [ location ] if ! exists { reg = & registry { endpoint : endpoint { location : location } , mirrors : [ ] endpoint { } , prefix : location , } regmap [ location ] = reg registryorder = append ( registryorder , location ) } return reg , nil } for , search : = range config . v1tomlconfig . search . registries { reg , err : = getregistry ( search ) if err ! = nil { return nil , err } reg . search = true } for , blocked : = range config . v1tomlconfig . block . registries { reg , err : = getregistry ( blocked ) if err ! = nil { return nil , err } reg . blocked = true } for , insecure : = range config . v1tomlconfig . insecure . registries { reg , err : = getregistry ( insecure ) if err ! = nil { return nil , err } reg . insecure = true } registries : = [ ] registry { } for , location : = range registryorder { reg : = regmap [ location ] registries = append ( registries , * reg ) } return registries , nil } 
func postprocessregistries ( regs [ ] registry ) ( [ ] registry , error ) { var registries [ ] registry regmap : = make ( map [ string ] [ ] registry ) for , reg : = range regs { var err error reg . location , err = parselocation ( reg . location ) if err ! = nil { return nil , err } if reg . prefix == " " { reg . prefix = reg . location } else { reg . prefix , err = parselocation ( reg . prefix ) if err ! = nil { return nil , err } } for , mir : = range reg . mirrors { mir . location , err = parselocation ( mir . location ) if err ! = nil { return nil , err } } registries = append ( registries , reg ) regmap [ reg . location ] = append ( regmap [ reg . location ] , reg ) } for , reg : = range registries { others , : = regmap [ reg . location ] for , other : = range others { if reg . insecure ! = other . insecure { msg : = fmt . sprintf ( " " , reg . location ) return nil , & invalidregistries { s : msg } } if reg . blocked ! = other . blocked { msg : = fmt . sprintf ( " " , reg . location ) return nil , & invalidregistries { s : msg } } } } return registries , nil } 
func getconfigpath ( ctx * types . systemcontext ) string { confpath : = systemregistriesconfpath if ctx ! = nil { if ctx . systemregistriesconfpath ! = " " { confpath = ctx . systemregistriesconfpath } else if ctx . rootforimplicitabsolutepaths ! = " " { confpath = filepath . join ( ctx . rootforimplicitabsolutepaths , systemregistriesconfpath ) } } return confpath } 
func getregistries ( ctx * types . systemcontext ) ( [ ] registry , error ) { configpath : = getconfigpath ( ctx ) configmutex . lock ( ) defer configmutex . unlock ( ) if registries , incache : = configcache [ configpath ] ; incache { return registries , nil } config , err : = loadregistryconf ( configpath ) if err ! = nil { if os . isnotexist ( err ) && ( ctx == nil | | ctx . systemregistriesconfpath == " " ) { return [ ] registry { } , nil } return nil , err } registries : = config . registries v1registries , err : = getv1registries ( config ) if err ! = nil { return nil , err } if len ( v1registries ) > 0 { if len ( registries ) > 0 { return nil , & invalidregistries { s : " " } } registries = v1registries } registries , err = postprocessregistries ( registries ) if err ! = nil { return nil , err } configcache [ configpath ] = registries return registries , err } 
func findunqualifiedsearchregistries ( ctx * types . systemcontext ) ( [ ] registry , error ) { registries , err : = getregistries ( ctx ) if err ! = nil { return nil , err } unqualified : = [ ] registry { } for , reg : = range registries { if reg . search { unqualified = append ( unqualified , reg ) } } return unqualified , nil } 
func readregistryconf ( configpath string ) ( [ ] byte , error ) { configbytes , err : = ioutil . readfile ( configpath ) return configbytes , err } 
func loadregistryconf ( configpath string ) ( * tomlconfig , error ) { config : = & tomlconfig { } configbytes , err : = readconf ( configpath ) if err ! = nil { return nil , err } err = toml . unmarshal ( configbytes , & config ) return config , err } 
func ( s stubtransport ) parsereference ( reference string ) ( types . imagereference , error ) { return nil , fmt . errorf ( ' the transport " %s : " is not supported in this build ' , string ( s ) ) } 
func fromsource ( ctx context . context , sys * types . systemcontext , src types . imagesource ) ( types . imagecloser , error ) { img , err : = fromunparsedimage ( ctx , sys , unparsedinstance ( src , nil ) ) if err ! = nil { return nil , err } return & imagecloser { image : img , src : src , } , nil } 
func fromunparsedimage ( ctx context . context , sys * types . systemcontext , unparsed * unparsedimage ) ( types . image , error ) { manifestblob , manifestmimetype , err : = unparsed . manifest ( ctx ) if err ! = nil { return nil , err } parsedmanifest , err : = manifestinstancefromblob ( ctx , sys , unparsed . src , manifestblob , manifestmimetype ) if err ! = nil { return nil , err } return & sourcedimage { unparsedimage : unparsed , manifestblob : manifestblob , manifestmimetype : manifestmimetype , genericmanifest : parsedmanifest , } , nil } 
func ( i * sourcedimage ) manifest ( ctx context . context ) ( [ ] byte , string , error ) { return i . manifestblob , i . manifestmimetype , nil } 
func ( r * tarballreference ) configupdate ( config imgspecv1 . image , annotations map [ string ] string ) error { r . config = config if r . annotations == nil { r . annotations = make ( map [ string ] string ) } for k , v : = range annotations { r . annotations [ k ] = v } return nil } 
func ( r * tarballreference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { src , err : = r . newimagesource ( ctx , sys ) if err ! = nil { return nil , err } img , err : = image . fromsource ( ctx , sys , src ) if err ! = nil { src . close ( ) return nil , err } return img , nil } 
func newimagesource ( sys * types . systemcontext , ref ocireference ) ( types . imagesource , error ) { tr : = tlsclientconfig . newtransport ( ) tr . tlsclientconfig = tlsconfig . serverdefault ( ) if sys ! = nil && sys . ocicertpath ! = " " { if err : = tlsclientconfig . setupcertificates ( sys . ocicertpath , tr . tlsclientconfig ) ; err ! = nil { return nil , err } tr . tlsclientconfig . insecureskipverify = sys . ociinsecureskiptlsverify } client : = & http . client { } client . transport = tr descriptor , err : = ref . getmanifestdescriptor ( ) if err ! = nil { return nil , err } d : = & ociimagesource { ref : ref , descriptor : descriptor , client : client } if sys ! = nil { d . sharedblobdir = sys . ocisharedblobdirpath } return d , nil } 
func ( s * ociimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { var dig digest . digest var mimetype string if instancedigest == nil { dig = digest . digest ( s . descriptor . digest ) mimetype = s . descriptor . mediatype } else { dig = * instancedigest mimetype = imgspecv1 . mediatypeimagemanifest } manifestpath , err : = s . ref . blobpath ( dig , s . sharedblobdir ) if err ! = nil { return nil , " " , err } m , err : = ioutil . readfile ( manifestpath ) if err ! = nil { return nil , " " , err } return m , mimetype , nil } 
func ( s * ociimagesource ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { return [ ] [ ] byte { } , nil } 
func manifestoci1fromcomponents ( config imgspecv1 . descriptor , src types . imagesource , configblob [ ] byte , layers [ ] imgspecv1 . descriptor ) genericmanifest { return & manifestoci1 { src : src , configblob : configblob , m : manifest . oci1fromcomponents ( config , layers ) , } } 
func ( m * manifestoci1 ) ociconfig ( ctx context . context ) ( * imgspecv1 . image , error ) { cb , err : = m . configblob ( ctx ) if err ! = nil { return nil , err } configoci : = & imgspecv1 . image { } if err : = json . unmarshal ( cb , configoci ) ; err ! = nil { return nil , err } return configoci , nil } 
func ( m * manifestoci1 ) updatedimage ( ctx context . context , options types . manifestupdateoptions ) ( types . image , error ) { copy : = manifestoci1 { src : m . src , configblob : m . configblob , m : manifest . oci1clone ( m . m ) , } if options . layerinfos ! = nil { if err : = copy . m . updatelayerinfos ( options . layerinfos ) ; err ! = nil { return nil , err } } switch options . manifestmimetype { case " " : case manifest . dockerv2schema1mediatype , manifest . dockerv2schema1signedmediatype : m2 , err : = copy . converttomanifestschema2 ( ) if err ! = nil { return nil , err } return m2 . updatedimage ( ctx , types . manifestupdateoptions { manifestmimetype : options . manifestmimetype , informationonly : options . informationonly , } ) case manifest . dockerv2schema2mediatype : return copy . converttomanifestschema2 ( ) default : return nil , errors . errorf ( " " , imgspecv1 . mediatypeimagemanifest , options . manifestmimetype ) } return memoryimagefrommanifest ( & copy ) , nil } 
func parseimageanddockerreference ( image types . unparsedimage , s2 string ) ( reference . named , reference . named , error ) { r1 : = image . reference ( ) . dockerreference ( ) if r1 == nil { return nil , nil , policyrequirementerror ( fmt . sprintf ( " " , transports . imagename ( image . reference ( ) ) ) ) } r2 , err : = reference . parsenormalizednamed ( s2 ) if err ! = nil { return nil , nil , err } return r1 , r2 , nil } 
func parsedockerreferences ( s1 , s2 string ) ( reference . named , reference . named , error ) { r1 , err : = reference . parsenormalizednamed ( s1 ) if err ! = nil { return nil , nil , err } r2 , err : = reference . parsenormalizednamed ( s2 ) if err ! = nil { return nil , nil , err } return r1 , r2 , nil } 
func imagename ( ref types . imagereference ) string { return ref . transport ( ) . name ( ) + " " + ref . stringwithintransport ( ) } 
func listnames ( ) [ ] string { kt . mu . lock ( ) defer kt . mu . unlock ( ) deprecated : = map [ string ] bool { " " : true , } var names [ ] string for , transport : = range kt . transports { if ! deprecated [ transport . name ( ) ] { names = append ( names , transport . name ( ) ) } } sort . strings ( names ) return names } 
func ( t ostreetransport ) validatepolicyconfigurationscope ( scope string ) error { sep : = strings . index ( scope , " " ) if sep < 0 { return errors . errorf ( " " , scope ) } repo : = scope [ : sep ] if ! strings . hasprefix ( repo , " " ) { return errors . errorf ( " " , scope ) } cleaned : = filepath . clean ( repo ) if cleaned ! = repo { return errors . errorf ( ' invalid ostree : scope %s : uses non - canonical path format , perhaps try with path %s ' , scope , cleaned ) } return nil } 
func newreference ( image string , repo string ) ( types . imagereference , error ) { ostreeimage , err : = reference . parsenormalizednamed ( image ) if err ! = nil { return nil , err } if reference . isnameonly ( ostreeimage ) { image = image + " " } resolved , err : = explicitfilepath . resolvepathtofullyexplicit ( repo ) if err ! = nil { if os . isnotexist ( err ) && repo == defaultostreerepo { resolved = repo } else { return nil , err } } if strings . contains ( resolved , " " ) { return nil , errors . errorf ( " " , image , repo , resolved ) } return ostreereference { image : image , branchname : encodeostreeref ( image ) , repo : resolved , } , nil } 
func ( ref ostreereference ) stringwithintransport ( ) string { return fmt . sprintf ( " " , ref . image , ref . repo ) } 
func ( ref ostreereference ) policyconfigurationnamespaces ( ) [ ] string { s : = strings . splitn ( ref . image , " " , 2 ) if len ( s ) ! = 2 { panic ( fmt . sprintf ( " " , ref . image ) ) } name : = s [ 0 ] res : = [ ] string { } for { res = append ( res , fmt . sprintf ( " " , ref . repo , name ) ) lastslash : = strings . lastindex ( name , " " ) if lastslash == - 1 { break } name = name [ : lastslash ] } return res } 
func ( ref ostreereference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { var tmpdir string if sys == nil | | sys . ostreetmpdirpath == " " { tmpdir = os . tempdir ( ) } else { tmpdir = sys . ostreetmpdirpath } src , err : = newimagesource ( tmpdir , ref ) if err ! = nil { return nil , err } return image . fromsource ( ctx , sys , src ) } 
func ( ref ostreereference ) newimagesource ( ctx context . context , sys * types . systemcontext ) ( types . imagesource , error ) { var tmpdir string if sys == nil | | sys . ostreetmpdirpath == " " { tmpdir = os . tempdir ( ) } else { tmpdir = sys . ostreetmpdirpath } return newimagesource ( tmpdir , ref ) } 
func ( ref ostreereference ) newimagedestination ( ctx context . context , sys * types . systemcontext ) ( types . imagedestination , error ) { var tmpdir string if sys == nil | | sys . ostreetmpdirpath == " " { tmpdir = os . tempdir ( ) } else { tmpdir = sys . ostreetmpdirpath } return newimagedestination ( ref , tmpdir ) } 
func ( ref ostreereference ) signaturepath ( index int ) string { return filepath . join ( " " , fmt . sprintf ( " " , index + 1 ) ) } 
func paranoidunmarshaljsonobject ( data [ ] byte , fieldresolver func ( string ) interface { } ) error { seenkeys : = map [ string ] struct { } { } dec : = json . newdecoder ( bytes . newreader ( data ) ) t , err : = dec . token ( ) if err ! = nil { return jsonformaterror ( err . error ( ) ) } if t ! = json . delim ( ' { ' ) { return jsonformaterror ( fmt . sprintf ( " " " " , t ) ) } for { t , err : = dec . token ( ) if err ! = nil { return jsonformaterror ( err . error ( ) ) } if t == json . delim ( ' } ' ) { break } key , ok : = t . ( string ) if ! ok { return jsonformaterror ( fmt . sprintf ( " " " " , t ) ) } if , ok : = seenkeys [ key ] ; ok { return jsonformaterror ( fmt . sprintf ( " " " " , key ) ) } seenkeys [ key ] = struct { } { } valueptr : = fieldresolver ( key ) if valueptr == nil { return jsonformaterror ( fmt . sprintf ( " " " " , key ) ) } if err : = dec . decode ( valueptr ) ; err ! = nil { return jsonformaterror ( err . error ( ) ) } } if , err : = dec . token ( ) ; err ! = io . eof { return jsonformaterror ( " " ) } return nil } 
func paranoidunmarshaljsonobjectexactfields ( data [ ] byte , exactfields map [ string ] interface { } ) error { seenkeys : = map [ string ] struct { } { } if err : = paranoidunmarshaljsonobject ( data , func ( key string ) interface { } { if valueptr , ok : = exactfields [ key ] ; ok { seenkeys [ key ] = struct { } { } return valueptr } return nil } ) ; err ! = nil { return err } for key : = range exactfields { if , ok : = seenkeys [ key ] ; ! ok { return jsonformaterror ( fmt . sprintf ( ' key " %s " missing in a json object ' , key ) ) } } return nil } 
func validateimagename ( image string ) error { if len ( image ) == 0 { return nil } var err error if ! refregexp . matchstring ( image ) { err = errors . errorf ( " " , image ) } return err } 
func splitpathandimage ( reference string ) ( string , string ) { if runtime . goos == " " { return splitpathandimagewindows ( reference ) } return splitpathandimagenonwindows ( reference ) } 
func validateocipath ( path string ) error { if runtime . goos == " " { if strings . count ( path , " " ) > 1 { return errors . errorf ( " " , path ) } } else { if strings . contains ( path , " " ) { return errors . errorf ( " " , path ) } } return nil } 
func validatescope ( scope string ) error { var err error if runtime . goos == " " { err = validatescopewindows ( scope ) } else { err = validatescopenonwindows ( scope ) } if err ! = nil { return err } cleaned : = filepath . clean ( scope ) if cleaned ! = scope { return errors . errorf ( ' invalid scope %s : uses non - canonical path format , perhaps try with path %s ' , scope , cleaned ) } return nil } 
func blobinfofromschema2descriptor ( desc schema2descriptor ) types . blobinfo { return types . blobinfo { digest : desc . digest , size : desc . size , urls : desc . urls , mediatype : desc . mediatype , } } 
func schema2frommanifest ( manifest [ ] byte ) ( * schema2 , error ) { s2 : = schema2 { } if err : = json . unmarshal ( manifest , & s2 ) ; err ! = nil { return nil , err } return & s2 , nil } 
func schema2fromcomponents ( config schema2descriptor , layers [ ] schema2descriptor ) * schema2 { return & schema2 { schemaversion : 2 , mediatype : dockerv2schema2mediatype , configdescriptor : config , layersdescriptors : layers , } } 
func ( m * schema2 ) layerinfos ( ) [ ] layerinfo { blobs : = [ ] layerinfo { } for , layer : = range m . layersdescriptors { blobs = append ( blobs , layerinfo { blobinfo : blobinfofromschema2descriptor ( layer ) , emptylayer : false , } ) } return blobs } 
func ( m * schema2 ) updatelayerinfos ( layerinfos [ ] types . blobinfo ) error { if len ( m . layersdescriptors ) ! = len ( layerinfos ) { return errors . errorf ( " " , len ( m . layersdescriptors ) , len ( layerinfos ) ) } original : = m . layersdescriptors m . layersdescriptors = make ( [ ] schema2descriptor , len ( layerinfos ) ) for i , info : = range layerinfos { m . layersdescriptors [ i ] . mediatype = original [ i ] . mediatype m . layersdescriptors [ i ] . digest = info . digest m . layersdescriptors [ i ] . size = info . size m . layersdescriptors [ i ] . urls = info . urls } return nil } 
func ( m * schema2 ) inspect ( configgetter func ( types . blobinfo ) ( [ ] byte , error ) ) ( * types . imageinspectinfo , error ) { config , err : = configgetter ( m . configinfo ( ) ) if err ! = nil { return nil , err } s2 : = & schema2image { } if err : = json . unmarshal ( config , s2 ) ; err ! = nil { return nil , err } i : = & types . imageinspectinfo { tag : " " , created : & s2 . created , dockerversion : s2 . dockerversion , architecture : s2 . architecture , os : s2 . os , layers : layerinfostostrings ( m . layerinfos ( ) ) , } if s2 . config ! = nil { i . labels = s2 . config . labels } return i , nil } 
func ( m * schema2 ) imageid ( [ ] digest . digest ) ( string , error ) { if err : = m . configdescriptor . digest . validate ( ) ; err ! = nil { return " " , err } return m . configdescriptor . digest . hex ( ) , nil } 
func setauthentication ( sys * types . systemcontext , registry , username , password string ) error { return modifyjson ( sys , func ( auths * dockerconfigfile ) ( bool , error ) { if ch , exists : = auths . credhelpers [ registry ] ; exists { return false , setauthtocredhelper ( ch , registry , username , password ) } creds : = base64 . stdencoding . encodetostring ( [ ] byte ( username + " " + password ) ) newcreds : = dockerauthconfig { auth : creds } auths . authconfigs [ registry ] = newcreds return true , nil } ) } 
func getauthentication ( sys * types . systemcontext , registry string ) ( string , string , error ) { if sys ! = nil && sys . dockerauthconfig ! = nil { return sys . dockerauthconfig . username , sys . dockerauthconfig . password , nil } dockerlegacypath : = filepath . join ( homedir . get ( ) , dockerlegacyhomepath ) var paths [ ] string pathtoauth , err : = getpathtoauth ( sys ) if err == nil { paths = append ( paths , pathtoauth ) } else { logrus . warnf ( " " , err ) } paths = append ( paths , filepath . join ( homedir . get ( ) , dockerhomepath ) , dockerlegacypath ) for , path : = range paths { legacyformat : = path == dockerlegacypath username , password , err : = findauthentication ( registry , path , legacyformat ) if err ! = nil { return " " , " " , err } if username ! = " " && password ! = " " { return username , password , nil } } return " " , " " , nil } 
func removeauthentication ( sys * types . systemcontext , registry string ) error { return modifyjson ( sys , func ( auths * dockerconfigfile ) ( bool , error ) { if ch , exists : = auths . credhelpers [ registry ] ; exists { return false , deleteauthfromcredhelper ( ch , registry ) } if , ok : = auths . authconfigs [ registry ] ; ok { delete ( auths . authconfigs , registry ) } else if , ok : = auths . authconfigs [ normalizeregistry ( registry ) ] ; ok { delete ( auths . authconfigs , normalizeregistry ( registry ) ) } else { return false , errnotloggedin } return true , nil } ) } 
func removeallauthentication ( sys * types . systemcontext ) error { return modifyjson ( sys , func ( auths * dockerconfigfile ) ( bool , error ) { auths . credhelpers = make ( map [ string ] string ) auths . authconfigs = make ( map [ string ] dockerauthconfig ) return true , nil } ) } 
func getpathtoauth ( sys * types . systemcontext ) ( string , error ) { if sys ! = nil { if sys . authfilepath ! = " " { return sys . authfilepath , nil } if sys . rootforimplicitabsolutepaths ! = " " { return filepath . join ( sys . rootforimplicitabsolutepaths , fmt . sprintf ( defaultperuidpathformat , os . getuid ( ) ) ) , nil } } runtimedir : = os . getenv ( " " ) if runtimedir ! = " " { , err : = os . stat ( runtimedir ) if os . isnotexist ( err ) { return " " , errors . wrapf ( err , " " , runtimedir ) } return filepath . join ( runtimedir , xdgruntimedirpath ) , nil } return fmt . sprintf ( defaultperuidpathformat , os . getuid ( ) ) , nil } 
func readjsonfile ( path string , legacyformat bool ) ( dockerconfigfile , error ) { var auths dockerconfigfile raw , err : = ioutil . readfile ( path ) if err ! = nil { if os . isnotexist ( err ) { auths . authconfigs = map [ string ] dockerauthconfig { } return auths , nil } return dockerconfigfile { } , err } if legacyformat { if err = json . unmarshal ( raw , & auths . authconfigs ) ; err ! = nil { return dockerconfigfile { } , errors . wrapf ( err , " " , path ) } return auths , nil } if err = json . unmarshal ( raw , & auths ) ; err ! = nil { return dockerconfigfile { } , errors . wrapf ( err , " " , path ) } return auths , nil } 
func modifyjson ( sys * types . systemcontext , editor func ( auths * dockerconfigfile ) ( bool , error ) ) error { path , err : = getpathtoauth ( sys ) if err ! = nil { return err } dir : = filepath . dir ( path ) if , err : = os . stat ( dir ) ; os . isnotexist ( err ) { if err = os . mkdirall ( dir , 0700 ) ; err ! = nil { return errors . wrapf ( err , " " , dir ) } } auths , err : = readjsonfile ( path , false ) if err ! = nil { return errors . wrapf ( err , " " , path ) } updated , err : = editor ( & auths ) if err ! = nil { return errors . wrapf ( err , " " , path ) } if updated { newdata , err : = json . marshalindent ( auths , " " , " \ t " ) if err ! = nil { return errors . wrapf ( err , " " , path ) } if err = ioutil . writefile ( path , newdata , 0755 ) ; err ! = nil { return errors . wrapf ( err , " " , path ) } } return nil } 
func findauthentication ( registry , path string , legacyformat bool ) ( string , string , error ) { auths , err : = readjsonfile ( path , legacyformat ) if err ! = nil { return " " , " " , errors . wrapf ( err , " " , path ) } if ch , exists : = auths . credhelpers [ registry ] ; exists { return getauthfromcredhelper ( ch , registry ) } if val , exists : = auths . authconfigs [ registry ] ; exists { return decodedockerauth ( val . auth ) } registry = normalizeregistry ( registry ) normalizedauths : = map [ string ] dockerauthconfig { } for k , v : = range auths . authconfigs { normalizedauths [ normalizeregistry ( k ) ] = v } if val , exists : = normalizedauths [ registry ] ; exists { return decodedockerauth ( val . auth ) } return " " , " " , nil } 
func ( is * tarballimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { if instancedigest ! = nil { return nil , " " , fmt . errorf ( " " , transportname ) } return is . manifest , imgspecv1 . mediatypeimagemanifest , nil } 
func ( * tarballimagesource ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { if instancedigest ! = nil { return nil , fmt . errorf ( " " , transportname ) } return nil , nil } 
func ( * tarballimagesource ) layerinfosforcopy ( ctx context . context ) ( [ ] types . blobinfo , error ) { return nil , nil } 
func newdestination ( dest io . writer , ref reference . namedtagged ) * destination { repotags : = [ ] reference . namedtagged { } if ref ! = nil { repotags = append ( repotags , ref ) } return & destination { writer : dest , tar : tar . newwriter ( dest ) , repotags : repotags , blobs : make ( map [ digest . digest ] types . blobinfo ) , } } 
func ( d * destination ) addrepotags ( tags [ ] reference . namedtagged ) { d . repotags = append ( d . repotags , tags ... ) } 
func ( d * destination ) tryreusingblob ( ctx context . context , info types . blobinfo , cache types . blobinfocache , cansubstitute bool ) ( bool , types . blobinfo , error ) { if info . digest == " " { return false , types . blobinfo { } , errors . errorf ( " " ) } if blob , ok : = d . blobs [ info . digest ] ; ok { return true , types . blobinfo { digest : info . digest , size : blob . size } , nil } return false , types . blobinfo { } , nil } 
func ( d * destination ) putmanifest ( ctx context . context , m [ ] byte ) error { var man manifest . schema2 if err : = json . unmarshal ( m , & man ) ; err ! = nil { return errors . wrap ( err , " " ) } if man . schemaversion ! = 2 | | man . mediatype ! = manifest . dockerv2schema2mediatype { return errors . errorf ( " " ) } layerpaths , lastlayerid , err : = d . writelegacylayermetadata ( man . layersdescriptors ) if err ! = nil { return err } if len ( man . layersdescriptors ) > 0 { if err : = d . createrepositoriesfile ( lastlayerid ) ; err ! = nil { return err } } repotags : = [ ] string { } for , tag : = range d . repotags { refstring : = fmt . sprintf ( " " , tag . name ( ) , tag . tag ( ) ) repotags = append ( repotags , refstring ) } items : = [ ] manifestitem { { config : man . configdescriptor . digest . hex ( ) + " " , repotags : repotags , layers : layerpaths , parent : " " , layersources : nil , } } itemsbytes , err : = json . marshal ( & items ) if err ! = nil { return err } return d . sendbytes ( manifestfilename , itemsbytes ) } 
func ( d * destination ) sendsymlink ( path string , target string ) error { hdr , err : = tar . fileinfoheader ( & tarfi { path : path , size : 0 , issymlink : true } , target ) if err ! = nil { return nil } logrus . debugf ( " " , path , target ) return d . tar . writeheader ( hdr ) } 
func ( d * destination ) sendbytes ( path string , b [ ] byte ) error { return d . sendfile ( path , int64 ( len ( b ) ) , bytes . newreader ( b ) ) } 
func ( d * destination ) sendfile ( path string , expectedsize int64 , stream io . reader ) error { hdr , err : = tar . fileinfoheader ( & tarfi { path : path , size : expectedsize } , " " ) if err ! = nil { return nil } logrus . debugf ( " " , path ) if err : = d . tar . writeheader ( hdr ) ; err ! = nil { return err } size , err : = io . copy ( d . tar , stream ) if err ! = nil { return err } if size ! = expectedsize { return errors . errorf ( " " , path , expectedsize , size ) } return nil } 
func ( d * destination ) putsignatures ( ctx context . context , signatures [ ] [ ] byte ) error { if len ( signatures ) ! = 0 { return errors . errorf ( " " ) } return nil } 
func ( d * destination ) commit ( ctx context . context ) error { return d . tar . close ( ) } 
func imagematchesrepo ( image * storage . image , ref reference . named ) bool { repo : = ref . name ( ) for , name : = range image . names { if named , err : = reference . parsenormalizednamed ( name ) ; err == nil { if named . name ( ) == repo { return true } } } return false } 
func ( s storagereference ) transport ( ) types . imagetransport { return & storagetransport { store : s . transport . store , defaultuidmap : s . transport . defaultuidmap , defaultgidmap : s . transport . defaultgidmap , } } 
func ( s storagereference ) stringwithintransport ( ) string { optionslist : = " " options : = s . transport . store . graphoptions ( ) if len ( options ) > 0 { optionslist = " " + strings . join ( options , " " ) } res : = " " + s . transport . store . graphdrivername ( ) + " " + s . transport . store . graphroot ( ) + " " + s . transport . store . runroot ( ) + optionslist + " " if s . named ! = nil { res = res + s . named . string ( ) } if s . id ! = " " { res = res + " " + s . id } return res } 
func ( s storagereference ) policyconfigurationnamespaces ( ) [ ] string { storespec : = " " + s . transport . store . graphdrivername ( ) + " " + s . transport . store . graphroot ( ) + " " driverlessstorespec : = " " + s . transport . store . graphroot ( ) + " " namespaces : = [ ] string { } if s . named ! = nil { if s . id ! = " " { namespaces = append ( namespaces , storespec + s . named . string ( ) ) } tagged , istagged : = s . named . ( reference . tagged ) , isdigested : = s . named . ( reference . digested ) if istagged && isdigested { namespaces = append ( namespaces , storespec + s . named . name ( ) + " " + tagged . tag ( ) ) } components : = strings . split ( s . named . name ( ) , " " ) for len ( components ) > 0 { namespaces = append ( namespaces , storespec + strings . join ( components , " " ) ) components = components [ : len ( components ) - 1 ] } } namespaces = append ( namespaces , storespec ) namespaces = append ( namespaces , driverlessstorespec ) return namespaces } 
func ( s storagereference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { return newimage ( ctx , sys , s ) } 
func dockerreferenceidentity ( ref reference . named ) ( string , error ) { res : = ref . name ( ) tagged , istagged : = ref . ( reference . namedtagged ) digested , isdigested : = ref . ( reference . canonical ) switch { case istagged && isdigested : return " " , errors . errorf ( " " , reference . familiarstring ( ref ) ) case ! istagged && ! isdigested : return " " , errors . errorf ( " " , reference . familiarstring ( ref ) ) case istagged : res = res + " " + tagged . tag ( ) case isdigested : res = res + " " + digested . digest ( ) . string ( ) default : return " " , errors . new ( " " ) } return res , nil } 
func dockerreferencenamespaces ( ref reference . named ) [ ] string { res : = [ ] string { } name : = ref . name ( ) for { res = append ( res , name ) lastslash : = strings . lastindex ( name , " " ) if lastslash == - 1 { break } name = name [ : lastslash ] } return res } 
func gzipdecompressor ( r io . reader ) ( io . readcloser , error ) { return pgzip . newreader ( r ) } 
func bzip2decompressor ( r io . reader ) ( io . readcloser , error ) { return ioutil . nopcloser ( bzip2 . newreader ( r ) ) , nil } 
func xzdecompressor ( r io . reader ) ( io . readcloser , error ) { r , err : = xz . newreader ( r ) if err ! = nil { return nil , err } return ioutil . nopcloser ( r ) , nil } 
func detectcompression ( input io . reader ) ( decompressorfunc , io . reader , error ) { buffer : = [ 8 ] byte { } n , err : = io . readatleast ( input , buffer [ : ] , len ( buffer ) ) if err ! = nil && err ! = io . eof && err ! = io . errunexpectedeof { return nil , nil , err } var decompressor decompressorfunc for name , algo : = range compressionalgos { if bytes . hasprefix ( buffer [ : n ] , algo . prefix ) { logrus . debugf ( " " , name ) decompressor = algo . decompressor break } } if decompressor == nil { logrus . debugf ( " " ) } return decompressor , io . multireader ( bytes . newreader ( buffer [ : n ] ) , input ) , nil } 
func autodecompress ( stream io . reader ) ( io . readcloser , bool , error ) { decompressor , stream , err : = detectcompression ( stream ) if err ! = nil { return nil , false , errors . wrapf ( err , " " ) } var res io . readcloser if decompressor ! = nil { res , err = decompressor ( stream ) if err ! = nil { return nil , false , errors . wrapf ( err , " " ) } } else { res = ioutil . nopcloser ( stream ) } return res , decompressor ! = nil , nil } 
func newimagedestination ( sys * types . systemcontext , ref dockerreference ) ( types . imagedestination , error ) { c , err : = newdockerclientfromref ( sys , ref , true , " " ) if err ! = nil { return nil , err } return & dockerimagedestination { ref : ref , c : c , } , nil } 
func ( d * dockerimagedestination ) supportssignatures ( ctx context . context ) error { if err : = d . c . detectproperties ( ctx ) ; err ! = nil { return err } switch { case d . c . signaturebase ! = nil : return nil case d . c . supportssignatures : return nil default : return errors . errorf ( " " ) } } 
func ( d * dockerimagedestination ) blobexists ( ctx context . context , repo reference . named , digest digest . digest , extrascope * authscope ) ( bool , int64 , error ) { checkpath : = fmt . sprintf ( blobspath , reference . path ( repo ) , digest . string ( ) ) logrus . debugf ( " " , checkpath ) res , err : = d . c . makerequest ( ctx , " " , checkpath , nil , nil , v2auth , extrascope ) if err ! = nil { return false , - 1 , err } defer res . body . close ( ) switch res . statuscode { case http . statusok : logrus . debugf ( " " ) return true , getblobsize ( res ) , nil case http . statusunauthorized : logrus . debugf ( " " ) return false , - 1 , errors . wrapf ( client . handleerrorresponse ( res ) , " " , digest , repo . name ( ) ) case http . statusnotfound : logrus . debugf ( " " ) return false , - 1 , nil default : return false , - 1 , errors . errorf ( " " , reference . path ( d . ref . ref ) , res . statuscode , http . statustext ( res . statuscode ) ) } } 
func ( d * dockerimagedestination ) putmanifest ( ctx context . context , m [ ] byte ) error { digest , err : = manifest . digest ( m ) if err ! = nil { return err } d . manifestdigest = digest reftail , err : = d . ref . tagordigest ( ) if err ! = nil { return err } path : = fmt . sprintf ( manifestpath , reference . path ( d . ref . ref ) , reftail ) headers : = map [ string ] [ ] string { } mimetype : = manifest . guessmimetype ( m ) if mimetype ! = " " { headers [ " " ] = [ ] string { mimetype } } res , err : = d . c . makerequest ( ctx , " " , path , headers , bytes . newreader ( m ) , v2auth , nil ) if err ! = nil { return err } defer res . body . close ( ) if ! successstatus ( res . statuscode ) { err = errors . wrapf ( client . handleerrorresponse ( res ) , " " , reftail , d . ref . ref . name ( ) ) if ismanifestinvaliderror ( errors . cause ( err ) ) { err = types . manifesttyperejectederror { err : err } } return err } return nil } 
func ismanifestinvaliderror ( err error ) bool { errors , ok : = err . ( errcode . errors ) if ! ok | | len ( errors ) == 0 { return false } err = errors [ 0 ] ec , ok : = err . ( errcode . errorcoder ) if ! ok { return false } switch ec . errorcode ( ) { case v2 . errorcodemanifestinvalid : return true case v2 . errorcodetaginvalid : return true case errcode . errorcodeunsupported : return strings . contains ( err . error ( ) , " " ) default : return false } } 
func ( d * dockerimagedestination ) putsignaturestolookaside ( signatures [ ] [ ] byte ) error { if len ( signatures ) == 0 { return nil } if d . manifestdigest . string ( ) == " " { return errors . errorf ( " " ) } for i , signature : = range signatures { url : = signaturestorageurl ( d . c . signaturebase , d . manifestdigest , i ) if url == nil { return errors . errorf ( " " ) } err : = d . putonesignature ( url , signature ) if err ! = nil { return err } } for i : = len ( signatures ) ; ; i ++ { url : = signaturestorageurl ( d . c . signaturebase , d . manifestdigest , i ) if url == nil { return errors . errorf ( " " ) } missing , err : = d . c . deleteonesignature ( url ) if err ! = nil { return err } if missing { break } } return nil } 
func ( d * dockerimagedestination ) putonesignature ( url * url . url , signature [ ] byte ) error { switch url . scheme { case " " : logrus . debugf ( " " , url . path ) err : = os . mkdirall ( filepath . dir ( url . path ) , 0755 ) if err ! = nil { return err } err = ioutil . writefile ( url . path , signature , 0644 ) if err ! = nil { return err } return nil case " " , " " : return errors . errorf ( " " , url . scheme , url . string ( ) ) default : return errors . errorf ( " " , url . string ( ) ) } } 
func ( c * dockerclient ) deleteonesignature ( url * url . url ) ( missing bool , err error ) { switch url . scheme { case " " : logrus . debugf ( " " , url . path ) err : = os . remove ( url . path ) if err ! = nil && os . isnotexist ( err ) { return true , nil } return false , err case " " , " " : return false , errors . errorf ( " " , url . scheme , url . string ( ) ) default : return false , errors . errorf ( " " , url . string ( ) ) } } 
func bictransportscope ( ref dockerreference ) types . bictransportscope { return types . bictransportscope { opaque : reference . domain ( ref . ref ) } } 
func newbiclocationreference ( ref dockerreference ) types . biclocationreference { return types . biclocationreference { opaque : ref . ref . name ( ) } } 
func parsebiclocationreference ( lr types . biclocationreference ) ( reference . named , error ) { return reference . parsenormalizednamed ( lr . opaque ) } 
func newsourcefromfile ( path string ) ( * source , error ) { file , err : = os . open ( path ) if err ! = nil { return nil , errors . wrapf ( err , " " , path ) } defer file . close ( ) stream , iscompressed , err : = compression . autodecompress ( file ) if err ! = nil { return nil , errors . wrapf ( err , " " , path ) } defer stream . close ( ) if ! iscompressed { return & source { tarpath : path , } , nil } return newsourcefromstream ( stream ) } 
func newsourcefromstream ( inputstream io . reader ) ( * source , error ) { tarcopyfile , err : = ioutil . tempfile ( tmpdir . temporarydirectoryforbigfiles ( ) , " " ) if err ! = nil { return nil , errors . wrap ( err , " " ) } defer tarcopyfile . close ( ) succeeded : = false defer func ( ) { if ! succeeded { os . remove ( tarcopyfile . name ( ) ) } } ( ) uncompressedstream , , err : = compression . autodecompress ( inputstream ) if err ! = nil { return nil , errors . wrap ( err , " " ) } defer uncompressedstream . close ( ) if , err : = io . copy ( tarcopyfile , uncompressedstream ) ; err ! = nil { return nil , errors . wrapf ( err , " " , tarcopyfile . name ( ) ) } succeeded = true return & source { tarpath : tarcopyfile . name ( ) , removetarpathonclose : true , } , nil } 
func ( s * source ) opentarcomponent ( componentpath string ) ( io . readcloser , error ) { f , err : = os . open ( s . tarpath ) if err ! = nil { return nil , err } succeeded : = false defer func ( ) { if ! succeeded { f . close ( ) } } ( ) tarreader , header , err : = findtarcomponent ( f , componentpath ) if err ! = nil { return nil , err } if header == nil { return nil , os . errnotexist } if header . fileinfo ( ) . mode ( ) & os . modetype == os . modesymlink { if , err : = f . seek ( 0 , os . seek set ) ; err ! = nil { return nil , err } tarreader , header , err = findtarcomponent ( f , path . join ( path . dir ( componentpath ) , header . linkname ) ) if err ! = nil { return nil , err } if header == nil { return nil , os . errnotexist } } if ! header . fileinfo ( ) . mode ( ) . isregular ( ) { return nil , errors . errorf ( " " , header . name ) } succeeded = true return & tarreadcloser { reader : tarreader , backingfile : f } , nil } 
func findtarcomponent ( inputfile io . reader , path string ) ( * tar . reader , * tar . header , error ) { t : = tar . newreader ( inputfile ) for { h , err : = t . next ( ) if err == io . eof { break } if err ! = nil { return nil , nil , err } if h . name == path { return t , h , nil } } return nil , nil , nil } 
func ( s * source ) readtarcomponent ( path string ) ( [ ] byte , error ) { file , err : = s . opentarcomponent ( path ) if err ! = nil { return nil , errors . wrapf ( err , " " , path ) } defer file . close ( ) bytes , err : = ioutil . readall ( file ) if err ! = nil { return nil , err } return bytes , nil } 
func ( s * source ) ensurecacheddataispresent ( ) error { s . cachedatalock . do ( func ( ) { tarmanifest , err : = s . loadtarmanifest ( ) if err ! = nil { s . cachedataresult = err return } if len ( tarmanifest ) ! = 1 { s . cachedataresult = errors . errorf ( " " , len ( tarmanifest ) ) return } configbytes , err : = s . readtarcomponent ( tarmanifest [ 0 ] . config ) if err ! = nil { s . cachedataresult = err return } var parsedconfig manifest . schema2image if err : = json . unmarshal ( configbytes , & parsedconfig ) ; err ! = nil { s . cachedataresult = errors . wrapf ( err , " " , tarmanifest [ 0 ] . config ) return } knownlayers , err : = s . preparelayerdata ( & tarmanifest [ 0 ] , & parsedconfig ) if err ! = nil { s . cachedataresult = err return } s . tarmanifest = & tarmanifest [ 0 ] s . configbytes = configbytes s . configdigest = digest . frombytes ( configbytes ) s . ordereddiffidlist = parsedconfig . rootfs . diffids s . knownlayers = knownlayers } ) return s . cachedataresult } 
func ( s * source ) loadtarmanifest ( ) ( [ ] manifestitem , error ) { bytes , err : = s . readtarcomponent ( manifestfilename ) if err ! = nil { return nil , err } var items [ ] manifestitem if err : = json . unmarshal ( bytes , & items ) ; err ! = nil { return nil , errors . wrap ( err , " " ) } return items , nil } 
func ( s * source ) close ( ) error { if s . removetarpathonclose { return os . remove ( s . tarpath ) } return nil } 
func ( s * source ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { if instancedigest ! = nil { return nil , " " , errors . errorf ( ' manifest lists are not supported by " docker - daemon : " ' ) } if s . generatedmanifest == nil { if err : = s . ensurecacheddataispresent ( ) ; err ! = nil { return nil , " " , err } m : = manifest . schema2 { schemaversion : 2 , mediatype : manifest . dockerv2schema2mediatype , configdescriptor : manifest . schema2descriptor { mediatype : manifest . dockerv2schema2configmediatype , size : int64 ( len ( s . configbytes ) ) , digest : s . configdigest , } , layersdescriptors : [ ] manifest . schema2descriptor { } , } for , diffid : = range s . ordereddiffidlist { li , ok : = s . knownlayers [ diffid ] if ! ok { return nil , " " , errors . errorf ( " " , diffid ) } m . layersdescriptors = append ( m . layersdescriptors , manifest . schema2descriptor { digest : diffid , mediatype : manifest . dockerv2schema2layermediatype , size : li . size , } ) } manifestbytes , err : = json . marshal ( & m ) if err ! = nil { return nil , " " , err } s . generatedmanifest = manifestbytes } return s . generatedmanifest , manifest . dockerv2schema2mediatype , nil } 
func ( s * source ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { if instancedigest ! = nil { return nil , errors . errorf ( ' manifest lists are not supported by " docker - daemon : " ' ) } return [ ] [ ] byte { } , nil } 
func newimagedestination ( ctx context . context , sys * types . systemcontext , ref daemonreference ) ( types . imagedestination , error ) { if ref . ref == nil { return nil , errors . errorf ( " " , ref . stringwithintransport ( ) ) } namedtaggedref , ok : = ref . ref . ( reference . namedtagged ) if ! ok { return nil , errors . errorf ( " " , ref . stringwithintransport ( ) ) } var mustmatchruntimeos = true if sys ! = nil && sys . dockerdaemonhost ! = client . defaultdockerhost { mustmatchruntimeos = false } c , err : = newdockerclient ( sys ) if err ! = nil { return nil , errors . wrap ( err , " " ) } reader , writer : = io . pipe ( ) statuschannel : = make ( chan error , 1 ) goroutinecontext , goroutinecancel : = context . withcancel ( ctx ) go imageloadgoroutine ( goroutinecontext , c , reader , statuschannel ) return & daemonimagedestination { ref : ref , mustmatchruntimeos : mustmatchruntimeos , destination : tarfile . newdestination ( writer , namedtaggedref ) , goroutinecancel : goroutinecancel , statuschannel : statuschannel , writer : writer , committed : false , } , nil } 
func imageloadgoroutine ( ctx context . context , c * client . client , reader * io . pipereader , statuschannel chan < - error ) { err : = errors . new ( " " ) defer func ( ) { logrus . debugf ( " " , err ) statuschannel < - err } ( ) defer func ( ) { if err == nil { reader . close ( ) } else { reader . closewitherror ( err ) } } ( ) resp , err : = c . imageload ( ctx , reader , true ) if err ! = nil { err = errors . wrap ( err , " " ) return } defer resp . body . close ( ) } 
func ( d * daemonimagedestination ) close ( ) error { if ! d . committed { logrus . debugf ( " " ) d . writer . closewitherror ( errors . new ( " " ) ) } d . goroutinecancel ( ) return nil } 
func ( d * daemonimagedestination ) commit ( ctx context . context ) error { logrus . debugf ( " " ) if err : = d . destination . commit ( ctx ) ; err ! = nil { return err } if err : = d . writer . close ( ) ; err ! = nil { return err } d . committed = true logrus . debugf ( " " ) select { case < - ctx . done ( ) : return ctx . err ( ) case err : = < - d . statuschannel : return err } } 
func ( t ociarchivetransport ) parsereference ( reference string ) ( types . imagereference , error ) { return parsereference ( reference ) } 
func newreference ( file , image string ) ( types . imagereference , error ) { resolved , err : = explicitfilepath . resolvepathtofullyexplicit ( file ) if err ! = nil { return nil , err } if err : = internal . validateocipath ( file ) ; err ! = nil { return nil , err } if err : = internal . validateimagename ( image ) ; err ! = nil { return nil , err } return ociarchivereference { file : file , resolvedfile : resolved , image : image } , nil } 
func ( ref ociarchivereference ) stringwithintransport ( ) string { return fmt . sprintf ( " " , ref . file , ref . image ) } 
func ( ref ociarchivereference ) policyconfigurationnamespaces ( ) [ ] string { res : = [ ] string { } path : = ref . resolvedfile for { lastslash : = strings . lastindex ( path , " " ) if lastslash == - 1 | | path == " " { break } res = append ( res , path ) path = path [ : lastslash ] } return res } 
func ( ref ociarchivereference ) deleteimage ( ctx context . context , sys * types . systemcontext ) error { return errors . errorf ( " " ) } 
func createociref ( image string ) ( tempdirociref , error ) { dir , err : = ioutil . tempdir ( tmpdir . temporarydirectoryforbigfiles ( ) , " " ) if err ! = nil { return tempdirociref { } , errors . wrapf ( err , " " ) } ociref , err : = ocilayout . newreference ( dir , image ) if err ! = nil { return tempdirociref { } , err } tempdirref : = tempdirociref { tempdirectory : dir , ocirefextracted : ociref } return tempdirref , nil } 
func createuntartempdir ( ref ociarchivereference ) ( tempdirociref , error ) { tempdirref , err : = createociref ( ref . image ) if err ! = nil { return tempdirociref { } , errors . wrap ( err , " " ) } src : = ref . resolvedfile dst : = tempdirref . tempdirectory if err : = archive . untarpath ( src , dst ) ; err ! = nil { if err : = tempdirref . deletetempdir ( ) ; err ! = nil { return tempdirociref { } , errors . wrapf ( err , " " , tempdirref . tempdirectory ) } return tempdirociref { } , errors . wrapf ( err , " " , tempdirref . tempdirectory ) } return tempdirref , nil } 
func destructivelyprioritizereplacementcandidateswithmax ( cs [ ] candidatewithtime , primarydigest , uncompresseddigest digest . digest , maxcandidates int ) [ ] types . bicreplacementcandidate { sort . sort ( & candidatesortstate { cs : cs , primarydigest : primarydigest , uncompresseddigest : uncompresseddigest , } ) reslength : = len ( cs ) if reslength > maxcandidates { reslength = maxcandidates } res : = make ( [ ] types . bicreplacementcandidate , reslength ) for i : = range res { res [ i ] = cs [ i ] . candidate } return res } 
func destructivelyprioritizereplacementcandidates ( cs [ ] candidatewithtime , primarydigest , uncompresseddigest digest . digest ) [ ] types . bicreplacementcandidate { return destructivelyprioritizereplacementcandidateswithmax ( cs , primarydigest , uncompresseddigest , replacementattempts ) } 
func newimagedestination ( ref ostreereference , tmpdirpath string ) ( types . imagedestination , error ) { tmpdirpath = filepath . join ( tmpdirpath , ref . branchname ) if err : = ensuredirectoryexists ( tmpdirpath ) ; err ! = nil { return nil , err } return & ostreeimagedestination { ref , " " , manifestschema { } , tmpdirpath , map [ string ] * blobtoimport { } , " " , 0 , nil } , nil } 
func ( d * ostreeimagedestination ) close ( ) error { if d . repo ! = nil { c . g object unref ( c . gpointer ( d . repo ) ) } return os . removeall ( d . tmpdirpath ) } 
func ( d * ostreeimagedestination ) putblob ( ctx context . context , stream io . reader , inputinfo types . blobinfo , cache types . blobinfocache , isconfig bool ) ( types . blobinfo , error ) { tmpdir , err : = ioutil . tempdir ( d . tmpdirpath , " " ) if err ! = nil { return types . blobinfo { } , err } blobpath : = filepath . join ( tmpdir , " " ) blobfile , err : = os . create ( blobpath ) if err ! = nil { return types . blobinfo { } , err } defer blobfile . close ( ) digester : = digest . canonical . digester ( ) tee : = io . teereader ( stream , digester . hash ( ) ) size , err : = io . copy ( blobfile , tee ) if err ! = nil { return types . blobinfo { } , err } computeddigest : = digester . digest ( ) if inputinfo . size ! = - 1 && size ! = inputinfo . size { return types . blobinfo { } , errors . errorf ( " " , computeddigest , inputinfo . size , size ) } if err : = blobfile . sync ( ) ; err ! = nil { return types . blobinfo { } , err } hash : = computeddigest . hex ( ) d . blobs [ hash ] = & blobtoimport { size : size , digest : computeddigest , blobpath : blobpath } return types . blobinfo { digest : computeddigest , size : size } , nil } 
func ( d * ostreeimagedestination ) tryreusingblob ( ctx context . context , info types . blobinfo , cache types . blobinfocache , cansubstitute bool ) ( bool , types . blobinfo , error ) { if d . repo == nil { repo , err : = openrepo ( d . ref . repo ) if err ! = nil { return false , types . blobinfo { } , err } d . repo = repo } branch : = fmt . sprintf ( " " , info . digest . hex ( ) ) found , data , err : = readmetadata ( d . repo , branch , " " ) if err ! = nil | | ! found { return found , types . blobinfo { } , err } found , data , err = readmetadata ( d . repo , branch , " " ) if err ! = nil | | ! found { return found , types . blobinfo { } , err } found , data , err = readmetadata ( d . repo , branch , " " ) if err ! = nil | | ! found { return found , types . blobinfo { } , err } size , err : = strconv . parseint ( data , 10 , 64 ) if err ! = nil { return false , types . blobinfo { } , err } return true , types . blobinfo { digest : info . digest , size : size } , nil } 
func ( d * ostreeimagedestination ) putmanifest ( ctx context . context , manifestblob [ ] byte ) error { d . manifest = string ( manifestblob ) if err : = json . unmarshal ( manifestblob , & d . schema ) ; err ! = nil { return err } manifestpath : = filepath . join ( d . tmpdirpath , d . ref . manifestpath ( ) ) if err : = ensureparentdirectoryexists ( manifestpath ) ; err ! = nil { return err } digest , err : = manifest . digest ( manifestblob ) if err ! = nil { return err } d . digest = digest return ioutil . writefile ( manifestpath , manifestblob , 0644 ) } 
func resolvepathtofullyexplicit ( path string ) ( string , error ) { switch , err : = os . lstat ( path ) ; { case err == nil : return resolveexistingpathtofullyexplicit ( path ) case os . isnotexist ( err ) : parent , file : = filepath . split ( path ) resolvedparent , err : = resolveexistingpathtofullyexplicit ( parent ) if err ! = nil { return " " , err } if file == " " | | file == " " { return " " , errors . errorf ( " " , path ) } resolvedpath : = filepath . join ( resolvedparent , file ) cleanedresolvedpath : = filepath . clean ( resolvedpath ) if cleanedresolvedpath ! = resolvedpath { return " " , errors . errorf ( " " , path , resolvedpath , cleanedresolvedpath ) } return resolvedpath , nil default : return " " , err } } 
func resolveexistingpathtofullyexplicit ( path string ) ( string , error ) { resolved , err : = filepath . abs ( path ) if err ! = nil { return " " , err } resolved , err = filepath . evalsymlinks ( resolved ) if err ! = nil { return " " , err } return filepath . clean ( resolved ) , nil } 
func ( d * dirimagedestination ) putmanifest ( ctx context . context , manifest [ ] byte ) error { return ioutil . writefile ( d . ref . manifestpath ( ) , manifest , 0644 ) } 
func isdirempty ( path string ) ( bool , error ) { files , err : = ioutil . readdir ( path ) if err ! = nil { return false , err } return len ( files ) == 0 , nil } 
func removedircontents ( path string ) error { files , err : = ioutil . readdir ( path ) if err ! = nil { return err } for , file : = range files { if err : = os . removeall ( filepath . join ( path , file . name ( ) ) ) ; err ! = nil { return err } } return nil } 
func newimage ( ctx context . context , sys * types . systemcontext , ref dockerreference ) ( types . imagecloser , error ) { s , err : = newimagesource ( ctx , sys , ref ) if err ! = nil { return nil , err } img , err : = image . fromsource ( ctx , sys , s ) if err ! = nil { return nil , err } return & image { imagecloser : img , src : s } , nil } 
func ( i * image ) getrepositorytags ( ctx context . context ) ( [ ] string , error ) { return getrepositorytags ( ctx , i . src . c . sys , i . src . ref ) } 
func blobinfocachedir ( sys * types . systemcontext , euid int ) ( string , error ) { if sys ! = nil && sys . blobinfocachedir ! = " " { return sys . blobinfocachedir , nil } if euid == 0 { if sys ! = nil && sys . rootforimplicitabsolutepaths ! = " " { return filepath . join ( sys . rootforimplicitabsolutepaths , systemblobinfocachedir ) , nil } return systemblobinfocachedir , nil } datadir : = os . getenv ( " " ) if datadir == " " { home : = os . getenv ( " " ) if home == " " { return " " , fmt . errorf ( " " ) } datadir = filepath . join ( home , " " , " " ) } return filepath . join ( datadir , " " , " " ) , nil } 
func defaultcache ( sys * types . systemcontext ) types . blobinfocache { dir , err : = blobinfocachedir ( sys , getrootlessuid ( ) ) if err ! = nil { logrus . debugf ( " " , blobinfocachefilename ) return memory . new ( ) } path : = filepath . join ( dir , blobinfocachefilename ) if err : = os . mkdirall ( dir , 0700 ) ; err ! = nil { logrus . debugf ( " " , blobinfocachefilename , err ) return memory . new ( ) } logrus . debugf ( " " , path ) return boltdb . new ( path ) } 
func ( t archivetransport ) parsereference ( reference string ) ( types . imagereference , error ) { return parsereference ( reference ) } 
func parsereference ( refstring string ) ( types . imagereference , error ) { if refstring == " " { return nil , errors . errorf ( " " , refstring ) } parts : = strings . splitn ( refstring , " " , 2 ) path : = parts [ 0 ] var destinationref reference . namedtagged if len ( parts ) == 2 { ref , err : = reference . parsenormalizednamed ( parts [ 1 ] ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } ref = reference . tagnameonly ( ref ) if , isdigest : = ref . ( reference . canonical ) ; isdigest { return nil , errors . errorf ( " " , refstring ) } reftagged , istagged : = ref . ( reference . namedtagged ) if ! istagged { return nil , errors . errorf ( " " , refstring ) } destinationref = reftagged } return archivereference { destinationref : destinationref , path : path , } , nil } 
func ( ref archivereference ) stringwithintransport ( ) string { if ref . destinationref == nil { return ref . path } return fmt . sprintf ( " " , ref . path , ref . destinationref . string ( ) ) } 
func ( ref archivereference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { src , err : = newimagesource ( ctx , ref ) if err ! = nil { return nil , err } return ctrimage . fromsource ( ctx , sys , src ) } 
func ( ref archivereference ) newimagesource ( ctx context . context , sys * types . systemcontext ) ( types . imagesource , error ) { return newimagesource ( ctx , ref ) } 
func ( ref archivereference ) newimagedestination ( ctx context . context , sys * types . systemcontext ) ( types . imagedestination , error ) { return newimagedestination ( sys , ref ) } 
func ( ref archivereference ) deleteimage ( ctx context . context , sys * types . systemcontext ) error { return errors . new ( " " ) } 
func new ( ) types . blobinfocache { return & cache { uncompresseddigests : map [ digest . digest ] digest . digest { } , digestsbyuncompressed : map [ digest . digest ] map [ digest . digest ] struct { } { } , knownlocations : map [ locationkey ] map [ types . biclocationreference ] time . time { } , } } 
func ( mem * cache ) uncompresseddigest ( anydigest digest . digest ) digest . digest { mem . mutex . lock ( ) defer mem . mutex . unlock ( ) return mem . uncompresseddigestlocked ( anydigest ) } 
func ( mem * cache ) uncompresseddigestlocked ( anydigest digest . digest ) digest . digest { if d , ok : = mem . uncompresseddigests [ anydigest ] ; ok { return d } if m , ok : = mem . digestsbyuncompressed [ anydigest ] ; ok && len ( m ) > 0 { return anydigest } return " " } 
func ( mem * cache ) recorddigestuncompressedpair ( anydigest digest . digest , uncompressed digest . digest ) { mem . mutex . lock ( ) defer mem . mutex . unlock ( ) if previous , ok : = mem . uncompresseddigests [ anydigest ] ; ok && previous ! = uncompressed { logrus . warnf ( " " , anydigest , previous , uncompressed ) } mem . uncompresseddigests [ anydigest ] = uncompressed anydigestset , ok : = mem . digestsbyuncompressed [ uncompressed ] if ! ok { anydigestset = map [ digest . digest ] struct { } { } mem . digestsbyuncompressed [ uncompressed ] = anydigestset } anydigestset [ anydigest ] = struct { } { } } 
func ( mem * cache ) recordknownlocation ( transport types . imagetransport , scope types . bictransportscope , blobdigest digest . digest , location types . biclocationreference ) { mem . mutex . lock ( ) defer mem . mutex . unlock ( ) key : = locationkey { transport : transport . name ( ) , scope : scope , blobdigest : blobdigest } locationscope , ok : = mem . knownlocations [ key ] if ! ok { locationscope = map [ types . biclocationreference ] time . time { } mem . knownlocations [ key ] = locationscope } locationscope [ location ] = time . now ( ) } 
func ( mem * cache ) appendreplacementcandidates ( candidates [ ] prioritize . candidatewithtime , transport types . imagetransport , scope types . bictransportscope , digest digest . digest ) [ ] prioritize . candidatewithtime { locations : = mem . knownlocations [ locationkey { transport : transport . name ( ) , scope : scope , blobdigest : digest } ] for l , t : = range locations { candidates = append ( candidates , prioritize . candidatewithtime { candidate : types . bicreplacementcandidate { digest : digest , location : l , } , lastseen : t , } ) } return candidates } 
func ( mem * cache ) candidatelocations ( transport types . imagetransport , scope types . bictransportscope , primarydigest digest . digest , cansubstitute bool ) [ ] types . bicreplacementcandidate { mem . mutex . lock ( ) defer mem . mutex . unlock ( ) res : = [ ] prioritize . candidatewithtime { } res = mem . appendreplacementcandidates ( res , transport , scope , primarydigest ) var uncompresseddigest digest . digest if cansubstitute { if uncompresseddigest = mem . uncompresseddigestlocked ( primarydigest ) ; uncompresseddigest ! = " " { otherdigests : = mem . digestsbyuncompressed [ uncompresseddigest ] for d : = range otherdigests { if d ! = primarydigest && d ! = uncompresseddigest { res = mem . appendreplacementcandidates ( res , transport , scope , d ) } } if uncompresseddigest ! = primarydigest { res = mem . appendreplacementcandidates ( res , transport , scope , uncompresseddigest ) } } } return prioritize . destructivelyprioritizereplacementcandidates ( res , primarydigest , uncompresseddigest ) } 
func unparsedinstance ( src types . imagesource , instancedigest * digest . digest ) * unparsedimage { return & unparsedimage { src : src , instancedigest : instancedigest , } } 
func ( i * unparsedimage ) manifest ( ctx context . context ) ( [ ] byte , string , error ) { if i . cachedmanifest == nil { m , mt , err : = i . src . getmanifest ( ctx , i . instancedigest ) if err ! = nil { return nil , " " , err } if digest , havedigest : = i . expectedmanifestdigest ( ) ; havedigest { matches , err : = manifest . matchesdigest ( m , digest ) if err ! = nil { return nil , " " , errors . wrap ( err , " " ) } if ! matches { return nil , " " , errors . errorf ( " " , digest ) } } i . cachedmanifest = m i . cachedmanifestmimetype = mt } return i . cachedmanifest , i . cachedmanifestmimetype , nil } 
func ( i * unparsedimage ) expectedmanifestdigest ( ) ( digest . digest , bool ) { if i . instancedigest ! = nil { return * i . instancedigest , true } ref : = i . reference ( ) . dockerreference ( ) if ref ! = nil { if canonical , ok : = ref . ( reference . canonical ) ; ok { return canonical . digest ( ) , true } } return " " , false } 
func ( i * unparsedimage ) signatures ( ctx context . context ) ( [ ] [ ] byte , error ) { if i . cachedsignatures == nil { sigs , err : = i . src . getsignatures ( ctx , i . instancedigest ) if err ! = nil { return nil , err } i . cachedsignatures = sigs } return i . cachedsignatures , nil } 
func newgpgsigningmechanismindirectory ( optionaldir string ) ( signingmechanism , error ) { ctx , err : = newgpgmecontext ( optionaldir ) if err ! = nil { return nil , err } return & gpgmesigningmechanism { ctx : ctx , ephemeraldir : " " , } , nil } 
func newephemeralgpgsigningmechanism ( blob [ ] byte ) ( signingmechanism , [ ] string , error ) { dir , err : = ioutil . tempdir ( " " , " " ) if err ! = nil { return nil , nil , err } removedir : = true defer func ( ) { if removedir { os . removeall ( dir ) } } ( ) ctx , err : = newgpgmecontext ( dir ) if err ! = nil { return nil , nil , err } mech : = & gpgmesigningmechanism { ctx : ctx , ephemeraldir : dir , } keyidentities , err : = mech . importkeysfrombytes ( blob ) if err ! = nil { return nil , nil , err } removedir = false return mech , keyidentities , nil } 
func newgpgmecontext ( optionaldir string ) ( * gpgme . context , error ) { ctx , err : = gpgme . new ( ) if err ! = nil { return nil , err } if err = ctx . setprotocol ( gpgme . protocolopenpgp ) ; err ! = nil { return nil , err } if optionaldir ! = " " { err : = ctx . setengineinfo ( gpgme . protocolopenpgp , " " , optionaldir ) if err ! = nil { return nil , err } } ctx . setarmor ( false ) ctx . settextmode ( false ) return ctx , nil } 
func ( m * gpgmesigningmechanism ) importkeysfrombytes ( blob [ ] byte ) ( [ ] string , error ) { inputdata , err : = gpgme . newdatabytes ( blob ) if err ! = nil { return nil , err } res , err : = m . ctx . import ( inputdata ) if err ! = nil { return nil , err } keyidentities : = [ ] string { } for , i : = range res . imports { if i . result == nil { keyidentities = append ( keyidentities , i . fingerprint ) } } return keyidentities , nil } 
func ( m * gpgmesigningmechanism ) sign ( input [ ] byte , keyidentity string ) ( [ ] byte , error ) { key , err : = m . ctx . getkey ( keyidentity , true ) if err ! = nil { return nil , err } inputdata , err : = gpgme . newdatabytes ( input ) if err ! = nil { return nil , err } var sigbuffer bytes . buffer sigdata , err : = gpgme . newdatawriter ( & sigbuffer ) if err ! = nil { return nil , err } if err = m . ctx . sign ( [ ] * gpgme . key { key } , inputdata , sigdata , gpgme . sigmodenormal ) ; err ! = nil { return nil , err } return sigbuffer . bytes ( ) , nil } 
func ( m gpgmesigningmechanism ) verify ( unverifiedsignature [ ] byte ) ( contents [ ] byte , keyidentity string , err error ) { signedbuffer : = bytes . buffer { } signeddata , err : = gpgme . newdatawriter ( & signedbuffer ) if err ! = nil { return nil , " " , err } unverifiedsignaturedata , err : = gpgme . newdatabytes ( unverifiedsignature ) if err ! = nil { return nil , " " , err } , sigs , err : = m . ctx . verify ( unverifiedsignaturedata , nil , signeddata ) if err ! = nil { return nil , " " , err } if len ( sigs ) ! = 1 { return nil , " " , invalidsignatureerror { msg : fmt . sprintf ( " " , len ( sigs ) ) } } sig : = sigs [ 0 ] if sig . status ! = nil | | sig . validity == gpgme . validitynever | | sig . validityreason ! = nil | | sig . wrongkeyusage { return nil , " " , invalidsignatureerror { msg : fmt . sprintf ( " " , sig ) } } return signedbuffer . bytes ( ) , sig . fingerprint , nil } 
func newimagedestination ( ctx context . context , sys * types . systemcontext , ref ociarchivereference ) ( types . imagedestination , error ) { tempdirref , err : = createociref ( ref . image ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } unpackeddest , err : = tempdirref . ocirefextracted . newimagedestination ( ctx , sys ) if err ! = nil { if err : = tempdirref . deletetempdir ( ) ; err ! = nil { return nil , errors . wrapf ( err , " " , tempdirref . tempdirectory ) } return nil , err } return & ociarchiveimagedestination { ref : ref , unpackeddest : unpackeddest , tempdirref : tempdirref } , nil } 
func ( d * ociarchiveimagedestination ) close ( ) error { defer d . tempdirref . deletetempdir ( ) return d . unpackeddest . close ( ) } 
func ( d * ociarchiveimagedestination ) supportssignatures ( ctx context . context ) error { return d . unpackeddest . supportssignatures ( ctx ) } 
func ( d * ociarchiveimagedestination ) putblob ( ctx context . context , stream io . reader , inputinfo types . blobinfo , cache types . blobinfocache , isconfig bool ) ( types . blobinfo , error ) { return d . unpackeddest . putblob ( ctx , stream , inputinfo , cache , isconfig ) } 
func ( d * ociarchiveimagedestination ) tryreusingblob ( ctx context . context , info types . blobinfo , cache types . blobinfocache , cansubstitute bool ) ( bool , types . blobinfo , error ) { return d . unpackeddest . tryreusingblob ( ctx , info , cache , cansubstitute ) } 
func ( d * ociarchiveimagedestination ) putmanifest ( ctx context . context , m [ ] byte ) error { return d . unpackeddest . putmanifest ( ctx , m ) } 
func ( d * ociarchiveimagedestination ) commit ( ctx context . context ) error { if err : = d . unpackeddest . commit ( ctx ) ; err ! = nil { return errors . wrapf ( err , " " , d . ref . image ) } src : = d . tempdirref . tempdirectory dst : = d . ref . resolvedfile return tardirectory ( src , dst ) } 
func tardirectory ( src , dst string ) error { input , err : = archive . tar ( src , archive . uncompressed ) if err ! = nil { return errors . wrapf ( err , " " , src ) } outfile , err : = os . create ( dst ) if err ! = nil { return errors . wrapf ( err , " " , dst ) } defer outfile . close ( ) , err = io . copy ( outfile , input ) return err } 
func choosedigestfrommanifestlist ( sys * types . systemcontext , blob [ ] byte ) ( digest . digest , error ) { wantedarch : = runtime . goarch if sys ! = nil && sys . architecturechoice ! = " " { wantedarch = sys . architecturechoice } wantedos : = runtime . goos if sys ! = nil && sys . oschoice ! = " " { wantedos = sys . oschoice } list : = manifestlist { } if err : = json . unmarshal ( blob , & list ) ; err ! = nil { return " " , err } for , d : = range list . manifests { if d . platform . architecture == wantedarch && d . platform . os == wantedos { return d . digest , nil } } return " " , fmt . errorf ( " " , wantedarch , wantedos ) } 
func choosemanifestinstancefrommanifestlist ( ctx context . context , sys * types . systemcontext , src types . unparsedimage ) ( digest . digest , error ) { blob , mt , err : = src . manifest ( ctx ) if err ! = nil { return " " , err } if mt ! = manifest . dockerv2listmediatype { return " " , fmt . errorf ( " " , mt ) } return choosedigestfrommanifestlist ( sys , blob ) } 
func ( s * dirimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { if instancedigest ! = nil { return nil , " " , errors . errorf ( ' getting target manifest not supported by " dir : " ' ) } m , err : = ioutil . readfile ( s . ref . manifestpath ( ) ) if err ! = nil { return nil , " " , err } return m , manifest . guessmimetype ( m ) , err } 
func ( s * dirimagesource ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { if instancedigest ! = nil { return nil , errors . errorf ( ' manifests lists are not supported by " dir : " ' ) } signatures : = [ ] [ ] byte { } for i : = 0 ; ; i ++ { signature , err : = ioutil . readfile ( s . ref . signaturepath ( i ) ) if err ! = nil { if os . isnotexist ( err ) { break } return nil , err } signatures = append ( signatures , signature ) } return signatures , nil } 
func ( s * dirimagesource ) layerinfosforcopy ( ctx context . context ) ( [ ] types . blobinfo , error ) { return nil , nil } 
func manifestschema1fromcomponents ( ref reference . named , fslayers [ ] manifest . schema1fslayers , history [ ] manifest . schema1history , architecture string ) ( genericmanifest , error ) { m , err : = manifest . schema1fromcomponents ( ref , fslayers , history , architecture ) if err ! = nil { return nil , err } return & manifestschema1 { m : m } , nil } 
func ( m * manifestschema1 ) ociconfig ( ctx context . context ) ( * imgspecv1 . image , error ) { v2s2 , err : = m . converttomanifestschema2 ( nil , nil ) if err ! = nil { return nil , err } return v2s2 . ociconfig ( ctx ) } 
func ( m * manifestschema1 ) embeddeddockerreferenceconflicts ( ref reference . named ) bool { name : = reference . path ( ref ) var tag string if tagged , istagged : = ref . ( reference . namedtagged ) ; istagged { tag = tagged . tag ( ) } else { tag = " " } return m . m . name ! = name | | m . m . tag ! = tag } 
func ( m * manifestschema1 ) inspect ( context . context ) ( * types . imageinspectinfo , error ) { return m . m . inspect ( nil ) } 
func ( m * manifestschema1 ) updatedimageneedslayerdiffids ( options types . manifestupdateoptions ) bool { return ( options . manifestmimetype == manifest . dockerv2schema2mediatype | | options . manifestmimetype == imgspecv1 . mediatypeimagemanifest ) } 
func ( m * manifestschema1 ) updatedimage ( ctx context . context , options types . manifestupdateoptions ) ( types . image , error ) { copy : = manifestschema1 { m : manifest . schema1clone ( m . m ) } if options . layerinfos ! = nil { if err : = copy . m . updatelayerinfos ( options . layerinfos ) ; err ! = nil { return nil , err } } if options . embeddeddockerreference ! = nil { copy . m . name = reference . path ( options . embeddeddockerreference ) if tagged , istagged : = options . embeddeddockerreference . ( reference . namedtagged ) ; istagged { copy . m . tag = tagged . tag ( ) } else { copy . m . tag = " " } } switch options . manifestmimetype { case " " : case manifest . dockerv2schema1mediatype , manifest . dockerv2schema1signedmediatype : case manifest . dockerv2schema2mediatype : m2 , err : = copy . converttomanifestschema2 ( options . informationonly . layerinfos , options . informationonly . layerdiffids ) if err ! = nil { return nil , err } return memoryimagefrommanifest ( m2 ) , nil case imgspecv1 . mediatypeimagemanifest : m2 , err : = copy . converttomanifestschema2 ( options . informationonly . layerinfos , options . informationonly . layerdiffids ) if err ! = nil { return nil , err } return m2 . updatedimage ( ctx , types . manifestupdateoptions { manifestmimetype : imgspecv1 . mediatypeimagemanifest , informationonly : options . informationonly , } ) default : return nil , errors . errorf ( " " , manifest . dockerv2schema1signedmediatype , options . manifestmimetype ) } return memoryimagefrommanifest ( & copy ) , nil } 
func newimagesource ( ctx context . context , sys * types . systemcontext , ref dockerreference ) ( * dockerimagesource , error ) { registry , err : = sysregistriesv2 . findregistry ( sys , ref . ref . name ( ) ) if err ! = nil { return nil , errors . wrapf ( err , " " ) } if registry == nil { registry = & sysregistriesv2 . registry { endpoint : sysregistriesv2 . endpoint { location : ref . ref . string ( ) , } , } } var ( imagesource * dockerimagesource manifestloaderr error ) for , endpoint : = range append ( registry . mirrors , registry . endpoint ) { logrus . debugf ( " " , ref . ref , endpoint . location ) newref , err : = endpoint . rewritereference ( ref . ref , registry . prefix ) if err ! = nil { return nil , err } dockerref , err : = newreference ( newref ) if err ! = nil { return nil , err } client , err : = newdockerclientfromref ( sys , dockerref , false , " " ) if err ! = nil { return nil , err } client . tlsclientconfig . insecureskipverify = endpoint . insecure testimagesource : = & dockerimagesource { ref : dockerref , c : client , } manifestloaderr = testimagesource . ensuremanifestisloaded ( ctx ) if manifestloaderr == nil { imagesource = testimagesource break } } return imagesource , manifestloaderr } 
func ( s * dockerimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { if instancedigest ! = nil { return s . fetchmanifest ( ctx , instancedigest . string ( ) ) } err : = s . ensuremanifestisloaded ( ctx ) if err ! = nil { return nil , " " , err } return s . cachedmanifest , s . cachedmanifestmimetype , nil } 
func ( s * dockerimagesource ) ensuremanifestisloaded ( ctx context . context ) error { if s . cachedmanifest ! = nil { return nil } reference , err : = s . ref . tagordigest ( ) if err ! = nil { return err } manblob , mt , err : = s . fetchmanifest ( ctx , reference ) if err ! = nil { return err } s . cachedmanifest = manblob s . cachedmanifestmimetype = mt return nil } 
func ( s * dockerimagesource ) getsignatures ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { if err : = s . c . detectproperties ( ctx ) ; err ! = nil { return nil , err } switch { case s . c . signaturebase ! = nil : return s . getsignaturesfromlookaside ( ctx , instancedigest ) case s . c . supportssignatures : return s . getsignaturesfromapiextension ( ctx , instancedigest ) default : return [ ] [ ] byte { } , nil } } 
func ( s * dockerimagesource ) manifestdigest ( ctx context . context , instancedigest * digest . digest ) ( digest . digest , error ) { if instancedigest ! = nil { return * instancedigest , nil } if digested , ok : = s . ref . ref . ( reference . digested ) ; ok { d : = digested . digest ( ) if d . algorithm ( ) == digest . canonical { return d , nil } } if err : = s . ensuremanifestisloaded ( ctx ) ; err ! = nil { return " " , err } return manifest . digest ( s . cachedmanifest ) } 
func ( s * dockerimagesource ) getsignaturesfromlookaside ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { manifestdigest , err : = s . manifestdigest ( ctx , instancedigest ) if err ! = nil { return nil , err } signatures : = [ ] [ ] byte { } for i : = 0 ; ; i ++ { url : = signaturestorageurl ( s . c . signaturebase , manifestdigest , i ) if url == nil { return nil , errors . errorf ( " " ) } signature , missing , err : = s . getonesignature ( ctx , url ) if err ! = nil { return nil , err } if missing { break } signatures = append ( signatures , signature ) } return signatures , nil } 
func ( s * dockerimagesource ) getonesignature ( ctx context . context , url * url . url ) ( signature [ ] byte , missing bool , err error ) { switch url . scheme { case " " : logrus . debugf ( " " , url . path ) sig , err : = ioutil . readfile ( url . path ) if err ! = nil { if os . isnotexist ( err ) { return nil , true , nil } return nil , false , err } return sig , false , nil case " " , " " : logrus . debugf ( " " , url ) req , err : = http . newrequest ( " " , url . string ( ) , nil ) if err ! = nil { return nil , false , err } req = req . withcontext ( ctx ) res , err : = s . c . dohttp ( req ) if err ! = nil { return nil , false , err } defer res . body . close ( ) if res . statuscode == http . statusnotfound { return nil , true , nil } else if res . statuscode ! = http . statusok { return nil , false , errors . errorf ( " " , url . string ( ) , res . statuscode , http . statustext ( res . statuscode ) ) } sig , err : = ioutil . readall ( res . body ) if err ! = nil { return nil , false , err } return sig , false , nil default : return nil , false , errors . errorf ( " " , url . string ( ) ) } } 
func ( s * dockerimagesource ) getsignaturesfromapiextension ( ctx context . context , instancedigest * digest . digest ) ( [ ] [ ] byte , error ) { manifestdigest , err : = s . manifestdigest ( ctx , instancedigest ) if err ! = nil { return nil , err } parsedbody , err : = s . c . getextensionssignatures ( ctx , s . ref , manifestdigest ) if err ! = nil { return nil , err } var sigs [ ] [ ] byte for , sig : = range parsedbody . signatures { if sig . version == extensionsignatureschemaversion && sig . type == extensionsignaturetypeatomic { sigs = append ( sigs , sig . content ) } } return sigs , nil } 
func ( i * memoryimage ) manifest ( ctx context . context ) ( [ ] byte , string , error ) { if i . serializedmanifest == nil { m , err : = i . genericmanifest . serialize ( ) if err ! = nil { return nil , " " , err } i . serializedmanifest = m } return i . serializedmanifest , i . genericmanifest . manifestmimetype ( ) , nil } 
func ( i * memoryimage ) signatures ( ctx context . context ) ( [ ] [ ] byte , error ) { return nil , errors . new ( " " ) } 
func ( i * memoryimage ) layerinfosforcopy ( ctx context . context ) ( [ ] types . blobinfo , error ) { return nil , nil } 
func schema1frommanifest ( manifest [ ] byte ) ( * schema1 , error ) { s1 : = schema1 { } if err : = json . unmarshal ( manifest , & s1 ) ; err ! = nil { return nil , err } if s1 . schemaversion ! = 1 { return nil , errors . errorf ( " " , s1 . schemaversion ) } if err : = s1 . initialize ( ) ; err ! = nil { return nil , err } if err : = s1 . fixmanifestlayers ( ) ; err ! = nil { return nil , err } return & s1 , nil } 
func schema1fromcomponents ( ref reference . named , fslayers [ ] schema1fslayers , history [ ] schema1history , architecture string ) ( * schema1 , error ) { var name , tag string if ref ! = nil { name = reference . path ( ref ) if tagged , ok : = ref . ( reference . namedtagged ) ; ok { tag = tagged . tag ( ) } } s1 : = schema1 { name : name , tag : tag , architecture : architecture , fslayers : fslayers , history : history , schemaversion : 1 , } if err : = s1 . initialize ( ) ; err ! = nil { return nil , err } return & s1 , nil } 
func ( m * schema1 ) initialize ( ) error { if len ( m . fslayers ) ! = len ( m . history ) { return errors . new ( " " ) } if len ( m . fslayers ) == 0 { return errors . new ( " " ) } m . extractedv1compatibility = make ( [ ] schema1v1compatibility , len ( m . history ) ) for i , h : = range m . history { if err : = json . unmarshal ( [ ] byte ( h . v1compatibility ) , & m . extractedv1compatibility [ i ] ) ; err ! = nil { return errors . wrapf ( err , " " , i ) } } return nil } 
func ( m * schema1 ) layerinfos ( ) [ ] layerinfo { layers : = make ( [ ] layerinfo , len ( m . fslayers ) ) for i , layer : = range m . fslayers { layers [ ( len ( m . fslayers ) - 1 ) - i ] = layerinfo { blobinfo : types . blobinfo { digest : layer . blobsum , size : - 1 } , emptylayer : m . extractedv1compatibility [ i ] . throwaway , } } return layers } 
func ( m * schema1 ) updatelayerinfos ( layerinfos [ ] types . blobinfo ) error { if len ( m . fslayers ) ! = len ( layerinfos ) { return errors . errorf ( " " , len ( m . fslayers ) , len ( layerinfos ) ) } m . fslayers = make ( [ ] schema1fslayers , len ( layerinfos ) ) for i , info : = range layerinfos { m . fslayers [ ( len ( layerinfos ) - 1 ) - i ] . blobsum = info . digest } return nil } 
func ( m * schema1 ) serialize ( ) ( [ ] byte , error ) { unsigned , err : = json . marshal ( * m ) if err ! = nil { return nil , err } return adddummyv2s1signature ( unsigned ) } 
func ( m * schema1 ) inspect ( func ( types . blobinfo ) ( [ ] byte , error ) ) ( * types . imageinspectinfo , error ) { s1 : = & schema2v1image { } if err : = json . unmarshal ( [ ] byte ( m . history [ 0 ] . v1compatibility ) , s1 ) ; err ! = nil { return nil , err } i : = & types . imageinspectinfo { tag : m . tag , created : & s1 . created , dockerversion : s1 . dockerversion , architecture : s1 . architecture , os : s1 . os , layers : layerinfostostrings ( m . layerinfos ( ) ) , } if s1 . config ! = nil { i . labels = s1 . config . labels } return i , nil } 
func ( m * schema1 ) imageid ( diffids [ ] digest . digest ) ( string , error ) { image , err : = m . toschema2config ( diffids ) if err ! = nil { return " " , err } return digest . frombytes ( image ) . hex ( ) , nil } 
func guessmimetype ( manifest [ ] byte ) string { meta : = struct { mediatype string ' json : " mediatype " ' schemaversion int ' json : " schemaversion " ' signatures interface { } ' json : " signatures " ' } { } if err : = json . unmarshal ( manifest , & meta ) ; err ! = nil { return " " } switch meta . mediatype { case dockerv2schema2mediatype , dockerv2listmediatype : return meta . mediatype } switch meta . schemaversion { case 1 : if meta . signatures ! = nil { return dockerv2schema1signedmediatype } return dockerv2schema1mediatype case 2 : ociman : = struct { config struct { mediatype string ' json : " mediatype " ' } ' json : " config " ' layers [ ] imgspecv1 . descriptor ' json : " layers " ' } { } if err : = json . unmarshal ( manifest , & ociman ) ; err ! = nil { return " " } if ociman . config . mediatype == imgspecv1 . mediatypeimageconfig && len ( ociman . layers ) ! = 0 { return imgspecv1 . mediatypeimagemanifest } ociindex : = struct { manifests [ ] imgspecv1 . descriptor ' json : " manifests " ' } { } if err : = json . unmarshal ( manifest , & ociindex ) ; err ! = nil { return " " } if len ( ociindex . manifests ) ! = 0 && ociindex . manifests [ 0 ] . mediatype == imgspecv1 . mediatypeimagemanifest { return imgspecv1 . mediatypeimageindex } return dockerv2schema2mediatype } return " " } 
func digest ( manifest [ ] byte ) ( digest . digest , error ) { if guessmimetype ( manifest ) == dockerv2schema1signedmediatype { sig , err : = libtrust . parseprettysignature ( manifest , " " ) if err ! = nil { return " " , err } manifest , err = sig . payload ( ) if err ! = nil { return " " , err } } return digest . frombytes ( manifest ) , nil } 
func matchesdigest ( manifest [ ] byte , expecteddigest digest . digest ) ( bool , error ) { actualdigest , err : = digest ( manifest ) if err ! = nil { return false , err } return expecteddigest == actualdigest , nil } 
func adddummyv2s1signature ( manifest [ ] byte ) ( [ ] byte , error ) { key , err : = libtrust . generateecp256privatekey ( ) if err ! = nil { return nil , err } js , err : = libtrust . newjsonsignature ( manifest ) if err ! = nil { return nil , err } if err : = js . sign ( key ) ; err ! = nil { return nil , err } return js . prettysignature ( " " ) } 
func normalizedmimetype ( input string ) string { switch input { case " " : return dockerv2schema1signedmediatype case dockerv2schema1mediatype , dockerv2schema1signedmediatype , imgspecv1 . mediatypeimagemanifest , dockerv2schema2mediatype , dockerv2listmediatype : return input default : return dockerv2schema1signedmediatype } } 
func fromblob ( manblob [ ] byte , mt string ) ( manifest , error ) { switch normalizedmimetype ( mt ) { case dockerv2schema1mediatype , dockerv2schema1signedmediatype : return schema1frommanifest ( manblob ) case imgspecv1 . mediatypeimagemanifest : return oci1frommanifest ( manblob ) case dockerv2schema2mediatype : return schema2frommanifest ( manblob ) case dockerv2listmediatype : return nil , fmt . errorf ( " " ) default : return nil , fmt . errorf ( " " , mt ) } } 
func layerinfostostrings ( infos [ ] layerinfo ) [ ] string { layers : = make ( [ ] string , len ( infos ) ) for i , info : = range infos { layers [ i ] = info . digest . string ( ) } return layers } 
func ( t dirtransport ) parsereference ( reference string ) ( types . imagereference , error ) { return newreference ( reference ) } 
func ( t dirtransport ) validatepolicyconfigurationscope ( scope string ) error { if ! strings . hasprefix ( scope , " " ) { return errors . errorf ( " " , scope ) } if scope == " " { return errors . new ( ' invalid scope " / " : use the generic default scope " " ' ) } cleaned : = filepath . clean ( scope ) if cleaned ! = scope { return errors . errorf ( ' invalid scope %s : uses non - canonical format , perhaps try %s ' , scope , cleaned ) } return nil } 
func newreference ( path string ) ( types . imagereference , error ) { resolved , err : = explicitfilepath . resolvepathtofullyexplicit ( path ) if err ! = nil { return nil , err } return dirreference { path : path , resolvedpath : resolved } , nil } 
func ( ref dirreference ) policyconfigurationnamespaces ( ) [ ] string { res : = [ ] string { } path : = ref . resolvedpath for { lastslash : = strings . lastindex ( path , " " ) if lastslash == - 1 | | lastslash == 0 { break } path = path [ : lastslash ] res = append ( res , path ) } return res } 
func ( ref dirreference ) newimage ( ctx context . context , sys * types . systemcontext ) ( types . imagecloser , error ) { src : = newimagesource ( ref ) return image . fromsource ( ctx , sys , src ) } 
func ( ref dirreference ) newimagesource ( ctx context . context , sys * types . systemcontext ) ( types . imagesource , error ) { return newimagesource ( ref ) , nil } 
func ( ref dirreference ) newimagedestination ( ctx context . context , sys * types . systemcontext ) ( types . imagedestination , error ) { compress : = false if sys ! = nil { compress = sys . dirforcecompress } return newimagedestination ( ref , compress ) } 
func ( ref dirreference ) layerpath ( digest digest . digest ) string { return filepath . join ( ref . path , digest . hex ( ) ) } 
func ( ref dirreference ) signaturepath ( index int ) string { return filepath . join ( ref . path , fmt . sprintf ( " " , index + 1 ) ) } 
func newimagesource ( tmpdir string , ref ostreereference ) ( types . imagesource , error ) { return & ostreeimagesource { ref : ref , tmpdir : tmpdir , compressed : nil } , nil } 
func ( s * ostreeimagesource ) close ( ) error { if s . repo ! = nil { c . g object unref ( c . gpointer ( s . repo ) ) } return nil } 
func ( s * ostreeimagesource ) getmanifest ( ctx context . context , instancedigest * digest . digest ) ( [ ] byte , string , error ) { if instancedigest ! = nil { return nil , " " , errors . errorf ( ' manifest lists are not supported by " ostree : " ' ) } if s . repo == nil { repo , err : = openrepo ( s . ref . repo ) if err ! = nil { return nil , " " , err } s . repo = repo } b : = fmt . sprintf ( " " , s . ref . branchname ) found , out , err : = readmetadata ( s . repo , b , " " ) if err ! = nil { return nil , " " , err } if ! found { return nil , " " , errors . new ( " " ) } m : = [ ] byte ( out ) return m , manifest . guessmimetype ( m ) , nil } 
func ( s * ostreeimagesource ) layerinfosforcopy ( ctx context . context ) ( [ ] types . blobinfo , error ) { updatedblobinfos : = [ ] types . blobinfo { } manifestblob , manifesttype , err : = s . getmanifest ( ctx , nil ) if err ! = nil { return nil , err } man , err : = manifest . fromblob ( manifestblob , manifesttype ) s . compressed = make ( map [ digest . digest ] digest . digest ) layerblobs : = man . layerinfos ( ) for , layerblob : = range layerblobs { branch : = fmt . sprintf ( " " , layerblob . digest . hex ( ) ) found , uncompresseddigeststr , err : = readmetadata ( s . repo , branch , " " ) if err ! = nil | | ! found { return nil , err } found , uncompressedsizestr , err : = readmetadata ( s . repo , branch , " " ) if err ! = nil | | ! found { return nil , err } uncompressedsize , err : = strconv . parseint ( uncompressedsizestr , 10 , 64 ) if err ! = nil { return nil , err } uncompresseddigest : = digest . digest ( uncompresseddigeststr ) blobinfo : = types . blobinfo { digest : uncompresseddigest , size : uncompressedsize , mediatype : layerblob . mediatype , } s . compressed [ uncompresseddigest ] = layerblob . digest updatedblobinfos = append ( updatedblobinfos , blobinfo ) } return updatedblobinfos , nil } 
func new ( n int , ctor func ( ) worker ) * pool { p : = & pool { ctor : ctor , reqchan : make ( chan workrequest ) , } p . setsize ( n ) return p } 
func newfunc ( n int , f func ( interface { } ) interface { } ) * pool { return new ( n , func ( ) worker { return & closureworker { processor : f , } } ) } 
func ( p * pool ) processtimed ( payload interface { } , timeout time . duration , ) ( interface { } , error ) { atomic . addint64 ( & p . queuedjobs , 1 ) defer atomic . addint64 ( & p . queuedjobs , - 1 ) tout : = time . newtimer ( timeout ) var request workrequest var open bool select { case request , open = < - p . reqchan : if ! open { return nil , errpoolnotrunning } case < - tout . c : return nil , errjobtimedout } select { case request . jobchan < - payload : case < - tout . c : request . interruptfunc ( ) return nil , errjobtimedout } select { case payload , open = < - request . retchan : if ! open { return nil , errworkerclosed } case < - tout . c : request . interruptfunc ( ) return nil , errjobtimedout } tout . stop ( ) return payload , nil } 
func ( p * pool ) setsize ( n int ) { p . workermut . lock ( ) defer p . workermut . unlock ( ) lworkers : = len ( p . workers ) if lworkers == n { return } for i : = lworkers ; i < n ; i ++ { p . workers = append ( p . workers , newworkerwrapper ( p . reqchan , p . ctor ( ) ) ) } for i : = n ; i < lworkers ; i ++ { p . workers [ i ] . stop ( ) } for i : = n ; i < lworkers ; i ++ { p . workers [ i ] . join ( ) } p . workers = p . workers [ : n ] } 
func ( p * pool ) getsize ( ) int { p . workermut . lock ( ) defer p . workermut . unlock ( ) return len ( p . workers ) } 
func getperspectivetransform ( rect , dst [ ] cvpoint2d32f ) * mat { mat : = createmat ( 3 , 3 , cv 64f ) result : = c . cvgetperspectivetransform ( ( * c . cvpoint2d32f ) ( & rect [ 0 ] ) , ( * c . cvpoint2d32f ) ( & dst [ 0 ] ) , ( * c . struct cvmat ) ( mat ) ) return ( * mat ) ( result ) } 
func warpperspective ( src , dst * iplimage , mapmatrix * mat , flags int , fillval scalar ) { c . cvwarpperspective ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , ( * c . struct cvmat ) ( mapmatrix ) , c . int ( flags ) , ( c . cvscalar ) ( fillval ) ) } 
func ( image * iplimage ) findcontours ( mode , method int , offset point ) * seq { storage : = c . cvcreatememstorage ( 0 ) header size : = ( c . size t ) ( unsafe . sizeof ( c . cvcontour { } ) ) var seq * c . cvseq c . cvfindcontours ( unsafe . pointer ( image ) , storage , & seq , c . int ( header size ) , c . int ( mode ) , c . int ( method ) , c . cvpoint ( c . int ( offset . x ) , c . int ( offset . y ) ) ) return ( * seq ) ( seq ) } 
func drawcontours ( image * iplimage , contours * seq , externalcolor , holecolor scalar , maxlevel , thickness , linetype int , offset point ) { c . cvdrawcontours ( unsafe . pointer ( image ) , ( * c . cvseq ) ( contours ) , ( c . cvscalar ) ( externalcolor ) , ( c . cvscalar ) ( holecolor ) , c . int ( maxlevel ) , c . int ( thickness ) , c . int ( linetype ) , c . cvpoint ( c . int ( offset . x ) , c . int ( offset . y ) ) ) } 
func approxpoly ( src * seq , header size int , storage * memstorage , method int , eps float64 , recursive int ) * seq { seq : = c . cvapproxpoly ( unsafe . pointer ( src ) , c . int ( header size ) , ( * c . cvmemstorage ) ( storage ) , c . int ( method ) , c . double ( eps ) , c . int ( recursive ) ) return ( * seq ) ( seq ) } 
func arclength ( curve * seq , slice slice , is closed bool ) float64 { is closed int : = 0 if is closed { is closed int = 1 } return float64 ( c . cvarclength ( unsafe . pointer ( curve ) , ( c . cvslice ) ( slice ) , c . int ( is closed int ) ) ) } 
func contourarea ( contour * seq , slice slice , oriented int ) float64 { return float64 ( c . cvcontourarea ( unsafe . pointer ( contour ) , ( c . cvslice ) ( slice ) , c . int ( oriented ) ) ) } 
func fitellipse2 ( points unsafe . pointer ) box2d { box : = c . cvfitellipse2 ( points ) center : = point2d32f { float32 ( box . center . x ) , float32 ( box . center . y ) } size : = size2d32f { float32 ( box . size . width ) , float32 ( box . size . height ) } angle : = float32 ( box . angle ) return box2d { center , size , angle } } 
func minarearect ( points unsafe . pointer ) box2d { box : = c . cvminarearect2 ( points , nil ) center : = point2d32f { float32 ( box . center . x ) , float32 ( box . center . y ) } size : = size2d32f { float32 ( box . size . width ) , float32 ( box . size . height ) } angle : = float32 ( box . angle ) return box2d { center , size , angle } } 
func boundingrect ( points unsafe . pointer ) rect { return ( rect ) ( c . cvboundingrect ( points , c . int ( 0 ) ) ) } 
func kmeans ( data * mat , k int , termcrit termcriteria , attempts int , rng rng , flags int ) ( labels , centers * mat ) { var compactness c . double labels = createmat ( data . rows ( ) , 1 , cv 32s ) centers = createmat ( k , 1 , data . type ( ) ) c . cvkmeans2 ( unsafe . pointer ( data ) , c . int ( k ) , unsafe . pointer ( labels ) , ( c . cvtermcriteria ) ( termcrit ) , c . int ( attempts ) , ( * c . cvrng ) ( & rng ) , c . int ( flags ) , unsafe . pointer ( centers ) , & compactness ) return labels , centers } 
func decodeimagemem ( data [ ] byte ) * iplimage { buf : = creatematheader ( 1 , len ( data ) , cv 8u ) buf . setdata ( unsafe . pointer ( & data [ 0 ] ) , cv autostep ) defer buf . release ( ) return decodeimage ( unsafe . pointer ( buf ) , cv load image unchanged ) } 
func fromimage ( img image . image ) * iplimage { b : = img . bounds ( ) model : = color . rgbamodel dst : = createimage ( b . max . x - b . min . x , b . max . y - b . min . y , ipl depth 8u , 4 ) for y : = b . min . y ; y < b . max . y ; y ++ { for x : = b . min . x ; x < b . max . x ; x ++ { px : = img . at ( x , y ) c : = model . convert ( px ) . ( color . rgba ) value : = newscalar ( float64 ( c . b ) , float64 ( c . g ) , float64 ( c . r ) , float64 ( c . a ) ) dst . set2d ( x - b . min . x , y - b . min . y , value ) } } return dst } 
func fromimageunsafe ( img * image . rgba ) * iplimage { b : = img . bounds ( ) buf : = createimageheader ( b . max . x - b . min . x , b . max . y - b . min . y , ipl depth 8u , 4 ) dst : = createimage ( b . max . x - b . min . x , b . max . y - b . min . y , ipl depth 8u , 4 ) buf . setdata ( unsafe . pointer ( & img . pix [ 0 ] ) , cv autostep ) cvtcolor ( buf , dst , cv rgba2bgra ) buf . release ( ) return dst } 
func ( img * iplimage ) toimage ( ) image . image { var height , width , channels , step int = img . height ( ) , img . width ( ) , img . channels ( ) , img . widthstep ( ) out : = image . newnrgba ( image . rect ( 0 , 0 , width , height ) ) if img . depth ( ) ! = ipl depth 8u { return nil } var limg * c . char = img . imagedata var limg ptr unsafe . pointer = unsafe . pointer ( limg ) var data [ ] c . char = ( * [ 1 < < 30 ] c . char ) ( limg ptr ) [ : height * step : height * step ] c : = color . nrgba { r : uint8 ( 0 ) , g : uint8 ( 0 ) , b : uint8 ( 0 ) , a : uint8 ( 255 ) } for y : = 0 ; y < height ; y ++ { for x : = 0 ; x < step ; x = x + channels { c . b = uint8 ( data [ y * step + x ] ) c . g = uint8 ( data [ y * step + x + 1 ] ) c . r = uint8 ( data [ y * step + x + 2 ] ) if channels == 4 { c . a = uint8 ( data [ y * step + x + 3 ] ) } out . setnrgba ( int ( x / channels ) , y , c ) } } return out } 
func gcvmattomat64 ( mat gcvmat ) * mat64 . dense { col : = mat . getcols ( ) row : = mat . getrows ( ) data : = [ ] float64 { } for i : = 0 ; i < row ; i ++ { for j : = 0 ; j < col ; j ++ { if fltptr , ok : = mat . gcvatf64 ( i , j ) . ( * float64 ) ; ok { data = append ( data , * fltptr ) } else { panic ( " " ) } } } return mat64 . newdense ( row , col , data ) } 
func mat64togcvmat ( mat * mat64 . dense ) gcvmat { row , col : = mat . dims ( ) rawdata : = newgcvfloat64vector ( int64 ( row * col ) ) for i : = 0 ; i < row ; i ++ { for j : = 0 ; j < col ; j ++ { rawdata . set ( i * col + j , mat . at ( i , j ) ) } } return mat64togcvmat ( row , col , rawdata ) } 
func ( r * rect ) tl ( ) point { return point { int ( r . x ) , int ( r . y ) } } 
func ( r * rect ) br ( ) point { return point { int ( r . x ) + int ( r . width ) , int ( r . y ) + int ( r . height ) } } 
func newcvpoint ( x , y int ) cvpoint { return cvpoint { c . int ( x ) , c . int ( y ) } } 
func newcvpoint2d32f ( x , y float32 ) cvpoint2d32f { return cvpoint2d32f { c . float ( x ) , c . float ( y ) } } 
func ( box * box2d ) cvbox ( ) c . cvbox2d { var cvbox c . cvbox2d cvbox . angle = c . float ( box . angle ) cvbox . center . x = c . float ( box . center . x ) cvbox . center . y = c . float ( box . center . y ) cvbox . size . width = c . float ( box . size . width ) cvbox . size . height = c . float ( box . size . height ) return cvbox } 
func ( box * box2d ) points ( ) [ ] point2d32f { var pts [ 4 ] c . cvpoint2d32f c . cvboxpoints ( box . cvbox ( ) , ( * c . cvpoint2d32f ) ( unsafe . pointer ( & pts [ 0 ] ) ) , ) outpts : = make ( [ ] point2d32f , 4 ) for i , p : = range pts { outpts [ i ] . x = float32 ( p . x ) outpts [ i ] . y = float32 ( p . y ) } return outpts } 
func wholeseq ( ) slice { slice : = c . cvslice ( c . int ( 0 ) , c . cv whole seq end index ) return ( slice ) ( slice ) } 
func ( s scalar ) val ( ) [ 4 ] float64 { return [ 4 ] float64 { float64 ( s . val [ 0 ] ) , float64 ( s . val [ 1 ] ) , float64 ( s . val [ 2 ] ) , float64 ( s . val [ 3 ] ) , } } 
func waitkey ( delay int ) int { key : = c . cvwaitkey ( c . int ( delay ) ) return int ( key ) } 
func newwindow ( name string , flags ... int ) * window { win flags : = c . int ( cv window autosize ) if len ( flags ) > 0 { win flags = c . int ( flags [ 0 ] ) } win : = & window { name : name , name c : c . cstring ( name ) , flags : win flags , trackbarhandle : make ( map [ string ] trackbarfunc , 50 ) , trackbarmax : make ( map [ string ] int , 50 ) , trackbarval : make ( map [ string ] int , 50 ) , trackbarname : make ( map [ string ] ( * c . char ) , 50 ) , trackbarparam : make ( map [ string ] ( [ ] interface { } ) , 50 ) , } c . cvnamedwindow ( win . name c , win . flags ) c . goopencv setmousecallback ( win . name c ) allwindows [ win . name ] = win return win } 
func ( win * window ) setproperty ( prop id int , value float64 ) { c . cvsetwindowproperty ( win . name c , c . int ( prop id ) , c . double ( value ) ) } 
func ( win * window ) showimage ( image * iplimage ) { win . image = image c . cvshowimage ( win . name c , unsafe . pointer ( image ) ) } 
func ( win * window ) resize ( width , height int ) { c . cvresizewindow ( win . name c , c . int ( width ) , c . int ( height ) ) } 
func ( win * window ) gethandle ( ) unsafe . pointer { p : = c . cvgetwindowhandle ( win . name c ) return unsafe . pointer ( p ) } 
func gotrackbarcallback ( barname , winname * c . char , pos c . int ) { runtime . lockosthread ( ) defer runtime . unlockosthread ( ) winname : = c . gostring ( winname ) barname : = c . gostring ( barname ) win , ok : = allwindows [ winname ] if ! ok { return } trackbarhandle , ok : = win . trackbarhandle [ barname ] if ! ok { return } if trackbarhandle == nil { return } if fa , ok : = trackbarhandle . ( func ( pos int ) ) ; ok { fa ( int ( pos ) ) } else if fb , ok : = trackbarhandle . ( func ( pos int , param ... interface { } ) ) ; ok { param : = win . trackbarparam [ barname ] if param ! = nil { fb ( int ( pos ) , param ... ) } else { fb ( int ( pos ) ) } } } 
func ( win * window ) gettrackbarpos ( name string ) ( value , max int ) { rv : = c . cvgettrackbarpos ( win . trackbarname [ name ] , win . name c ) return int ( rv ) , win . trackbarmax [ name ] } 
func ( win * window ) setmousecallback ( on mouse mousefunc , param ... interface { } ) { switch f : = on mouse . ( type ) { case mousefunca : win . mousehandle = mousefunc ( f ) case mousefuncb : win . mousehandle = mousefunc ( f ) case func ( event , x , y , flags int ) : win . mousehandle = mousefunc ( f ) case func ( event , x , y , flags int , param ... interface { } ) : win . mousehandle = mousefunc ( f ) default : panic ( " " ) } if len ( param ) > 0 { win . param = param } else { win . param = nil } } 
func gomousecallback ( name * c . char , event , x , y , flags c . int ) { runtime . lockosthread ( ) defer runtime . unlockosthread ( ) winname : = c . gostring ( name ) win , ok : = allwindows [ winname ] if ! ok { return } if win . mousehandle == nil { return } if fa , ok : = win . mousehandle . ( func ( event , x , y , flags int ) ) ; ok { fa ( int ( event ) , int ( x ) , int ( y ) , int ( flags ) ) return } if fb , ok : = win . mousehandle . ( func ( event , x , y , flags int , param ... interface { } ) ) ; ok { if win . param ! = nil { fb ( int ( event ) , int ( x ) , int ( y ) , int ( flags ) , win . param ... ) } else { fb ( int ( event ) , int ( x ) , int ( y ) , int ( flags ) ) } return } } 
func loadimage ( filename string , iscolor ... int ) * iplimage { iscolor : = cv load image color if len ( iscolor ) > 0 { iscolor = iscolor [ 0 ] } name c : = c . cstring ( filename ) defer c . free ( unsafe . pointer ( name c ) ) rv : = c . cvloadimage ( name c , c . int ( iscolor ) ) return ( * iplimage ) ( rv ) } 
func saveimage ( filename string , image * iplimage , params [ ] int ) int { name c : = c . cstring ( filename ) defer c . free ( unsafe . pointer ( name c ) ) var firstparam * c . int if len ( params ) > 0 { var params c [ ] c . int for , param : = range params { params c = append ( params c , c . int ( param ) ) } firstparam = & params c [ 0 ] } rv : = c . cvsaveimage ( name c , unsafe . pointer ( image ) , firstparam ) return int ( rv ) } 
func decodeimage ( buf unsafe . pointer , iscolor int ) * iplimage { rv : = c . cvdecodeimage ( ( * c . cvmat ) ( buf ) , c . int ( iscolor ) ) return ( * iplimage ) ( rv ) } 
func encodeimage ( ext string , image unsafe . pointer , params [ ] int ) * mat { var firstparam * c . int if len ( params ) > 0 { var params c [ ] c . int for , param : = range params { params c = append ( params c , c . int ( param ) ) } firstparam = & params c [ 0 ] } ext c : = c . cstring ( ext ) defer c . free ( unsafe . pointer ( ext c ) ) rv : = c . cvencodeimage ( ext c , ( image ) , firstparam ) return ( * mat ) ( rv ) } 
func convertimage ( src , dst unsafe . pointer , flags int ) { c . cvconvertimage ( src , dst , c . int ( flags ) ) } 
func newfilecapture ( filename string ) * capture { filename c : = c . cstring ( filename ) defer c . free ( unsafe . pointer ( filename c ) ) cap : = c . cvcreatefilecapture ( filename c ) return ( * capture ) ( cap ) } 
func newcameracapture ( index int ) * capture { cap : = c . cvcreatecameracapture ( c . int ( index ) ) return ( * capture ) ( cap ) } 
func ( capture * capture ) grabframe ( ) bool { rv : = c . cvgrabframe ( ( * c . cvcapture ) ( capture ) ) return ( rv ! = c . int ( 0 ) ) } 
func ( capture * capture ) retrieveframe ( streamidx int ) * iplimage { rv : = c . cvretrieveframe ( ( * c . cvcapture ) ( capture ) , c . int ( streamidx ) ) return ( * iplimage ) ( rv ) } 
func ( capture * capture ) queryframe ( ) * iplimage { rv : = c . cvqueryframe ( ( * c . cvcapture ) ( capture ) ) return ( * iplimage ) ( rv ) } 
func ( capture * capture ) release ( ) { cap c : = ( * c . cvcapture ) ( capture ) c . cvreleasecapture ( & cap c ) } 
func ( capture * capture ) getproperty ( property id int ) float64 { rv : = c . cvgetcaptureproperty ( ( * c . cvcapture ) ( capture ) , c . int ( property id ) , ) return float64 ( rv ) } 
func ( capture * capture ) getdomain ( ) int { rv : = c . cvgetcapturedomain ( ( * c . cvcapture ) ( capture ) ) return int ( rv ) } 
func fourcc ( c1 , c2 , c3 , c4 int8 ) uint32 { rv : = c . goopencv fourcc ( c . int ( c1 ) , c . int ( c2 ) , c . int ( c3 ) , c . int ( c4 ) ) return uint32 ( rv ) } 
func newvideowriter ( filename string , fourcc int , fps float32 , frame width , frame height , is color int ) * videowriter { size : = c . cvsize ( c . int ( frame width ) , c . int ( frame height ) ) filename c : = c . cstring ( filename ) defer c . free ( unsafe . pointer ( filename c ) ) rv : = c . cvcreatevideowriter ( filename c , c . int ( fourcc ) , c . double ( fps ) , size , c . int ( is color ) , ) return ( * videowriter ) ( rv ) } 
func ( writer * videowriter ) writeframe ( image * iplimage ) int { rv : = c . cvwriteframe ( ( * c . cvvideowriter ) ( writer ) , ( * c . iplimage ) ( image ) ) return int ( rv ) } 
func ( writer * videowriter ) release ( ) { writer c : = ( * c . cvvideowriter ) ( writer ) c . cvreleasevideowriter ( & writer c ) } 
func gcvinitcameramatrix2d ( objpts , imgpts * mat64 . dense , dims [ 2 ] int , aspectratio float64 ) ( cammat * mat64 . dense ) { objdim , nobjpts : = objpts . dims ( ) imgdim , nimgpts : = imgpts . dims ( ) if objdim ! = 3 | | imgdim ! = 2 | | nobjpts ! = nimgpts { panic ( " " ) } objptsvec : = newgcvpoint3f32vector ( int64 ( nobjpts ) ) imgptsvec : = newgcvpoint2f32vector ( int64 ( nobjpts ) ) for j : = 0 ; j < nobjpts ; j ++ { objptsvec . set ( j , newgcvpoint3f32 ( mat64 . col ( nil , j , objpts ) ... ) ) } for j : = 0 ; j < nobjpts ; j ++ { imgptsvec . set ( j , newgcvpoint2f32 ( mat64 . col ( nil , j , imgpts ) ... ) ) } imgsize : = newgcvsize2i ( dims [ 0 ] , dims [ 1 ] ) cammat = gcvmattomat64 ( gcvinitcameramatrix2d ( objptsvec , imgptsvec , imgsize , aspectratio ) ) return cammat } 
func gcvrodrigues ( src * mat64 . dense ) ( dst * mat64 . dense ) { gcvsrc : = mat64togcvmat ( src ) gcvdst : = newgcvmat ( ) gcvrodrigues ( gcvsrc , gcvdst ) dst = gcvmattomat64 ( gcvdst ) return dst } 
func createimageheader ( w , h , depth , channels int ) * iplimage { hdr : = c . cvcreateimageheader ( c . cvsize ( c . int ( w ) , c . int ( h ) ) , c . int ( depth ) , c . int ( channels ) , ) return ( * iplimage ) ( hdr ) } 
func ( img * iplimage ) initheader ( w , h , depth , channels , origin , align int ) { c . cvinitimageheader ( ( * c . iplimage ) ( img ) , c . cvsize ( c . int ( w ) , c . int ( h ) ) , c . int ( depth ) , c . int ( channels ) , c . int ( origin ) , c . int ( align ) , ) } 
func createimage ( w , h , depth , channels int ) * iplimage { size : = c . cvsize ( c . int ( w ) , c . int ( h ) ) img : = c . cvcreateimage ( size , c . int ( depth ) , c . int ( channels ) ) return ( * iplimage ) ( img ) } 
func merge ( imgblue , imggreen , imgred , imgalpha , dst * iplimage ) { c . cvmerge ( unsafe . pointer ( imgblue ) , unsafe . pointer ( imggreen ) , unsafe . pointer ( imgred ) , unsafe . pointer ( imgalpha ) , unsafe . pointer ( dst ) , ) } 
func split ( src , imgblue , imggreen , imgred , imgalpha * iplimage ) { c . cvsplit ( unsafe . pointer ( src ) , unsafe . pointer ( imgblue ) , unsafe . pointer ( imggreen ) , unsafe . pointer ( imgred ) , unsafe . pointer ( imgalpha ) , ) } 
func addweighted ( src1 * iplimage , alpha float64 , src2 * iplimage , beta float64 , gamma float64 , dst * iplimage ) { c . cvaddweighted ( unsafe . pointer ( src1 ) , c . double ( alpha ) , unsafe . pointer ( src2 ) , c . double ( beta ) , c . double ( gamma ) , unsafe . pointer ( dst ) , ) } 
func ( img * iplimage ) setdata ( data unsafe . pointer , step int ) { c . cvsetdata ( unsafe . pointer ( img ) , data , c . int ( step ) ) } 
func ( img * iplimage ) release ( ) { img c : = ( * c . iplimage ) ( img ) c . cvreleaseimage ( & img c ) } 
func ( img * iplimage ) clone ( ) * iplimage { p : = c . cvcloneimage ( ( * c . iplimage ) ( img ) ) return ( * iplimage ) ( p ) } 
func ( img * iplimage ) setcoi ( coi int ) { c . cvsetimagecoi ( ( * c . iplimage ) ( img ) , c . int ( coi ) ) } 
func ( img * iplimage ) getcoi ( ) int { coi : = c . cvgetimagecoi ( ( * c . iplimage ) ( img ) ) return int ( coi ) } 
func ( img * iplimage ) setroi ( rect rect ) { c . cvsetimageroi ( ( * c . iplimage ) ( img ) , c . cvrect ( rect ) ) } 
func ( img * iplimage ) getroi ( ) rect { r : = c . cvgetimageroi ( ( * c . iplimage ) ( img ) ) return rect ( r ) } 
func ( img * iplimage ) reshape ( channels , rows , type int ) * mat { total : = img . width ( ) * img . height ( ) header : = createmat ( rows , total / rows , type ) n : = c . cvreshape ( unsafe . pointer ( img ) , ( * c . cvmat ) ( header ) , c . int ( channels ) , c . int ( rows ) ) return ( * mat ) ( n ) } 
func ( img * iplimage ) get1d ( x int ) scalar { ret : = c . cvget1d ( unsafe . pointer ( img ) , c . int ( x ) ) return scalar ( ret ) } 
func ( img * iplimage ) get2d ( x , y int ) scalar { ret : = c . cvget2d ( unsafe . pointer ( img ) , c . int ( y ) , c . int ( x ) ) return scalar ( ret ) } 
func ( img * iplimage ) get3d ( x , y , z int ) scalar { ret : = c . cvget3d ( unsafe . pointer ( img ) , c . int ( z ) , c . int ( y ) , c . int ( x ) ) return scalar ( ret ) } 
func ( img * iplimage ) set ( value scalar ) { c . cvset ( unsafe . pointer ( img ) , ( c . cvscalar ) ( value ) , nil ) } 
func ( img * iplimage ) set1d ( x int , value scalar ) { c . cvset1d ( unsafe . pointer ( img ) , c . int ( x ) , ( c . cvscalar ) ( value ) ) } 
func ( img * iplimage ) set2d ( x , y int , value scalar ) { c . cvset2d ( unsafe . pointer ( img ) , c . int ( y ) , c . int ( x ) , ( c . cvscalar ) ( value ) ) } 
func ( img * iplimage ) set3d ( x , y , z int , value scalar ) { c . cvset3d ( unsafe . pointer ( img ) , c . int ( z ) , c . int ( y ) , c . int ( x ) , ( c . cvscalar ) ( value ) ) } 
func ( img * iplimage ) getmat ( ) * mat { var null c . int tmp : = createmat ( img . height ( ) , img . width ( ) , cv 32s ) m : = c . cvgetmat ( unsafe . pointer ( img ) , ( * c . cvmat ) ( tmp ) , & null , c . int ( 0 ) ) return ( * mat ) ( m ) } 
func creatematheader ( rows , cols , type int ) * mat { mat : = c . cvcreatematheader ( c . int ( rows ) , c . int ( cols ) , c . int ( type ) , ) return ( * mat ) ( mat ) } 
func createmat ( rows , cols , type int ) * mat { mat : = c . cvcreatemat ( c . int ( rows ) , c . int ( cols ) , c . int ( type ) , ) return ( * mat ) ( mat ) } 
func ( mat * mat ) initheader ( rows , cols , type int , data unsafe . pointer , step int ) { c . cvinitmatheader ( ( * c . cvmat ) ( mat ) , c . int ( rows ) , c . int ( cols ) , c . int ( type ) , data , c . int ( step ) , ) } 
func ( mat * mat ) setdata ( data unsafe . pointer , step int ) { c . cvsetdata ( unsafe . pointer ( mat ) , data , c . int ( step ) ) } 
func ( mat * mat ) release ( ) { mat c : = ( * c . cvmat ) ( mat ) c . cvreleasemat ( & mat c ) } 
func ( mat * mat ) clone ( ) * mat { mat new : = c . cvclonemat ( ( * c . cvmat ) ( mat ) ) return ( * mat ) ( mat new ) } 
func ( m * mat ) reshape ( channels , rows int ) * mat { total : = m . cols ( ) * m . rows ( ) n : = createmat ( rows , total / rows , m . type ( ) ) c . cvreshape ( unsafe . pointer ( m ) , ( * c . cvmat ) ( n ) , c . int ( channels ) , c . int ( rows ) ) return n } 
func getsubrect ( arr arr , submat * mat , rect rect ) * mat { mat new : = c . cvgetsubrect ( unsafe . pointer ( arr ) , ( * c . cvmat ) ( submat ) , ( c . cvrect ) ( rect ) , ) return ( * mat ) ( mat new ) } 
func getcols ( arr arr , submat * mat , start col , end col int ) * mat { mat new : = c . cvgetcols ( unsafe . pointer ( arr ) , ( * c . cvmat ) ( submat ) , c . int ( start col ) , c . int ( end col ) , ) return ( * mat ) ( mat new ) } 
func getdiag ( arr arr , submat * mat , diag int ) * mat { mat new : = c . cvgetdiag ( unsafe . pointer ( arr ) , ( * c . cvmat ) ( submat ) , c . int ( diag ) , ) return ( * mat ) ( mat new ) } 
func ( m * mat ) get1d ( x int ) scalar { ret : = c . cvget1d ( unsafe . pointer ( m ) , c . int ( x ) ) return scalar ( ret ) } 
func ( m * mat ) get2d ( x , y int ) scalar { ret : = c . cvget2d ( unsafe . pointer ( m ) , c . int ( x ) , c . int ( y ) ) return scalar ( ret ) } 
func ( m * mat ) get3d ( x , y , z int ) scalar { ret : = c . cvget3d ( unsafe . pointer ( m ) , c . int ( x ) , c . int ( y ) , c . int ( z ) ) return scalar ( ret ) } 
func ( m * mat ) set1d ( x int , value scalar ) { c . cvset1d ( unsafe . pointer ( m ) , c . int ( x ) , ( c . cvscalar ) ( value ) ) } 
func ( m * mat ) set2d ( x , y int , value scalar ) { c . cvset2d ( unsafe . pointer ( m ) , c . int ( x ) , c . int ( y ) , ( c . cvscalar ) ( value ) ) } 
func ( m * mat ) set3d ( x , y , z int , value scalar ) { c . cvset3d ( unsafe . pointer ( m ) , c . int ( x ) , c . int ( y ) , c . int ( z ) , ( c . cvscalar ) ( value ) ) } 
func ( m * mat ) getimage ( channels int ) * iplimage { tmp : = createimage ( m . cols ( ) , m . rows ( ) , m . type ( ) , channels ) img : = c . cvgetimage ( unsafe . pointer ( m ) , ( * c . iplimage ) ( tmp ) ) return ( * iplimage ) ( img ) } 
func scalartorawdata ( scalar * scalar , data unsafe . pointer , type , extend to 12 int ) { c . cvscalartorawdata ( ( * c . cvscalar ) ( scalar ) , data , c . int ( type ) , c . int ( extend to 12 ) , ) } 
func creatematndheader ( sizes [ ] int , type int ) * matnd { dims : = c . int ( len ( sizes ) ) sizes c : = make ( [ ] c . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i ++ { sizes c [ i ] = c . int ( sizes [ i ] ) } mat : = c . cvcreatematndheader ( dims , ( * c . int ) ( & sizes c [ 0 ] ) , c . int ( type ) , ) return ( * matnd ) ( mat ) } 
func creatematnd ( sizes [ ] int , type int ) * matnd { dims : = c . int ( len ( sizes ) ) sizes c : = make ( [ ] c . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i ++ { sizes c [ i ] = c . int ( sizes [ i ] ) } mat : = c . cvcreatematnd ( dims , ( * c . int ) ( & sizes c [ 0 ] ) , c . int ( type ) , ) return ( * matnd ) ( mat ) } 
func ( mat * matnd ) initmatndheader ( sizes [ ] int , type int , data unsafe . pointer ) { dims : = c . int ( len ( sizes ) ) sizes c : = make ( [ ] c . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i ++ { sizes c [ i ] = c . int ( sizes [ i ] ) } c . cvinitmatndheader ( ( * c . cvmatnd ) ( mat ) , dims , ( * c . int ) ( & sizes c [ 0 ] ) , c . int ( type ) , data , ) } 
func ( mat * matnd ) release ( ) { mat c : = ( * c . cvmatnd ) ( mat ) c . cvreleasematnd ( & mat c ) } 
func ( mat * matnd ) clone ( ) * matnd { mat c : = ( * c . cvmatnd ) ( mat ) mat ret : = c . cvclonematnd ( mat c ) return ( * matnd ) ( mat ret ) } 
func createsparsemat ( sizes [ ] int , type int ) * sparsemat { dims : = c . int ( len ( sizes ) ) sizes c : = make ( [ ] c . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i ++ { sizes c [ i ] = c . int ( sizes [ i ] ) } mat : = c . cvcreatesparsemat ( dims , ( * c . int ) ( & sizes c [ 0 ] ) , c . int ( type ) , ) return ( * sparsemat ) ( mat ) } 
func ( mat * sparsemat ) release ( ) { mat c : = ( * c . cvsparsemat ) ( mat ) c . cvreleasesparsemat ( & mat c ) } 
func ( mat * sparsemat ) clone ( ) * sparsemat { mat c : = ( * c . cvsparsemat ) ( mat ) mat ret : = c . cvclonesparsemat ( mat c ) return ( * sparsemat ) ( mat ret ) } 
func ( mat * sparsemat ) initsparsematiterator ( iter * sparsematiterator ) * sparsenode { mat c : = ( * c . cvsparsemat ) ( mat ) node : = c . cvinitsparsematiterator ( mat c , ( * c . cvsparsematiterator ) ( iter ) ) return ( * sparsenode ) ( node ) } 
func ( iter * sparsematiterator ) next ( ) * sparsenode { node : = c . cvgetnextsparsenode ( ( * c . cvsparsematiterator ) ( iter ) ) return ( * sparsenode ) ( node ) } 
func copy ( src , dst , mask * iplimage ) { c . cvcopy ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) ) } 
func and ( src1 , src2 , dst * iplimage ) { andwithmask ( src1 , src2 , dst , nil ) } 
func andwithmask ( src1 , src2 , dst , mask * iplimage ) { c . cvand ( unsafe . pointer ( src1 ) , unsafe . pointer ( src2 ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func andscalar ( src * iplimage , value scalar , dst * iplimage ) { andscalarwithmask ( src , value , dst , nil ) } 
func andscalarwithmask ( src * iplimage , value scalar , dst , mask * iplimage ) { c . cvands ( unsafe . pointer ( src ) , ( c . cvscalar ) ( value ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func or ( src1 , src2 , dst * iplimage ) { orwithmask ( src1 , src2 , dst , nil ) } 
func orwithmask ( src1 , src2 , dst , mask * iplimage ) { c . cvor ( unsafe . pointer ( src1 ) , unsafe . pointer ( src2 ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func orscalar ( src * iplimage , value scalar , dst * iplimage ) { orscalarwithmask ( src , value , dst , nil ) } 
func orscalarwithmask ( src * iplimage , value scalar , dst , mask * iplimage ) { c . cvors ( unsafe . pointer ( src ) , ( c . cvscalar ) ( value ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func addwithmask ( src1 , src2 , dst , mask * iplimage ) { c . cvadd ( unsafe . pointer ( src1 ) , unsafe . pointer ( src2 ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func addscalar ( src * iplimage , value scalar , dst * iplimage ) { addscalarwithmask ( src , value , dst , nil ) } 
func addscalarwithmask ( src * iplimage , value scalar , dst , mask * iplimage ) { c . cvadds ( unsafe . pointer ( src ) , ( c . cvscalar ) ( value ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func subtract ( src1 , src2 , dst * iplimage ) { subtractwithmask ( src1 , src2 , dst , nil ) } 
func subtractwithmask ( src1 , src2 , dst , mask * iplimage ) { c . cvsub ( unsafe . pointer ( src1 ) , unsafe . pointer ( src2 ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func subscalar ( src * iplimage , value scalar , dst * iplimage ) { subscalarwithmask ( src , value , dst , nil ) } 
func subscalarwithmask ( src * iplimage , value scalar , dst , mask * iplimage ) { c . cvsubs ( unsafe . pointer ( src ) , ( c . cvscalar ) ( value ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func subscalarrev ( value scalar , src , dst * iplimage ) { subscalarwithmaskrev ( value , src , dst , nil ) } 
func subscalarwithmaskrev ( value scalar , src , dst , mask * iplimage ) { c . cvsubrs ( unsafe . pointer ( src ) , ( c . cvscalar ) ( value ) , unsafe . pointer ( dst ) , unsafe . pointer ( mask ) , ) } 
func absdiff ( src1 , src2 , dst * iplimage ) { c . cvabsdiff ( unsafe . pointer ( src1 ) , unsafe . pointer ( src2 ) , unsafe . pointer ( dst ) , ) } 
func absdiffscalar ( src * iplimage , value scalar , dst * iplimage ) { c . cvabsdiffs ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , ( c . cvscalar ) ( value ) , ) } 
func ( src * iplimage ) equalizehist ( dst * iplimage ) { c . cvequalizehist ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) ) } 
func meanstddevwithmask ( src , mask * iplimage ) ( scalar , scalar ) { var mean , stddev scalar c . cvavgsdv ( unsafe . pointer ( src ) , ( * c . cvscalar ) ( & mean ) , ( * c . cvscalar ) ( & stddev ) , unsafe . pointer ( mask ) , ) return mean , stddev } 
func createseq ( seq flags , elem size int ) * seq { return ( * seq ) ( c . cvcreateseq ( c . int ( seq flags ) , c . size t ( unsafe . sizeof ( seq { } ) ) , c . size t ( elem size ) , c . cvcreatememstorage ( c . int ( 0 ) ) , ) ) } 
func ( seq * seq ) push ( element unsafe . pointer ) unsafe . pointer { return unsafe . pointer ( c . cvseqpush ( ( * c . struct cvseq ) ( seq ) , element ) ) } 
func ( seq * seq ) pop ( element unsafe . pointer ) { c . cvseqpop ( ( * c . struct cvseq ) ( seq ) , element ) } 
func ( seq * seq ) pushfront ( element unsafe . pointer ) unsafe . pointer { return unsafe . pointer ( ( c . cvseqpushfront ( ( * c . struct cvseq ) ( seq ) , element ) ) ) } 
func ( seq * seq ) popfront ( element unsafe . pointer ) { c . cvseqpopfront ( ( * c . struct cvseq ) ( seq ) , element ) } 
func ( seq * seq ) getelemat ( index int ) unsafe . pointer { return ( unsafe . pointer ) ( c . cvgetseqelem ( ( * c . struct cvseq ) ( seq ) , c . int ( index ) , ) ) } 
func ( seq * seq ) removeat ( index int ) { c . cvseqremove ( ( * c . struct cvseq ) ( seq ) , c . int ( index ) ) } 
func initfont ( fontface int , hscale , vscale , shear float32 , thickness , linetype int ) * font { font : = new ( font ) c . cvinitfont ( & font . font , c . int ( fontface ) , c . double ( hscale ) , c . double ( vscale ) , c . double ( shear ) , c . int ( thickness ) , c . int ( linetype ) , ) return font } 
func ( this * font ) puttext ( image * iplimage , text string , pt1 point , color scalar ) { c . cvputtext ( unsafe . pointer ( image ) , c . cstring ( text ) , c . cvpoint ( c . int ( pt1 . x ) , c . int ( pt1 . y ) ) , & this . font , ( c . cvscalar ) ( color ) , ) } 
func smooth ( src , dst * iplimage , smoothtype , param1 , param2 int , param3 , param4 float64 ) { c . cvsmooth ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , c . int ( smoothtype ) , c . int ( param1 ) , c . int ( param2 ) , c . double ( param3 ) , c . double ( param4 ) , ) } 
func laplace ( src , dst * iplimage , aperture size int ) { c . cvlaplace ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , c . int ( aperture size ) ) } 
func convertscale ( a , b * iplimage , scale , shift float64 ) { c . cvconvertscale ( unsafe . pointer ( a ) , unsafe . pointer ( b ) , c . double ( scale ) , c . double ( shift ) ) } 
func cvtcolor ( src , dst * iplimage , code int ) { c . cvcvtcolor ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , c . int ( code ) ) } 
func canny ( image , edges * iplimage , threshold1 , threshold2 float64 , aperture size int ) { c . cvcanny ( unsafe . pointer ( image ) , unsafe . pointer ( edges ) , c . double ( threshold1 ) , c . double ( threshold2 ) , c . int ( aperture size ) , ) } 
func sobel ( src , dst * iplimage , xorder , yorder , aperture size int ) { c . cvsobel ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , c . int ( xorder ) , c . int ( yorder ) , c . int ( aperture size ) , ) } 
func inpaint ( src , inpaint mask , dst * iplimage , inpaintrange float64 , flags int ) { c . cvinpaint ( unsafe . pointer ( src ) , unsafe . pointer ( inpaint mask ) , unsafe . pointer ( dst ) , c . double ( inpaintrange ) , c . int ( flags ) , ) } 
func threshold ( src , dst * iplimage , threshold , max value float64 , threshold type int ) { c . cvthreshold ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , c . double ( threshold ) , c . double ( max value ) , c . int ( threshold type ) , ) } 
func adaptivethreshold ( src , dst * iplimage , max value float64 , adaptive method , threshold type , block size int , thresh c float64 ) { c . cvadaptivethreshold ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , c . double ( max value ) , c . int ( adaptive method ) , c . int ( threshold type ) , c . int ( block size ) , c . double ( thresh c ) , ) } 
func createstructuringelement ( cols , rows , anchor x , anchor y , shape int ) * iplconvkernel { return ( * iplconvkernel ) ( c . cvcreatestructuringelementex ( c . int ( cols ) , c . int ( rows ) , c . int ( anchor x ) , c . int ( anchor y ) , c . int ( shape ) , nil , ) ) } 
func ( k * iplconvkernel ) releaseelement ( ) { c . cvreleasestructuringelement ( ( * * c . iplconvkernel ) ( unsafe . pointer ( & k ) ) , ) } 
func dilate ( src , dst * iplimage , element * iplconvkernel , iterations int ) { c . cvdilate ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , ( * c . iplconvkernel ) ( unsafe . pointer ( element ) ) , c . int ( iterations ) , ) } 
func erode ( src , dst * iplimage , element * iplconvkernel , iterations int ) { c . cverode ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , ( * c . iplconvkernel ) ( unsafe . pointer ( element ) ) , c . int ( iterations ) , ) } 
func morphologyex ( src , dst , temp * iplimage , element * iplconvkernel , operation int , iterations int ) { c . cvmorphologyex ( unsafe . pointer ( src ) , unsafe . pointer ( dst ) , unsafe . pointer ( temp ) , ( * c . iplconvkernel ) ( unsafe . pointer ( element ) ) , c . int ( operation ) , c . int ( iterations ) , ) } 
func delay ( delay time . duration ) option { return func ( c * config ) { c . delay = delay } } 
func backoffdelay ( n uint , config * config ) time . duration { return config . delay * ( 1 < < ( n - 1 ) ) } 
func ( e error ) error ( ) string { logwithnumber : = make ( [ ] string , lenwithoutnil ( e ) ) for i , l : = range e { if l ! = nil { logwithnumber [ i ] = fmt . sprintf ( " " , i + 1 , l . error ( ) ) } } return fmt . sprintf ( " \n " , strings . join ( logwithnumber , " \n " ) ) } 
func ( r * requestbuilder ) arguments ( args ... string ) * requestbuilder { r . args = append ( r . args , args ... ) return r } 
func ( r * requestbuilder ) bodystring ( body string ) * requestbuilder { return r . body ( strings . newreader ( body ) ) } 
func ( r * requestbuilder ) bodybytes ( body [ ] byte ) * requestbuilder { return r . body ( bytes . newreader ( body ) ) } 
func ( r * requestbuilder ) body ( body io . reader ) * requestbuilder { r . body = body return r } 
func ( r * requestbuilder ) option ( key string , value interface { } ) * requestbuilder { var s string switch v : = value . ( type ) { case bool : s = strconv . formatbool ( v ) case string : s = v case [ ] byte : s = string ( v ) default : s = fmt . sprint ( value ) } if r . opts == nil { r . opts = make ( map [ string ] string , 1 ) } r . opts [ key ] = s return r } 
func ( r * requestbuilder ) header ( name , value string ) * requestbuilder { if r . headers == nil { r . headers = make ( map [ string ] string , 1 ) } r . headers [ name ] = value return r } 
func ( r * requestbuilder ) send ( ctx context . context ) ( * response , error ) { req : = newrequest ( ctx , r . shell . url , r . command , r . args ... ) req . opts = r . opts req . headers = r . headers req . body = r . body return req . send ( & r . shell . httpcli ) } 
func ( r * requestbuilder ) exec ( ctx context . context , res interface { } ) error { httpres , err : = r . send ( ctx ) if err ! = nil { return err } if res == nil { lateerr : = httpres . close ( ) if httpres . error ! = nil { return httpres . error } return lateerr } return httpres . decode ( res ) } 
func ( s * pubsubsubscription ) next ( ) ( * message , error ) { if s . resp . error ! = nil { return nil , s . resp . error } d : = json . newdecoder ( s . resp . output ) var r struct { from [ ] byte ' json : " from , omitempty " ' data [ ] byte ' json : " data , omitempty " ' seqno [ ] byte ' json : " seqno , omitempty " ' topicids [ ] string ' json : " topicids , omitempty " ' } err : = d . decode ( & r ) if err ! = nil { return nil , err } from , err : = peer . idfrombytes ( r . from ) if err ! = nil { return nil , err } return & message { from : from , data : r . data , seqno : r . seqno , topicids : r . topicids , } , nil } 
func ( s * pubsubsubscription ) cancel ( ) error { if s . resp . output == nil { return nil } return s . resp . output . close ( ) } 
func ( s * shell ) filelist ( path string ) ( * unixlsobject , error ) { var out lsoutput if err : = s . request ( " " , path ) . exec ( context . background ( ) , & out ) ; err ! = nil { return nil , err } for , object : = range out . objects { return object , nil } return nil , fmt . errorf ( " " ) } 
func ( s * shell ) id ( peer ... string ) ( * idoutput , error ) { if len ( peer ) > 1 { return nil , fmt . errorf ( " " ) } var out idoutput if err : = s . request ( " " , peer ... ) . exec ( context . background ( ) , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( s * shell ) cat ( path string ) ( io . readcloser , error ) { resp , err : = s . request ( " " , path ) . send ( context . background ( ) ) if err ! = nil { return nil , err } if resp . error ! = nil { return nil , resp . error } return resp . output , nil } 
func ( s * shell ) list ( path string ) ( [ ] * lslink , error ) { var out struct { objects [ ] lsobject } err : = s . request ( " " , path ) . exec ( context . background ( ) , & out ) if err ! = nil { return nil , err } if len ( out . objects ) ! = 1 { return nil , errors . new ( " " ) } return out . objects [ 0 ] . links , nil } 
func ( s * shell ) pin ( path string ) error { return s . request ( " " , path ) . option ( " " , true ) . exec ( context . background ( ) , nil ) } 
func ( s * shell ) pins ( ) ( map [ string ] pininfo , error ) { var raw struct { keys map [ string ] pininfo } return raw . keys , s . request ( " " ) . exec ( context . background ( ) , & raw ) } 
func ( s * shell ) version ( ) ( string , string , error ) { ver : = struct { version string commit string } { } if err : = s . request ( " " ) . exec ( context . background ( ) , & ver ) ; err ! = nil { return " " , " " , err } return ver . version , ver . commit , nil } 
func ( s * shell ) objectstat ( key string ) ( * objectstats , error ) { var stat objectstats err : = s . request ( " " , key ) . exec ( context . background ( ) , & stat ) if err ! = nil { return nil , err } return & stat , nil } 
func ( s * shell ) statsbw ( ctx context . context ) ( * p2pmetrics . stats , error ) { v : = & p2pmetrics . stats { } err : = s . request ( " " ) . exec ( ctx , & v ) return v , err } 
func ( s * shell ) swarmpeers ( ctx context . context ) ( * swarmconninfos , error ) { v : = & swarmconninfos { } err : = s . request ( " " ) . exec ( ctx , & v ) return v , err } 
func ( s * shell ) swarmconnect ( ctx context . context , addr ... string ) error { var conn * swarmconnection err : = s . request ( " " ) . arguments ( addr ... ) . exec ( ctx , & conn ) return err } 
func dagputoptions ( opts ... dagputoption ) ( * dagputsettings , error ) { options : = & dagputsettings { inputenc : " " , kind : " " , pin : " " , hash : " " , } for , opt : = range opts { err : = opt ( options ) if err ! = nil { return nil , err } } return options , nil } 
func ( dagopts ) pin ( pin string ) dagputoption { return func ( opts * dagputsettings ) error { opts . pin = pin return nil } } 
func ( dagopts ) inputenc ( enc string ) dagputoption { return func ( opts * dagputsettings ) error { opts . inputenc = enc return nil } } 
func ( dagopts ) kind ( kind string ) dagputoption { return func ( opts * dagputsettings ) error { opts . kind = kind return nil } } 
func ( dagopts ) hash ( hash string ) dagputoption { return func ( opts * dagputsettings ) error { opts . hash = hash return nil } } 
func ( s * shell ) addnopin ( r io . reader ) ( string , error ) { return s . add ( r , pin ( false ) ) } 
func ( s * shell ) addwithopts ( r io . reader , pin bool , rawleaves bool ) ( string , error ) { return s . add ( r , pin ( pin ) , rawleaves ( rawleaves ) ) } 
func ( s * shell ) adddir ( dir string ) ( string , error ) { stat , err : = os . lstat ( dir ) if err ! = nil { return " " , err } sf , err : = files . newserialfile ( dir , false , stat ) if err ! = nil { return " " , err } slf : = files . newslicedirectory ( [ ] files . direntry { files . fileentry ( filepath . base ( dir ) , sf ) } ) reader : = files . newmultifilereader ( slf , true ) resp , err : = s . request ( " " ) . option ( " " , true ) . body ( reader ) . send ( context . background ( ) ) if err ! = nil { return " " , nil } defer resp . close ( ) if resp . error ! = nil { return " " , resp . error } dec : = json . newdecoder ( resp . output ) var final string for { var out object err = dec . decode ( & out ) if err ! = nil { if err == io . eof { break } return " " , err } final = out . hash } if final == " " { return " " , errors . new ( " " ) } return final , nil } 
func ( s * shell ) publish ( node string , value string ) error { var pubresp publishresponse req : = s . request ( " " ) if node ! = " " { req . arguments ( node ) } req . arguments ( value ) return req . exec ( context . background ( ) , & pubresp ) } 
func ( s * shell ) publishwithdetails ( contenthash , key string , lifetime , ttl time . duration , resolve bool ) ( * publishresponse , error ) { var pubresp publishresponse req : = s . request ( " " , contenthash ) . option ( " " , resolve ) if key ! = " " { req . option ( " " , key ) } if lifetime ! = 0 { req . option ( " " , lifetime ) } if ttl . seconds ( ) > 0 { req . option ( " " , ttl ) } err : = req . exec ( context . background ( ) , & pubresp ) if err ! = nil { return nil , err } return & pubresp , nil } 
func ( s * shell ) resolve ( id string ) ( string , error ) { req : = s . request ( " " ) if id ! = " " { req . arguments ( id ) } var out struct { path string } err : = req . exec ( context . background ( ) , & out ) return out . path , err } 
func ( pv planvalue ) resolvevalue ( bindvars map [ string ] * querypb . bindvariable ) ( value , error ) { switch { case pv . key ! = " " : bv , err : = pv . lookupvalue ( bindvars ) if err ! = nil { return null , err } return maketrusted ( bv . type , bv . value ) , nil case ! pv . value . isnull ( ) : return pv . value , nil case pv . listkey ! = " " | | pv . values ! = nil : return null , errors . new ( " " ) } return null , nil } 
func resolverows ( pvs [ ] planvalue , bindvars map [ string ] * querypb . bindvariable ) ( [ ] [ ] value , error ) { count , err : = rowcount ( pvs , bindvars ) if err ! = nil { return nil , err } rows : = make ( [ ] [ ] value , count ) for i : = range rows { rows [ i ] = make ( [ ] value , len ( pvs ) ) } for j , pv : = range pvs { switch { case pv . key ! = " " : bv , err : = pv . lookupvalue ( bindvars ) if err ! = nil { return nil , err } for i : = range rows { rows [ i ] [ j ] = maketrusted ( bv . type , bv . value ) } case ! pv . value . isnull ( ) : for i : = range rows { rows [ i ] [ j ] = pv . value } case pv . listkey ! = " " : bv , err : = pv . lookuplist ( bindvars ) if err ! = nil { return nil , err } for i : = range rows { rows [ i ] [ j ] = maketrusted ( bv . values [ i ] . type , bv . values [ i ] . value ) } case pv . values ! = nil : for i : = range rows { rows [ i ] [ j ] , err = pv . values [ i ] . resolvevalue ( bindvars ) if err ! = nil { return nil , err } } } } return rows , nil } 
func ( pq * parsedquery ) generatequery ( bindvariables map [ string ] * querypb . bindvariable , extras map [ string ] encodable ) ( [ ] byte , error ) { if len ( pq . bindlocations ) == 0 { return [ ] byte ( pq . query ) , nil } buf : = bytes . newbuffer ( make ( [ ] byte , 0 , len ( pq . query ) ) ) current : = 0 for , loc : = range pq . bindlocations { buf . writestring ( pq . query [ current : loc . offset ] ) name : = pq . query [ loc . offset : loc . offset + loc . length ] if encodable , ok : = extras [ name [ 1 : ] ] ; ok { encodable . encodesql ( buf ) } else { supplied , , err : = fetchbindvar ( name , bindvariables ) if err ! = nil { return nil , err } encodevalue ( buf , supplied ) } current = loc . offset + loc . length } buf . writestring ( pq . query [ current : ] ) return buf . bytes ( ) , nil } 
func encodevalue ( buf * bytes . buffer , value * querypb . bindvariable ) { if value . type ! = querypb . type tuple { v , : = sqltypes . bindvariabletovalue ( value ) v . encodesql ( buf ) return } buf . writebyte ( ' ( ' ) for i , bv : = range value . values { if i ! = 0 { buf . writestring ( " " ) } sqltypes . prototovalue ( bv ) . encodesql ( buf ) } buf . writebyte ( ' ) ' ) } 
func ( tkn * tokenizer ) lex ( lval * yysymtype ) int { typ , val : = tkn . scan ( ) for typ == comment { if tkn . allowcomments { break } typ , val = tkn . scan ( ) } lval . bytes = val tkn . lasttoken = val return typ } 
func ( tkn * tokenizer ) skipstatement ( ) { ch : = tkn . lastchar for ch ! = ' ; ' && ch ! = eofchar { tkn . next ( ) ch = tkn . lastchar } } 
func ( tkn * tokenizer ) reset ( ) { tkn . parsetree = nil tkn . partialddl = nil tkn . specialcomment = nil tkn . posvarindex = 0 tkn . nesting = 0 tkn . forceeof = false } 
func preview ( sql string ) int { trimmed : = stripleadingcomments ( sql ) firstword : = trimmed if end : = strings . indexfunc ( trimmed , unicode . isspace ) ; end ! = - 1 { firstword = trimmed [ : end ] } firstword = strings . trimleftfunc ( firstword , func ( r rune ) bool { return ! unicode . isletter ( r ) } ) loweredfirstword : = strings . tolower ( firstword ) switch loweredfirstword { case " " : return stmtselect case " " : return stmtstream case " " : return stmtinsert case " " : return stmtreplace case " " : return stmtupdate case " " : return stmtdelete } trimmednocomments , : = splitmargincomments ( trimmed ) switch strings . tolower ( trimmednocomments ) { case " " , " " : return stmtbegin case " " : return stmtcommit case " " : return stmtrollback } switch loweredfirstword { case " " , " " , " " , " " , " " : return stmtddl case " " : return stmtset case " " : return stmtshow case " " : return stmtuse case " " , " " , " " , " " , " " , " " : return stmtother } if strings . index ( trimmed , " " ) == 0 { return stmtcomment } return stmtunknown } 
func stringin ( str string , values ... string ) bool { for , val : = range values { if str == val { return true } } return false } 
func newtrackedbuffer ( nodeformatter nodeformatter ) * trackedbuffer { return & trackedbuffer { buffer : new ( bytes . buffer ) , nodeformatter : nodeformatter , } } 
func newstringarena ( size int ) * stringarena { sa : = & stringarena { buf : make ( [ ] byte , 0 , size ) } pbytes : = ( * reflect . sliceheader ) ( unsafe . pointer ( & sa . buf ) ) pstring : = ( * reflect . stringheader ) ( unsafe . pointer ( & sa . str ) ) pstring . data = pbytes . data pstring . len = pbytes . cap return sa } 
func ( sa * stringarena ) newstring ( b [ ] byte ) string { if len ( b ) == 0 { return " " } if len ( sa . buf ) + len ( b ) > cap ( sa . buf ) { return string ( b ) } start : = len ( sa . buf ) sa . buf = append ( sa . buf , b ... ) return sa . str [ start : start + len ( b ) ] } 
func ( sa * stringarena ) spaceleft ( ) int { return cap ( sa . buf ) - len ( sa . buf ) } 
func string ( b [ ] byte ) ( s string ) { if len ( b ) == 0 { return " " } pbytes : = ( * reflect . sliceheader ) ( unsafe . pointer ( & b ) ) pstring : = ( * reflect . stringheader ) ( unsafe . pointer ( & s ) ) pstring . data = pbytes . data pstring . len = pbytes . len return } 
func parse ( sql string ) ( statement , error ) { tokenizer : = newstringtokenizer ( sql ) if yyparse ( tokenizer ) ! = 0 { if tokenizer . partialddl ! = nil { log . printf ( " " , sql , tokenizer . lasterror ) tokenizer . parsetree = tokenizer . partialddl return tokenizer . parsetree , nil } return nil , tokenizer . lasterror } return tokenizer . parsetree , nil } 
func parsestrictddl ( sql string ) ( statement , error ) { tokenizer : = newstringtokenizer ( sql ) if yyparse ( tokenizer ) ! = 0 { return nil , tokenizer . lasterror } return tokenizer . parsetree , nil } 
func parsenext ( tokenizer * tokenizer ) ( statement , error ) { if tokenizer . lastchar == ' ; ' { tokenizer . next ( ) tokenizer . skipblank ( ) } if tokenizer . lastchar == eofchar { return nil , io . eof } tokenizer . reset ( ) tokenizer . multi = true if yyparse ( tokenizer ) ! = 0 { if tokenizer . partialddl ! = nil { tokenizer . parsetree = tokenizer . partialddl return tokenizer . parsetree , nil } return nil , tokenizer . lasterror } return tokenizer . parsetree , nil } 
func append ( buf * bytes . buffer , node sqlnode ) { tbuf : = & trackedbuffer { buffer : buf , } node . format ( tbuf ) } 
func ( node * update ) format ( buf * trackedbuffer ) { buf . myprintf ( " " , node . comments , node . tableexprs , node . exprs , node . where , node . orderby , node . limit ) } 
func ( node * show ) format ( buf * trackedbuffer ) { if node . type == " " && node . showtablesopt ! = nil { opt : = node . showtablesopt if opt . dbname ! = " " { if opt . filter ! = nil { buf . myprintf ( " " , opt . extended , opt . full , opt . dbname , opt . filter ) } else { buf . myprintf ( " " , opt . extended , opt . full , opt . dbname ) } } else { if opt . filter ! = nil { buf . myprintf ( " " , opt . extended , opt . full , opt . filter ) } else { buf . myprintf ( " " , opt . extended , opt . full ) } } return } if node . scope == " " { buf . myprintf ( " " , node . type ) } else { buf . myprintf ( " " , node . scope , node . type ) } if node . hasontable ( ) { buf . myprintf ( " " , node . ontable ) } } 
func ( node * showfilter ) format ( buf * trackedbuffer ) { if node . like ! = " " { buf . myprintf ( " " , node . like ) } else { buf . myprintf ( " " , node . filter ) } } 
func exprfromvalue ( value sqltypes . value ) ( expr , error ) { switch { case value . type ( ) == sqltypes . null : return & nullval { } , nil case value . isintegral ( ) : return newintval ( value . tobytes ( ) ) , nil case value . isfloat ( ) | | value . type ( ) == sqltypes . decimal : return newfloatval ( value . tobytes ( ) ) , nil case value . isquoted ( ) : return newstrval ( value . tobytes ( ) ) , nil default : return nil , fmt . errorf ( " " , value ) } } 
func ( node * substrexpr ) format ( buf * trackedbuffer ) { if node . to == nil { buf . myprintf ( " " , node . name , node . from ) } else { buf . myprintf ( " " , node . name , node . from , node . to ) } } 
func ( node * setexpr ) format ( buf * trackedbuffer ) { if node . name . equalstring ( " " ) | | node . name . equalstring ( " " ) { buf . myprintf ( " " , node . name . string ( ) , node . expr ) } else { buf . myprintf ( " " , node . name . string ( ) , node . expr ) } } 
func backtick ( in string ) string { var buf bytes . buffer buf . writebyte ( ' ' ' ) for , c : = range in { buf . writerune ( c ) if c == ' ' ' { buf . writebyte ( ' ' ' ) } } buf . writebyte ( ' ' ' ) return buf . string ( ) } 
func newvalue ( typ querypb . type , val [ ] byte ) ( v value , err error ) { switch { case issigned ( typ ) : if , err : = strconv . parseint ( string ( val ) , 0 , 64 ) ; err ! = nil { return null , err } return maketrusted ( typ , val ) , nil case isunsigned ( typ ) : if , err : = strconv . parseuint ( string ( val ) , 0 , 64 ) ; err ! = nil { return null , err } return maketrusted ( typ , val ) , nil case isfloat ( typ ) | | typ == decimal : if , err : = strconv . parsefloat ( string ( val ) , 64 ) ; err ! = nil { return null , err } return maketrusted ( typ , val ) , nil case isquoted ( typ ) | | typ == null : return maketrusted ( typ , val ) , nil } return null , fmt . errorf ( " " , typ ) } 
func ( v value ) string ( ) string { if v . typ == null { return " " } if v . isquoted ( ) { return fmt . sprintf ( " " , v . typ , v . val ) } return fmt . sprintf ( " " , v . typ , v . val ) } 
func ( v value ) encodesql ( b binwriter ) { switch { case v . typ == null : b . write ( nullstr ) case v . isquoted ( ) : encodebytessql ( v . val , b ) default : b . write ( v . val ) } } 
func ( iv insertvalues ) encodesql ( buf * bytes . buffer ) { for i , rows : = range iv { if i ! = 0 { buf . writestring ( " " ) } buf . writebyte ( ' ( ' ) for j , bv : = range rows { if j ! = 0 { buf . writestring ( " " ) } bv . encodesql ( buf ) } buf . writebyte ( ' ) ' ) } } 
func ( tpl * tupleequalitylist ) encodesql ( buf * bytes . buffer ) { if len ( tpl . columns ) == 1 { tpl . encodeasin ( buf ) return } tpl . encodeasequality ( buf ) } 
func ( nz * normalizer ) walkstatement ( node sqlnode ) ( bool , error ) { switch node : = node . ( type ) { case * select : = walk ( nz . walkselect , node ) return false , nil case * sqlval : nz . convertsqlval ( node ) case * comparisonexpr : nz . convertcomparison ( node ) } return true , nil } 
func ( nz * normalizer ) walkselect ( node sqlnode ) ( bool , error ) { switch node : = node . ( type ) { case * sqlval : nz . convertsqlvaldedup ( node ) case * comparisonexpr : nz . convertcomparison ( node ) } return true , nil } 
func getbindvars ( stmt statement ) map [ string ] struct { } { bindvars : = make ( map [ string ] struct { } ) = walk ( func ( node sqlnode ) ( kontinue bool , err error ) { switch node : = node . ( type ) { case * sqlval : if node . type == valarg { bindvars [ string ( node . val [ 1 : ] ) ] = struct { } { } } case listarg : bindvars [ string ( node [ 2 : ] ) ] = struct { } { } } return true , nil } , stmt ) return bindvars } 
func bindvariablesequal ( x , y map [ string ] * querypb . bindvariable ) bool { return reflect . deepequal ( & querypb . boundquery { bindvariables : x } , & querypb . boundquery { bindvariables : y } ) } 
func new ( options ... options ) * jwtmiddleware { var opts options if len ( options ) == 0 { opts = options { } } else { opts = options [ 0 ] } if opts . userproperty == " " { opts . userproperty = " " } if opts . errorhandler == nil { opts . errorhandler = onerror } if opts . extractor == nil { opts . extractor = fromauthheader } return & jwtmiddleware { options : opts , } } 
func ( m * jwtmiddleware ) handlerwithnext ( w http . responsewriter , r * http . request , next http . handlerfunc ) { err : = m . checkjwt ( w , r ) if err == nil && next ! = nil { next ( w , r ) } } 
func fromauthheader ( r * http . request ) ( string , error ) { authheader : = r . header . get ( " " ) if authheader == " " { return " " , nil } authheaderparts : = strings . split ( authheader , " " ) if len ( authheaderparts ) ! = 2 | | strings . tolower ( authheaderparts [ 0 ] ) ! = " " { return " " , errors . new ( " " ) } return authheaderparts [ 1 ] , nil } 
func fromparameter ( param string ) tokenextractor { return func ( r * http . request ) ( string , error ) { return r . url . query ( ) . get ( param ) , nil } } 
func fromfirst ( extractors ... tokenextractor ) tokenextractor { return func ( r * http . request ) ( string , error ) { for , ex : = range extractors { token , err : = ex ( r ) if err ! = nil { return " " , err } if token ! = " " { return token , nil } } return " " , nil } } 
func ( p * pubsub ) gethellopacket ( ) * rpc { var rpc rpc for t : = range p . mytopics { as : = & pb . rpc subopts { topicid : proto . string ( t ) , subscribe : proto . bool ( true ) , } rpc . subscriptions = append ( rpc . subscriptions , as ) } return & rpc } 
func newfloodsubwithprotocols ( ctx context . context , h host . host , ps [ ] protocol . id , opts ... option ) ( * pubsub , error ) { rt : = & floodsubrouter { protocols : ps , } return newpubsub ( ctx , h , rt , opts ... ) } 
func newfloodsub ( ctx context . context , h host . host , opts ... option ) ( * pubsub , error ) { return newfloodsubwithprotocols ( ctx , h , [ ] protocol . id { floodsubid } , opts ... ) } 
func newlrublacklist ( cap int ) ( blacklist , error ) { c , err : = lru . new ( cap ) if err ! = nil { return nil , err } b : = & lrublacklist { lru : c } return b , nil } 
func newrandomsub ( ctx context . context , h host . host , opts ... option ) ( * pubsub , error ) { rt : = & randomsubrouter { peers : make ( map [ peer . id ] protocol . id ) , } return newpubsub ( ctx , h , rt , opts ... ) } 
func newgossipsub ( ctx context . context , h host . host , opts ... option ) ( * pubsub , error ) { rt : = & gossipsubrouter { peers : make ( map [ peer . id ] protocol . id ) , mesh : make ( map [ string ] map [ peer . id ] struct { } ) , fanout : make ( map [ string ] map [ peer . id ] struct { } ) , lastpub : make ( map [ string ] int64 ) , gossip : make ( map [ peer . id ] [ ] * pb . controlihave ) , control : make ( map [ peer . id ] * pb . controlmessage ) , mcache : newmessagecache ( gossipsubhistorygossip , gossipsubhistorylength ) , } return newpubsub ( ctx , h , rt , opts ... ) } 
func withvalidatethrottle ( n int ) option { return func ( ps * pubsub ) error { ps . validatethrottle = make ( chan struct { } , n ) return nil } } 
func withmessagesigning ( enabled bool ) option { return func ( p * pubsub ) error { if enabled { p . signkey = p . host . peerstore ( ) . privkey ( p . signid ) if p . signkey == nil { return fmt . errorf ( " " , p . signid ) } } else { p . signkey = nil p . signstrict = false } return nil } } 
func withmessageauthor ( author peer . id ) option { return func ( p * pubsub ) error { if author == " " { author = p . host . id ( ) } if p . signkey ! = nil { newsignkey : = p . host . peerstore ( ) . privkey ( author ) if newsignkey == nil { return fmt . errorf ( " " , p . signid ) } p . signkey = newsignkey } p . signid = author return nil } } 
func withstrictsignatureverification ( required bool ) option { return func ( p * pubsub ) error { p . signstrict = required return nil } } 
func withblacklist ( b blacklist ) option { return func ( p * pubsub ) error { p . blacklist = b return nil } } 
func ( p * pubsub ) handleremovesubscription ( sub * subscription ) { subs : = p . mytopics [ sub . topic ] if subs == nil { return } sub . err = fmt . errorf ( " " ) close ( sub . ch ) delete ( subs , sub ) if len ( subs ) == 0 { delete ( p . mytopics , sub . topic ) p . announce ( sub . topic , false ) p . rt . leave ( sub . topic ) } } 
func ( p * pubsub ) handleaddsubscription ( req * addsubreq ) { sub : = req . sub subs : = p . mytopics [ sub . topic ] if len ( subs ) == 0 { p . announce ( sub . topic , true ) p . rt . join ( sub . topic ) } if subs == nil { p . mytopics [ sub . topic ] = make ( map [ * subscription ] struct { } ) subs = p . mytopics [ sub . topic ] } sub . ch = make ( chan * message , 32 ) sub . cancelch = p . cancelch p . mytopics [ sub . topic ] [ sub ] = struct { } { } req . resp < - sub } 
func ( p * pubsub ) announce ( topic string , sub bool ) { subopt : = & pb . rpc subopts { topicid : & topic , subscribe : & sub , } out : = rpcwithsubs ( subopt ) for pid , peer : = range p . peers { select { case peer < - out : default : log . infof ( " " , pid ) go p . announceretry ( pid , topic , sub ) } } } 
func ( p * pubsub ) notifysubs ( msg * pb . message ) { for , topic : = range msg . gettopicids ( ) { subs : = p . mytopics [ topic ] for f : = range subs { select { case f . ch < - & message { msg } : default : log . infof ( " " , topic ) } } } } 
func ( p * pubsub ) seenmessage ( id string ) bool { return p . seenmessages . has ( id ) } 
func ( p * pubsub ) subscribedtomsg ( msg * pb . message ) bool { if len ( p . mytopics ) == 0 { return false } for , t : = range msg . gettopicids ( ) { if , ok : = p . mytopics [ t ] ; ok { return true } } return false } 
func msgid ( pmsg * pb . message ) string { return string ( pmsg . getfrom ( ) ) + string ( pmsg . getseqno ( ) ) } 
func ( p * pubsub ) pushmsg ( vals [ ] * topicval , src peer . id , msg * message ) { if p . blacklist . contains ( src ) { log . warningf ( " " , src ) return } if p . blacklist . contains ( msg . getfrom ( ) ) { log . warningf ( " " , src ) return } if p . signstrict && msg . signature == nil { log . debugf ( " " , src ) return } id : = msgid ( msg . message ) if p . seenmessage ( id ) { return } if len ( vals ) > 0 | | msg . signature ! = nil { select { case p . validatethrottle < - struct { } { } : go func ( ) { p . validate ( vals , src , msg ) < - p . validatethrottle } ( ) default : log . warningf ( " " , src ) } return } p . publishmessage ( src , msg . message ) } 
func ( p * pubsub ) validate ( vals [ ] * topicval , src peer . id , msg * message ) { if msg . signature ! = nil { if ! p . validatesignature ( msg ) { log . warningf ( " " , src ) return } } if len ( vals ) > 0 { if ! p . validatetopic ( vals , src , msg ) { log . warningf ( " " , src ) return } } p . sendmsg < - & sendreq { from : src , msg : msg , } } 
func ( p * pubsub ) validatesingletopic ( val * topicval , src peer . id , msg * message ) bool { select { case val . validatethrottle < - struct { } { } : ctx , cancel : = context . withcancel ( p . ctx ) defer cancel ( ) res : = val . validatemsg ( ctx , src , msg ) < - val . validatethrottle return res default : log . debugf ( " " , val . topic ) return false } } 
func ( p * pubsub ) getvalidators ( msg * message ) [ ] * topicval { var vals [ ] * topicval for , topic : = range msg . gettopicids ( ) { val , ok : = p . topicvals [ topic ] if ! ok { continue } vals = append ( vals , val ) } return vals } 
func ( p * pubsub ) subscribe ( topic string , opts ... subopt ) ( * subscription , error ) { td : = pb . topicdescriptor { name : & topic } return p . subscribebytopicdescriptor ( & td , opts ... ) } 
func ( p * pubsub ) subscribebytopicdescriptor ( td * pb . topicdescriptor , opts ... subopt ) ( * subscription , error ) { if td . getauth ( ) . getmode ( ) ! = pb . topicdescriptor authopts none { return nil , fmt . errorf ( " " ) } if td . getenc ( ) . getmode ( ) ! = pb . topicdescriptor encopts none { return nil , fmt . errorf ( " " ) } sub : = & subscription { topic : td . getname ( ) , } for , opt : = range opts { err : = opt ( sub ) if err ! = nil { return nil , err } } out : = make ( chan * subscription , 1 ) p . addsub < - & addsubreq { sub : sub , resp : out , } return < - out , nil } 
func ( p * pubsub ) gettopics ( ) [ ] string { out : = make ( chan [ ] string , 1 ) p . gettopics < - & topicreq { resp : out } return < - out } 
func ( p * pubsub ) publish ( topic string , data [ ] byte ) error { seqno : = p . nextseqno ( ) m : = & pb . message { data : data , topicids : [ ] string { topic } , from : [ ] byte ( p . host . id ( ) ) , seqno : seqno , } if p . signkey ! = nil { m . from = [ ] byte ( p . signid ) err : = signmessage ( p . signid , p . signkey , m ) if err ! = nil { return err } } p . publish < - & message { m } return nil } 
func ( p * pubsub ) listpeers ( topic string ) [ ] peer . id { out : = make ( chan [ ] peer . id ) p . getpeers < - & listpeerreq { resp : out , topic : topic , } return < - out } 
func withvalidatortimeout ( timeout time . duration ) validatoropt { return func ( addval * addvalreq ) error { addval . timeout = timeout return nil } } 
func withvalidatorconcurrency ( n int ) validatoropt { return func ( addval * addvalreq ) error { addval . throttle = n return nil } } 
func ( p * pubsub ) registertopicvalidator ( topic string , val validator , opts ... validatoropt ) error { addval : = & addvalreq { topic : topic , validate : val , resp : make ( chan error , 1 ) , } for , opt : = range opts { err : = opt ( addval ) if err ! = nil { return err } } p . addval < - addval return < - addval . resp } 
func ( p * pubsub ) unregistertopicvalidator ( topic string ) error { rmval : = & rmvalreq { topic : topic , resp : make ( chan error , 1 ) , } p . rmval < - rmval return < - rmval . resp } 
func defaultmetricprefix ( name string , tags map [ string ] string ) string { return metricwithprefix ( " " , name , tags ) } 
func metricwithprefix ( prefix , name string , tags map [ string ] string ) string { buf : = bufpool . get ( ) . ( * bytes . buffer ) buf . reset ( ) if prefix ! = " " { buf . writestring ( prefix ) } buf . writestring ( name ) addkeys : = make ( [ ] string , 0 , 5 ) switch { case strings . hasprefix ( name , " " ) : addkeys = append ( addkeys , " " , " " , " " ) if strings . hasprefix ( name , " " ) { addkeys = append ( addkeys , " " ) } case strings . hasprefix ( name , " " ) : addkeys = append ( addkeys , " " , " " , " " ) } for , k : = range addkeys { buf . writebyte ( ' . ' ) v , ok : = tags [ k ] if ok { writeclean ( buf , v ) } else { buf . writestring ( " " ) buf . writestring ( k ) } } m : = buf . string ( ) bufpool . put ( buf ) return m } 
func writeclean ( buf * bytes . buffer , v string ) { for i : = 0 ; i < len ( v ) ; i ++ { c : = v [ i ] switch c { case ' { ' , ' } ' , ' / ' , ' \ \ ' , ' : ' , ' . ' , ' ' , ' \ t ' , ' ' , ' \n ' : buf . writebyte ( ' - ' ) default : buf . writebyte ( c ) } } } 
func newclient ( ch * tchannel . channel , targetservice string , opts * clientoptions ) * client { client : = & client { ch : ch , targetservice : targetservice , } if opts ! = nil && opts . hostport ! = " " { client . hostport = opts . hostport } return client } 
func ( c * client ) call ( ctx context , method string , arg , resp interface { } ) error { var ( headers = ctx . headers ( ) respheaders map [ string ] string resperr errapplication errat string isok bool ) err : = c . ch . runwithretry ( ctx , func ( ctx context . context , rs * tchannel . requeststate ) error { respheaders , resperr , isok = nil , nil , false errat = " " call , err : = c . startcall ( ctx , method , & tchannel . calloptions { format : tchannel . json , requeststate : rs , } ) if err ! = nil { return err } isok , errat , err = makecall ( call , headers , arg , & respheaders , resp , & resperr ) return err } ) if err ! = nil { return fmt . errorf ( " " , errat , err ) } if ! isok { return resperr } return nil } 
func wrapcall ( ctx context , call * tchannel . outboundcall , method string , arg , resp interface { } ) error { var respheaders map [ string ] string var resperr errapplication isok , errat , err : = makecall ( call , ctx . headers ( ) , arg , & respheaders , resp , & resperr ) if err ! = nil { return fmt . errorf ( " " , errat , err ) } if ! isok { return resperr } ctx . setresponseheaders ( respheaders ) return nil } 
func callpeer ( ctx context , peer * tchannel . peer , servicename , method string , arg , resp interface { } ) error { call , err : = peer . begincall ( ctx , servicename , method , & tchannel . calloptions { format : tchannel . json } ) if err ! = nil { return err } return wrapcall ( ctx , call , method , arg , resp ) } 
func callsc ( ctx context , sc * tchannel . subchannel , method string , arg , resp interface { } ) error { call , err : = sc . begincall ( ctx , method , & tchannel . calloptions { format : tchannel . json } ) if err ! = nil { return err } return wrapcall ( ctx , call , method , arg , resp ) } 
func writeheaders ( w io . writer , headers map [ string ] string ) error { size : = 2 for k , v : = range headers { size += 4 / * size of key / value lengths * / size += len ( k ) + len ( v ) } buf : = make ( [ ] byte , size ) writebuffer : = typed . newwritebuffer ( buf ) writebuffer . writeuint16 ( uint16 ( len ( headers ) ) ) for k , v : = range headers { writebuffer . writelen16string ( k ) writebuffer . writelen16string ( v ) } if err : = writebuffer . err ( ) ; err ! = nil { return err } if writebuffer . byteswritten ( ) ! = size { return fmt . errorf ( " " , size , writebuffer . byteswritten ( ) ) } , err : = writebuffer . flushto ( w ) return err } 
func readheaders ( r io . reader ) ( map [ string ] string , error ) { reader : = typed . newreader ( r ) m , err : = readheaders ( reader ) reader . release ( ) return m , err } 
func newtcprawrelay ( dests [ ] string ) ( relay , error ) { return newtcprelay ( dests , func ( bool , src , dst net . conn ) { io . copy ( src , dst ) } ) } 
func ( f * failstrategy ) unmarshaltext ( text [ ] byte ) error { switch strategy : = string ( text ) ; strategy { case " " , " " : * f = failstrategyfatal case " " : * f = failstrategyignore default : return fmt . errorf ( " " , strategy ) } return nil } 
func newclient ( ch * tchannel . channel , config configuration , opts * clientoptions ) ( * client , error ) { client : = & client { tchan : ch , quit : make ( chan struct { } ) } if opts ! = nil { client . opts = * opts } if client . opts . timeout == 0 { client . opts . timeout = 3 * time . second } if client . opts . timeoutperattempt == 0 { client . opts . timeoutperattempt = time . second } if client . opts . handler == nil { client . opts . handler = nullhandler { } } if client . opts . timesleep == nil { client . opts . timesleep = time . sleep } if err : = parseconfig ( & config ) ; err ! = nil { return nil , err } for , node : = range config . initialnodes { addpeer ( ch , node ) } client . jsonclient = tjson . newclient ( ch , hyperbahnservicename , nil ) thriftclient : = tthrift . newclient ( ch , hyperbahnservicename , nil ) client . hyperbahnclient = htypes . newtchanhyperbahnclient ( thriftclient ) return client , nil } 
func parseconfig ( config * configuration ) error { if config . initialnodesfile ! = " " { f , err : = os . open ( config . initialnodesfile ) if err ! = nil { return err } defer f . close ( ) decoder : = json . newdecoder ( f ) if err : = decoder . decode ( & config . initialnodes ) ; err ! = nil { return err } } if len ( config . initialnodes ) == 0 { return fmt . errorf ( " " ) } for , node : = range config . initialnodes { if , , err : = net . splithostport ( node ) ; err ! = nil { return fmt . errorf ( " " , node , err ) } } return nil } 
func addpeer ( ch * tchannel . channel , hostport string ) { peers : = ch . getsubchannel ( hyperbahnservicename ) . peers ( ) peers . add ( hostport ) } 
func ( c * client ) advertise ( otherservices ... tchannel . registrar ) error { c . getservicenames ( otherservices ) if err : = c . initialadvertise ( ) ; err ! = nil { return err } c . opts . handler . on ( advertised ) go c . advertiseloop ( ) return nil } 
func verifyhandler ( t reflect . type ) error { if t . numin ( ) ! = 2 | | t . numout ( ) ! = 2 { return fmt . errorf ( " " ) } isstructptr : = func ( t reflect . type ) bool { return t . kind ( ) == reflect . ptr && t . elem ( ) . kind ( ) == reflect . struct } ismap : = func ( t reflect . type ) bool { return t . kind ( ) == reflect . map && t . key ( ) . kind ( ) == reflect . string } validateargres : = func ( t reflect . type , name string ) error { if ! isstructptr ( t ) && ! ismap ( t ) { return fmt . errorf ( " " , name ) } return nil } if t . in ( 0 ) ! = typeofcontext { return fmt . errorf ( " " ) } if err : = validateargres ( t . in ( 1 ) , " " ) ; err ! = nil { return err } if err : = validateargres ( t . out ( 0 ) , " " ) ; err ! = nil { return err } if ! t . out ( 1 ) . assignableto ( typeoferror ) { return fmt . errorf ( " " ) } return nil } 
func register ( registrar tchannel . registrar , funcs handlers , onerror func ( context . context , error ) ) error { handlers : = make ( map [ string ] * handler ) handler : = tchannel . handlerfunc ( func ( ctx context . context , call * tchannel . inboundcall ) { h , ok : = handlers [ string ( call . method ( ) ) ] if ! ok { onerror ( ctx , fmt . errorf ( " " , call . method ( ) ) ) return } if err : = h . handle ( ctx , call ) ; err ! = nil { onerror ( ctx , err ) } } ) for m , f : = range funcs { h , err : = tohandler ( f ) if err ! = nil { return fmt . errorf ( " " , m , err ) } h . tracer = func ( ) opentracing . tracer { return tchannel . tracerfromregistrar ( registrar ) } handlers [ m ] = h registrar . register ( handler , m ) } return nil } 
func ( s * server ) start ( ) error { if s . hostport == " " { s . hostport = " " + common . defaultserverport } channelopts : = & tchannel . channeloptions { tracer : s . tracer , } ch , err : = tchannel . newchannel ( common . defaultservicename , channelopts ) if err ! = nil { return err } if err : = ch . listenandserve ( s . hostport ) ; err ! = nil { return err } s . hostport = ch . peerinfo ( ) . hostport log . printf ( " \n " , s . hostport ) s . ch = ch return nil } 
func ( s * server ) port ( ) string { hostportsplit : = strings . split ( s . hostport , " " ) port : = hostportsplit [ len ( hostportsplit ) - 1 ] return port } 
func ( l * peerlist ) setstrategy ( sc scorecalculator ) { l . lock ( ) defer l . unlock ( ) l . scorecalculator = sc for , ps : = range l . peersbyhostport { newscore : = l . scorecalculator . getscore ( ps . peer ) l . updatepeer ( ps , newscore ) } } 
func ( l * peerlist ) add ( hostport string ) * peer { if ps , ok : = l . exists ( hostport ) ; ok { return ps . peer } l . lock ( ) defer l . unlock ( ) if p , ok : = l . peersbyhostport [ hostport ] ; ok { return p . peer } p : = l . parent . add ( hostport ) p . addsc ( ) ps : = newpeerscore ( p , l . scorecalculator . getscore ( p ) ) l . peersbyhostport [ hostport ] = ps l . peerheap . addpeer ( ps ) return p } 
func ( l * peerlist ) getnew ( prevselected map [ string ] struct { } ) ( * peer , error ) { l . lock ( ) defer l . unlock ( ) if l . peerheap . len ( ) == 0 { return nil , errnopeers } peer : = l . choosepeer ( prevselected , true / * avoidhost * / ) if peer == nil { peer = l . choosepeer ( prevselected , false / * avoidhost * / ) } if peer == nil { return nil , errnonewpeers } return peer , nil } 
func ( l * peerlist ) get ( prevselected map [ string ] struct { } ) ( * peer , error ) { peer , err : = l . getnew ( prevselected ) if err == errnonewpeers { l . lock ( ) peer = l . choosepeer ( nil , false / * avoidhost * / ) l . unlock ( ) } else if err ! = nil { return nil , err } if peer == nil { return nil , errnopeers } return peer , nil } 
func ( l * peerlist ) remove ( hostport string ) error { l . lock ( ) defer l . unlock ( ) p , ok : = l . peersbyhostport [ hostport ] if ! ok { return errpeernotfound } p . delsc ( ) delete ( l . peersbyhostport , hostport ) l . peerheap . removepeer ( p ) return nil } 
func ( l * peerlist ) getoradd ( hostport string ) * peer { if ps , ok : = l . exists ( hostport ) ; ok { return ps . peer } return l . add ( hostport ) } 
func ( l * peerlist ) copy ( ) map [ string ] * peer { l . rlock ( ) defer l . runlock ( ) listcopy : = make ( map [ string ] * peer ) for k , v : = range l . peersbyhostport { listcopy [ k ] = v . peer } return listcopy } 
func ( l * peerlist ) len ( ) int { l . rlock ( ) defer l . runlock ( ) return l . peerheap . len ( ) } 
func ( l * peerlist ) exists ( hostport string ) ( * peerscore , bool ) { l . rlock ( ) ps , ok : = l . peersbyhostport [ hostport ] l . runlock ( ) return ps , ok } 
func ( l * peerlist ) getpeerscore ( hostport string ) ( * peerscore , uint64 , bool ) { ps , ok : = l . peersbyhostport [ hostport ] if ! ok { return nil , 0 , false } return ps , ps . score , ok } 
func ( l * peerlist ) onpeerchange ( p * peer ) { l . rlock ( ) ps , psscore , ok : = l . getpeerscore ( p . hostport ) sc : = l . scorecalculator l . runlock ( ) if ! ok { return } newscore : = sc . getscore ( ps . peer ) if newscore == psscore { return } l . lock ( ) l . updatepeer ( ps , newscore ) l . unlock ( ) } 
func ( l * peerlist ) updatepeer ( ps * peerscore , newscore uint64 ) { if ps . score == newscore { return } ps . score = newscore l . peerheap . updatepeer ( ps ) } 
func ( p * peer ) getconn ( i int ) * connection { inboundlen : = len ( p . inboundconnections ) if i < inboundlen { return p . inboundconnections [ i ] } return p . outboundconnections [ i - inboundlen ] } 
func ( p * peer ) getactiveconn ( ) ( * connection , bool ) { p . rlock ( ) conn , ok : = p . getactiveconnlocked ( ) p . runlock ( ) return conn , ok } 
func ( p * peer ) getconnection ( ctx context . context ) ( * connection , error ) { if activeconn , ok : = p . getactiveconn ( ) ; ok { return activeconn , nil } p . newconnlock . lock ( ) defer p . newconnlock . unlock ( ) if activeconn , ok : = p . getactiveconn ( ) ; ok { return activeconn , nil } return p . connect ( ctx ) } 
func ( p * peer ) getconnectionrelay ( timeout time . duration ) ( * connection , error ) { if conn , ok : = p . getactiveconn ( ) ; ok { return conn , nil } p . newconnlock . lock ( ) defer p . newconnlock . unlock ( ) if activeconn , ok : = p . getactiveconn ( ) ; ok { return activeconn , nil } ctx , cancel : = newcontextbuilder ( timeout ) . hidelisteningonoutbound ( ) . build ( ) defer cancel ( ) return p . connect ( ctx ) } 
func ( p * peer ) canremove ( ) bool { p . rlock ( ) count : = len ( p . inboundconnections ) + len ( p . outboundconnections ) + int ( p . sccount ) p . runlock ( ) return count == 0 } 
func ( p * peer ) addconnection ( c * connection , direction connectiondirection ) error { conns : = p . connectionsfor ( direction ) if c . readstate ( ) ! = connectionactive { return errinvalidconnectionstate } p . lock ( ) * conns = append ( * conns , c ) p . unlock ( ) p . onstatuschanged ( p ) return nil } 
func ( p * peer ) removeconnection ( connsptr * [ ] * connection , changed * connection ) bool { conns : = * connsptr for i , c : = range conns { if c == changed { last : = len ( conns ) - 1 conns [ i ] , conns [ last ] = conns [ last ] , nil * connsptr = conns [ : last ] return true } } return false } 
func ( p * peer ) connectionclosestatechange ( changed * connection ) { if changed . isactive ( ) { return } p . lock ( ) found : = p . removeconnection ( & p . inboundconnections , changed ) if ! found { found = p . removeconnection ( & p . outboundconnections , changed ) } p . unlock ( ) if found { p . onclosedconnremoved ( p ) p . onstatuschanged ( p ) } } 
func ( p * peer ) connect ( ctx context . context ) ( * connection , error ) { return p . channel . connect ( ctx , p . hostport ) } 
func ( p * peer ) begincall ( ctx context . context , servicename , methodname string , calloptions * calloptions ) ( * outboundcall , error ) { if calloptions == nil { calloptions = defaultcalloptions } calloptions . requeststate . addselectedpeer ( p . hostport ( ) ) if err : = validatecall ( ctx , servicename , methodname , calloptions ) ; err ! = nil { return nil , err } conn , err : = p . getconnection ( ctx ) if err ! = nil { return nil , err } call , err : = conn . begincall ( ctx , servicename , methodname , calloptions ) if err ! = nil { return nil , err } return call , err } 
func ( p * peer ) numconnections ( ) ( inbound int , outbound int ) { p . rlock ( ) inbound = len ( p . inboundconnections ) outbound = len ( p . outboundconnections ) p . runlock ( ) return inbound , outbound } 
func ( p * peer ) numpendingoutbound ( ) int { count : = 0 p . rlock ( ) for , c : = range p . outboundconnections { count += c . outbound . count ( ) } for , c : = range p . inboundconnections { count += c . outbound . count ( ) } p . runlock ( ) return count } 
func isephemeralhostport ( hostport string ) bool { return hostport == " " | | hostport == ephemeralhostport | | strings . hassuffix ( hostport , " " ) } 
func ( h * kvhandler ) get ( ctx thrift . context , key string ) ( string , error ) { if err : = isvalidkey ( key ) ; err ! = nil { return " " , err } h . rlock ( ) defer h . runlock ( ) if val , ok : = h . vals [ key ] ; ok { return val , nil } return " " , & keyvalue . keynotfound { key : key } } 
func ( h * kvhandler ) set ( ctx thrift . context , key , value string ) error { if err : = isvalidkey ( key ) ; err ! = nil { return err } h . lock ( ) defer h . unlock ( ) h . vals [ key ] = value ctx . setresponseheaders ( map [ string ] string { " " : fmt . sprint ( len ( h . vals ) ) } ) return nil } 
func ( h * kvhandler ) clearall ( ctx thrift . context ) error { if ! isadmin ( ctx ) { return & keyvalue . notauthorized { } } h . lock ( ) defer h . unlock ( ) h . vals = make ( map [ string ] string ) return nil } 
func ( ccc channelconnectioncommon ) tracer ( ) opentracing . tracer { if ccc . tracer ! = nil { return ccc . tracer } return opentracing . globaltracer ( ) } 
func ( ch * channel ) serve ( l net . listener ) error { mutable : = & ch . mutable mutable . lock ( ) defer mutable . unlock ( ) if mutable . l ! = nil { return erralreadylistening } mutable . l = tnet . wrap ( l ) if mutable . state ! = channelclient { return errinvalidstateforop } mutable . state = channellistening mutable . peerinfo . hostport = l . addr ( ) . string ( ) mutable . peerinfo . isephemeral = false ch . log = ch . log . withfields ( logfield { " " , mutable . peerinfo . hostport } ) ch . log . info ( " " ) go ch . serve ( ) return nil } 
func ( ch * channel ) listenandserve ( hostport string ) error { mutable : = & ch . mutable mutable . rlock ( ) if mutable . l ! = nil { mutable . runlock ( ) return erralreadylistening } l , err : = net . listen ( " " , hostport ) if err ! = nil { mutable . runlock ( ) return err } mutable . runlock ( ) return ch . serve ( l ) } 
func ( ch * channel ) register ( h handler , methodname string ) { if , ok : = ch . handler . ( channelhandler ) ; ! ok { panic ( " " ) } ch . getsubchannel ( ch . peerinfo ( ) . servicename ) . register ( h , methodname ) } 
func ( ch * channel ) peerinfo ( ) localpeerinfo { ch . mutable . rlock ( ) peerinfo : = ch . mutable . peerinfo ch . mutable . runlock ( ) return peerinfo } 
func ( ch * channel ) getsubchannel ( servicename string , opts ... subchanneloption ) * subchannel { sub , added : = ch . subchannels . getoradd ( servicename , ch ) if added { for , opt : = range opts { opt ( sub ) } } return sub } 
func ( ch * channel ) begincall ( ctx context . context , hostport , servicename , methodname string , calloptions * calloptions ) ( * outboundcall , error ) { p : = ch . rootpeers ( ) . getoradd ( hostport ) return p . begincall ( ctx , servicename , methodname , calloptions ) } 
func ( ch * channel ) serve ( ) { acceptbackoff : = 0 * time . millisecond for { netconn , err : = ch . mutable . l . accept ( ) if err ! = nil { if ne , ok : = err . ( net . error ) ; ok && ne . temporary ( ) { if acceptbackoff == 0 { acceptbackoff = 5 * time . millisecond } else { acceptbackoff * = 2 } if max : = 1 * time . second ; acceptbackoff > max { acceptbackoff = max } ch . log . withfields ( errfield ( err ) , logfield { " " , acceptbackoff } , ) . warn ( " " ) time . sleep ( acceptbackoff ) continue } else { if ch . state ( ) >= channelstartclose { return } ch . log . withfields ( errfield ( err ) ) . fatal ( " " ) return } } acceptbackoff = 0 go func ( ) { events : = connectionevents { onactive : ch . inboundconnectionactive , onclosestatechange : ch . connectionclosestatechange , onexchangeupdated : ch . exchangeupdated , } if , err : = ch . inboundhandshake ( context . background ( ) , netconn , events ) ; err ! = nil { netconn . close ( ) } } ( ) } } 
func ( ch * channel ) ping ( ctx context . context , hostport string ) error { peer : = ch . rootpeers ( ) . getoradd ( hostport ) conn , err : = peer . getconnection ( ctx ) if err ! = nil { return err } return conn . ping ( ctx ) } 
func ( ch * channel ) statstags ( ) map [ string ] string { m : = make ( map [ string ] string ) for k , v : = range ch . commonstatstags { m [ k ] = v } return m } 
func ( ch * channel ) exchangeupdated ( c * connection ) { if c . remotepeerinfo . hostport == " " { return } p , ok : = ch . rootpeers ( ) . get ( c . remotepeerinfo . hostport ) if ! ok { return } ch . updatepeer ( p ) } 
func ( ch * channel ) updatepeer ( p * peer ) { ch . peers . onpeerchange ( p ) ch . subchannels . updatepeer ( p ) p . callonupdatecomplete ( ) } 
func ( ch * channel ) addconnection ( c * connection , direction connectiondirection ) bool { ch . mutable . lock ( ) defer ch . mutable . unlock ( ) if c . readstate ( ) ! = connectionactive { return false } switch state : = ch . mutable . state ; state { case channelclient , channellistening : break default : return false } ch . mutable . conns [ c . connid ] = c return true } 
func ( ch * channel ) removeclosedconn ( c * connection ) { if c . readstate ( ) ! = connectionclosed { return } ch . mutable . lock ( ) delete ( ch . mutable . conns , c . connid ) ch . mutable . unlock ( ) } 
func ( ch * channel ) connectionclosestatechange ( c * connection ) { ch . removeclosedconn ( c ) if peer , ok : = ch . rootpeers ( ) . get ( c . remotepeerinfo . hostport ) ; ok { peer . connectionclosestatechange ( c ) ch . updatepeer ( peer ) } if c . outboundhp ! = " " && c . outboundhp ! = c . remotepeerinfo . hostport { if peer , ok : = ch . rootpeers ( ) . get ( c . outboundhp ) ; ok { peer . connectionclosestatechange ( c ) ch . updatepeer ( peer ) } } chstate : = ch . state ( ) if chstate ! = channelstartclose && chstate ! = channelinboundclosed { return } ch . mutable . rlock ( ) minstate : = ch . getminconnectionstate ( ) ch . mutable . runlock ( ) var updateto channelstate if minstate >= connectionclosed { updateto = channelclosed } else if minstate >= connectioninboundclosed && chstate == channelstartclose { updateto = channelinboundclosed } var updatedtostate channelstate if updateto > 0 { ch . mutable . lock ( ) if ch . mutable . state == chstate { ch . mutable . state = updateto updatedtostate = updateto } ch . mutable . unlock ( ) chstate = updateto } c . log . debugf ( " " , chstate , minstate ) if updatedtostate == channelclosed { ch . onclosed ( ) } } 
func ( ch * channel ) state ( ) channelstate { ch . mutable . rlock ( ) state : = ch . mutable . state ch . mutable . runlock ( ) return state } 
func ( ch * channel ) close ( ) { ch . logger ( ) . info ( " " ) var connections [ ] * connection var channelclosed bool func ( ) { ch . mutable . lock ( ) defer ch . mutable . unlock ( ) if ch . mutable . state == channelclosed { ch . logger ( ) . info ( " " ) return } if ch . mutable . l ! = nil { ch . mutable . l . close ( ) } ch . mutable . idlesweep . stop ( ) ch . mutable . state = channelstartclose if len ( ch . mutable . conns ) == 0 { ch . mutable . state = channelclosed channelclosed = true } for , c : = range ch . mutable . conns { connections = append ( connections , c ) } } ( ) for , c : = range connections { c . close ( logfield { " " , " " } ) } if channelclosed { ch . onclosed ( ) } } 
func newreader ( reader io . reader ) * reader { r : = readerpool . get ( ) . ( * reader ) r . reader = reader r . err = nil return r } 
func ( r * reader ) readuint16 ( ) uint16 { if r . err ! = nil { return 0 } buf : = r . buf [ : 2 ] var readn int readn , r . err = io . readfull ( r . reader , buf ) if readn < 2 { return 0 } return binary . bigendian . uint16 ( buf ) } 
func ( r * reader ) readstring ( n int ) string { if r . err ! = nil { return " " } var buf [ ] byte if n <= maxpoolstringlen { buf = r . buf [ : n ] } else { buf = make ( [ ] byte , n ) } var readn int readn , r . err = io . readfull ( r . reader , buf ) if readn < n { return " " } s : = string ( buf ) return s } 
func ( r * reader ) readlen16string ( ) string { len : = r . readuint16 ( ) return r . readstring ( int ( len ) ) } 
func ( b * behavior ) register ( ch * tchannel . channel ) { b . registerthrift ( ch ) b . registerjson ( ch ) } 
func ( tp * relaytimerpool ) get ( ) * relaytimer { timer , ok : = tp . pool . get ( ) . ( * relaytimer ) if ok { timer . released = false return timer } rt : = & relaytimer { pool : tp , } rt . timer = time . afterfunc ( time . duration ( math . maxint64 ) , rt . ontimer ) if ! rt . timer . stop ( ) { panic ( " " ) } return rt } 
func ( tp * relaytimerpool ) put ( rt * relaytimer ) { if tp . verify { return } tp . pool . put ( rt ) } 
func ( rt * relaytimer ) start ( d time . duration , items * relayitems , id uint32 , isoriginator bool ) { rt . verifynotreleased ( ) if rt . active { panic ( " " ) } rt . active = true rt . items = items rt . id = id rt . isoriginator = isoriginator if wasactive : = rt . timer . reset ( d ) ; wasactive { panic ( " " ) } } 
func ( rt * relaytimer ) release ( ) { rt . verifynotreleased ( ) if rt . active { panic ( " " ) } rt . released = true rt . pool . put ( rt ) } 
func newlogger ( writer io . writer , fields ... logfield ) logger { return & writerlogger { writer , fields } } 
func newtcpframerelay ( dests [ ] string , modifier func ( bool , * tchannel . frame ) * tchannel . frame ) ( relay , error ) { var err error r : = & tcpframerelay { modifier : modifier } r . tcprelay , err = newtcprelay ( dests , r . handleconnframerelay ) if err ! = nil { return nil , err } return r , nil } 
func ( kt knowntags ) tallytags ( ) map [ string ] string { tallytags : = make ( map [ string ] string , 5 ) if kt . dest ! = " " { tallytags [ " " ] = kt . dest } if kt . source ! = " " { tallytags [ " " ] = kt . source } if kt . procedure ! = " " { tallytags [ " " ] = kt . procedure } if kt . retrycount ! = " " { tallytags [ " " ] = kt . retrycount } return tallytags } 
func isolated ( s * subchannel ) { s . lock ( ) s . peers = s . topchannel . peers . newsibling ( ) s . peers . setstrategy ( newleastpendingcalculator ( ) ) s . unlock ( ) } 
func ( c * subchannel ) begincall ( ctx context . context , methodname string , calloptions * calloptions ) ( * outboundcall , error ) { if calloptions == nil { calloptions = defaultcalloptions } peer , err : = c . peers . get ( calloptions . requeststate . prevselectedpeers ( ) ) if err ! = nil { return nil , err } return peer . begincall ( ctx , c . servicename ( ) , methodname , calloptions ) } 
func ( c * subchannel ) isolated ( ) bool { c . rlock ( ) defer c . runlock ( ) return c . topchannel . peers ( ) ! = c . peers } 
func ( c * subchannel ) register ( h handler , methodname string ) { handlers , ok : = c . handler . ( * handlermap ) if ! ok { panic ( fmt . sprintf ( " " , c . servicename ( ) , ) ) } handlers . register ( h , methodname ) } 
func ( c * subchannel ) gethandlers ( ) map [ string ] handler { handlers , ok : = c . handler . ( * handlermap ) if ! ok { panic ( fmt . sprintf ( " " , c . servicename ( ) , ) ) } handlers . rlock ( ) handlersmap : = make ( map [ string ] handler , len ( handlers . handlers ) ) for k , v : = range handlers . handlers { handlersmap [ k ] = v } handlers . runlock ( ) return handlersmap } 
func ( c * subchannel ) statstags ( ) map [ string ] string { tags : = c . topchannel . statstags ( ) tags [ " " ] = c . servicename return tags } 
func ( subchmap * subchannelmap ) registernewsubchannel ( servicename string , ch * channel ) ( * subchannel , added bool ) { subchmap . lock ( ) defer subchmap . unlock ( ) if subchmap . subchannels == nil { subchmap . subchannels = make ( map [ string ] * subchannel ) } if sc , ok : = subchmap . subchannels [ servicename ] ; ok { return sc , false } sc : = newsubchannel ( servicename , ch ) subchmap . subchannels [ servicename ] = sc return sc , true } 
func ( subchmap * subchannelmap ) get ( servicename string ) ( * subchannel , bool ) { subchmap . rlock ( ) sc , ok : = subchmap . subchannels [ servicename ] subchmap . runlock ( ) return sc , ok } 
func ( subchmap * subchannelmap ) getoradd ( servicename string , ch * channel ) ( * subchannel , added bool ) { if sc , ok : = subchmap . get ( servicename ) ; ok { return sc , false } return subchmap . registernewsubchannel ( servicename , ch ) } 
func ( c * client ) discover ( servicename string ) ( [ ] string , error ) { ctx , cancel : = thrift . newcontext ( time . second ) defer cancel ( ) result , err : = c . hyperbahnclient . discover ( ctx , & hyperbahn . discoveryquery { servicename : servicename } ) if err ! = nil { return nil , err } var hostports [ ] string for , peer : = range result . getpeers ( ) { hostports = append ( hostports , servicepeertohostport ( peer ) ) } return hostports , nil } 
func ( c * client ) start ( ) error { if err : = c . listen ( ) ; err ! = nil { return err } go func ( ) { http . serve ( c . listener , c . mux ) } ( ) return nil } 
func ( c * client ) listen ( ) error { c . setdefaultport ( & c . clienthostport , " " + common . defaultclientporthttp ) c . setdefaultport ( & c . serverport , common . defaultserverport ) c . mux = http . newservemux ( ) c . mux . handle ( " " , crossdock . handler ( c . behaviors , true ) ) listener , err : = net . listen ( " " , c . clienthostport ) if err ! = nil { return err } c . listener = listener c . clienthostport = listener . addr ( ) . string ( ) return nil } 
func newreadbufferwithsize ( size int ) * readbuffer { return & readbuffer { buffer : make ( [ ] byte , size ) , remaining : nil } } 
func ( r * readbuffer ) readbyte ( ) ( byte , error ) { if r . err ! = nil { return 0 , r . err } if len ( r . remaining ) < 1 { r . err = erreof return 0 , r . err } b : = r . remaining [ 0 ] r . remaining = r . remaining [ 1 : ] return b , nil } 
func ( r * readbuffer ) readbytes ( n int ) [ ] byte { if r . err ! = nil { return nil } if len ( r . remaining ) < n { r . err = erreof return nil } b : = r . remaining [ 0 : n ] r . remaining = r . remaining [ n : ] return b } 
func ( r * readbuffer ) readstring ( n int ) string { if b : = r . readbytes ( n ) ; b ! = nil { return string ( b ) } return " " } 
func ( r * readbuffer ) readuint16 ( ) uint16 { if b : = r . readbytes ( 2 ) ; b ! = nil { return binary . bigendian . uint16 ( b ) } return 0 } 
func ( r * readbuffer ) readuint32 ( ) uint32 { if b : = r . readbytes ( 4 ) ; b ! = nil { return binary . bigendian . uint32 ( b ) } return 0 } 
func ( r * readbuffer ) readuint64 ( ) uint64 { if b : = r . readbytes ( 8 ) ; b ! = nil { return binary . bigendian . uint64 ( b ) } return 0 } 
func ( r * readbuffer ) readuvarint ( ) uint64 { v , : = binary . readuvarint ( r ) return v } 
func ( r * readbuffer ) readlen8string ( ) string { n : = r . readsinglebyte ( ) return r . readstring ( int ( n ) ) } 
func ( r * readbuffer ) readlen16string ( ) string { n : = r . readuint16 ( ) return r . readstring ( int ( n ) ) } 
func ( r * readbuffer ) fillfrom ( ior io . reader , n int ) ( int , error ) { if len ( r . buffer ) < n { return 0 , erreof } r . err = nil r . remaining = r . buffer [ : n ] return io . readfull ( ior , r . remaining ) } 
func ( r * readbuffer ) wrap ( b [ ] byte ) { r . buffer = b r . remaining = b r . err = nil } 
func ( w * writebuffer ) writesinglebyte ( n byte ) { if w . err ! = nil { return } if len ( w . remaining ) == 0 { w . seterr ( errbufferfull ) return } w . remaining [ 0 ] = n w . remaining = w . remaining [ 1 : ] } 
func ( w * writebuffer ) writebytes ( in [ ] byte ) { if b : = w . reserve ( len ( in ) ) ; b ! = nil { copy ( b , in ) } } 
func ( w * writebuffer ) writeuint16 ( n uint16 ) { if b : = w . reserve ( 2 ) ; b ! = nil { binary . bigendian . putuint16 ( b , n ) } } 
func ( w * writebuffer ) writeuint32 ( n uint32 ) { if b : = w . reserve ( 4 ) ; b ! = nil { binary . bigendian . putuint32 ( b , n ) } } 
func ( w * writebuffer ) writeuint64 ( n uint64 ) { if b : = w . reserve ( 8 ) ; b ! = nil { binary . bigendian . putuint64 ( b , n ) } } 
func ( w * writebuffer ) writeuvarint ( n uint64 ) { buf : = make ( [ ] byte , 10 ) varbytes : = binary . putuvarint ( buf , n ) if b : = w . reserve ( varbytes ) ; b ! = nil { copy ( b , buf [ 0 : varbytes ] ) } } 
func ( w * writebuffer ) writestring ( s string ) { if b : = w . reserve ( len ( s ) ) ; b ! = nil { copy ( b , s ) } } 
func ( w * writebuffer ) writelen8string ( s string ) { if int ( byte ( len ( s ) ) ) ! = len ( s ) { w . seterr ( errstringtoolong ) } w . writesinglebyte ( byte ( len ( s ) ) ) w . writestring ( s ) } 
func ( w * writebuffer ) writelen16string ( s string ) { if int ( uint16 ( len ( s ) ) ) ! = len ( s ) { w . seterr ( errstringtoolong ) } w . writeuint16 ( uint16 ( len ( s ) ) ) w . writestring ( s ) } 
func ( w * writebuffer ) deferbyte ( ) byteref { if len ( w . remaining ) == 0 { w . seterr ( errbufferfull ) return byteref ( nil ) } w . remaining [ 0 ] = 0 bufref : = byteref ( w . remaining [ 0 : ] ) w . remaining = w . remaining [ 1 : ] return bufref } 
func ( w * writebuffer ) deferbytes ( n int ) bytesref { return bytesref ( w . deferred ( n ) ) } 
func ( w * writebuffer ) flushto ( iow io . writer ) ( int , error ) { dirty : = w . buffer [ 0 : w . byteswritten ( ) ] return iow . write ( dirty ) } 
func ( w * writebuffer ) reset ( ) { w . remaining = w . buffer w . err = nil } 
func ( w * writebuffer ) wrap ( b [ ] byte ) { w . buffer = b w . remaining = b } 
func ( ref uint16ref ) update ( n uint16 ) { if ref ! = nil { binary . bigendian . putuint16 ( ref , n ) } } 
func ( ref uint32ref ) update ( n uint32 ) { if ref ! = nil { binary . bigendian . putuint32 ( ref , n ) } } 
func ( ref uint64ref ) update ( n uint64 ) { if ref ! = nil { binary . bigendian . putuint64 ( ref , n ) } } 
func ( ref bytesref ) update ( b [ ] byte ) { if ref ! = nil { copy ( ref , b ) } } 
func ( ref bytesref ) updatestring ( s string ) { if ref ! = nil { copy ( ref , s ) } } 
func ( r * fragmentingreader ) argreader ( last bool ) ( argreader , error ) { if err : = r . beginargument ( last ) ; err ! = nil { return nil , err } return r , nil } 
func ( f * writablefragment ) finish ( hasmorefragments bool ) { f . checksumref . update ( f . checksum . sum ( ) ) if hasmorefragments { f . flagsref . update ( hasmorefragmentsflag ) } else { f . checksum . release ( ) } } 
func newwritablechunk ( checksum checksum , contents * typed . writebuffer ) * writablechunk { return & writablechunk { size : 0 , sizeref : contents . deferuint16 ( ) , checksum : checksum , contents : contents , } } 
func ( c * writablechunk ) writeasfits ( b [ ] byte ) int { if len ( b ) > c . contents . bytesremaining ( ) { b = b [ : c . contents . bytesremaining ( ) ] } c . checksum . add ( b ) c . contents . writebytes ( b ) written : = len ( b ) c . size += uint16 ( written ) return written } 
func newfragmentingwriter ( logger logger , sender fragmentsender , checksum checksum ) * fragmentingwriter { return & fragmentingwriter { logger : logger , sender : sender , checksum : checksum , state : fragmentingwritestart , } } 
func ( w * fragmentingwriter ) argwriter ( last bool ) ( argwriter , error ) { if err : = w . beginargument ( last ) ; err ! = nil { return nil , err } return w , nil } 
func ( w * fragmentingwriter ) beginargument ( last bool ) error { if w . err ! = nil { return w . err } switch { case w . state == fragmentingwritecomplete : w . err = errcomplete return w . err case w . state . iswritingargument ( ) : w . err = erralreadywritingargument return w . err } if w . curfragment == nil { initial : = w . state == fragmentingwritestart if w . curfragment , w . err = w . sender . newfragment ( initial , w . checksum ) ; w . err ! = nil { return w . err } } if w . curfragment . contents . bytesremaining ( ) <= chunkheadersize { panic ( fmt . errorf ( " " , w . curfragment . contents . bytesremaining ( ) ) ) } w . curchunk = newwritablechunk ( w . checksum , w . curfragment . contents ) w . state = fragmentingwriteinargument if last { w . state = fragmentingwriteinlastargument } return nil } 
func ( w * fragmentingwriter ) write ( b [ ] byte ) ( int , error ) { if w . err ! = nil { return 0 , w . err } if ! w . state . iswritingargument ( ) { w . err = errnotwritingargument return 0 , w . err } totalwritten : = 0 for { byteswritten : = w . curchunk . writeasfits ( b ) totalwritten += byteswritten if byteswritten == len ( b ) { return totalwritten , nil } if w . err = w . flush ( ) ; w . err ! = nil { return totalwritten , w . err } b = b [ byteswritten : ] } } 
func ( w * fragmentingwriter ) flush ( ) error { w . curchunk . finish ( ) w . curfragment . finish ( true ) if w . err = w . sender . flushfragment ( w . curfragment ) ; w . err ! = nil { return w . err } if w . curfragment , w . err = w . sender . newfragment ( false , w . checksum ) ; w . err ! = nil { return w . err } w . curchunk = newwritablechunk ( w . checksum , w . curfragment . contents ) return nil } 
func ( w * fragmentingwriter ) close ( ) error { last : = w . state == fragmentingwriteinlastargument if w . err ! = nil { return w . err } if ! w . state . iswritingargument ( ) { w . err = errnotwritingargument return w . err } w . curchunk . finish ( ) if last { w . state = fragmentingwritecomplete w . curfragment . finish ( false ) w . err = w . sender . flushfragment ( w . curfragment ) w . sender . donesending ( ) return w . err } w . state = fragmentingwritewaitingforargument if w . curfragment . contents . bytesremaining ( ) > chunkheadersize { return nil } w . curfragment . finish ( true ) if w . err = w . sender . flushfragment ( w . curfragment ) ; w . err ! = nil { return w . err } if w . curfragment , w . err = w . sender . newfragment ( false , w . checksum ) ; w . err ! = nil { return w . err } w . curfragment . contents . writeuint16 ( 0 ) return nil } 
func ( c * connection ) handlecallres ( frame * frame ) bool { if err : = c . outbound . forwardpeerframe ( frame ) ; err ! = nil { return true } return false } 
func ( call * outboundcall ) createstatstags ( connectiontags map [ string ] string , calloptions * calloptions , method string ) { call . commonstatstags = map [ string ] string { " " : call . callreq . service , } for k , v : = range connectiontags { call . commonstatstags [ k ] = v } if calloptions . format ! = http { call . commonstatstags [ " " ] = string ( method ) } } 
func ( call * outboundcall ) writemethod ( method [ ] byte ) error { call . statsreporter . inccounter ( " " , call . commonstatstags , 1 ) return newargwriter ( call . arg1writer ( ) ) . write ( method ) } 
func ( response * outboundcallresponse ) arg2reader ( ) ( argreader , error ) { var method [ ] byte if err : = newargreader ( response . arg1reader ( ) ) . read ( & method ) ; err ! = nil { return nil , err } return response . arg2reader ( ) } 
func ( c * connection ) handleerror ( frame * frame ) bool { errmsg : = errormessage { id : frame . header . id , } rbuf : = typed . newreadbuffer ( frame . sizedpayload ( ) ) if err : = errmsg . read ( rbuf ) ; err ! = nil { c . log . withfields ( logfield { " " , c . remotepeerinfo } , errfield ( err ) , ) . warn ( " " ) c . connectionerror ( " " , err ) return true } if errmsg . errcode == errcodeprotocol { c . log . withfields ( logfield { " " , c . remotepeerinfo } , logfield { " " , errmsg . message } , ) . warn ( " " ) c . connectionerror ( " " , errmsg . assystemerror ( ) ) return true } if err : = c . outbound . forwardpeerframe ( frame ) ; err ! = nil { c . log . withfields ( logfield { " " , frame . header . string ( ) } , logfield { " " , errmsg . id } , logfield { " " , errmsg . message } , logfield { " " , errmsg . errcode } , errfield ( err ) , ) . info ( " " ) return true } return false } 
func ( response * outboundcallresponse ) donereading ( unexpected error ) { now : = response . timenow ( ) issuccess : = unexpected == nil && ! response . applicationerror ( ) lastattempt : = issuccess | | ! response . requeststate . hasretries ( unexpected ) if span : = response . span ; span ! = nil { if unexpected ! = nil { span . logeventwithpayload ( " " , unexpected ) } if ! issuccess && lastattempt { ext . error . set ( span , true ) } span . finishwithoptions ( opentracing . finishoptions { finishtime : now } ) } latency : = now . sub ( response . startedat ) response . statsreporter . recordtimer ( " " , response . commonstatstags , latency ) if lastattempt { requestlatency : = response . requeststate . sincestart ( now , latency ) response . statsreporter . recordtimer ( " " , response . commonstatstags , requestlatency ) } if retrycount : = response . requeststate . retrycount ( ) ; retrycount > 0 { retrytags : = clonetags ( response . commonstatstags ) retrytags [ " " ] = fmt . sprint ( retrycount ) response . statsreporter . inccounter ( " " , retrytags , 1 ) } if unexpected ! = nil { } else if response . applicationerror ( ) { response . statsreporter . inccounter ( " " , response . commonstatstags , 1 ) if lastattempt { response . statsreporter . inccounter ( " " , response . commonstatstags , 1 ) } } else { response . statsreporter . inccounter ( " " , response . commonstatstags , 1 ) } response . mex . shutdown ( ) } 
func ( w * reqreswriter ) argwriter ( last bool , instate reqreswriterstate , outstate reqreswriterstate ) ( argwriter , error ) { if w . err ! = nil { return nil , w . err } if w . state ! = instate { return nil , w . failed ( errreqreswriterstatemismatch { state : w . state , expectedstate : instate } ) } argwriter , err : = w . contents . argwriter ( last ) if err ! = nil { return nil , w . failed ( err ) } w . state = outstate return argwriter , nil } 
func ( w * reqreswriter ) newfragment ( initial bool , checksum checksum ) ( * writablefragment , error ) { if err : = w . mex . checkerror ( ) ; err ! = nil { return nil , w . failed ( err ) } message : = w . messageforfragment ( initial ) frame : = w . conn . opts . framepool . get ( ) frame . header . id = w . mex . msgid frame . header . messagetype = message . messagetype ( ) wbuf : = typed . newwritebuffer ( frame . payload [ : ] ) fragment : = new ( writablefragment ) fragment . frame = frame fragment . flagsref = wbuf . deferbyte ( ) if err : = message . write ( wbuf ) ; err ! = nil { return nil , err } wbuf . writesinglebyte ( byte ( checksum . typecode ( ) ) ) fragment . checksumref = wbuf . deferbytes ( checksum . size ( ) ) fragment . checksum = checksum fragment . contents = wbuf return fragment , wbuf . err ( ) } 
func ( w * reqreswriter ) flushfragment ( fragment * writablefragment ) error { if w . err ! = nil { return w . err } frame : = fragment . frame . ( * frame ) frame . header . setpayloadsize ( uint16 ( fragment . contents . byteswritten ( ) ) ) if err : = w . mex . checkerror ( ) ; err ! = nil { return w . failed ( err ) } select { case < - w . mex . ctx . done ( ) : return w . failed ( getcontexterror ( w . mex . ctx . err ( ) ) ) case < - w . mex . errch . c : return w . failed ( w . mex . errch . err ) case w . conn . sendch < - frame : return nil } } 
func ( w * reqreswriter ) failed ( err error ) error { w . log . debugf ( " " , err , w . err ) if w . err ! = nil { return w . err } w . mex . shutdown ( ) w . err = err return w . err } 
func ( r * reqresreader ) arg1reader ( ) ( argreader , error ) { return r . argreader ( false / * last * / , reqresreaderprearg1 , reqresreaderprearg2 ) } 
func ( r * reqresreader ) arg2reader ( ) ( argreader , error ) { return r . argreader ( false / * last * / , reqresreaderprearg2 , reqresreaderprearg3 ) } 
func ( r * reqresreader ) arg3reader ( ) ( argreader , error ) { return r . argreader ( true / * last * / , reqresreaderprearg3 , reqresreadercomplete ) } 
func ( r * reqresreader ) argreader ( last bool , instate reqresreaderstate , outstate reqresreaderstate ) ( argreader , error ) { if r . state ! = instate { return nil , r . failed ( errreqresreaderstatemismatch { state : r . state , expectedstate : instate } ) } argreader , err : = r . contents . argreader ( last ) if err ! = nil { return nil , r . failed ( err ) } r . state = outstate return argreader , nil } 
func ( r * reqresreader ) recvnextfragment ( initial bool ) ( * readablefragment , error ) { if r . initialfragment ! = nil { fragment : = r . initialfragment r . initialfragment = nil r . previousfragment = fragment return fragment , nil } message : = r . messageforfragment ( initial ) frame , err : = r . mex . recvpeerframeoftype ( message . messagetype ( ) ) if err ! = nil { if err , ok : = err . ( errormessage ) ; ok { r . err = err . assystemerror ( ) return nil , err } return nil , r . failed ( err ) } fragment , err : = parseinboundfragment ( r . mex . framepool , frame , message ) if err ! = nil { return nil , r . failed ( err ) } r . previousfragment = fragment return fragment , nil } 
func ( r * reqresreader ) releasepreviousfragment ( ) { fragment : = r . previousfragment r . previousfragment = nil if fragment ! = nil { fragment . done ( ) } } 
func ( r * reqresreader ) failed ( err error ) error { r . log . debugf ( " " , err , r . err ) if r . err ! = nil { return r . err } r . mex . shutdown ( ) r . err = err return r . err } 
func parseinboundfragment ( framepool framepool , frame * frame , message message ) ( * readablefragment , error ) { rbuf : = typed . newreadbuffer ( frame . sizedpayload ( ) ) fragment : = new ( readablefragment ) fragment . flags = rbuf . readsinglebyte ( ) if err : = message . read ( rbuf ) ; err ! = nil { return nil , err } fragment . checksumtype = checksumtype ( rbuf . readsinglebyte ( ) ) fragment . checksum = rbuf . readbytes ( fragment . checksumtype . checksumsize ( ) ) fragment . contents = rbuf fragment . ondone = func ( ) { framepool . release ( frame ) } return fragment , rbuf . err ( ) } 
func newcontext ( timeout time . duration ) ( context , context . cancelfunc ) { ctx , cancel : = tchannel . newcontext ( timeout ) return wrap ( ctx ) , cancel } 
func withheaders ( ctx context . context , headers map [ string ] string ) context { return tchannel . wrapwithheaders ( ctx , headers ) } 
func ( c * connection ) healthcheck ( connid uint32 ) { defer close ( c . healthcheckdone ) opts : = c . opts . healthchecks ticker : = c . timeticker ( opts . interval ) defer ticker . stop ( ) consecutivefailures : = 0 for { select { case < - ticker . c : case < - c . healthcheckctx . done ( ) : return } ctx , cancel : = context . withtimeout ( c . healthcheckctx , opts . timeout ) err : = c . ping ( ctx ) cancel ( ) c . healthcheckhistory . add ( err == nil ) if err == nil { if c . log . enabled ( logleveldebug ) { c . log . debug ( " " ) } consecutivefailures = 0 continue } if getsystemerrorcode ( err ) == errcodecancelled | | err == errinvalidconnectionstate { c . log . withfields ( errfield ( err ) ) . debug ( " " ) return } consecutivefailures ++ c . log . withfields ( logfields { { " " , consecutivefailures } , errfield ( err ) , { " " , opts . failurestoclose } , } ... ) . warn ( " " ) if consecutivefailures >= opts . failurestoclose { c . close ( logfields { { " " , " " } , errfield ( err ) , } ... ) return } } } 
func ( cb * contextbuilder ) settimeout ( timeout time . duration ) * contextbuilder { cb . timeout = timeout return cb } 
func ( cb * contextbuilder ) addheader ( key , value string ) * contextbuilder { if cb . headers == nil { cb . headers = map [ string ] string { key : value } } else { cb . headers [ key ] = value } return cb } 
func ( cb * contextbuilder ) setheaders ( headers map [ string ] string ) * contextbuilder { cb . headers = headers cb . replaceparentheaders = true return cb } 
func ( cb * contextbuilder ) setshardkey ( sk string ) * contextbuilder { if cb . calloptions == nil { cb . calloptions = new ( calloptions ) } cb . calloptions . shardkey = sk return cb } 
func ( cb * contextbuilder ) setformat ( f format ) * contextbuilder { if cb . calloptions == nil { cb . calloptions = new ( calloptions ) } cb . calloptions . format = f return cb } 
func ( cb * contextbuilder ) setroutingkey ( rk string ) * contextbuilder { if cb . calloptions == nil { cb . calloptions = new ( calloptions ) } cb . calloptions . routingkey = rk return cb } 
func ( cb * contextbuilder ) setroutingdelegate ( rd string ) * contextbuilder { if cb . calloptions == nil { cb . calloptions = new ( calloptions ) } cb . calloptions . routingdelegate = rd return cb } 
func ( cb * contextbuilder ) setconnecttimeout ( d time . duration ) * contextbuilder { cb . connecttimeout = d return cb } 
func ( cb * contextbuilder ) setretryoptions ( retryoptions * retryoptions ) * contextbuilder { cb . retryoptions = retryoptions return cb } 
func ( cb * contextbuilder ) settimeoutperattempt ( timeoutperattempt time . duration ) * contextbuilder { if cb . retryoptions == nil { cb . retryoptions = & retryoptions { } } cb . retryoptions . timeoutperattempt = timeoutperattempt return cb } 
func ( cb * contextbuilder ) setparentcontext ( ctx context . context ) * contextbuilder { cb . parentcontext = ctx return cb } 
func ( cb * contextbuilder ) build ( ) ( contextwithheaders , context . cancelfunc ) { params : = & tchannelctxparams { options : cb . calloptions , call : cb . incomingcall , retryoptions : cb . retryoptions , connecttimeout : cb . connecttimeout , hidelisteningonoutbound : cb . hidelisteningonoutbound , tracingdisabled : cb . tracingdisabled , } parent : = cb . parentcontext if parent == nil { parent = context . background ( ) } else if headerctx , ok : = parent . ( headerctx ) ; ok { parent = headerctx . context } var ( ctx context . context cancel context . cancelfunc ) , parenthasdeadline : = parent . deadline ( ) if cb . timeout == 0 && parenthasdeadline { ctx , cancel = context . withcancel ( parent ) } else { ctx , cancel = context . withtimeout ( parent , cb . timeout ) } ctx = context . withvalue ( ctx , contextkeytchannel , params ) return wrapwithheaders ( ctx , cb . getheaders ( ) ) , cancel } 
func ( c * calloptions ) overrideheaders ( headers transportheaders ) { if c . format ! = " " { headers [ argscheme ] = c . format . string ( ) } if c . shardkey ! = " " { headers [ shardkey ] = c . shardkey } if c . routingkey ! = " " { headers [ routingkey ] = c . routingkey } if c . routingdelegate ! = " " { headers [ routingdelegate ] = c . routingdelegate } if c . callername ! = " " { headers [ callername ] = c . callername } } 
func ( r argreadhelper ) read ( bs * [ ] byte ) error { return r . read ( func ( ) error { var err error * bs , err = ioutil . readall ( r . reader ) return err } ) } 
func ( r argreadhelper ) readjson ( data interface { } ) error { return r . read ( func ( ) error { reader : = bufio . newreader ( r . reader ) if , err : = reader . peek ( 1 ) ; err == io . eof { return nil } else if err ! = nil { return err } d : = json . newdecoder ( reader ) return d . decode ( data ) } ) } 
func newargwriter ( writer io . writecloser , err error ) argwritehelper { return argwritehelper { writer , err } } 
func ( w argwritehelper ) write ( bs [ ] byte ) error { return w . write ( func ( ) error { , err : = w . writer . write ( bs ) return err } ) } 
func ( w argwritehelper ) writejson ( data interface { } ) error { return w . write ( func ( ) error { e : = json . newencoder ( w . writer ) return e . encode ( data ) } ) } 
func ( r * relayitems ) count ( ) int { r . rlock ( ) n : = len ( r . items ) - int ( r . tombs ) r . runlock ( ) return n } 
func ( r * relayitems ) get ( id uint32 ) ( relayitem , bool ) { r . rlock ( ) item , ok : = r . items [ id ] r . runlock ( ) return item , ok } 
func ( r * relayitems ) add ( id uint32 , item relayitem ) { r . lock ( ) r . items [ id ] = item r . unlock ( ) } 
func ( r * relayitems ) delete ( id uint32 ) ( relayitem , bool ) { r . lock ( ) item , ok : = r . items [ id ] if ! ok { r . unlock ( ) r . logger . withfields ( logfield { " " , id } ) . warn ( " " ) return item , false } delete ( r . items , id ) if item . tomb { r . tombs -- } r . unlock ( ) item . timeout . stop ( ) item . timeout . release ( ) return item , ! item . tomb } 
func ( r * relayitems ) entomb ( id uint32 , deleteafter time . duration ) ( relayitem , bool ) { r . lock ( ) if r . tombs > maxrelaytombs { r . unlock ( ) r . logger . withfields ( logfield { " " , id } ) . warn ( " " ) return r . delete ( id ) } item , ok : = r . items [ id ] if ! ok { r . unlock ( ) r . logger . withfields ( logfield { " " , id } ) . warn ( " " ) return item , false } if item . tomb { r . unlock ( ) r . logger . withfields ( logfield { " " , id } ) . warn ( " " ) return item , false } r . tombs ++ item . tomb = true r . items [ id ] = item r . unlock ( ) time . afterfunc ( deleteafter , func ( ) { r . delete ( id ) } ) return item , true } 
func newrelayer ( ch * channel , conn * connection ) * relayer { r : = & relayer { relayhost : ch . relayhost ( ) , maxtimeout : ch . relaymaxtimeout , localhandler : ch . relaylocal , outbound : newrelayitems ( conn . log . withfields ( logfield { " " , " " } ) ) , inbound : newrelayitems ( conn . log . withfields ( logfield { " " , " " } ) ) , peers : ch . rootpeers ( ) , conn : conn , relayconn : & relay . conn { remoteaddr : conn . conn . remoteaddr ( ) . string ( ) , remoteprocessname : conn . remotepeerinfo ( ) . processname , isoutbound : conn . conndirection == outbound , } , logger : conn . log , } r . timeouts = newrelaytimerpool ( r . timeoutrelayitem , ch . relaytimerverify ) return r } 
func ( r * relayer ) relay ( f * frame ) error { if f . messagetype ( ) ! = messagetypecallreq { err : = r . handlenoncallreq ( f ) if err == errunknownid { if err : = r . conn . outbound . forwardpeerframe ( f ) ; err == nil { return nil } } return err } return r . handlecallreq ( newlazycallreq ( f ) ) } 
func ( r * relayer ) receive ( f * frame , ftype frametype ) ( sent bool , failurereason string ) { id : = f . header . id items : = r . receiveritems ( ftype ) item , ok : = items . get ( id ) if ! ok { r . logger . withfields ( logfield { " " , id } , ) . warn ( " " ) return false , relayerrornotfound } finished : = finishescall ( f ) if item . tomb { return true , " " } if ftype == responseframe { if succeeded , failmsg : = determinescallsuccess ( f ) ; succeeded { item . call . succeeded ( ) } else if len ( failmsg ) > 0 { item . call . failed ( failmsg ) } } select { case r . conn . sendch < - f : default : r . logger . withfields ( logfield { " " , id } , ) . warn ( " " ) items : = r . receiveritems ( ftype ) err : = relayerrordestconnslow if ftype == responseframe { err = relayerrorsourceconnslow } r . failrelayitem ( items , id , err ) return false , err } if finished { r . finishrelayitem ( items , id ) } return true , " " } 
func ( r * relayer ) handlenoncallreq ( f * frame ) error { frametype : = frametypefor ( f ) finished : = finishescall ( f ) items : = r . outbound if frametype == responseframe { items = r . inbound } item , ok : = items . get ( f . header . id ) if ! ok { return errunknownid } if item . tomb { return nil } originalid : = f . header . id f . header . id = item . remapid sent , failure : = item . destination . receive ( f , frametype ) if ! sent { r . failrelayitem ( items , originalid , failure ) return nil } if finished { r . finishrelayitem ( items , originalid ) } return nil } 
func ( r * relayer ) addrelayitem ( isoriginator bool , id , remapid uint32 , destination * relayer , ttl time . duration , span span , call relaycall ) relayitem { item : = relayitem { call : call , remapid : remapid , destination : destination , span : span , } items : = r . inbound if isoriginator { items = r . outbound } item . timeout = r . timeouts . get ( ) items . add ( id , item ) item . timeout . start ( ttl , items , id , isoriginator ) return item } 
func ( r * relayer ) failrelayitem ( items * relayitems , id uint32 , failure string ) { item , ok : = items . get ( id ) if ! ok { items . logger . withfields ( logfield { " " , id } ) . warn ( " " ) return } if ! item . timeout . stop ( ) { return } item , ok = items . entomb ( id , relaytombttl ) if ! ok { return } if item . call ! = nil { if failure ! = relayerrorsourceconnslow { r . conn . sendsystemerror ( id , item . span , errframenotsent ) } item . call . failed ( failure ) item . call . end ( ) } r . decrementpending ( ) } 
func writestruct ( writer io . writer , s thrift . tstruct ) error { wp : = getprotocolwriter ( writer ) err : = s . write ( wp . protocol ) thriftprotocolpool . put ( wp ) return err } 
func readstruct ( reader io . reader , s thrift . tstruct ) error { wp : = getprotocolreader ( reader ) err : = s . read ( wp . protocol ) thriftprotocolpool . put ( wp ) return err } 
func ensureempty ( r io . reader , stage string ) error { buf : = bufpool . get ( ) . ( * [ ] byte ) defer bufpool . put ( buf ) n , err : = r . read ( * buf ) if n > 0 { return fmt . errorf ( " " , stage , ( * buf ) [ : n ] ) } if err == io . eof { return nil } return err } 
func newserver ( optfns ... option ) server { opts : = getoptions ( optfns ) if opts . external { return newexternalserver ( opts ) } ch , err : = tchannel . newchannel ( opts . svcname , & tchannel . channeloptions { logger : tchannel . newlevellogger ( tchannel . newlogger ( os . stderr ) , tchannel . loglevelwarn ) , } ) if err ! = nil { panic ( " " + err . error ( ) ) } if err : = ch . listenandserve ( " " ) ; err ! = nil { panic ( " " + err . error ( ) ) } s : = & internalserver { ch : ch , opts : opts , } tserver : = thrift . newserver ( ch ) tserver . register ( gen . newtchansecondserviceserver ( handler { calls : & s . thriftcalls } ) ) ch . register ( raw . wrap ( rawhandler { calls : & s . rawcalls } ) , " " ) if len ( opts . advertisehosts ) > 0 { if err : = s . advertise ( opts . advertisehosts ) ; err ! = nil { panic ( " " + err . error ( ) ) } } return s } 
func ( s * internalserver ) advertise ( hyperbahnhosts [ ] string ) error { config : = hyperbahn . configuration { initialnodes : hyperbahnhosts } hc , err : = hyperbahn . newclient ( s . ch , config , nil ) if err ! = nil { panic ( " " + err . error ( ) ) } return hc . advertise ( ) } 
func ( c * connection ) handlecallreqcontinue ( frame * frame ) bool { if err : = c . inbound . forwardpeerframe ( frame ) ; err ! = nil { return true } return false } 
func ( call * inboundcall ) createstatstags ( connectiontags map [ string ] string ) { call . commonstatstags = map [ string ] string { " " : call . callername ( ) , } for k , v : = range connectiontags { call . commonstatstags [ k ] = v } } 
func ( c * connection ) dispatchinbound ( uint32 , uint32 , call * inboundcall , frame * frame ) { if call . log . enabled ( logleveldebug ) { call . log . debugf ( " " , call . servicename ( ) , c . remotepeerinfo ) } if err : = call . readmethod ( ) ; err ! = nil { call . log . withfields ( logfield { " " , c . remotepeerinfo } , errfield ( err ) , ) . error ( " " ) c . opts . framepool . release ( frame ) return } call . commonstatstags [ " " ] = call . methodstring call . statsreporter . inccounter ( " " , call . commonstatstags , 1 ) if span : = call . response . span ; span ! = nil { span . setoperationname ( call . methodstring ) } go func ( ) { select { case < - call . mex . ctx . done ( ) : if call . mex . ctx . err ( ) ! = nil { call . mex . inboundexpired ( ) } case < - call . mex . errch . c : if c . log . enabled ( logleveldebug ) { call . log . debugf ( " " , call . mex . errch . err ) } call . response . cancel ( ) call . mex . inboundexpired ( ) } } ( ) c . handler . handle ( call . mex . ctx , call ) } 
func ( call * inboundcall ) calloptions ( ) * calloptions { return & calloptions { callername : call . callername ( ) , format : call . format ( ) , shardkey : call . shardkey ( ) , routingdelegate : call . routingdelegate ( ) , routingkey : call . routingkey ( ) , } } 
func ( call * inboundcall ) readmethod ( ) error { var arg1 [ ] byte if err : = newargreader ( call . arg1reader ( ) ) . read ( & arg1 ) ; err ! = nil { return call . failed ( err ) } call . method = arg1 call . methodstring = string ( arg1 ) return nil } 
func ( call * inboundcall ) response ( ) * inboundcallresponse { if call . err ! = nil { call . response . err = call . err } return call . response } 
func ( response * inboundcallresponse ) sendsystemerror ( err error ) error { if response . err ! = nil { return response . err } response . state = reqreswritercomplete response . systemerror = true response . donesending ( ) response . call . releasepreviousfragment ( ) span : = currentspan ( response . mex . ctx ) return response . conn . sendsystemerror ( response . mex . msgid , * span , err ) } 
func ( response * inboundcallresponse ) setapplicationerror ( ) error { if response . state > reqreswriterprearg2 { return response . failed ( errreqreswriterstatemismatch { state : response . state , expectedstate : reqreswriterprearg2 , } ) } response . applicationerror = true return nil } 
func ( response * inboundcallresponse ) arg2writer ( ) ( argwriter , error ) { if err : = newargwriter ( response . arg1writer ( ) ) . write ( nil ) ; err ! = nil { return nil , err } return response . arg2writer ( ) } 
func ( response * inboundcallresponse ) donesending ( ) { now : = response . timenow ( ) if span : = response . span ; span ! = nil { if response . applicationerror | | response . systemerror { ext . error . set ( span , true ) } span . finishwithoptions ( opentracing . finishoptions { finishtime : now } ) } latency : = now . sub ( response . calledat ) response . statsreporter . recordtimer ( " " , response . commonstatstags , latency ) if response . systemerror { } else if response . applicationerror { response . statsreporter . inccounter ( " " , response . commonstatstags , 1 ) } else { response . statsreporter . inccounter ( " " , response . commonstatstags , 1 ) } response . cancel ( ) if response . err == nil { response . mex . shutdown ( ) } } 
func newstate ( v * parser . thrift , all map [ string ] parsestate ) * state { typedefs : = make ( map [ string ] * parser . type ) for k , v : = range v . typedefs { typedefs [ k ] = v . type } i64type : = & parser . type { name : " " } for k : = range v . enums { typedefs [ k ] = i64type } return & state { typedefs , nil , all } } 
func ( s * state ) roottype ( thrifttype * parser . type ) * parser . type { if state , newtype , include : = s . checkinclude ( thrifttype ) ; include ! = nil { return state . roottype ( newtype ) } if v , ok : = s . typedefs [ thrifttype . name ] ; ok { return s . roottype ( v ) } return thrifttype } 
func ( s * state ) checkinclude ( thrifttype * parser . type ) ( * state , * parser . type , * include ) { parts : = strings . splitn ( thrifttype . name , " " , 2 ) if len ( parts ) < 2 { return nil , nil , nil } newtype : = * thrifttype newtype . name = parts [ 1 ] include : = s . includes [ parts [ 0 ] ] state : = s . all [ include . file ] return state . global , & newtype , include } 
func ( s * state ) isresultpointer ( thrifttype * parser . type ) bool { , basicgotype : = thrifttogo [ s . roottype ( thrifttype ) . name ] return ! basicgotype } 
func ( s * state ) gotype ( thrifttype * parser . type ) string { return s . gotypeprefix ( " " , thrifttype ) } 
func ( s * state ) gotypeprefix ( prefix string , thrifttype * parser . type ) string { switch thrifttype . name { case " " : return " " case " " : return " " + s . gotype ( thrifttype . valuetype ) case " " : return " " + s . gotype ( thrifttype . valuetype ) + " " case " " : return " " + s . gotype ( thrifttype . keytype ) + " " + s . gotype ( thrifttype . valuetype ) } if state , newtype , include : = s . checkinclude ( thrifttype ) ; include ! = nil { return state . gotypeprefix ( include . package ( ) + " " , newtype ) } if gotype , ok : = thrifttogo [ thrifttype . name ] ; ok { return gotype } gothriftname : = gopublicfieldname ( thrifttype . name ) gothriftname = prefix + gothriftname roottype : = s . roottype ( thrifttype ) if , ok : = thrifttogo [ roottype . name ] ; ok { return gothriftname } if roottype . name == " " | | roottype . name == " " | | roottype . name == " " { return gothriftname } if roottype ! = thrifttype { return gothriftname } return " " + gothriftname } 
func newcontext ( timeout time . duration ) ( context . context , context . cancelfunc ) { return newcontextbuilder ( timeout ) . build ( ) } 
func newincomingcontext ( call incomingcall , timeout time . duration ) ( context . context , context . cancelfunc ) { return newcontextbuilder ( timeout ) . setincomingcall ( call ) . build ( ) } 
func currentcall ( ctx context . context ) incomingcall { if params : = gettchannelparams ( ctx ) ; params ! = nil { return params . call } return nil } 
func ( p * keyvalueclient ) get ( key string ) ( r string , err error ) { if err = p . sendget ( key ) ; err ! = nil { return } return p . recvget ( ) } 
func ( p * keyvalueclient ) set ( key string , value string ) ( err error ) { if err = p . sendset ( key , value ) ; err ! = nil { return } return p . recvset ( ) } 
func new ( seed int64 ) * rand . rand { return rand . new ( & lockedsource { src : rand . newsource ( seed ) } ) } 
func ( h * metahandler ) health ( ctx context , req * meta . healthrequest ) ( * meta . healthstatus , error ) { ok , message : = h . healthfn ( ctx , metareqtoreq ( req ) ) if message == " " { return & meta . healthstatus { ok : ok } , nil } return & meta . healthstatus { ok : ok , message : & message } , nil } 
func ( p * metaclient ) health ( hr * healthrequest ) ( r * healthstatus , err error ) { if err = p . sendhealth ( hr ) ; err ! = nil { return } return p . recvhealth ( ) } 
func ( c headerctx ) headers ( ) map [ string ] string { if h : = c . headers ( ) ; h ! = nil { return h . reqheaders } return nil } 
func ( c headerctx ) responseheaders ( ) map [ string ] string { if h : = c . headers ( ) ; h ! = nil { return h . respheaders } return nil } 
func ( c headerctx ) setresponseheaders ( headers map [ string ] string ) { if h : = c . headers ( ) ; h ! = nil { h . respheaders = headers return } panic ( " " ) } 
func ( c headerctx ) child ( ) contextwithheaders { var headerscopy headerscontainer if h : = c . headers ( ) ; h ! = nil { headerscopy = * h } return wrap ( context . withvalue ( c . context , contextkeyheaders , & headerscopy ) ) } 
func wrap ( ctx context . context ) contextwithheaders { hctx : = headerctx { context : ctx } if h : = hctx . headers ( ) ; h ! = nil { return hctx } return wrapwithheaders ( ctx , nil ) } 
func wrapwithheaders ( ctx context . context , headers map [ string ] string ) contextwithheaders { h : = & headerscontainer { reqheaders : headers , } newctx : = context . withvalue ( ctx , contextkeyheaders , h ) return headerctx { context : newctx } } 
func withoutheaders ( ctx context . context ) context . context { return context . withvalue ( context . withvalue ( ctx , contextkeytchannel , nil ) , contextkeyheaders , nil ) } 
func ( e * errnotifier ) notify ( err error ) error { if err == nil { panic ( " " ) } if ! e . notified . cas ( false , true ) { return fmt . errorf ( " " , err , e . err ) } e . err = err close ( e . c ) return nil } 
func ( mex * messageexchange ) checkerror ( ) error { if err : = mex . ctx . err ( ) ; err ! = nil { return getcontexterror ( err ) } return mex . errch . checkerr ( ) } 
func ( mex * messageexchange ) forwardpeerframe ( frame * frame ) error { if err : = mex . ctx . err ( ) ; err ! = nil { return getcontexterror ( err ) } select { case mex . recvch < - frame : return nil case < - mex . ctx . done ( ) : return getcontexterror ( mex . ctx . err ( ) ) case < - mex . errch . c : select { case mex . recvch < - frame : return nil default : } return mex . errch . err } } 
func ( mex * messageexchange ) recvpeerframe ( ) ( * frame , error ) { if err : = mex . ctx . err ( ) ; err ! = nil { return nil , getcontexterror ( err ) } select { case frame : = < - mex . recvch : if err : = mex . checkframe ( frame ) ; err ! = nil { return nil , err } return frame , nil case < - mex . ctx . done ( ) : return nil , getcontexterror ( mex . ctx . err ( ) ) case < - mex . errch . c : select { case frame : = < - mex . recvch : if err : = mex . checkframe ( frame ) ; err ! = nil { return nil , err } return frame , nil default : } return nil , mex . errch . err } } 
func ( mex * messageexchange ) recvpeerframeoftype ( msgtype messagetype ) ( * frame , error ) { frame , err : = mex . recvpeerframe ( ) if err ! = nil { return nil , err } switch frame . header . messagetype { case msgtype : return frame , nil case messagetypeerror : defer mex . framepool . release ( frame ) errmsg : = errormessage { id : frame . header . id , } var rbuf typed . readbuffer rbuf . wrap ( frame . sizedpayload ( ) ) if err : = errmsg . read ( & rbuf ) ; err ! = nil { return nil , err } return nil , errmsg default : mex . mexset . log . withfields ( logfield { " " , frame . header } , logfield { " " , msgtype } , logfield { " " , mex . msgid } , ) . warn ( " " ) return nil , errunexpectedframetype } } 
func ( mex * messageexchange ) shutdown ( ) { if ! mex . shutdownatomic . cas ( false , true ) { return } if mex . errchnotified . cas ( false , true ) { mex . errch . notify ( errmexshutdown ) } mex . mexset . removeexchange ( mex . msgid ) } 
func newmessageexchangeset ( log logger , name string ) * messageexchangeset { return & messageexchangeset { name : name , log : log . withfields ( logfield { " " , name } ) , exchanges : make ( map [ uint32 ] * messageexchange ) , expiredexchanges : make ( map [ uint32 ] struct { } ) , } } 
func ( mexset * messageexchangeset ) addexchange ( mex * messageexchange ) error { if mexset . shutdown { return errmexsetshutdown } if , ok : = mexset . exchanges [ mex . msgid ] ; ok { return errduplicatemex } mexset . exchanges [ mex . msgid ] = mex return nil } 
func ( mexset * messageexchangeset ) newexchange ( ctx context . context , framepool framepool , msgtype messagetype , msgid uint32 , buffersize int ) ( * messageexchange , error ) { if mexset . log . enabled ( logleveldebug ) { mexset . log . debugf ( " " , mexset . name , msgtype , msgid ) } mex : = & messageexchange { msgtype : msgtype , msgid : msgid , ctx : ctx , recvch : make ( chan * frame , buffersize ) , errch : newerrnotifier ( ) , mexset : mexset , framepool : framepool , } mexset . lock ( ) adderr : = mexset . addexchange ( mex ) mexset . unlock ( ) if adderr ! = nil { logger : = mexset . log . withfields ( logfield { " " , mex . msgid } , logfield { " " , mex . msgtype } , logfield { " " , mexset . name } , ) if adderr == errmexsetshutdown { logger . warn ( " " ) } else if adderr == errduplicatemex { logger . warn ( " " ) } return nil , adderr } mexset . onadded ( ) return mex , nil } 
func ( mexset * messageexchangeset ) deleteexchange ( msgid uint32 ) ( found , timedout bool ) { if , found : = mexset . exchanges [ msgid ] ; found { delete ( mexset . exchanges , msgid ) return true , false } if , expired : = mexset . expiredexchanges [ msgid ] ; expired { delete ( mexset . expiredexchanges , msgid ) return false , true } return false , false } 
func ( mexset * messageexchangeset ) removeexchange ( msgid uint32 ) { if mexset . log . enabled ( logleveldebug ) { mexset . log . debugf ( " " , mexset . name , msgid ) } mexset . lock ( ) found , expired : = mexset . deleteexchange ( msgid ) mexset . unlock ( ) if ! found && ! expired { mexset . log . withfields ( logfield { " " , msgid } , ) . error ( " " ) return } mexset . onremoved ( ) } 
func ( mexset * messageexchangeset ) expireexchange ( msgid uint32 ) { mexset . log . debugf ( " " , mexset . name , msgid , ) mexset . lock ( ) found , expired : = mexset . deleteexchange ( msgid ) if found | | expired { mexset . expiredexchanges [ msgid ] = struct { } { } } mexset . unlock ( ) if expired { mexset . log . withfields ( logfield { " " , msgid } ) . info ( " " ) } mexset . onremoved ( ) } 
func ( mexset * messageexchangeset ) forwardpeerframe ( frame * frame ) error { if mexset . log . enabled ( logleveldebug ) { mexset . log . debugf ( " " , mexset . name , frame . header ) } mexset . rlock ( ) mex : = mexset . exchanges [ frame . header . id ] mexset . runlock ( ) if mex == nil { mexset . log . withfields ( logfield { " " , frame . header . string ( ) } , logfield { " " , mexset . name } , ) . info ( " " ) return nil } if err : = mex . forwardpeerframe ( frame ) ; err ! = nil { mexset . log . withfields ( logfield { " " , frame . header . string ( ) } , logfield { " " , frame . header . framesize ( ) } , logfield { " " , mexset . name } , errfield ( err ) , ) . info ( " " ) return err } return nil } 
func ( mexset * messageexchangeset ) copyexchanges ( ) ( shutdown bool , exchanges map [ uint32 ] * messageexchange ) { if mexset . shutdown { return true , nil } exchangescopy : = make ( map [ uint32 ] * messageexchange , len ( mexset . exchanges ) ) for k , mex : = range mexset . exchanges { exchangescopy [ k ] = mex } return false , exchangescopy } 
func ( mexset * messageexchangeset ) stopexchanges ( err error ) { if mexset . log . enabled ( logleveldebug ) { mexset . log . debugf ( " " , mexset . count ( ) , err ) } mexset . lock ( ) shutdown , exchanges : = mexset . copyexchanges ( ) mexset . shutdown = true mexset . unlock ( ) if shutdown { mexset . log . debugf ( " " ) return } for , mex : = range exchanges { if mex . errchnotified . cas ( false , true ) { mex . errch . notify ( err ) } } } 
func ( fh frameheader ) marshaljson ( ) ( [ ] byte , error ) { s : = struct { id uint32 ' json : " id " ' msgtype messagetype ' json : " msgtype " ' size uint16 ' json : " size " ' } { fh . id , fh . messagetype , fh . size } return json . marshal ( s ) } 
func newframe ( payloadcapacity int ) * frame { f : = & frame { } f . buffer = make ( [ ] byte , payloadcapacity + frameheadersize ) f . payload = f . buffer [ frameheadersize : ] f . headerbuffer = f . buffer [ : frameheadersize ] return f } 
func ( f * frame ) readbody ( header [ ] byte , r io . reader ) error { copy ( f . buffer , header ) if err : = f . header . read ( typed . newreadbuffer ( header ) ) ; err ! = nil { return err } switch payloadsize : = f . header . payloadsize ( ) ; { case payloadsize > maxframepayloadsize : return fmt . errorf ( " " , f . header . size ) case payloadsize > 0 : , err : = io . readfull ( r , f . sizedpayload ( ) ) return err default : return nil } } 
func ( f * frame ) readin ( r io . reader ) error { header : = make ( [ ] byte , frameheadersize ) if , err : = io . readfull ( r , header ) ; err ! = nil { return err } return f . readbody ( header , r ) } 
func ( f * frame ) writeout ( w io . writer ) error { var wbuf typed . writebuffer wbuf . wrap ( f . headerbuffer ) if err : = f . header . write ( & wbuf ) ; err ! = nil { return err } fullframe : = f . buffer [ : f . header . framesize ( ) ] if , err : = w . write ( fullframe ) ; err ! = nil { return err } return nil } 
func ( r retryon ) canretry ( err error ) bool { if r == retrynever { return false } if r == retrydefault { r = retryconnectionerror } code : = geterrcode ( err ) if code == errcodebusy | | code == errcodedeclined { return true } if code == errcodebadrequest { return false } switch r { case retryconnectionerror : return code == errcodenetwork case retryunexpected : return code == errcodeunexpected case retryidempotent : return true } return false } 
func ( rs * requeststate ) hasretries ( err error ) bool { if rs == nil { return false } ropts : = rs . retryopts return rs . attempt < ropts . maxattempts && ropts . retryon . canretry ( err ) } 
func ( rs * requeststate ) sincestart ( now time . time , fallback time . duration ) time . duration { if rs == nil { return fallback } return now . sub ( rs . start ) } 
func ( rs * requeststate ) addselectedpeer ( hostport string ) { if rs == nil { return } host : = gethost ( hostport ) if rs . selectedpeers == nil { rs . selectedpeers = map [ string ] struct { } { hostport : { } , host : { } , } } else { rs . selectedpeers [ hostport ] = struct { } { } rs . selectedpeers [ host ] = struct { } { } } } 
func ( ch * channel ) runwithretry ( runctx context . context , f retriablefunc ) error { var err error opts : = getretryoptions ( runctx ) rs : = ch . getrequeststate ( opts ) defer requeststatepool . put ( rs ) for i : = 0 ; i < opts . maxattempts ; i ++ { rs . attempt ++ if opts . timeoutperattempt == 0 { err = f ( runctx , rs ) } else { attemptctx , cancel : = context . withtimeout ( runctx , opts . timeoutperattempt ) err = f ( attemptctx , rs ) cancel ( ) } if err == nil { return nil } if ! opts . retryon . canretry ( err ) { if ch . log . enabled ( loglevelinfo ) { ch . log . withfields ( errfield ( err ) ) . info ( " " ) } return err } ch . log . withfields ( errfield ( err ) , logfield { " " , rs . attempt } , logfield { " " , opts . maxattempts } , ) . info ( " " ) } return err } 
func gethost ( hostport string ) string { for i : = 0 ; i < len ( hostport ) ; i ++ { if hostport [ i ] == ' : ' { return hostport [ : i ] } } return hostport } 
func ( t checksumtype ) checksumsize ( ) int { switch t { case checksumtypenone : return 0 case checksumtypecrc32 , checksumtypecrc32c : return crc32 . size case checksumtypefarmhash : return 4 default : return 0 } } 
func ( t checksumtype ) new ( ) checksum { s : = t . pool ( ) . get ( ) . ( checksum ) s . reset ( ) return s } 
func parsetemplates ( skiptchannel bool , templatefiles [ ] string ) ( [ ] * template , error ) { var templates [ ] * template if ! skiptchannel { templates = append ( templates , & template { name : " " , template : template . must ( parsetemplate ( tchanneltmpl ) ) , } ) } for , f : = range templatefiles { t , err : = parsetemplatefile ( f ) if err ! = nil { return nil , err } templates = append ( templates , t ) } return templates , nil } 
func newstringsliceflag ( name string , usage string ) * [ ] string { var ss stringsliceflag flag . var ( & ss , name , usage ) return ( * [ ] string ) ( & ss ) } 
func ( t * template ) withstatefuncs ( td templatedata ) * template . template { return t . template . funcs ( map [ string ] interface { } { " " : td . global . gotype , } ) } 
func ( ch * channel ) introspectstate ( opts * introspectionoptions ) * runtimestate { if opts == nil { opts = & introspectionoptions { } } ch . mutable . rlock ( ) state : = ch . mutable . state numconns : = len ( ch . mutable . conns ) inactiveconns : = make ( [ ] * connection , 0 , numconns ) connids : = make ( [ ] uint32 , 0 , numconns ) for id , conn : = range ch . mutable . conns { connids = append ( connids , id ) if ! conn . isactive ( ) { inactiveconns = append ( inactiveconns , conn ) } } ch . mutable . runlock ( ) ch . state ( ) return & runtimestate { id : ch . chid , channelstate : state . string ( ) , createdstack : ch . createdstack , localpeer : ch . peerinfo ( ) , subchannels : ch . subchannels . introspectstate ( opts ) , rootpeers : ch . rootpeers ( ) . introspectstate ( opts ) , peers : ch . peers ( ) . introspectlist ( opts ) , numconnections : numconns , connections : connids , inactiveconnections : getconnectionruntimestate ( inactiveconns , opts ) , otherchannels : ch . introspectothers ( opts ) , runtimeversion : introspectruntimeversion ( ) , } } 
func ( ch * channel ) introspectothers ( opts * introspectionoptions ) map [ string ] [ ] channelinfo { if ! opts . includeotherchannels { return nil } channelmap . lock ( ) defer channelmap . unlock ( ) states : = make ( map [ string ] [ ] channelinfo ) for svc , channels : = range channelmap . existing { channelinfos : = make ( [ ] channelinfo , 0 , len ( channels ) ) for , otherchan : = range channels { if ch == otherchan { continue } channelinfos = append ( channelinfos , otherchan . reportinfo ( opts ) ) } states [ svc ] = channelinfos } return states } 
func ( ch * channel ) reportinfo ( opts * introspectionoptions ) channelinfo { return channelinfo { id : ch . chid , createdstack : ch . createdstack , localpeer : ch . peerinfo ( ) , } } 
func ( l * rootpeerlist ) introspectstate ( opts * introspectionoptions ) map [ string ] peerruntimestate { return frompeerlist ( l , opts ) } 
func ( subchmap * subchannelmap ) introspectstate ( opts * introspectionoptions ) map [ string ] subchannelruntimestate { m : = make ( map [ string ] subchannelruntimestate ) subchmap . rlock ( ) for k , sc : = range subchmap . subchannels { state : = subchannelruntimestate { service : k , isolated : sc . isolated ( ) , } if state . isolated { state . isolatedpeers = sc . peers ( ) . introspectlist ( opts ) } if hmap , ok : = sc . handler . ( * handlermap ) ; ok { state . handler . type = methodhandler methods : = make ( [ ] string , 0 , len ( hmap . handlers ) ) for k : = range hmap . handlers { methods = append ( methods , k ) } sort . strings ( methods ) state . handler . methods = methods } else { state . handler . type = overridehandler } m [ k ] = state } subchmap . runlock ( ) return m } 
func ( p * peer ) introspectstate ( opts * introspectionoptions ) peerruntimestate { p . rlock ( ) defer p . runlock ( ) return peerruntimestate { hostport : p . hostport , inboundconnections : getconnectionruntimestate ( p . inboundconnections , opts ) , outboundconnections : getconnectionruntimestate ( p . outboundconnections , opts ) , chosencount : p . chosencount . load ( ) , sccount : p . sccount , } } 
func ( c * connection ) introspectstate ( opts * introspectionoptions ) connectionruntimestate { c . statemut . rlock ( ) defer c . statemut . runlock ( ) state : = connectionruntimestate { id : c . connid , connectionstate : c . state . string ( ) , localhostport : c . conn . localaddr ( ) . string ( ) , remotehostport : c . conn . remoteaddr ( ) . string ( ) , outboundhostport : c . outboundhp , remotepeer : c . remotepeerinfo , inboundexchange : c . inbound . introspectstate ( opts ) , outboundexchange : c . outbound . introspectstate ( opts ) , healthchecks : c . healthcheckhistory . asbools ( ) , lastactivity : c . lastactivity . load ( ) , } if c . relay ! = nil { state . relayer = c . relay . introspectstate ( opts ) } return state } 
func ( r * relayer ) introspectstate ( opts * introspectionoptions ) relayerruntimestate { count : = r . inbound . count ( ) + r . outbound . count ( ) return relayerruntimestate { count : count , inbounditems : r . inbound . introspectstate ( opts , " " ) , outbounditems : r . outbound . introspectstate ( opts , " " ) , maxtimeout : r . maxtimeout , } } 
func ( ri * relayitems ) introspectstate ( opts * introspectionoptions , name string ) relayitemsetstate { ri . rlock ( ) defer ri . runlock ( ) setstate : = relayitemsetstate { name : name , count : ri . count ( ) , } if opts . includeexchanges { setstate . items = make ( map [ string ] relayitemstate , len ( ri . items ) ) for k , v : = range ri . items { if ! opts . includetombstones && v . tomb { continue } state : = relayitemstate { id : k , remapid : v . remapid , destinationconnectionid : v . destination . conn . connid , tomb : v . tomb , } setstate . items [ strconv . itoa ( int ( k ) ) ] = state } } return setstate } 
func ( mexset * messageexchangeset ) introspectstate ( opts * introspectionoptions ) exchangesetruntimestate { mexset . rlock ( ) setstate : = exchangesetruntimestate { name : mexset . name , count : len ( mexset . exchanges ) , } if opts . includeexchanges { setstate . exchanges = make ( map [ string ] exchangeruntimestate , len ( mexset . exchanges ) ) for k , v : = range mexset . exchanges { state : = exchangeruntimestate { id : k , messagetype : v . msgtype , } setstate . exchanges [ strconv . itoa ( int ( k ) ) ] = state } } mexset . runlock ( ) return setstate } 
func ( l * peerlist ) introspectlist ( opts * introspectionoptions ) [ ] subpeerscore { var peers [ ] subpeerscore l . rlock ( ) for , ps : = range l . peerheap . peerscores { peers = append ( peers , subpeerscore { hostport : ps . peer . hostport , score : ps . score , } ) } l . runlock ( ) return peers } 
func ( ch * channel ) introspectnumconnections ( ) int { ch . mutable . rlock ( ) numconns : = len ( ch . mutable . conns ) ch . mutable . runlock ( ) return numconns } 
func ( ch * channel ) registerinternal ( ) { endpoints : = [ ] struct { name string handler func ( [ ] byte ) interface { } } { { " " , ch . handleintrospection } , { " " , handleinternalruntime } , } tchansc : = ch . getsubchannel ( " " ) for , ep : = range endpoints { ep : = ep handler : = func ( ctx context . context , call * inboundcall ) { var arg2 , arg3 [ ] byte if err : = newargreader ( call . arg2reader ( ) ) . read ( & arg2 ) ; err ! = nil { return } if err : = newargreader ( call . arg3reader ( ) ) . read ( & arg3 ) ; err ! = nil { return } if err : = newargwriter ( call . response ( ) . arg2writer ( ) ) . write ( nil ) ; err ! = nil { return } newargwriter ( call . response ( ) . arg3writer ( ) ) . writejson ( ep . handler ( arg3 ) ) } ch . register ( handlerfunc ( handler ) , ep . name ) tchansc . register ( handlerfunc ( handler ) , ep . name ) } } 
func newcontext ( timeout time . duration ) ( context , context . cancelfunc ) { ctx , cancel : = tchannel . newcontext ( timeout ) return tchannel . wrapwithheaders ( ctx , nil ) , cancel } 
func readargs ( call * tchannel . inboundcall ) ( *args , error ) { var args args args . caller = call . callername ( ) args . format = call . format ( ) args . method = string ( call . method ( ) ) if err : = tchannel . newargreader ( call . arg2reader ( ) ) . read ( & args . arg2 ) ; err ! = nil { return nil , err } if err : = tchannel . newargreader ( call . arg3reader ( ) ) . read ( & args . arg3 ) ; err ! = nil { return nil , err } return & args , nil } 
func writeresponse ( response * tchannel . inboundcallresponse , resp * res ) error { if resp . systemerr ! = nil { return response . sendsystemerror ( resp . systemerr ) } if resp . iserr { if err : = response . setapplicationerror ( ) ; err ! = nil { return err } } if err : = tchannel . newargwriter ( response . arg2writer ( ) ) . write ( resp . arg2 ) ; err ! = nil { return err } return tchannel . newargwriter ( response . arg3writer ( ) ) . write ( resp . arg3 ) } 
func wrap ( handler handler ) tchannel . handler { return tchannel . handlerfunc ( func ( ctx context . context , call * tchannel . inboundcall ) { args , err : = readargs ( call ) if err ! = nil { handler . onerror ( ctx , err ) return } resp , err : = handler . handle ( ctx , args ) response : = call . response ( ) if err ! = nil { resp = & res { systemerr : err , } } if err : = writeresponse ( response , resp ) ; err ! = nil { handler . onerror ( ctx , err ) } } ) } 
func ( s * injectablespan ) initfromopentracing ( span opentracing . span ) error { return span . tracer ( ) . inject ( span . context ( ) , zipkinspanformat , s ) } 
func currentspan ( ctx context . context ) * span { if sp : = opentracing . spanfromcontext ( ctx ) ; sp ! = nil { var injectable injectablespan if err : = injectable . initfromopentracing ( sp ) ; err == nil { span : = span ( injectable ) return & span } } return & emptyspan } 
func ( c * connection ) startoutboundspan ( ctx context . context , servicename , methodname string , call * outboundcall , starttime time . time ) opentracing . span { var parent opentracing . spancontext if s : = opentracing . spanfromcontext ( ctx ) ; s ! = nil { parent = s . context ( ) } span : = c . tracer ( ) . startspan ( methodname , opentracing . childof ( parent ) , opentracing . starttime ( starttime ) , ) if istracingdisabled ( ctx ) { ext . samplingpriority . set ( span , 0 ) } ext . spankindrpcclient . set ( span ) ext . peerservice . set ( span , servicename ) c . setpeerhostport ( span ) span . settag ( " " , call . callreq . headers [ argscheme ] ) var injectable injectablespan if err : = injectable . initfromopentracing ( span ) ; err == nil { call . callreq . tracing = span ( injectable ) } else { call . callreq . tracing . initrandom ( ) } return span } 
func injectoutboundspan ( response * outboundcallresponse , headers map [ string ] string ) map [ string ] string { span : = response . span if span == nil { return headers } newheaders : = make ( map [ string ] string ) carrier : = tracingheaderscarrier ( newheaders ) if err : = span . tracer ( ) . inject ( span . context ( ) , opentracing . textmap , carrier ) ; err ! = nil { response . log . withfields ( errfield ( err ) ) . error ( " " ) } if len ( newheaders ) == 0 { return headers } for k , v : = range headers { if , ok : = newheaders [ k ] ; ! ok { newheaders [ k ] = v } } return newheaders } 
func ( c * connection ) extractinboundspan ( callreq * callreq ) opentracing . span { spanctx , err : = c . tracer ( ) . extract ( zipkinspanformat , & callreq . tracing ) if err ! = nil { if err ! = opentracing . errunsupportedformat && err ! = opentracing . errspancontextnotfound { c . log . withfields ( errfield ( err ) ) . error ( " " ) } return nil } if spanctx == nil { return nil } operationname : = " " span : = c . tracer ( ) . startspan ( operationname , ext . rpcserveroption ( spanctx ) ) span . settag ( " " , callreq . headers [ argscheme ] ) ext . peerservice . set ( span , callreq . headers [ callername ] ) c . setpeerhostport ( span ) return span } 
func extractinboundspan ( ctx context . context , call * inboundcall , headers map [ string ] string , tracer opentracing . tracer ) context . context { var span = call . response ( ) . span if span ! = nil { if headers ! = nil { carrier : = tracingheaderscarrier ( headers ) if sc , err : = tracer . extract ( opentracing . textmap , carrier ) ; err == nil { sc . foreachbaggageitem ( func ( k , v string ) bool { span . setbaggageitem ( k , v ) return true } ) } carrier . removetracingkeys ( ) } } else { var parent opentracing . spancontext if headers ! = nil { carrier : = tracingheaderscarrier ( headers ) if p , err : = tracer . extract ( opentracing . textmap , carrier ) ; err == nil { parent = p } carrier . removetracingkeys ( ) } span = tracer . startspan ( call . methodstring ( ) , ext . rpcserveroption ( parent ) ) ext . peerservice . set ( span , call . callername ( ) ) span . settag ( " " , string ( call . format ( ) ) ) call . conn . setpeerhostport ( span ) call . response ( ) . span = span } return opentracing . contextwithspan ( ctx , span ) } 
func tracerfromregistrar ( registrar registrar ) opentracing . tracer { if tracerprovider , ok : = registrar . ( tracerprovider ) ; ok { return tracerprovider . tracer ( ) } return opentracing . globaltracer ( ) } 
func inttoip4 ( ip uint32 ) net . ip { return net . ip { byte ( ip > > 24 & 0xff ) , byte ( ip > > 16 & 0xff ) , byte ( ip > > 8 & 0xff ) , byte ( ip & 0xff ) , } } 
func servicepeertohostport ( peer * hyperbahn . servicepeer ) string { host : = inttoip4 ( uint32 ( * peer . ip . ipv4 ) ) . string ( ) port : = strconv . itoa ( int ( peer . port ) ) return net . joinhostport ( host , port ) } 
func newstatsdreporter ( addr , prefix string ) ( tchannel . statsreporter , error ) { client , err : = statsd . newbufferedclient ( addr , prefix , time . second , 0 ) if err ! = nil { return nil , err } return newstatsdreporterclient ( client ) , nil } 
func ( r * tos ) unmarshaltext ( data [ ] byte ) error { if v , ok : = tosnametovalue [ string ( data ) ] ; ok { * r = v return nil } return fmt . errorf ( " " , string ( data ) ) } 
func ( ph * peerheap ) push ( x interface { } ) { n : = len ( ph . peerscores ) item : = x . ( * peerscore ) item . index = n ph . peerscores = append ( ph . peerscores , item ) } 
func ( ph * peerheap ) pop ( ) interface { } { old : = * ph n : = len ( old . peerscores ) item : = old . peerscores [ n - 1 ] item . index = - 1 ph . peerscores = old . peerscores [ : n - 1 ] return item } 
func ( ph * peerheap ) updatepeer ( peerscore * peerscore ) { heap . fix ( ph , peerscore . index ) } 
func ( ph * peerheap ) removepeer ( peerscore * peerscore ) { heap . remove ( ph , peerscore . index ) } 
func ( ph * peerheap ) pushpeer ( peerscore * peerscore ) { ph . order ++ neworder : = ph . order randrange : = ph . len ( ) / 2 + 1 peerscore . order = neworder + uint64 ( ph . rng . intn ( randrange ) ) heap . push ( ph , peerscore ) } 
func ( ph * peerheap ) addpeer ( peerscore * peerscore ) { ph . pushpeer ( peerscore ) r : = ph . rng . intn ( ph . len ( ) ) ph . swaporder ( peerscore . index , r ) } 
func newclient ( ch * tchannel . channel , servicename string , opts * clientoptions ) tchanclient { client : = & client { ch : ch , sc : ch . getsubchannel ( servicename ) , servicename : servicename , } if opts ! = nil { client . opts = * opts } return client } 
func readresponse ( response * tchannel . outboundcallresponse , resp thrift . tstruct ) ( map [ string ] string , bool , error ) { reader , err : = response . arg2reader ( ) if err ! = nil { return nil , false , err } headers , err : = readheaders ( reader ) if err ! = nil { return nil , false , err } if err : = argreader . ensureempty ( reader , " " ) ; err ! = nil { return nil , false , err } if err : = reader . close ( ) ; err ! = nil { return nil , false , err } success : = ! response . applicationerror ( ) reader , err = response . arg3reader ( ) if err ! = nil { return headers , success , err } if err : = readstruct ( reader , resp ) ; err ! = nil { return headers , success , err } if err : = argreader . ensureempty ( reader , " " ) ; err ! = nil { return nil , false , err } return headers , success , reader . close ( ) } 
func ( l * rootpeerlist ) add ( hostport string ) * peer { l . rlock ( ) if p , ok : = l . peersbyhostport [ hostport ] ; ok { l . runlock ( ) return p } l . runlock ( ) l . lock ( ) defer l . unlock ( ) if p , ok : = l . peersbyhostport [ hostport ] ; ok { return p } var p * peer p = newpeer ( l . channel , hostport , l . onpeerstatuschanged , l . onclosedconnremoved ) l . peersbyhostport [ hostport ] = p return p } 
func ( l * rootpeerlist ) getoradd ( hostport string ) * peer { peer , ok : = l . get ( hostport ) if ok { return peer } return l . add ( hostport ) } 
func ( l * rootpeerlist ) get ( hostport string ) ( * peer , bool ) { l . rlock ( ) p , ok : = l . peersbyhostport [ hostport ] l . runlock ( ) return p , ok } 
func fnv32a ( s string ) uint32 { const ( initial = 2166136261 prime = 16777619 ) hash : = uint32 ( initial ) for i : = 0 ; i < len ( s ) ; i ++ { hash ^ = uint32 ( s [ i ] ) hash * = prime } return hash } 
func withtimeout ( timeout time . duration ) option { return func ( opts * options ) { opts . timeout = timeout } } 
func ( s * service ) extendsserviceprefix ( ) string { if dotindex : = strings . index ( s . extends , " " ) ; dotindex > 0 { return s . extendsprefix } return " " } 
func ( s * service ) methods ( ) [ ] * method { if s . methods ! = nil { return s . methods } for , m : = range s . service . methods { s . methods = append ( s . methods , & method { m , s , s . state } ) } sort . sort ( bymethodname ( s . methods ) ) return s . methods } 
func ( s * service ) inheritedmethods ( ) [ ] string { if s . inheritedmethods ! = nil { return s . inheritedmethods } for svc : = s . extendsservice ; svc ! = nil ; svc = svc . extendsservice { for m : = range svc . service . methods { s . inheritedmethods = append ( s . inheritedmethods , m ) } } sort . strings ( s . inheritedmethods ) return s . inheritedmethods } 
func ( m * method ) arguments ( ) [ ] * field { var args [ ] * field for , f : = range m . method . arguments { args = append ( args , & field { f , m . state } ) } return args } 
func ( m * method ) arglist ( ) string { args : = [ ] string { " " + contexttype ( ) } for , arg : = range m . arguments ( ) { args = append ( args , arg . declaration ( ) ) } return strings . join ( args , " " ) } 
func ( m * method ) calllist ( reqstruct string ) string { args : = [ ] string { " " } for , arg : = range m . arguments ( ) { args = append ( args , reqstruct + " " + arg . argstructname ( ) ) } return strings . join ( args , " " ) } 
func ( m * method ) rettype ( ) string { if ! m . hasreturn ( ) { return " " } return fmt . sprintf ( " " , m . state . gotype ( m . method . returntype ) , " " ) } 
func ( m * method ) wrapresult ( respvar string ) string { if ! m . hasreturn ( ) { panic ( " " ) } if m . state . isresultpointer ( m . returntype ) { return respvar } return " " + respvar } 
func ( m * method ) returnwith ( respname string , errname string ) string { if ! m . hasreturn ( ) { return errname } return fmt . sprintf ( " " , respname , errname ) } 
func ( a * field ) declaration ( ) string { return fmt . sprintf ( " " , a . name ( ) , a . argtype ( ) ) } 
func camelcase ( name string , publicname bool ) string { parts : = strings . split ( name , " " ) startat : = 1 if publicname { startat = 0 } for i : = startat ; i < len ( parts ) ; i ++ { name : = parts [ i ] if name == " " { continue } if i > 0 && strings . toupper ( name [ 0 : 1 ] ) == name [ 0 : 1 ] { name = " " + name } else { name = strings . toupper ( name [ 0 : 1 ] ) + name [ 1 : ] } if isinitialism : = commoninitialisms [ strings . toupper ( name ) ] ; isinitialism { name = strings . toupper ( name ) } parts [ i ] = name } return strings . join ( parts , " " ) } 
func startidlesweep ( ch * channel , opts * channeloptions ) * idlesweep { is : = & idlesweep { ch : ch , maxidletime : opts . maxidletime , idlecheckinterval : opts . idlecheckinterval , } is . start ( ) return is } 
func ( is * idlesweep ) start ( ) { if is . started | | is . idlecheckinterval <= 0 { return } is . ch . log . withfields ( logfield { " " , is . idlecheckinterval } , logfield { " " , is . maxidletime } , ) . info ( " " ) is . started = true is . stopch = make ( chan struct { } ) go is . pollerloop ( ) } 
func ( is * idlesweep ) stop ( ) { if ! is . started { return } is . started = false is . ch . log . info ( " " ) close ( is . stopch ) } 
func resolvewithgopath ( filename string ) ( string , error ) { for , file : = range gopathcandidates ( filename ) { if , err : = os . stat ( file ) ; ! os . isnotexist ( err ) { return file , nil } } return " " , fmt . errorf ( " " , filename ) } 
func setextends ( state map [ string ] parsestate ) error { for , v : = range state { for , s : = range v . services { if s . extends == " " { continue } var searchservices [ ] * service var searchfor string parts : = strings . splitn ( s . extends , " " , 2 ) if len ( parts ) < 2 { searchservices = v . services searchfor = s . extends } else { include : = v . global . includes [ parts [ 0 ] ] s . extendsprefix = include . pkg + " " searchservices = state [ include . file ] . services searchfor = parts [ 1 ] } foundservice : = sort . search ( len ( searchservices ) , func ( i int ) bool { return searchservices [ i ] . name >= searchfor } ) if foundservice == len ( searchservices ) { return fmt . errorf ( " " , s . extends , s . name ) } s . extendsservice = searchservices [ foundservice ] } } return nil } 
func ( f errorhandlerfunc ) handle ( ctx context . context , call * inboundcall ) { if err : = f ( ctx , call ) ; err ! = nil { if getsystemerrorcode ( err ) == errcodeunexpected { call . log . withfields ( f . getlogfields ( ) ... ) . withfields ( errfield ( err ) ) . error ( " " ) } call . response ( ) . sendsystemerror ( err ) } } 
func ( hmap * handlermap ) register ( h handler , method string ) { hmap . lock ( ) defer hmap . unlock ( ) if hmap . handlers == nil { hmap . handlers = make ( map [ string ] handler ) } hmap . handlers [ method ] = h } 
func ( c tracingheaderscarrier ) set ( key , val string ) { prefixedkey : = tracingkeyencoding . mapandcache ( key ) c [ prefixedkey ] = val } 
func ( c tracingheaderscarrier ) foreachkey ( handler func ( key , val string ) error ) error { for k , v : = range c { if ! strings . hasprefix ( k , tracingkeyprefix ) { continue } noprefixkey : = tracingkeydecoding . mapandcache ( k ) if err : = handler ( noprefixkey , v ) ; err ! = nil { return err } } return nil } 
func newclient ( hosts [ ] string , optfns ... option ) client { opts : = getoptions ( optfns ) if opts . external { return newexternalclient ( hosts , opts ) } if opts . numclients > 1 { return newinternalmulticlient ( hosts , opts ) } return newclient ( hosts , opts ) } 
func scoreaddr ( iface net . interface , addr net . addr ) ( int , net . ip ) { var ip net . ip if netaddr , ok : = addr . ( * net . ipnet ) ; ok { ip = netaddr . ip } else if netip , ok : = addr . ( * net . ipaddr ) ; ok { ip = netip . ip } else { return - 1 , nil } var score int if ip . to4 ( ) ! = nil { score += 300 } if iface . flags & net . flagloopback == 0 && ! ip . isloopback ( ) { score += 100 if iface . flags & net . flagup ! = 0 { score += 100 } } if islocalmacaddr ( iface . hardwareaddr ) { score - = 50 } return score , ip } 
func listenip ( ) ( net . ip , error ) { interfaces , err : = net . interfaces ( ) if err ! = nil { return nil , err } return listenip ( interfaces ) } 
func ( p * firstclient ) echo ( msg string ) ( r string , err error ) { if err = p . sendecho ( msg ) ; err ! = nil { return } return p . recvecho ( ) } 
func ( s * listener ) accept ( ) ( net . conn , error ) { s . incref ( ) defer s . decref ( ) return s . listener . accept ( ) } 
func ( s * listener ) close ( ) error { if err : = s . listener . close ( ) ; err ! = nil { return err } s . cond . l . lock ( ) for s . refs > 0 { s . cond . wait ( ) } s . cond . l . unlock ( ) return nil } 
func readargsv2 ( r tchannel . argreadable ) ( [ ] byte , [ ] byte , error ) { var arg2 , arg3 [ ] byte if err : = tchannel . newargreader ( r . arg2reader ( ) ) . read ( & arg2 ) ; err ! = nil { return nil , nil , err } if err : = tchannel . newargreader ( r . arg3reader ( ) ) . read ( & arg3 ) ; err ! = nil { return nil , nil , err } return arg2 , arg3 , nil } 
func writeargs ( call * tchannel . outboundcall , arg2 , arg3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . outboundcallresponse , error ) { if err : = tchannel . newargwriter ( call . arg2writer ( ) ) . write ( arg2 ) ; err ! = nil { return nil , nil , nil , err } if err : = tchannel . newargwriter ( call . arg3writer ( ) ) . write ( arg3 ) ; err ! = nil { return nil , nil , nil , err } resp : = call . response ( ) var resparg2 [ ] byte if err : = tchannel . newargreader ( resp . arg2reader ( ) ) . read ( & resparg2 ) ; err ! = nil { return nil , nil , nil , err } var resparg3 [ ] byte if err : = tchannel . newargreader ( resp . arg3reader ( ) ) . read ( & resparg3 ) ; err ! = nil { return nil , nil , nil , err } return resparg2 , resparg3 , resp , nil } 
func call ( ctx context . context , ch * tchannel . channel , hostport string , servicename , method string , arg2 , arg3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . outboundcallresponse , error ) { call , err : = ch . begincall ( ctx , hostport , servicename , method , nil ) if err ! = nil { return nil , nil , nil , err } return writeargs ( call , arg2 , arg3 ) } 
func callsc ( ctx context . context , sc * tchannel . subchannel , method string , arg2 , arg3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . outboundcallresponse , error ) { call , err : = sc . begincall ( ctx , method , nil ) if err ! = nil { return nil , nil , nil , err } return writeargs ( call , arg2 , arg3 ) } 
func callv2 ( ctx context . context , sc * tchannel . subchannel , cargs cargs ) ( * cres , error ) { call , err : = sc . begincall ( ctx , cargs . method , cargs . calloptions ) if err ! = nil { return nil , err } arg2 , arg3 , res , err : = writeargs ( call , cargs . arg2 , cargs . arg3 ) if err ! = nil { return nil , err } return & cres { arg2 : arg2 , arg3 : arg3 , apperror : res . applicationerror ( ) , } , nil } 
func newrealrelay ( services map [ string ] [ ] string ) ( relay , error ) { hosts : = & fixedhosts { hosts : services } ch , err : = tchannel . newchannel ( " " , & tchannel . channeloptions { relayhost : relaytest . hostfunc ( hosts . get ) , logger : tchannel . newlevellogger ( tchannel . newlogger ( os . stderr ) , tchannel . loglevelwarn ) , } ) if err ! = nil { return nil , err } if err : = ch . listenandserve ( " " ) ; err ! = nil { return nil , err } return & realrelay { ch : ch , hosts : hosts , } , nil } 
func newserver ( registrar tchannel . registrar ) * server { metahandler : = newmetahandler ( ) server : = & server { ch : registrar , log : registrar . logger ( ) , handlers : make ( map [ string ] handler ) , metahandler : metahandler , ctxfn : defaultcontextfn , } server . register ( newtchanmetaserver ( metahandler ) ) if ch , ok : = registrar . ( * tchannel . channel ) ; ok { newserver ( ch . getsubchannel ( " " ) ) } return server } 
func ( s * server ) register ( svr tchanserver , opts ... registeroption ) { service : = svr . service ( ) handler : = & handler { server : svr } for , opt : = range opts { opt . apply ( handler ) } s . lock ( ) s . handlers [ service ] = * handler s . unlock ( ) for , m : = range svr . methods ( ) { s . ch . register ( s , service + " " + m ) } } 
func ( s * server ) registerhealthhandler ( f healthfunc ) { wrapped : = func ( ctx context , r healthrequest ) ( bool , string ) { return f ( ctx ) } s . metahandler . sethandler ( wrapped ) } 
func ( s * server ) setcontextfn ( f func ( ctx context . context , method string , headers map [ string ] string ) context ) { s . ctxfn = f } 
func ( s * server ) handle ( ctx context . context , call * tchannel . inboundcall ) { op : = call . methodstring ( ) service , method , ok : = getservicemethod ( op ) if ! ok { log . fatalf ( " " , op ) } s . rlock ( ) handler , ok : = s . handlers [ service ] s . runlock ( ) if ! ok { log . fatalf ( " " , service ) } if err : = s . handle ( ctx , handler , method , call ) ; err ! = nil { s . onerror ( call , err ) } } 
func ( c systemerrcode ) metricskey ( ) string { switch c { case errcodeinvalid : return " " case errcodetimeout : return " " case errcodecancelled : return " " case errcodebusy : return " " case errcodedeclined : return " " case errcodeunexpected : return " " case errcodebadrequest : return " " case errcodenetwork : return " " case errcodeprotocol : return " " default : return c . string ( ) } } 
func newsystemerror ( code systemerrcode , msg string , args ... interface { } ) error { return systemerror { code : code , msg : fmt . sprintf ( msg , args ... ) } } 
func newwrappedsystemerror ( code systemerrcode , wrapped error ) error { if se , ok : = wrapped . ( systemerror ) ; ok { return se } return systemerror { code : code , msg : fmt . sprint ( wrapped ) , wrapped : wrapped } } 
func ( se systemerror ) error ( ) string { return fmt . sprintf ( " " , se . code ( ) , se . msg ) } 
func getcontexterror ( err error ) error { if err == context . deadlineexceeded { return errtimeout } if err == context . canceled { return errrequestcancelled } return err } 
func getsystemerrorcode ( err error ) systemerrcode { if err == nil { return errcodeinvalid } if se , ok : = err . ( systemerror ) ; ok { return se . code ( ) } return errcodeunexpected } 
func getsystemerrormessage ( err error ) string { if se , ok : = err . ( systemerror ) ; ok { return se . message ( ) } return err . error ( ) } 
func gettimeout ( ctx context . context ) time . duration { deadline , ok : = ctx . deadline ( ) if ! ok { return defaultconnecttimeout } return deadline . sub ( time . now ( ) ) } 
func ( c * connection ) ping ( ctx context . context ) error { req : = & pingreq { id : c . nextmessageid ( ) } mex , err : = c . outbound . newexchange ( ctx , c . opts . framepool , req . messagetype ( ) , req . id ( ) , 1 ) if err ! = nil { return c . connectionerror ( " " , err ) } defer c . outbound . removeexchange ( req . id ( ) ) if err : = c . sendmessage ( req ) ; err ! = nil { return c . connectionerror ( " " , err ) } return c . recvmessage ( ctx , & pingres { } , mex ) } 
func ( c * connection ) handlepingres ( frame * frame ) bool { if err : = c . outbound . forwardpeerframe ( frame ) ; err ! = nil { c . log . withfields ( logfield { " " , frame . header } ) . warn ( " " ) return true } return false } 
func ( c * connection ) handlepingreq ( frame * frame ) { if state : = c . readstate ( ) ; state ! = connectionactive { c . protocolerror ( frame . header . id , errconnnotactive { " " , state } ) return } pingres : = & pingres { id : frame . header . id } if err : = c . sendmessage ( pingres ) ; err ! = nil { c . connectionerror ( " " , err ) } } 
func ( c * connection ) sendmessage ( msg message ) error { frame : = c . opts . framepool . get ( ) if err : = frame . write ( msg ) ; err ! = nil { c . opts . framepool . release ( frame ) return err } select { case c . sendch < - frame : return nil default : return errsendbufferfull } } 
func ( c * connection ) recvmessage ( ctx context . context , msg message , mex * messageexchange ) error { frame , err : = mex . recvpeerframeoftype ( msg . messagetype ( ) ) if err ! = nil { if err , ok : = err . ( errormessage ) ; ok { return err . assystemerror ( ) } return err } err = frame . read ( msg ) c . opts . framepool . release ( frame ) return err } 
func ( c * connection ) sendsystemerror ( id uint32 , span span , err error ) error { frame : = c . opts . framepool . get ( ) if err : = frame . write ( & errormessage { id : id , errcode : getsystemerrorcode ( err ) , tracing : span , message : getsystemerrormessage ( err ) , } ) ; err ! = nil { c . log . withfields ( logfield { " " , c . remotepeerinfo } , logfield { " " , id } , errfield ( err ) , ) . warn ( " " ) return fmt . errorf ( " " , err ) } return c . withstaterlock ( func ( ) error { if c . state == connectionclosed { c . log . withfields ( logfield { " " , c . remotepeerinfo } , logfield { " " , id } , ) . info ( " " ) return fmt . errorf ( " " , c . state ) } select { case c . sendch < - frame : return nil default : } c . log . withfields ( logfield { " " , c . remotepeerinfo } , logfield { " " , id } , errfield ( err ) , ) . warn ( " " ) return fmt . errorf ( " " ) } ) } 
func ( c * connection ) connectionerror ( site string , err error ) error { var closelogfields logfields if err == io . eof { closelogfields = logfields { { " " , " " } } } else { closelogfields = logfields { { " " , " " } , errfield ( err ) , } } c . stophealthcheck ( ) err = c . logconnectionerror ( site , err ) c . close ( closelogfields ... ) if c . stoppedexchanges . cas ( false , true ) { c . outbound . stopexchanges ( err ) c . inbound . stopexchanges ( err ) } c . checkexchanges ( ) return err } 
func ( c * connection ) withstatelock ( f func ( ) error ) error { c . statemut . lock ( ) err : = f ( ) c . statemut . unlock ( ) return err } 
func ( c * connection ) withstaterlock ( f func ( ) error ) error { c . statemut . rlock ( ) err : = f ( ) c . statemut . runlock ( ) return err } 
func ( c * connection ) readframes ( uint32 ) { headerbuf : = make ( [ ] byte , frameheadersize ) handleerr : = func ( err error ) { if ! c . closenetworkcalled . load ( ) { c . connectionerror ( " " , err ) } else { c . log . debugf ( " " , err ) } } for { if , err : = io . readfull ( c . conn , headerbuf ) ; err ! = nil { handleerr ( err ) return } frame : = c . opts . framepool . get ( ) if err : = frame . readbody ( headerbuf , c . conn ) ; err ! = nil { handleerr ( err ) c . opts . framepool . release ( frame ) return } c . updatelastactivity ( frame ) var releaseframe bool if c . relay == nil { releaseframe = c . handleframenorelay ( frame ) } else { releaseframe = c . handleframerelay ( frame ) } if releaseframe { c . opts . framepool . release ( frame ) } } } 
func ( c * connection ) writeframes ( uint32 ) { for { select { case f : = < - c . sendch : if c . log . enabled ( logleveldebug ) { c . log . debugf ( " " , f . header ) } c . updatelastactivity ( f ) err : = f . writeout ( c . conn ) c . opts . framepool . release ( f ) if err ! = nil { c . connectionerror ( " " , err ) return } case < - c . stopch : if len ( c . sendch ) > 0 { continue } c . closenetwork ( ) return } } } 
func ( c * connection ) updatelastactivity ( frame * frame ) { switch frame . header . messagetype { case messagetypecallreq , messagetypecallreqcontinue , messagetypecallres , messagetypecallrescontinue , messagetypeerror : c . lastactivity . store ( c . timenow ( ) . unixnano ( ) ) } } 
func ( c * connection ) haspendingcalls ( ) bool { if c . inbound . count ( ) > 0 | | c . outbound . count ( ) > 0 { return true } if ! c . relay . canclose ( ) { return true } return false } 
func ( c * connection ) checkexchanges ( ) { c . callonexchangechange ( ) movestate : = func ( fromstate , tostate connectionstate ) bool { err : = c . withstatelock ( func ( ) error { if c . state ! = fromstate { return errors . new ( " " ) } c . state = tostate return nil } ) return err == nil } curstate : = c . readstate ( ) origstate : = curstate if curstate ! = connectionclosed && c . stoppedexchanges . load ( ) { if movestate ( curstate , connectionclosed ) { curstate = connectionclosed } } if curstate == connectionstartclose { if ! c . relay . canclose ( ) { return } if c . inbound . count ( ) == 0 && movestate ( connectionstartclose , connectioninboundclosed ) { curstate = connectioninboundclosed } } if curstate == connectioninboundclosed { if ! c . relay . canclose ( ) { c . relay . logger . error ( " " ) return } if c . outbound . count ( ) == 0 && movestate ( connectioninboundclosed , connectionclosed ) { curstate = connectionclosed } } if curstate ! = origstate { if curstate == connectionclosed { close ( c . stopch ) } c . log . withfields ( logfield { " " , curstate } , ) . debug ( " " ) c . callonclosestatechange ( ) } } 
func ( c * connection ) closenetwork ( ) { c . log . debugf ( " " ) c . stophealthcheck ( ) c . closenetworkcalled . store ( true ) if err : = c . conn . close ( ) ; err ! = nil { c . log . withfields ( logfield { " " , c . remotepeerinfo } , errfield ( err ) , ) . warn ( " " ) } } 
func ( c * connection ) getlastactivitytime ( ) time . time { return time . unix ( 0 , c . lastactivity . load ( ) ) } 
func validate ( svc * parser . service ) error { for , m : = range svc . methods { if err : = validatemethod ( svc , m ) ; err ! = nil { return err } } return nil } 
func ( c * client ) logfailedregistrationretry ( errlogger tchannel . logger , consecutivefailures uint ) { logfn : = errlogger . info if consecutivefailures > maxadvertisefailures { logfn = errlogger . warn } logfn ( " " ) } 
func ( c * client ) advertiseloop ( ) { sleepfor : = c . fuzzedadvertiseinterval ( ) consecutivefailures : = uint ( 0 ) for { c . sleep ( sleepfor ) if c . isclosed ( ) { c . tchan . logger ( ) . infof ( " " ) return } if err : = c . sendadvertise ( ) ; err ! = nil { consecutivefailures ++ errlogger : = c . tchan . logger ( ) . withfields ( tchannel . errfield ( err ) ) if consecutivefailures >= maxadvertisefailures && c . opts . failstrategy == failstrategyfatal { c . opts . handler . onerror ( erradvertisefailed { cause : err , willretry : false } ) errlogger . fatal ( " " ) } c . logfailedregistrationretry ( errlogger , consecutivefailures ) c . opts . handler . onerror ( erradvertisefailed { cause : err , willretry : true } ) if consecutivefailures < maxadvertisefailures { sleepfor = fuzzinterval ( advertiseretryinterval * time . duration ( 1 < < consecutivefailures ) ) } } else { c . opts . handler . on ( readvertised ) sleepfor = c . fuzzedadvertiseinterval ( ) consecutivefailures = 0 } } } 
func ( c * client ) initialadvertise ( ) error { var err error for attempt : = uint ( 0 ) ; attempt < maxadvertisefailures ; attempt ++ { err = c . sendadvertise ( ) if err == nil | | err == errephemeralpeer { break } c . tchan . logger ( ) . withfields ( tchannel . errfield ( err ) ) . info ( " " ) sleepfor : = fuzzinterval ( advertiseretryinterval * time . duration ( 1 < < attempt ) ) c . sleep ( sleepfor ) } return err } 
func ( p * hyperbahnclient ) discover ( query * discoveryquery ) ( r * discoveryresult , err error ) { if err = p . senddiscover ( query ) ; err ! = nil { return } return p . recvdiscover ( ) } 
func newlazycallreq ( f * frame ) lazycallreq { if msgtype : = f . header . messagetype ; msgtype ! = messagetypecallreq { panic ( fmt . errorf ( " " , msgtype ) ) } cr : = lazycallreq { frame : f } servicelen : = f . payload [ servicelenindex ] headerstart : = servicelenindex + 1 / * length byte * / + servicelen numheaders : = int ( f . payload [ headerstart ] ) cur : = int ( headerstart ) + 1 for i : = 0 ; i < numheaders ; i ++ { keylen : = int ( f . payload [ cur ] ) cur ++ key : = f . payload [ cur : cur + keylen ] cur += keylen vallen : = int ( f . payload [ cur ] ) cur ++ val : = f . payload [ cur : cur + vallen ] cur += vallen if bytes . equal ( key , callernamekeybytes ) { cr . caller = val } else if bytes . equal ( key , routingdelegatekeybytes ) { cr . delegate = val } else if bytes . equal ( key , routingkeykeybytes ) { cr . key = val } } checksumtype : = checksumtype ( f . payload [ cur ] ) cur += 1 / * checksum * / + checksumtype . checksumsize ( ) arg1len : = int ( binary . bigendian . uint16 ( f . payload [ cur : cur + 2 ] ) ) cur += 2 cr . method = f . payload [ cur : cur + arg1len ] return cr } 
func ( f lazycallreq ) service ( ) [ ] byte { l : = f . payload [ servicelenindex ] return f . payload [ servicenameindex : servicenameindex + l ] } 
func ( f lazycallreq ) ttl ( ) time . duration { ttl : = binary . bigendian . uint32 ( f . payload [ ttlindex : ttlindex + ttllen ] ) return time . duration ( ttl ) * time . millisecond } 
func ( f lazycallreq ) setttl ( d time . duration ) { ttl : = uint32 ( d / time . millisecond ) binary . bigendian . putuint32 ( f . payload [ ttlindex : ttlindex + ttllen ] , ttl ) } 
func finishescall ( f * frame ) bool { switch f . messagetype ( ) { case messagetypeerror : return true case messagetypecallres , messagetypecallrescontinue : flags : = f . payload [ flagsindex ] return flags & hasmorefragmentsflag == 0 default : return false } } 
func ( ps * platformstrings ) flat ( ) [ ] string { unique : = make ( map [ string ] struct { } ) for , s : = range ps . generic { unique [ s ] = struct { } { } } for , ss : = range ps . os { for , s : = range ss { unique [ s ] = struct { } { } } } for , ss : = range ps . arch { for , s : = range ss { unique [ s ] = struct { } { } } } for , ss : = range ps . platform { for , s : = range ss { unique [ s ] = struct { } { } } } flat : = make ( [ ] string , 0 , len ( unique ) ) for s : = range unique { flat = append ( flat , s ) } sort . strings ( flat ) return flat } 
func ( ps * platformstrings ) map ( f func ( s string ) ( string , error ) ) ( platformstrings , [ ] error ) { var errors [ ] error mapslice : = func ( ss [ ] string ) ( [ ] string , error ) { rs : = make ( [ ] string , 0 , len ( ss ) ) for , s : = range ss { if r , err : = f ( s ) ; err ! = nil { errors = append ( errors , err ) } else if r ! = " " { rs = append ( rs , r ) } } return rs , nil } result , : = ps . mapslice ( mapslice ) return result , errors } 
func ( ps * platformstrings ) mapslice ( f func ( [ ] string ) ( [ ] string , error ) ) ( platformstrings , [ ] error ) { var errors [ ] error mapslice : = func ( ss [ ] string ) [ ] string { rs , err : = f ( ss ) if err ! = nil { errors = append ( errors , err ) return nil } return rs } mapstringmap : = func ( m map [ string ] [ ] string ) map [ string ] [ ] string { if m == nil { return nil } rm : = make ( map [ string ] [ ] string ) for k , ss : = range m { ss = mapslice ( ss ) if len ( ss ) > 0 { rm [ k ] = ss } } if len ( rm ) == 0 { return nil } return rm } mapplatformmap : = func ( m map [ platform ] [ ] string ) map [ platform ] [ ] string { if m == nil { return nil } rm : = make ( map [ platform ] [ ] string ) for k , ss : = range m { ss = mapslice ( ss ) if len ( ss ) > 0 { rm [ k ] = ss } } if len ( rm ) == 0 { return nil } return rm } result : = platformstrings { generic : mapslice ( ps . generic ) , os : mapstringmap ( ps . os ) , arch : mapstringmap ( ps . arch ) , platform : mapplatformmap ( ps . platform ) , } return result , errors } 
func getprotoconfig ( c * config . config ) * protoconfig { pc : = c . exts [ protoname ] if pc == nil { return nil } return pc . ( * protoconfig ) } 
func inferprotomode ( c * config . config , rel string , f * rule . file ) { pc : = getprotoconfig ( c ) if pc . mode ! = defaultmode | | pc . modeexplicit { return } if pc . goprefix == wellknowntypesgoprefix { pc . mode = legacymode return } if path . base ( rel ) == " " { pc . mode = disablemode return } if f == nil { return } mode : = defaultmode outer : for , l : = range f . loads { name : = l . name ( ) if name == " " { break } if name == " " { mode = legacymode break } for , sym : = range l . symbols ( ) { if sym == " " { mode = disablemode break outer } } } if mode == defaultmode | | pc . mode == mode | | c . shouldfix && mode == legacymode { return } pc . mode = mode } 
func flattenexpr ( e bzl . expr ) bzl . expr { ps , err : = extractplatformstringsexprs ( e ) if err ! = nil { return e } ls : = makelistsquasher ( ) addelem : = func ( e bzl . expr ) bool { s , ok : = e . ( * bzl . stringexpr ) if ! ok { return false } ls . add ( s ) return true } addlist : = func ( e bzl . expr ) bool { l , ok : = e . ( * bzl . listexpr ) if ! ok { return false } for , elem : = range l . list { if ! addelem ( elem ) { return false } } return true } adddict : = func ( d * bzl . dictexpr ) bool { for , kv : = range d . list { if ! addlist ( kv . ( * bzl . keyvalueexpr ) . value ) { return false } } return true } if ps . generic ! = nil { if ! addlist ( ps . generic ) { return e } } for , d : = range [ ] * bzl . dictexpr { ps . os , ps . arch , ps . platform } { if d == nil { continue } if ! adddict ( d ) { return e } } return ls . list ( ) } 
func makeplatformstringsexpr ( ps platformstringsexprs ) bzl . expr { makeselect : = func ( dict * bzl . dictexpr ) bzl . expr { return & bzl . callexpr { x : & bzl . ident { name : " " } , list : [ ] bzl . expr { dict } , } } forcemultiline : = func ( e bzl . expr ) { switch e : = e . ( type ) { case * bzl . listexpr : e . forcemultiline = true case * bzl . callexpr : e . list [ 0 ] . ( * bzl . dictexpr ) . forcemultiline = true } } var parts [ ] bzl . expr if ps . generic ! = nil { parts = append ( parts , ps . generic ) } if ps . os ! = nil { parts = append ( parts , makeselect ( ps . os ) ) } if ps . arch ! = nil { parts = append ( parts , makeselect ( ps . arch ) ) } if ps . platform ! = nil { parts = append ( parts , makeselect ( ps . platform ) ) } if len ( parts ) == 0 { return nil } if len ( parts ) == 1 { return parts [ 0 ] } expr : = parts [ 0 ] forcemultiline ( expr ) for , part : = range parts [ 1 : ] { forcemultiline ( part ) expr = & bzl . binaryexpr { op : " " , x : expr , y : part , } } return expr } 
func ( p platform ) string ( ) string { switch { case p . os ! = " " && p . arch ! = " " : return p . os + " " + p . arch case p . os ! = " " : return p . os case p . arch ! = " " : return p . arch default : return " " } } 
func find ( dir string ) ( string , error ) { dir , err : = filepath . abs ( dir ) if err ! = nil { return " " , err } for { , err = os . stat ( filepath . join ( dir , workspacefile ) ) if err == nil { return dir , nil } if ! os . isnotexist ( err ) { return " " , err } if strings . hassuffix ( dir , string ( os . pathseparator ) ) { return " " , os . errnotexist } dir = filepath . dir ( dir ) } } 
func movelocations ( from , to , str string ) string { matches : = locationsregexp . findallstringsubmatchindex ( str , - 1 ) buf : = new ( bytes . buffer ) pos : = 0 for , match : = range matches { buf . writestring ( str [ pos : match [ 2 ] ] ) label : = str [ match [ 2 ] : match [ 3 ] ] moved : = movelabel ( from , to , label ) buf . writestring ( moved ) buf . writestring ( str [ match [ 3 ] : match [ 1 ] ] ) pos = match [ 1 ] } buf . writestring ( str [ pos : ] ) return buf . string ( ) } 
func rungazelle ( mode mode , dirs [ ] string ) error { if mode == fastmode && len ( dirs ) == 0 { return nil } args : = [ ] string { os . getenv ( " " ) , " " , * gazellelabel , " " , " " } args = append ( args , " " ) if mode == fastmode { args = append ( args , " " ) args = append ( args , dirs ... ) } cmd : = exec . command ( args [ 0 ] , args [ 1 : ] ... ) cmd . stdout = os . stdout cmd . stderr = os . stderr log . printf ( " \n " , strings . join ( cmd . args , " " ) ) return cmd . run ( ) } 
func restorebuildfilesinrepo ( ) { err : = filepath . walk ( " " , func ( path string , info os . fileinfo , err error ) error { if err ! = nil { log . print ( err ) return nil } restorebuildfilesindir ( path ) return nil } ) if err ! = nil { log . print ( err ) } } 
func fixload ( load * rule . load , file string , kinds map [ string ] bool , knownkinds map [ string ] string ) * rule . load { if load == nil { if len ( kinds ) == 0 { return nil } load = rule . newload ( file ) } for k : = range kinds { load . add ( k ) } for , k : = range load . symbols ( ) { if knownkinds [ k ] ! = " " && ! kinds [ k ] { load . remove ( k ) } } return load } 
func newloadindex ( f * rule . file , after [ ] string ) int { if len ( after ) == 0 { return 0 } index : = 0 for , r : = range f . rules { for , a : = range after { if r . kind ( ) == a && r . index ( ) >= index { index = r . index ( ) + 1 } } } return index } 
func checkgazelleloaded ( f * rule . file ) error { needgazelle : = false for , l : = range f . loads { if strings . hasprefix ( l . name ( ) , " " ) { needgazelle = true } } if ! needgazelle { return nil } for , r : = range f . rules { if r . name ( ) == " " { return nil } } for , d : = range f . directives { if d . key ! = " " { continue } if fs : = strings . fields ( d . value ) ; len ( fs ) > 0 && fs [ 0 ] == " " { return nil } } return fmt . errorf ( , f . path ) } 
func removelegacygorepository ( f * rule . file ) { for , l : = range f . loads { if l . name ( ) == " " { l . remove ( " " ) if l . isempty ( ) { l . delete ( ) } } } } 
func ( x version ) compare ( y version ) int { n : = len ( x ) if len ( y ) < n { n = len ( y ) } for i : = 0 ; i < n ; i ++ { cmp : = x [ i ] - y [ i ] if cmp ! = 0 { return cmp } } return len ( x ) - len ( y ) } 
func parseversion ( vs string ) ( version , error ) { i : = strings . indexbyte ( vs , ' - ' ) if i >= 0 { vs = vs [ : i ] } cstrs : = strings . split ( vs , " " ) v : = make ( version , len ( cstrs ) ) for i , cstr : = range cstrs { cn , err : = strconv . atoi ( cstr ) if err ! = nil { return nil , fmt . errorf ( " " , cstr ) } if cn < 0 { return nil , fmt . errorf ( " " , cstr ) } v [ i ] = cn } return v , nil } 
func emptyfile ( path , pkg string ) * file { return & file { file : & bzl . file { path : path , type : bzl . typebuild } , path : path , pkg : pkg , } } 
func loadfile ( path , pkg string ) ( * file , error ) { data , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } return loaddata ( path , pkg , data ) } 
func loadworkspacefile ( path , pkg string ) ( * file , error ) { data , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } return loadworkspacedata ( path , pkg , data ) } 
func loadmacrofile ( path , pkg , defname string ) ( * file , error ) { data , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } return loadmacrodata ( path , pkg , defname , data ) } 
func emptymacrofile ( path , pkg , defname string ) ( * file , error ) { , err : = os . create ( path ) if err ! = nil { return nil , err } return loadmacrodata ( path , pkg , defname , nil ) } 
func loaddata ( path , pkg string , data [ ] byte ) ( * file , error ) { ast , err : = bzl . parsebuild ( path , data ) if err ! = nil { return nil , err } return scanast ( pkg , ast ) , nil } 
func loadworkspacedata ( path , pkg string , data [ ] byte ) ( * file , error ) { ast , err : = bzl . parseworkspace ( path , data ) if err ! = nil { return nil , err } return scanast ( pkg , ast ) , nil } 
func loadmacrodata ( path , pkg , defname string , data [ ] byte ) ( * file , error ) { ast , err : = bzl . parsebzl ( path , data ) if err ! = nil { return nil , err } return scanastbody ( pkg , defname , ast ) , nil } 
func scanast ( pkg string , bzlfile * bzl . file ) * file { return scanastbody ( pkg , " " , bzlfile ) } 
func scanastbody ( pkg , defname string , bzlfile * bzl . file ) * file { f : = & file { file : bzlfile , pkg : pkg , path : bzlfile . path , } var defstmt * bzl . defstmt f . rules , f . loads , defstmt = scanexprs ( defname , bzlfile . stmt ) if defstmt ! = nil { f . rules , , = scanexprs ( " " , defstmt . body ) f . function = & function { stmt : defstmt , inserted : true , } if len ( defstmt . body ) == 1 { if v , ok : = defstmt . body [ 0 ] . ( * bzl . branchstmt ) ; ok && v . token == " " { f . function . haspass = true } } } else if defname ! = " " { f . function = & function { stmt : & bzl . defstmt { name : defname } , inserted : false , } } f . directives = parsedirectives ( bzlfile ) return f } 
func matchbuildfilename ( dir string , names [ ] string , files [ ] os . fileinfo ) string { for , name : = range names { for , fi : = range files { if fi . name ( ) == name && ! fi . isdir ( ) { return filepath . join ( dir , name ) } } } return " " } 
func ( f * file ) syncmacrofile ( from * file ) { fromfunc : = * from . function . stmt , , tofunc : = scanexprs ( from . function . stmt . name , f . file . stmt ) if tofunc ! = nil { * tofunc = fromfunc } else { f . file . stmt = append ( f . file . stmt , & fromfunc ) } } 
func ( f * file ) macroname ( ) string { if f . function ! = nil && f . function . stmt ! = nil { return f . function . stmt . name } return " " } 
func ( f * file ) format ( ) [ ] byte { f . sync ( ) return bzl . format ( f . file ) } 
func ( f * file ) save ( path string ) error { f . sync ( ) data : = bzl . format ( f . file ) return ioutil . writefile ( path , data , 0666 ) } 
func ( f * file ) hasdefaultvisibility ( ) bool { for , r : = range f . rules { if r . kind ( ) == " " && r . attr ( " " ) ! = nil { return true } } return false } 
func newload ( name string ) * load { return & load { stmt : stmt { expr : & bzl . loadstmt { module : & bzl . stringexpr { value : name } , forcecompact : true , } , } , name : name , symbols : make ( map [ string ] identpair ) , } } 
func ( l * load ) symbols ( ) [ ] string { syms : = make ( [ ] string , 0 , len ( l . symbols ) ) for sym : = range l . symbols { syms = append ( syms , sym ) } sort . strings ( syms ) return syms } 
func ( l * load ) has ( sym string ) bool { , ok : = l . symbols [ sym ] return ok } 
func ( l * load ) add ( sym string ) { if , ok : = l . symbols [ sym ] ; ! ok { i : = & bzl . ident { name : sym } l . symbols [ sym ] = identpair { to : i , from : i } l . updated = true } } 
func ( l * load ) remove ( sym string ) { if , ok : = l . symbols [ sym ] ; ok { delete ( l . symbols , sym ) l . updated = true } } 
func ( l * load ) insert ( f * file , index int ) { l . index = index l . inserted = true f . loads = append ( f . loads , l ) } 
func newrule ( kind , name string ) * rule { nameattr : = & bzl . assignexpr { lhs : & bzl . ident { name : " " } , rhs : & bzl . stringexpr { value : name } , op : " " , } r : = & rule { stmt : stmt { expr : & bzl . callexpr { x : & bzl . ident { name : kind } , list : [ ] bzl . expr { nameattr } , } , } , kind : kind , attrs : map [ string ] * bzl . assignexpr { " " : nameattr } , private : map [ string ] interface { } { } , } return r } 
func ( r * rule ) setkind ( kind string ) { r . kind = kind r . updated = true } 
func ( r * rule ) attrkeys ( ) [ ] string { keys : = make ( [ ] string , 0 , len ( r . attrs ) ) for k : = range r . attrs { keys = append ( keys , k ) } sort . slicestable ( keys , func ( i , j int ) bool { if cmp : = bt . namepriority [ keys [ i ] ] - bt . namepriority [ keys [ j ] ] ; cmp ! = 0 { return cmp < 0 } return keys [ i ] < keys [ j ] } ) return keys } 
func ( r * rule ) attr ( key string ) bzl . expr { attr , ok : = r . attrs [ key ] if ! ok { return nil } return attr . rhs } 
func ( r * rule ) attrstring ( key string ) string { attr , ok : = r . attrs [ key ] if ! ok { return " " } str , ok : = attr . rhs . ( * bzl . stringexpr ) if ! ok { return " " } return str . value } 
func ( r * rule ) attrstrings ( key string ) [ ] string { attr , ok : = r . attrs [ key ] if ! ok { return nil } list , ok : = attr . rhs . ( * bzl . listexpr ) if ! ok { return nil } strs : = make ( [ ] string , 0 , len ( list . list ) ) for , e : = range list . list { if str , ok : = e . ( * bzl . stringexpr ) ; ok { strs = append ( strs , str . value ) } } return strs } 
func ( r * rule ) delattr ( key string ) { delete ( r . attrs , key ) r . updated = true } 
func ( r * rule ) setattr ( key string , value interface { } ) { rhs : = exprfromvalue ( value ) if attr , ok : = r . attrs [ key ] ; ok { attr . rhs = rhs } else { r . attrs [ key ] = & bzl . assignexpr { lhs : & bzl . ident { name : key } , rhs : rhs , op : " " , } } r . updated = true } 
func ( r * rule ) privateattrkeys ( ) [ ] string { keys : = make ( [ ] string , 0 , len ( r . private ) ) for k : = range r . private { keys = append ( keys , k ) } sort . strings ( keys ) return keys } 
func ( r * rule ) setprivateattr ( key string , value interface { } ) { r . private [ key ] = value } 
func ( r * rule ) insert ( f * file ) { var stmt [ ] bzl . expr if f . function == nil { stmt = f . file . stmt } else { stmt = f . function . stmt . body } r . index = len ( stmt ) r . inserted = true f . rules = append ( f . rules , r ) } 
func ( r * rule ) isempty ( info kindinfo ) bool { if info . nonemptyattrs == nil { return false } for k : = range info . nonemptyattrs { if , ok : = r . attrs [ k ] ; ok { return false } } return true } 
func shouldkeep ( e bzl . expr ) bool { for , c : = range append ( e . comment ( ) . before , e . comment ( ) . suffix ... ) { text : = strings . trimspace ( strings . trimprefix ( c . token , " " ) ) if text == " " { return true } } return false } 
func checkinternalvisibility ( rel , visibility string ) string { if i : = strings . lastindex ( rel , " " ) ; i >= 0 { visibility = fmt . sprintf ( " " , rel [ : i ] ) } else if strings . hasprefix ( rel , " " ) { visibility = " " } return visibility } 
func new ( repo , pkg , name string ) label { return label { repo : repo , pkg : pkg , name : name } } 
func ( l label ) abs ( repo , pkg string ) label { if ! l . relative { return l } return label { repo : repo , pkg : pkg , name : l . name } } 
func ( l label ) rel ( repo , pkg string ) label { if l . relative | | l . repo ! = repo { return l } if l . pkg == pkg { return label { name : l . name , relative : true } } return label { pkg : l . pkg , name : l . name } } 
func ( l label ) equal ( other label ) bool { return l . repo == other . repo && l . pkg == other . pkg && l . name == other . name && l . relative == other . relative } 
func ( l label ) contains ( other label ) bool { if l . relative { log . panicf ( " " , l ) } if other . relative { log . panicf ( " " , other ) } result : = l . repo == other . repo && pathtools . hasprefix ( other . pkg , l . pkg ) return result } 
func issemverprefix ( v string ) bool { dots : = 0 for i : = 0 ; i < len ( v ) ; i ++ { switch v [ i ] { case ' - ' , ' + ' : return false case ' . ' : dots ++ if dots >= 2 { return false } } } return true } 
func generatefrompath ( w io . writer , rootpath string ) error { return filepath . walk ( rootpath , func ( path string , info os . fileinfo , err error ) error { if err ! = nil { return err } if ! strings . hassuffix ( path , " " ) { return nil } relpath , err : = filepath . rel ( rootpath , path ) if err ! = nil | | strings . hasprefix ( relpath , " " ) { log . panicf ( " " , path , rootpath ) } relpath = filepath . toslash ( relpath ) if strings . hasprefix ( relpath , " " ) { packagepath : = " " protolabel , golabel : = protolabels ( " " , " " ) fmt . fprintf ( w , " \n " , relpath , protolabel , packagepath , golabel ) return nil } packagepath , packagename , err : = loadgopackage ( path ) if err ! = nil { log . print ( err ) return nil } protolabel , golabel : = protolabels ( relpath , packagename ) fmt . fprintf ( w , " \n " , relpath , protolabel , packagepath , golabel ) return nil } ) } 
func buildupdaterelmap ( root string , dirs [ ] string ) map [ string ] bool { relmap : = make ( map [ string ] bool ) for , dir : = range dirs { rel , : = filepath . rel ( root , dir ) rel = filepath . toslash ( rel ) if rel == " " { rel = " " } i : = 0 for { next : = strings . indexbyte ( rel [ i : ] , ' / ' ) + i if next - i < 0 { relmap [ rel ] = true break } prefix : = rel [ : next ] relmap [ prefix ] = relmap [ prefix ] i = next + 1 } } return relmap } 
func shouldcall ( rel string , mode mode , updaterels map [ string ] bool ) bool { return mode ! = updatedirsmode | | updaterels [ rel ] } 
func shouldupdate ( rel string , mode mode , updateparent bool , updaterels map [ string ] bool ) bool { return mode == visitallupdatesubdirsmode && updateparent | | updaterels [ rel ] } 
func shouldvisit ( rel string , mode mode , updaterels map [ string ] bool ) bool { if mode ! = updatedirsmode { return true } , ok : = updaterels [ rel ] return ok } 
func ( r * symlinkresolver ) follow ( c * config . config , dir , rel , base string ) bool { if dir == c . reporoot && strings . hasprefix ( base , " " ) { return false } wc : = getwalkconfig ( c ) linkrel : = path . join ( rel , base ) for , follow : = range wc . follow { if linkrel == follow { return true } } fullpath : = filepath . join ( dir , base ) dest , err : = filepath . evalsymlinks ( fullpath ) if err ! = nil { return false } if ! filepath . isabs ( dest ) { dest , err = filepath . abs ( filepath . join ( dir , dest ) ) if err ! = nil { return false } } for , p : = range r . visited { if pathtools . hasprefix ( dest , p ) | | pathtools . hasprefix ( p , dest ) { return false } } r . visited = append ( r . visited , dest ) stat , err : = os . stat ( fullpath ) if err ! = nil { return false } return stat . isdir ( ) } 
func mergerules ( src , dst * rule , mergeable map [ string ] bool , filename string ) { if dst . shouldkeep ( ) { return } for key , dstattr : = range dst . attrs { if , ok : = src . attrs [ key ] ; ok | | ! mergeable [ key ] | | shouldkeep ( dstattr ) { continue } dstvalue : = dstattr . rhs if mergedvalue , err : = mergeexprs ( nil , dstvalue ) ; err ! = nil { start , end : = dstvalue . span ( ) log . printf ( " " , filename , start . line , start . linerune , end . line , end . linerune ) } else if mergedvalue == nil { dst . delattr ( key ) } else { dst . setattr ( key , mergedvalue ) } } for key , srcattr : = range src . attrs { srcvalue : = srcattr . rhs if dstattr , ok : = dst . attrs [ key ] ; ! ok { dst . setattr ( key , srcvalue ) } else if mergeable [ key ] && ! shouldkeep ( dstattr ) { dstvalue : = dstattr . rhs if mergedvalue , err : = mergeexprs ( srcvalue , dstvalue ) ; err ! = nil { start , end : = dstvalue . span ( ) log . printf ( " " , filename , start . line , start . linerune , end . line , end . linerune ) } else { dst . setattr ( key , mergedvalue ) } } } } 
func mergeexprs ( src , dst bzl . expr ) ( bzl . expr , error ) { if shouldkeep ( dst ) { return nil , nil } if src == nil && ( dst == nil | | isscalar ( dst ) ) { return nil , nil } if isscalar ( src ) { return src , nil } srcexprs , err : = extractplatformstringsexprs ( src ) if err ! = nil { return nil , err } dstexprs , err : = extractplatformstringsexprs ( dst ) if err ! = nil { return nil , err } mergedexprs , err : = mergeplatformstringsexprs ( srcexprs , dstexprs ) if err ! = nil { return nil , err } return makeplatformstringsexpr ( mergedexprs ) , nil } 
func squashrules ( src , dst * rule , filename string ) error { if dst . shouldkeep ( ) { return nil } for key , srcattr : = range src . attrs { srcvalue : = srcattr . rhs if dstattr , ok : = dst . attrs [ key ] ; ! ok { dst . setattr ( key , srcvalue ) } else if ! shouldkeep ( dstattr ) { dstvalue : = dstattr . rhs if squashedvalue , err : = squashexprs ( srcvalue , dstvalue ) ; err ! = nil { start , end : = dstvalue . span ( ) return fmt . errorf ( " " , filename , start . line , start . linerune , end . line , end . linerune ) } else { dst . setattr ( key , squashedvalue ) } } } dst . expr . comment ( ) . before = append ( dst . expr . comment ( ) . before , src . expr . comment ( ) . before ... ) dst . expr . comment ( ) . suffix = append ( dst . expr . comment ( ) . suffix , src . expr . comment ( ) . suffix ... ) dst . expr . comment ( ) . after = append ( dst . expr . comment ( ) . after , src . expr . comment ( ) . after ... ) return nil } 
func substituterule ( r * rule . rule , substitutions map [ string ] string , info rule . kindinfo ) { for attr : = range info . substituteattrs { if expr : = r . attr ( attr ) ; expr ! = nil { expr = rule . mapexprstrings ( expr , func ( s string ) string { if rename , ok : = substitutions [ strings . trimprefix ( s , " " ) ] ; ok { return " " + rename } else { return s } } ) r . setattr ( attr , expr ) } } } 
func runclient ( ) error { starttime : = time . now ( ) conn , err : = net . dial ( " " , * socketpath ) if err ! = nil { if err : = startserver ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } for retry : = 0 ; retry < 3 ; retry ++ { conn , err = net . dial ( " " , * socketpath ) if err == nil { break } time . sleep ( 1 * time . second ) } if err ! = nil { return fmt . errorf ( " " , err ) } } defer conn . close ( ) if , err : = io . copy ( os . stderr , conn ) ; err ! = nil { log . print ( err ) } elapsedtime : = time . since ( starttime ) log . printf ( " " , elapsedtime . seconds ( ) ) return nil } 
func parsedirectives ( f * bzl . file ) [ ] directive { var directives [ ] directive parsecomment : = func ( com bzl . comment ) { match : = directivere . findstringsubmatch ( com . token ) if match == nil { return } key , value : = match [ 1 ] , match [ 2 ] directives = append ( directives , directive { key , value } ) } for , s : = range f . stmt { coms : = s . comment ( ) for , com : = range coms . before { parsecomment ( com ) } for , com : = range coms . after { parsecomment ( com ) } } return directives } 
func updaterepo ( rc * remotecache , importpath string ) ( repo , error ) { root , name , err : = rc . root ( importpath ) if err ! = nil { return repo { } , err } remote , vcs , err : = rc . remote ( root ) if err ! = nil { return repo { } , err } commit , tag , err : = rc . head ( remote , vcs ) if err ! = nil { return repo { } , err } repo : = repo { name : name , goprefix : root , commit : commit , tag : tag , remote : remote , vcs : vcs , } return repo , nil } 
func newremotecache ( knownrepos [ ] repo ) ( r * remotecache , cleanup func ( ) error ) { r = & remotecache { reporootforimportpath : vcs . reporootforimportpath , headcmd : defaultheadcmd , root : remotecachemap { cache : make ( map [ string ] * remotecacheentry ) } , remote : remotecachemap { cache : make ( map [ string ] * remotecacheentry ) } , head : remotecachemap { cache : make ( map [ string ] * remotecacheentry ) } , mod : remotecachemap { cache : make ( map [ string ] * remotecacheentry ) } , } r . modinfo = func ( importpath string ) ( string , error ) { return defaultmodinfo ( r , importpath ) } for , repo : = range knownrepos { r . root . cache [ repo . goprefix ] = & remotecacheentry { value : rootvalue { root : repo . goprefix , name : repo . name , } , } if repo . remote ! = " " { r . remote . cache [ repo . goprefix ] = & remotecacheentry { value : remotevalue { remote : repo . remote , vcs : repo . vcs , } , } } r . mod . cache [ repo . goprefix ] = & remotecacheentry { value : modvalue { path : repo . goprefix , name : repo . name , known : true , } , } } return r , r . cleanup } 
func ( r * remotecache ) remote ( root string ) ( remote , vcs string , err error ) { v , err : = r . remote . ensure ( root , func ( ) ( interface { } , error ) { repo , err : = r . reporootforimportpath ( root , false ) if err ! = nil { return nil , err } return remotevalue { remote : repo . repo , vcs : repo . vcs . cmd } , nil } ) if err ! = nil { return " " , " " , err } value : = v . ( remotevalue ) return value . remote , value . vcs , nil } 
func ( r * remotecache ) head ( remote , vcs string ) ( commit , tag string , err error ) { if vcs ! = " " { return " " , " " , fmt . errorf ( " " , remote , vcs ) } v , err : = r . head . ensure ( remote , func ( ) ( interface { } , error ) { commit , err : = r . headcmd ( remote , vcs ) if err ! = nil { return nil , err } return headvalue { commit : commit } , nil } ) if err ! = nil { return " " , " " , err } value : = v . ( headvalue ) return value . commit , value . tag , nil } 
func ( r * remotecache ) mod ( importpath string ) ( modpath , name string , err error ) { prefix : = importpath for { v , ok , err : = r . mod . get ( prefix ) if ok { if err ! = nil { return " " , " " , err } value : = v . ( modvalue ) if value . known { return value . path , value . name , nil } else { break } } prefix = path . dir ( prefix ) if prefix == " " | | prefix == " " { break } } v , err : = r . mod . ensure ( importpath , func ( ) ( interface { } , error ) { modpath , err : = r . modinfo ( importpath ) if err ! = nil { return nil , err } return modvalue { path : modpath , name : label . importpathtobazelreponame ( modpath ) , } , nil } ) if err ! = nil { return " " , " " , err } value : = v . ( modvalue ) return value . path , value . name , nil } 
func ( m * remotecachemap ) get ( key string ) ( value interface { } , ok bool , err error ) { m . mu . lock ( ) e , ok : = m . cache [ key ] m . mu . unlock ( ) if ! ok { return nil , ok , nil } if e . ready ! = nil { < - e . ready } return e . value , ok , e . err } 
func ( m * remotecachemap ) ensure ( key string , load func ( ) ( interface { } , error ) ) ( interface { } , error ) { m . mu . lock ( ) e , ok : = m . cache [ key ] if ! ok { e = & remotecacheentry { ready : make ( chan struct { } ) } m . cache [ key ] = e m . mu . unlock ( ) e . value , e . err = load ( ) close ( e . ready ) } else { m . mu . unlock ( ) if e . ready ! = nil { < - e . ready } } return e . value , e . err } 
func hasprefix ( p , prefix string ) bool { return prefix == " " | | p == prefix | | strings . hasprefix ( p , prefix + " " ) } 
func trimprefix ( p , prefix string ) string { if prefix == " " { return p } if prefix == p { return " " } return strings . trimprefix ( p , prefix + " " ) } 
func relbasename ( rel , prefix , root string ) string { base : = path . base ( rel ) if base == " " | | base == " " { base = path . base ( prefix ) } if base == " " | | base == " " { base = filepath . base ( root ) } if base == " " | | base == " " { base = " " } return base } 
func ( c * config ) clone ( ) * config { cc : = * c cc . exts = make ( map [ string ] interface { } ) for k , v : = range c . exts { cc . exts [ k ] = v } cc . kindmap = make ( map [ string ] mappedkind ) for k , v : = range c . kindmap { cc . kindmap [ k ] = v } return & cc } 
func ( c * config ) isvalidbuildfilename ( name string ) bool { for , n : = range c . validbuildfilenames { if name == n { return true } } return false } 
func ( l tagline ) check ( c * config . config , os , arch string ) bool { if len ( l ) == 0 { return false } for , g : = range l { if g . check ( c , os , arch ) { return true } } return false } 
func ( g taggroup ) check ( c * config . config , os , arch string ) bool { goconf : = getgoconfig ( c ) for , t : = range g { if strings . hasprefix ( t , " " ) { return false } not : = strings . hasprefix ( t , " " ) if not { t = t [ 1 : ] } if isignoredtag ( t ) { continue } var match bool if , ok : = rule . knownosset [ t ] ; ok { if os == " " { return false } match = os == t } else if , ok : = rule . knownarchset [ t ] ; ok { if arch == " " { return false } match = arch == t } else { match = goconf . generictags [ t ] } if not { match = ! match } if ! match { return false } } return true } 
func otherfileinfo ( path string ) fileinfo { info : = filenameinfo ( path ) if info . ext == unknownext { return info } tags , err : = readtags ( info . path ) if err ! = nil { log . printf ( " " , info . path , err ) return info } info . tags = tags return info } 
func splitquoted ( s string ) ( r [ ] string , err error ) { var args [ ] string arg : = make ( [ ] rune , len ( s ) ) escaped : = false quoted : = false quote : = ' \ x00 ' i : = 0 for , rune : = range s { switch { case escaped : escaped = false case rune == ' \ \ ' : escaped = true continue case quote ! = ' \ x00 ' : if rune == quote { quote = ' \ x00 ' continue } case rune == ' " ' | | rune == ' \ ' ' : quoted = true quote = rune continue case unicode . isspace ( rune ) : if quoted | | i > 0 { quoted = false args = append ( args , string ( arg [ : i ] ) ) i = 0 } continue } arg [ i ] = rune i ++ } if quoted | | i > 0 { args = append ( args , string ( arg [ : i ] ) ) } if quote ! = 0 { err = errors . new ( " " ) } else if escaped { err = errors . new ( " " ) } return args , err } 
func expandsrcdir ( str string , srcdir string ) ( string , bool ) { srcdir = filepath . toslash ( srcdir ) if srcdir == " " { srcdir = " " } chunks : = strings . split ( str , " " ) if len ( chunks ) < 2 { return str , safecgoname ( str , false ) } ok : = true for , chunk : = range chunks { ok = ok && ( chunk == " " | | safecgoname ( chunk , false ) ) } ok = ok && ( srcdir == " " | | safecgoname ( srcdir , true ) ) res : = strings . join ( chunks , srcdir ) return res , ok && res ! = " " } 
func safecgoname ( s string , spaces bool ) bool { if s == " " { return false } safe : = safebytes if ! spaces { safe = safe [ len ( safespaces ) : ] } for i : = 0 ; i < len ( s ) ; i ++ { if c : = s [ i ] ; c < utf8 . runeself && bytes . indexbyte ( safe , c ) < 0 { return false } } return true } 
func readtags ( path string ) ( [ ] tagline , error ) { f , err : = os . open ( path ) if err ! = nil { return nil , err } defer f . close ( ) scanner : = bufio . newscanner ( f ) var lines [ ] string end : = 0 for scanner . scan ( ) { line : = strings . trimspace ( scanner . text ( ) ) if line == " " { end = len ( lines ) continue } if strings . hasprefix ( line , " " ) { lines = append ( lines , line [ len ( " " ) : ] ) continue } break } if err : = scanner . err ( ) ; err ! = nil { return nil , err } lines = lines [ : end ] var taglines [ ] tagline for , line : = range lines { fields : = strings . fields ( line ) if len ( fields ) > 0 && fields [ 0 ] == " " { taglines = append ( taglines , parsetagsingroups ( fields [ 1 : ] ) ) } } return taglines , nil } 
func checkconstraints ( c * config . config , os , arch , ossuffix , archsuffix string , filetags [ ] tagline , cgotags tagline ) bool { if ossuffix ! = " " && ossuffix ! = os | | archsuffix ! = " " && archsuffix ! = arch { return false } for , l : = range filetags { if ! l . check ( c , os , arch ) { return false } } if len ( cgotags ) > 0 && ! cgotags . check ( c , os , arch ) { return false } return true } 
func isignoredtag ( tag string ) bool { if tag == " " | | tag == " " | | tag == " " { return true } if len ( tag ) < 5 | | ! strings . hasprefix ( tag , " " ) { return false } if tag [ 2 ] < ' 0 ' | | tag [ 2 ] > ' 9 ' | | tag [ 3 ] ! = ' . ' { return false } for , c : = range tag [ 4 : ] { if c < ' 0 ' | | c > ' 9 ' { return false } } return true } 
func protofileinfo ( path string , protoinfo proto . fileinfo ) fileinfo { info : = filenameinfo ( path ) for , opt : = range protoinfo . options { if opt . key ! = " " { continue } if strings . lastindexbyte ( opt . value , ' / ' ) == - 1 { info . packagename = opt . value } else { if i : = strings . lastindexbyte ( opt . value , ' ; ' ) ; i ! = - 1 { info . importpath = opt . value [ : i ] info . packagename = opt . value [ i + 1 : ] } else { info . importpath = opt . value info . packagename = path . base ( opt . value ) } } } if info . packagename == " " && protoinfo . packagename ! = " " { info . packagename = strings . replace ( protoinfo . packagename , " " , " " , - 1 ) } info . imports = protoinfo . imports info . hasservices = protoinfo . hasservices return info } 
func findrulewithoverride ( c * config . config , imp importspec , lang string ) ( label . label , bool ) { rc : = getresolveconfig ( c ) for i : = len ( rc . overrides ) - 1 ; i >= 0 ; i -- { o : = rc . overrides [ i ] if o . matches ( imp , lang ) { return o . dep , true } } return label . nolabel , false } 
func newruleindex ( mrslv func ( r * rule . rule , pkgrel string ) resolver ) * ruleindex { return & ruleindex { labelmap : make ( map [ label . label ] * rulerecord ) , mrslv : mrslv , } } 
func ( ix * ruleindex ) addrule ( c * config . config , r * rule . rule , f * rule . file ) { var imps [ ] importspec if rslv : = ix . mrslv ( r , f . pkg ) ; rslv ! = nil { imps = rslv . imports ( c , r , f ) } if imps == nil { return } record : = & rulerecord { rule : r , label : label . new ( c . reponame , f . pkg , r . name ( ) ) , file : f , importedas : imps , } if , ok : = ix . labelmap [ record . label ] ; ok { log . printf ( " " , record . label ) return } ix . rules = append ( ix . rules , record ) ix . labelmap [ record . label ] = record } 
func ( ix * ruleindex ) finish ( ) { for , r : = range ix . rules { ix . collectembeds ( r ) } ix . buildimportindex ( ) } 
func ( ix * ruleindex ) buildimportindex ( ) { ix . importmap = make ( map [ importspec ] [ ] * rulerecord ) for , r : = range ix . rules { if r . embedded { continue } indexed : = make ( map [ importspec ] bool ) for , imp : = range r . importedas { if indexed [ imp ] { continue } indexed [ imp ] = true ix . importmap [ imp ] = append ( ix . importmap [ imp ] , r ) } } } 
func ( ix * ruleindex ) findrulesbyimport ( imp importspec , lang string ) [ ] findresult { matches : = ix . importmap [ imp ] results : = make ( [ ] findresult , 0 , len ( matches ) ) for , m : = range matches { if ix . mrslv ( m . rule , " " ) . name ( ) ! = lang { continue } results = append ( results , findresult { label : m . label , embeds : m . embeds , } ) } return results } 
func ( r findresult ) isselfimport ( from label . label ) bool { if from . equal ( r . label ) { return true } for , e : = range r . embeds { if from . equal ( e ) { return true } } return false } 
func applykindmappings ( mappedkinds [ ] config . mappedkind , loads [ ] rule . loadinfo ) [ ] rule . loadinfo { if len ( mappedkinds ) == 0 { return loads } mappedloads : = make ( [ ] rule . loadinfo , len ( loads ) ) copy ( mappedloads , loads ) for , mappedkind : = range mappedkinds { mappedloads = appendormergekindmapping ( mappedloads , mappedkind ) } return mappedloads } 
func appendormergekindmapping ( mappedloads [ ] rule . loadinfo , mappedkind config . mappedkind ) [ ] rule . loadinfo { for , load : = range mappedloads { if load . name == mappedkind . kindload { load . symbols = append ( load . symbols , mappedkind . kindname ) return mappedloads } } return append ( mappedloads , rule . loadinfo { name : mappedkind . kindload , symbols : [ ] string { mappedkind . kindname } , } ) } 
func rulename ( names ... string ) string { base : = " " for , name : = range names { notident : = func ( c rune ) bool { return ! ( ' a ' <= c && c <= ' z ' | | ' a ' <= c && c <= ' z ' | | ' 0 ' <= c && c <= ' 9 ' | | c == ' ' ) } if i : = strings . lastindexfunc ( name , notident ) ; i >= 0 { name = name [ i + 1 : ] } if name ! = " " { base = name break } } return base + " " } 
func buildpackages ( pc * protoconfig , dir , rel string , protofiles , genfiles [ ] string ) [ ] * package { packagemap : = make ( map [ string ] * package ) for , name : = range protofiles { info : = protofileinfo ( dir , name ) key : = info . packagename if pc . groupoption ! = " " { for , opt : = range info . options { if opt . key == pc . groupoption { key = opt . value break } } } if packagemap [ key ] == nil { packagemap [ key ] = newpackage ( info . packagename ) } packagemap [ key ] . addfile ( info ) } switch pc . mode { case defaultmode : pkg , err : = selectpackage ( dir , rel , packagemap ) if err ! = nil { log . print ( err ) } if pkg == nil { return nil } for , name : = range genfiles { pkg . addgenfile ( dir , name ) } return [ ] * package { pkg } case packagemode : pkgs : = make ( [ ] * package , 0 , len ( packagemap ) ) for , pkg : = range packagemap { pkgs = append ( pkgs , pkg ) } return pkgs default : return nil } } 
func selectpackage ( dir , rel string , packagemap map [ string ] * package ) ( * package , error ) { if len ( packagemap ) == 0 { return nil , nil } if len ( packagemap ) == 1 { for , pkg : = range packagemap { return pkg , nil } } defaultpackagename : = strings . replace ( rel , " " , " " , - 1 ) for , pkg : = range packagemap { if pkgname : = gopackagename ( pkg ) ; pkgname ! = " " && pkgname == defaultpackagename { return pkg , nil } } return nil , fmt . errorf ( " " , dir ) } 
func gopackagename ( pkg * package ) string { if opt , ok : = pkg . options [ " " ] ; ok { if i : = strings . indexbyte ( opt , ' ; ' ) ; i >= 0 { return opt [ i + 1 : ] } else if i : = strings . lastindexbyte ( opt , ' / ' ) ; i >= 0 { return opt [ i + 1 : ] } else { return opt } } if pkg . name ! = " " { return strings . replace ( pkg . name , " " , " " , - 1 ) } if len ( pkg . files ) == 1 { for s : = range pkg . files { return strings . trimsuffix ( s , " " ) } } return " " } 
func generateproto ( pc * protoconfig , rel string , pkg * package , shouldsetvisibility bool ) * rule . rule { var name string if pc . mode == defaultmode { name = rulename ( gopackagename ( pkg ) , pc . goprefix , rel ) } else { name = rulename ( pkg . options [ pc . groupoption ] , pkg . name , rel ) } r : = rule . newrule ( " " , name ) srcs : = make ( [ ] string , 0 , len ( pkg . files ) ) for f : = range pkg . files { srcs = append ( srcs , f ) } sort . strings ( srcs ) if len ( srcs ) > 0 { r . setattr ( " " , srcs ) } r . setprivateattr ( packagekey , * pkg ) imports : = make ( [ ] string , 0 , len ( pkg . imports ) ) for i : = range pkg . imports { imports = append ( imports , i ) } sort . strings ( imports ) r . setprivateattr ( config . gazelleimportskey , imports ) for k , v : = range pkg . options { r . setprivateattr ( k , v ) } if shouldsetvisibility { vis : = rule . checkinternalvisibility ( rel , " " ) r . setattr ( " " , [ ] string { vis } ) } if pc . stripimportprefix ! = " " { r . setattr ( " " , pc . stripimportprefix ) } if pc . importprefix ! = " " { r . setattr ( " " , pc . importprefix ) } return r } 
func generateempty ( f * rule . file , regularfiles , genfiles [ ] string ) [ ] * rule . rule { if f == nil { return nil } knownfiles : = make ( map [ string ] bool ) for , f : = range regularfiles { knownfiles [ f ] = true } for , f : = range genfiles { knownfiles [ f ] = true } var empty [ ] * rule . rule outer : for , r : = range f . rules { if r . kind ( ) ! = " " { continue } srcs : = r . attrstrings ( " " ) if len ( srcs ) == 0 && r . attr ( " " ) ! = nil { continue } for , src : = range r . attrstrings ( " " ) { if knownfiles [ src ] { continue outer } } empty = append ( empty , rule . newrule ( " " , r . name ( ) ) ) } return empty } 
func importreporules ( filename string , repocache * remotecache ) ( [ ] * rule . rule , error ) { format : = getlockfileformat ( filename ) if format == unknownformat { return nil , fmt . errorf ( ' %s : unrecognized lock file format . expected " gopkg . lock " , " go . mod " , or " godeps . json " ' , filename ) } parser : = lockfileparsers [ format ] repos , err : = parser ( filename , repocache ) if err ! = nil { return nil , fmt . errorf ( " " , filename , err ) } sort . stable ( byname ( repos ) ) rules : = make ( [ ] * rule . rule , 0 , len ( repos ) ) for , repo : = range repos { rules = append ( rules , generaterule ( repo ) ) } return rules , nil } 
func generaterule ( repo repo ) * rule . rule { r : = rule . newrule ( " " , repo . name ) if repo . commit ! = " " { r . setattr ( " " , repo . commit ) } if repo . tag ! = " " { r . setattr ( " " , repo . tag ) } r . setattr ( " " , repo . goprefix ) if repo . remote ! = " " { r . setattr ( " " , repo . remote ) } if repo . vcs ! = " " { r . setattr ( " " , repo . vcs ) } if repo . version ! = " " { r . setattr ( " " , repo . version ) } if repo . sum ! = " " { r . setattr ( " " , repo . sum ) } if repo . replace ! = " " { r . setattr ( " " , repo . replace ) } return r } 
func findexternalrepo ( reporoot , name string ) ( string , error ) { externalpath : = strings . join ( [ ] string { reporoot , " " , " " , " " , " " , " " , name } , string ( os . pathseparator ) ) cleanpath , err : = filepath . evalsymlinks ( externalpath ) if err ! = nil { return " " , err } st , err : = os . stat ( cleanpath ) if err ! = nil { return " " , err } if ! st . isdir ( ) { return " " , fmt . errorf ( " " , externalpath ) } return cleanpath , nil } 
func listrepositories ( workspace * rule . file ) ( repos [ ] repo , reponamesbyfile map [ * rule . file ] [ ] string , err error ) { reponamesbyfile = make ( map [ * rule . file ] [ ] string ) repos , reponamesbyfile [ workspace ] = getrepos ( workspace . rules ) for , d : = range workspace . directives { switch d . key { case " " : f , defname , err : = parserepositorymacrodirective ( d . value ) if err ! = nil { return nil , nil , err } f = filepath . join ( filepath . dir ( workspace . path ) , filepath . clean ( f ) ) macrofile , err : = rule . loadmacrofile ( f , " " , defname ) if err ! = nil { return nil , nil , err } currrepos , names : = getrepos ( macrofile . rules ) reponamesbyfile [ macrofile ] = names repos = append ( repos , currrepos ... ) } } return repos , reponamesbyfile , nil } 
func migratelibraryembed ( c * config . config , f * rule . file ) { for , r : = range f . rules { if ! isgorule ( r . kind ( ) ) { continue } libexpr : = r . attr ( " " ) if libexpr == nil | | rule . shouldkeep ( libexpr ) | | r . attr ( " " ) ! = nil { continue } r . delattr ( " " ) r . setattr ( " " , & bzl . listexpr { list : [ ] bzl . expr { libexpr } } ) } } 
func migrategrpccompilers ( c * config . config , f * rule . file ) { for , r : = range f . rules { if r . kind ( ) ! = " " | | r . shouldkeep ( ) | | r . attr ( " " ) ! = nil { continue } r . setkind ( " " ) r . setattr ( " " , [ ] string { grpccompilerlabel } ) } } 
func squashcgolibrary ( c * config . config , f * rule . file ) { var cgolibrary , golibrary * rule . rule for , r : = range f . rules { if r . kind ( ) == " " && r . name ( ) == " " && ! r . shouldkeep ( ) { if cgolibrary ! = nil { log . printf ( " " , f . path ) continue } cgolibrary = r continue } if r . kind ( ) == " " && r . name ( ) == defaultlibname { if golibrary ! = nil { log . printf ( " " , f . path ) } golibrary = r continue } } if cgolibrary == nil { return } if ! c . shouldfix { log . printf ( " " , f . path ) return } if golibrary == nil { cgolibrary . setkind ( " " ) cgolibrary . setname ( defaultlibname ) cgolibrary . setattr ( " " , true ) return } if err : = rule . squashrules ( cgolibrary , golibrary , f . path ) ; err ! = nil { log . print ( err ) return } golibrary . delattr ( " " ) golibrary . setattr ( " " , true ) cgolibrary . delete ( ) } 
func flattensrcs ( c * config . config , f * rule . file ) { for , r : = range f . rules { if ! isgorule ( r . kind ( ) ) { continue } oldsrcs : = r . attr ( " " ) if oldsrcs == nil { continue } flatsrcs : = rule . flattenexpr ( oldsrcs ) if flatsrcs ! = oldsrcs { r . setattr ( " " , flatsrcs ) } } } 
func removelegacyproto ( c * config . config , f * rule . file ) { if pcmode : = getprotomode ( c ) ; pcmode ! = proto . defaultmode { return } var protoloads [ ] * rule . load for , l : = range f . loads { if l . name ( ) == " " { protoloads = append ( protoloads , l ) } } var protofilegroups , protorules [ ] * rule . rule for , r : = range f . rules { if r . kind ( ) == " " && r . name ( ) == legacyprotofilegroupname { protofilegroups = append ( protofilegroups , r ) } if r . kind ( ) == " " { protorules = append ( protorules , r ) } } if len ( protoloads ) + len ( protofilegroups ) == 0 { return } if ! c . shouldfix { log . printf ( " " , f . path ) return } for , l : = range protoloads { l . delete ( ) } for , r : = range protofilegroups { r . delete ( ) } if len ( protoloads ) > 0 { for , r : = range protorules { r . delete ( ) } } } 
func removelegacygazelle ( c * config . config , f * rule . file ) { for , l : = range f . loads { if l . name ( ) == " " && l . has ( " " ) { l . remove ( " " ) if l . isempty ( ) { l . delete ( ) } } } } 
func selectpackage ( c * config . config , dir string , packagemap map [ string ] * gopackage ) ( * gopackage , error ) { buildablepackages : = make ( map [ string ] * gopackage ) for name , pkg : = range packagemap { if pkg . isbuildable ( c ) { buildablepackages [ name ] = pkg } } if len ( buildablepackages ) == 0 { return nil , & build . nogoerror { dir : dir } } if len ( buildablepackages ) == 1 { for , pkg : = range buildablepackages { return pkg , nil } } if pkg , ok : = buildablepackages [ defaultpackagename ( c , dir ) ] ; ok { return pkg , nil } err : = & build . multiplepackageerror { dir : dir } for name , pkg : = range buildablepackages { err . packages = append ( err . packages , name ) err . files = append ( err . files , pkg . firstgofile ( ) ) } return nil , err } 
func ( g * generator ) options ( opts rule . platformstrings , pkgrel string ) rule . platformstrings { fixpath : = func ( opt string ) string { if strings . hasprefix ( opt , " " ) { return opt } return path . clean ( path . join ( pkgrel , opt ) ) } fixgroups : = func ( groups [ ] string ) ( [ ] string , error ) { fixedgroups : = make ( [ ] string , len ( groups ) ) for i , group : = range groups { opts : = strings . split ( group , optseparator ) fixedopts : = make ( [ ] string , len ( opts ) ) ispath : = false for j , opt : = range opts { if ispath { opt = fixpath ( opt ) ispath = false goto next } for , short : = range shortoptprefixes { if strings . hasprefix ( opt , short ) && len ( opt ) > len ( short ) { opt = short + fixpath ( opt [ len ( short ) : ] ) goto next } } for , long : = range longoptprefixes { if opt == long { ispath = true goto next } } next : fixedopts [ j ] = escapeoption ( opt ) } fixedgroups [ i ] = strings . join ( fixedopts , " " ) } return fixedgroups , nil } opts , errs : = opts . mapslice ( fixgroups ) if errs ! = nil { log . panicf ( " " , pkgrel , errs ) } return opts } 
func ( mr * metaresolver ) addbuiltin ( kindname string , resolver resolve . resolver ) { mr . builtins [ kindname ] = resolver } 
func ( mr * metaresolver ) mappedkind ( pkgrel string , kind config . mappedkind ) { mr . mappedkinds [ pkgrel ] = append ( mr . mappedkinds [ pkgrel ] , kind ) } 
func ( mr metaresolver ) resolver ( r * rule . rule , pkgrel string ) resolve . resolver { for , mappedkind : = range mr . mappedkinds [ pkgrel ] { if mappedkind . kindname == r . kind ( ) { return mr . builtins [ mappedkind . fromkind ] } } return mr . builtins [ r . kind ( ) ] } 
func sortexprlabels ( e bzl . expr , [ ] bzl . expr ) { list , ok : = e . ( * bzl . listexpr ) if ! ok | | len ( list . list ) == 0 { return } keys : = make ( [ ] stringsortkey , len ( list . list ) ) for i , elem : = range list . list { s , ok : = elem . ( * bzl . stringexpr ) if ! ok { return } keys [ i ] = makesortkey ( i , s ) } before : = keys [ 0 ] . x . comment ( ) . before keys [ 0 ] . x . comment ( ) . before = nil sort . sort ( bystringexpr ( keys ) ) keys [ 0 ] . x . comment ( ) . before = append ( before , keys [ 0 ] . x . comment ( ) . before ... ) for i , k : = range keys { list . list [ i ] = k . x } } 
func checkrulesgoversion ( reporoot string ) { const message = rulesgopath , err : = repo . findexternalrepo ( reporoot , config . rulesgoreponame ) if err ! = nil { return } defbzlpath : = filepath . join ( rulesgopath , " " , " " ) defbzlcontent , err : = ioutil . readfile ( defbzlpath ) if err ! = nil { return } versionre : = regexp . mustcompile ( ' ( ?m ) ^ rules go version = [ ' " ] ( [ 0 - 9 . ] * ) [ ' " ] ' ) match : = versionre . findsubmatch ( defbzlcontent ) if match == nil { log . printf ( " \n " , config . rulesgoreponame , message ) return } vstr : = string ( match [ 1 ] ) v , err : = version . parseversion ( vstr ) if err ! = nil { log . printf ( " \n " , vstr , config . rulesgoreponame , message ) } if v . compare ( minimumrulesgoversion ) < 0 { log . printf ( " \n " , v , minimumrulesgoversion , message ) } } 
func ( gc * goconfig ) preprocesstags ( ) { if gc . generictags == nil { gc . generictags = make ( map [ string ] bool ) } gc . generictags [ " " ] = true } 
func ( gc * goconfig ) setbuildtags ( tags string ) error { if tags == " " { return nil } for , t : = range strings . split ( tags , " " ) { if strings . hasprefix ( t , " " ) { return fmt . errorf ( " " , t ) } gc . generictags [ t ] = true } return nil } 
func checkprefix ( prefix string ) error { if strings . hasprefix ( prefix , " " ) | | build . islocalimport ( prefix ) { return fmt . errorf ( " " , prefix ) } return nil } 
func splitvalue ( value string ) [ ] string { parts : = strings . split ( value , " " ) values : = make ( [ ] string , 0 , len ( parts ) ) for , part : = range parts { values = append ( values , strings . trimspace ( part ) ) } return values } 
func copygomodtotemp ( filename string ) ( tempdir string , err error ) { gomodorig , err : = os . open ( filename ) if err ! = nil { return " " , err } defer gomodorig . close ( ) tempdir , err = ioutil . tempdir ( " " , " " ) if err ! = nil { return " " , err } gomodcopy , err : = os . create ( filepath . join ( tempdir , " " ) ) if err ! = nil { os . remove ( tempdir ) return " " , err } defer func ( ) { if cerr : = gomodcopy . close ( ) ; err == nil && cerr ! = nil { err = cerr } } ( ) , err = io . copy ( gomodcopy , gomodorig ) if err ! = nil { os . removeall ( tempdir ) return " " , err } return tempdir , err } 
func findgotool ( ) string { path : = " " if goroot , ok : = os . lookupenv ( " " ) ; ok { path = filepath . join ( goroot , " " , " " ) } if runtime . goos == " " { path += " " } return path } 
func ( pkg * gopackage ) addfile ( c * config . config , info fileinfo , cgo bool ) error { switch { case info . ext == unknownext | | ! cgo && ( info . ext == cext | | info . ext == csext ) : return nil case info . ext == protoext : if pcmode : = getprotomode ( c ) ; pcmode == proto . legacymode { pkg . proto . addfile ( c , info ) } case info . istest : if info . iscgo { return fmt . errorf ( " " , info . path ) } pkg . test . addfile ( c , info ) default : pkg . library . addfile ( c , info ) } return nil } 
func ( pkg * gopackage ) isbuildable ( c * config . config ) bool { return pkg . firstgofile ( ) ! = " " | | ! pkg . proto . sources . isempty ( ) } 
func ( pkg * gopackage ) firstgofile ( ) string { gosrcs : = [ ] platformstringsbuilder { pkg . library . sources , pkg . binary . sources , pkg . test . sources , } for , sb : = range gosrcs { if sb . strs ! = nil { for s : = range sb . strs { if strings . hassuffix ( s , " " ) { return s } } } } return " " } 
func startserver ( ) error { exe , err : = os . executable ( ) if err ! = nil { return err } args : = [ ] string { " " } args = append ( args , os . args [ 1 : ] ... ) cmd : = exec . command ( exe , args ... ) log . printf ( " " , strings . join ( cmd . args , " " ) ) if err : = cmd . start ( ) ; err ! = nil { return err } if err : = cmd . process . release ( ) ; err ! = nil { return err } return nil } 
func listdirs ( dir string ) ( [ ] string , [ ] error ) { var dirs [ ] string var errs [ ] error err : = filepath . walk ( dir , func ( path string , info os . fileinfo , err error ) error { if err ! = nil { errs = append ( errs , err ) return nil } if info . isdir ( ) { dirs = append ( dirs , path ) } return nil } ) if err ! = nil { errs = append ( errs , err ) } return dirs , errs } 
func shouldignore ( p string ) bool { p = strings . trimprefix ( filepath . toslash ( p ) , " " ) base : = path . base ( p ) return strings . hasprefix ( p , " " ) | | base == " " | | base == " " | | base == " " } 
func recordwrite ( path string ) { dirsetmutex . lock ( ) defer dirsetmutex . unlock ( ) dirset [ path ] = true } 
func getandclearwrittendirs ( ) [ ] string { dirsetmutex . lock ( ) defer dirsetmutex . unlock ( ) dirs : = make ( [ ] string , 0 , len ( dirset ) ) for d : = range dirset { dirs = append ( dirs , d ) } dirset = make ( map [ string ] bool ) return dirs } 
func start ( command * exec . cmd , outwriter io . writer , errwriter io . writer ) ( * session , error ) { exited : = make ( chan struct { } ) session : = & session { command : command , out : gbytes . newbuffer ( ) , err : gbytes . newbuffer ( ) , exited : exited , lock : & sync . mutex { } , exitcode : - 1 , } var commandout , commanderr io . writer commandout , commanderr = session . out , session . err if outwriter ! = nil { commandout = io . multiwriter ( commandout , outwriter ) } if errwriter ! = nil { commanderr = io . multiwriter ( commanderr , errwriter ) } command . stdout = commandout command . stderr = commanderr err : = command . start ( ) if err == nil { go session . monitorforexit ( exited ) trackedsessionsmutex . lock ( ) defer trackedsessionsmutex . unlock ( ) trackedsessions = append ( trackedsessions , session ) } return session , err } 
func ( s * session ) wait ( timeout ... interface { } ) * session { eventuallywithoffset ( 1 , s , timeout ... ) . should ( exit ( ) ) return s } 
func ( s * session ) signal ( signal os . signal ) * session { if s . processisalive ( ) { s . command . process . signal ( signal ) } return s } 
func killandwait ( timeout ... interface { } ) { trackedsessionsmutex . lock ( ) defer trackedsessionsmutex . unlock ( ) for , session : = range trackedsessions { session . kill ( ) . wait ( timeout ... ) } trackedsessions = [ ] * session { } } 
func terminateandwait ( timeout ... interface { } ) { trackedsessionsmutex . lock ( ) defer trackedsessionsmutex . unlock ( ) for , session : = range trackedsessions { session . terminate ( ) . wait ( timeout ... ) } } 
func kill ( ) { trackedsessionsmutex . lock ( ) defer trackedsessionsmutex . unlock ( ) for , session : = range trackedsessions { session . kill ( ) } } 
func terminate ( ) { trackedsessionsmutex . lock ( ) defer trackedsessionsmutex . unlock ( ) for , session : = range trackedsessions { session . terminate ( ) } } 
func signal ( signal os . signal ) { trackedsessionsmutex . lock ( ) defer trackedsessionsmutex . unlock ( ) for , session : = range trackedsessions { session . signal ( signal ) } } 
func interrupt ( ) { trackedsessionsmutex . lock ( ) defer trackedsessionsmutex . unlock ( ) for , session : = range trackedsessions { session . interrupt ( ) } } 
func combinehandlers ( handlers ... http . handlerfunc ) http . handlerfunc { return func ( w http . responsewriter , req * http . request ) { for , handler : = range handlers { handler ( w , req ) } } } 
func verifyrequest ( method string , path interface { } , rawquery ... string ) http . handlerfunc { return func ( w http . responsewriter , req * http . request ) { expect ( req . method ) . should ( equal ( method ) , " " ) switch p : = path . ( type ) { case types . gomegamatcher : expect ( req . url . path ) . should ( p , " " ) default : expect ( req . url . path ) . should ( equal ( path ) , " " ) } if len ( rawquery ) > 0 { values , err : = url . parsequery ( rawquery [ 0 ] ) expect ( err ) . shouldnot ( haveoccurred ( ) , " " ) expect ( req . url . query ( ) ) . should ( equal ( values ) , " " ) } } } 
func verifycontenttype ( contenttype string ) http . handlerfunc { return func ( w http . responsewriter , req * http . request ) { expect ( req . header . get ( " " ) ) . should ( equal ( contenttype ) ) } } 
func verifymimetype ( mimetype string ) http . handlerfunc { return func ( w http . responsewriter , req * http . request ) { expect ( strings . split ( req . header . get ( " " ) , " " ) [ 0 ] ) . should ( equal ( mimetype ) ) } } 
func verifybasicauth ( username string , password string ) http . handlerfunc { return func ( w http . responsewriter , req * http . request ) { auth : = req . header . get ( " " ) expect ( auth ) . shouldnot ( equal ( " " ) , " " ) decoded , err : = base64 . stdencoding . decodestring ( auth [ 6 : ] ) expect ( err ) . shouldnot ( haveoccurred ( ) ) expect ( string ( decoded ) ) . should ( equal ( fmt . sprintf ( " " , username , password ) ) , " " ) } } 
func verifybody ( expectedbody [ ] byte ) http . handlerfunc { return combinehandlers ( func ( w http . responsewriter , req * http . request ) { body , err : = ioutil . readall ( req . body ) req . body . close ( ) expect ( err ) . shouldnot ( haveoccurred ( ) ) expect ( body ) . should ( equal ( expectedbody ) , " " ) } , ) } 
func verifyjson ( expectedjson string ) http . handlerfunc { return combinehandlers ( verifymimetype ( " " ) , func ( w http . responsewriter , req * http . request ) { body , err : = ioutil . readall ( req . body ) req . body . close ( ) expect ( err ) . shouldnot ( haveoccurred ( ) ) expect ( body ) . should ( matchjson ( expectedjson ) , " " ) } , ) } 
func verifyjsonrepresenting ( object interface { } ) http . handlerfunc { data , err : = json . marshal ( object ) expect ( err ) . shouldnot ( haveoccurred ( ) ) return combinehandlers ( verifycontenttype ( " " ) , verifyjson ( string ( data ) ) , ) } 
func verifyform ( values url . values ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { err : = r . parseform ( ) expect ( err ) . shouldnot ( haveoccurred ( ) ) for key , vals : = range values { expect ( r . form [ key ] ) . should ( equal ( vals ) , " " , key ) } } } 
func verifyformkv ( key string , values ... string ) http . handlerfunc { return verifyform ( url . values { key : values } ) } 
func verifyprotorepresenting ( expected proto . message ) http . handlerfunc { return combinehandlers ( verifycontenttype ( " " ) , func ( w http . responsewriter , req * http . request ) { body , err : = ioutil . readall ( req . body ) expect ( err ) . shouldnot ( haveoccurred ( ) ) req . body . close ( ) expectedtype : = reflect . typeof ( expected ) actualvalueptr : = reflect . new ( expectedtype . elem ( ) ) actual , ok : = actualvalueptr . interface ( ) . ( proto . message ) expect ( ok ) . should ( betrue ( ) , " " ) err = proto . unmarshal ( body , actual ) expect ( err ) . shouldnot ( haveoccurred ( ) , " " ) expect ( actual ) . should ( equal ( expected ) , " " ) } , ) } 
func registerfailhandlerwitht ( t types . twithhelper , handler types . gomegafailhandler ) { if handler == nil { globalfailwrapper = nil return } globalfailwrapper = & types . gomegafailwrapper { fail : handler , twithhelper : t , } } 
func interceptgomegafailures ( f func ( ) ) [ ] string { originalhandler : = globalfailwrapper . fail failures : = [ ] string { } registerfailhandler ( func ( message string , callerskip ... int ) { failures = append ( failures , message ) } ) f ( ) registerfailhandler ( originalhandler ) return failures } 
func expectwithoffset ( offset int , actual interface { } , extra ... interface { } ) assertion { if globalfailwrapper == nil { panic ( nilfailhandlerpanic ) } return assertion . new ( actual , globalfailwrapper , offset , extra ... ) } 
func eventuallywithoffset ( offset int , actual interface { } , intervals ... interface { } ) asyncassertion { if globalfailwrapper == nil { panic ( nilfailhandlerpanic ) } timeoutinterval : = defaulteventuallytimeout pollinginterval : = defaulteventuallypollinginterval if len ( intervals ) > 0 { timeoutinterval = toduration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollinginterval = toduration ( intervals [ 1 ] ) } return asyncassertion . new ( asyncassertion . asyncassertiontypeeventually , actual , globalfailwrapper , timeoutinterval , pollinginterval , offset ) } 
func consistentlywithoffset ( offset int , actual interface { } , intervals ... interface { } ) asyncassertion { if globalfailwrapper == nil { panic ( nilfailhandlerpanic ) } timeoutinterval : = defaultconsistentlyduration pollinginterval : = defaultconsistentlypollinginterval if len ( intervals ) > 0 { timeoutinterval = toduration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollinginterval = toduration ( intervals [ 1 ] ) } return asyncassertion . new ( asyncassertion . asyncassertiontypeconsistently , actual , globalfailwrapper , timeoutinterval , pollinginterval , offset ) } 
func ( g * witht ) expect ( actual interface { } , extra ... interface { } ) assertion { return assertion . new ( actual , testingtsupport . buildtestingtgomegafailwrapper ( g . t ) , 0 , extra ... ) } 
func ( g * witht ) eventually ( actual interface { } , intervals ... interface { } ) asyncassertion { timeoutinterval : = defaulteventuallytimeout pollinginterval : = defaulteventuallypollinginterval if len ( intervals ) > 0 { timeoutinterval = toduration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollinginterval = toduration ( intervals [ 1 ] ) } return asyncassertion . new ( asyncassertion . asyncassertiontypeeventually , actual , testingtsupport . buildtestingtgomegafailwrapper ( g . t ) , timeoutinterval , pollinginterval , 0 ) } 
func ( g * witht ) consistently ( actual interface { } , intervals ... interface { } ) asyncassertion { timeoutinterval : = defaultconsistentlyduration pollinginterval : = defaultconsistentlypollinginterval if len ( intervals ) > 0 { timeoutinterval = toduration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollinginterval = toduration ( intervals [ 1 ] ) } return asyncassertion . new ( asyncassertion . asyncassertiontypeconsistently , actual , testingtsupport . buildtestingtgomegafailwrapper ( g . t ) , timeoutinterval , pollinginterval , 0 ) } 
func message ( actual interface { } , message string , expected ... interface { } ) string { if len ( expected ) == 0 { return fmt . sprintf ( " \n \n " , object ( actual , 1 ) , message ) } return fmt . sprintf ( " \n \n \n " , object ( actual , 1 ) , message , object ( expected [ 0 ] , 1 ) ) } 
func messagewithdiff ( actual , message , expected string ) string { if truncateddiff && len ( actual ) >= truncatethreshold && len ( expected ) >= truncatethreshold { diffpoint : = findfirstmismatch ( actual , expected ) formattedactual : = truncateandformat ( actual , diffpoint ) formattedexpected : = truncateandformat ( expected , diffpoint ) spacesbeforeformattedmismatch : = findfirstmismatch ( formattedactual , formattedexpected ) tablength : = 4 spacefrommessagetoactual : = tablength + len ( " " ) - len ( message ) padding : = strings . repeat ( " " , spacefrommessagetoactual + spacesbeforeformattedmismatch ) + " " return message ( formattedactual , message + padding , formattedexpected ) } return message ( actual , message , expected ) } 
func object ( object interface { } , indentation uint ) string { indent : = strings . repeat ( indent , int ( indentation ) ) value : = reflect . valueof ( object ) return fmt . sprintf ( " " , indent , formattype ( object ) , formatvalue ( value , indentation ) ) } 
func indentstring ( s string , indentation uint ) string { components : = strings . split ( s , " \n " ) result : = " " indent : = strings . repeat ( indent , int ( indentation ) ) for i , component : = range components { result += indent + component if i < len ( components ) - 1 { result += " \n " } } return result } 
func isprintablestring ( str string ) bool { for , runevalue : = range str { if ! strconv . isprint ( runevalue ) { return false } } return true } 
func exit ( optionalexitcode ... int ) * exitmatcher { exitcode : = - 1 if len ( optionalexitcode ) > 0 { exitcode = optionalexitcode [ 0 ] } return & exitmatcher { exitcode : exitcode , } } 
func matchfields ( options options , fields fields ) types . gomegamatcher { return & fieldsmatcher { fields : fields , ignoreextras : options & ignoreextras ! = 0 , ignoremissing : options & ignoremissing ! = 0 , } } 
func say ( expected string , args ... interface { } ) * saymatcher { if len ( args ) > 0 { expected = fmt . sprintf ( expected , args ... ) } return & saymatcher { re : regexp . mustcompile ( expected ) , } } 
func receive ( args ... interface { } ) types . gomegamatcher { var arg interface { } if len ( args ) > 0 { arg = args [ 0 ] } return & matchers . receivematcher { arg : arg , } } 
func matchregexp ( regexp string , args ... interface { } ) types . gomegamatcher { return & matchers . matchregexpmatcher { regexp : regexp , args : args , } } 
func containsubstring ( substr string , args ... interface { } ) types . gomegamatcher { return & matchers . containsubstringmatcher { substr : substr , args : args , } } 
func haveprefix ( prefix string , args ... interface { } ) types . gomegamatcher { return & matchers . haveprefixmatcher { prefix : prefix , args : args , } } 
func havesuffix ( suffix string , args ... interface { } ) types . gomegamatcher { return & matchers . havesuffixmatcher { suffix : suffix , args : args , } } 
func havekeywithvalue ( key interface { } , value interface { } ) types . gomegamatcher { return & matchers . havekeywithvaluematcher { key : key , value : value , } } 
func benumerically ( comparator string , compareto ... interface { } ) types . gomegamatcher { return & matchers . benumericallymatcher { comparator : comparator , compareto : compareto , } } 
func betemporally ( comparator string , compareto time . time , threshold ... time . duration ) types . gomegamatcher { return & matchers . betemporallymatcher { comparator : comparator , compareto : compareto , threshold : threshold , } } 
func and ( ms ... types . gomegamatcher ) types . gomegamatcher { return & matchers . andmatcher { matchers : ms } } 
func or ( ms ... types . gomegamatcher ) types . gomegamatcher { return & matchers . ormatcher { matchers : ms } } 
func not ( matcher types . gomegamatcher ) types . gomegamatcher { return & matchers . notmatcher { matcher : matcher } } 
func withtransform ( transform interface { } , matcher types . gomegamatcher ) types . gomegamatcher { return matchers . newwithtransformmatcher ( transform , matcher ) } 
func build ( packagepath string , args ... string ) ( compiledpath string , err error ) { return dobuild ( build . default . gopath , packagepath , nil , args ... ) } 
func buildwithenvironment ( packagepath string , env [ ] string , args ... string ) ( compiledpath string , err error ) { return dobuild ( build . default . gopath , packagepath , env , args ... ) } 
func buildin ( gopath string , packagepath string , args ... string ) ( compiledpath string , err error ) { return dobuild ( gopath , packagepath , nil , args ... ) } 
func cleanupbuildartifacts ( ) { mu . lock ( ) defer mu . unlock ( ) if tmpdir ! = " " { os . removeall ( tmpdir ) tmpdir = " " } } 
func timeoutcloser ( c io . closer , timeout time . duration ) io . closer { return timeoutreaderwritercloser { c : c , d : timeout } } 
func timeoutreader ( r io . reader , timeout time . duration ) io . reader { return timeoutreaderwritercloser { r : r , d : timeout } } 
func timeoutwriter ( w io . writer , timeout time . duration ) io . writer { return timeoutreaderwritercloser { w : w , d : timeout } } 
func bufferwithbytes ( bytes [ ] byte ) * buffer { return & buffer { lock : & sync . mutex { } , contents : bytes , } } 
func bufferreader ( reader io . reader ) * buffer { b : = & buffer { lock : & sync . mutex { } , } go func ( ) { io . copy ( b , reader ) b . close ( ) } ( ) return b } 
func ( b * buffer ) write ( p [ ] byte ) ( n int , err error ) { b . lock . lock ( ) defer b . lock . unlock ( ) if b . closed { return 0 , errors . new ( " " ) } b . contents = append ( b . contents , p ... ) return len ( p ) , nil } 
func ( b * buffer ) read ( d [ ] byte ) ( int , error ) { b . lock . lock ( ) defer b . lock . unlock ( ) if b . closed { return 0 , errors . new ( " " ) } if uint64 ( len ( b . contents ) ) <= b . readcursor { return 0 , io . eof } n : = copy ( d , b . contents [ b . readcursor : ] ) b . readcursor += uint64 ( n ) return n , nil } 
func ( b * buffer ) close ( ) error { b . lock . lock ( ) defer b . lock . unlock ( ) b . closed = true return nil } 
func ( b * buffer ) closed ( ) bool { b . lock . lock ( ) defer b . lock . unlock ( ) return b . closed } 
func ( b * buffer ) contents ( ) [ ] byte { b . lock . lock ( ) defer b . lock . unlock ( ) contents : = make ( [ ] byte , len ( b . contents ) ) copy ( contents , b . contents ) return contents } 
func ( b * buffer ) canceldetects ( ) { b . lock . lock ( ) defer b . lock . unlock ( ) close ( b . detectcloser ) b . detectcloser = nil } 
func nest ( path string , err error ) error { if ag , ok : = err . ( aggregateerror ) ; ok { var errs aggregateerror for , e : = range ag { errs = append ( errs , nest ( path , e ) ) } return errs } if ne , ok : = err . ( * nestederror ) ; ok { return & nestederror { path : path + ne . path , err : ne . err , } } return & nestederror { path : path , err : err , } } 
func ( err aggregateerror ) error ( ) string { if len ( err ) == 0 { return " " } if len ( err ) == 1 { return err [ 0 ] . error ( ) } result : = fmt . sprintf ( " " , err [ 0 ] . error ( ) ) for i : = 1 ; i < len ( err ) ; i ++ { result += fmt . sprintf ( " " , err [ i ] . error ( ) ) } result += " " return result } 
func matchallelements ( identifier identifier , elements elements ) types . gomegamatcher { return & elementsmatcher { identifier : identifier , elements : elements , } } 
func matchelements ( identifier identifier , options options , elements elements ) types . gomegamatcher { return & elementsmatcher { identifier : identifier , elements : elements , ignoreextras : options & ignoreextras ! = 0 , ignoremissing : options & ignoremissing ! = 0 , allowduplicates : options & allowduplicates ! = 0 , } } 
func setmockservice ( m * mockservice ) { m . cache = & cache . mockappcacheservice { } m . plan = & app . mockplanservice { } m . platform = & app . mockplatformservice { } m . platformimage = & image . mockplatformimageservice { } m . team = & auth . mockteamservice { } m . userquota = & quota . mockquotaservice { } m . appquota = & quota . mockquotaservice { } m . cluster = & provision . mockclusterservice { } m . servicebroker = & service . mockservicebrokerservice { } m . servicebrokercatalogcache = & service . mockservicebrokercatalogcacheservice { } servicemanager . appcache = m . cache servicemanager . plan = m . plan servicemanager . platform = m . platform servicemanager . platformimage = m . platformimage servicemanager . team = m . team servicemanager . userquota = m . userquota servicemanager . appquota = m . appquota servicemanager . cluster = m . cluster servicemanager . servicebroker = m . servicebroker servicemanager . servicebrokercatalogcache = m . servicebrokercatalogcache } 
func open ( addr , dbname string ) ( storage * storage , err error ) { sessionlock . rlock ( ) if sessions [ addr ] == nil { sessionlock . runlock ( ) sessionlock . lock ( ) if sessions [ addr ] == nil { sessions [ addr ] , err = open ( addr ) } sessionlock . unlock ( ) if err ! = nil { return } } else { sessionlock . runlock ( ) } cloned : = sessions [ addr ] . clone ( ) runtime . setfinalizer ( cloned , sessionfinalizer ) storage = & storage { session : cloned , dbname : dbname , } return } 
func findmachinebyidoraddress ( id string , address string ) ( machine , error ) { coll , err : = collection ( ) if err ! = nil { return machine { } , err } defer coll . close ( ) var result machine query : = bson . m { } if id ! = " " { query [ " " ] = id } else { query [ " " ] = address } err = coll . find ( query ) . one ( & result ) if err == mgo . errnotfound { err = errmachinenotfound } return result , err } 
func ( w * flushingwriter ) write ( data [ ] byte ) ( written int , err error ) { w . writemutex . lock ( ) defer w . writemutex . unlock ( ) w . wrote = true written , err = w . responsewriter . write ( data ) if err ! = nil { return } if f , ok : = w . responsewriter . ( http . flusher ) ; ok { defer func ( ) { if r : = recover ( ) ; r ! = nil { msg : = fmt . sprintf ( " " , r ) log . debugf ( msg ) err = errors . errorf ( msg ) } } ( ) f . flush ( ) } return } 
func ( w * flushingwriter ) hijack ( ) ( net . conn , * bufio . readwriter , error ) { if hijacker , ok : = w . responsewriter . ( http . hijacker ) ; ok { return hijacker . hijack ( ) } return nil , nil , errors . new ( " " ) } 
func listdeploys ( filter * filter , skip , limit int ) ( [ ] deploydata , error ) { appslist , err : = list ( filter ) if err ! = nil { return nil , err } apps : = make ( [ ] string , len ( appslist ) ) for i , a : = range appslist { apps [ i ] = a . getname ( ) } evts , err : = event . list ( & event . filter { target : event . target { type : event . targettypeapp } , raw : bson . m { " " : bson . m { " " : apps } } , kindnames : [ ] string { permission . permappdeploy . fullname ( ) } , kindtype : event . kindtypepermission , limit : limit , skip : skip , } ) if err ! = nil { return nil , err } validimages , err : = findvalidimages ( appslist ... ) if err ! = nil { return nil , err } list : = make ( [ ] deploydata , len ( evts ) ) for i : = range evts { list [ i ] = * eventtodeploydata ( & evts [ i ] , validimages , false ) } return list , nil } 
func eventlist ( w http . responsewriter , r * http . request , t auth . token ) error { var filter * event . filter err : = parseinput ( r , & filter ) if err ! = nil { return err } filter . loadkindnames ( r . form ) filter . pruneuservalues ( ) filter . permissions , err = t . permissions ( ) if err ! = nil { return err } events , err : = event . list ( filter ) if err ! = nil { return err } if len ( events ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( events ) } 
func kindlist ( w http . responsewriter , r * http . request , t auth . token ) error { kinds , err : = event . getkinds ( ) if err ! = nil { return err } if len ( kinds ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( kinds ) } 
func eventinfo ( w http . responsewriter , r * http . request , t auth . token ) error { uuid : = r . url . query ( ) . get ( " " ) if ! bson . isobjectidhex ( uuid ) { msg : = fmt . sprintf ( " " , uuid ) return & errors . http { code : http . statusbadrequest , message : msg } } objid : = bson . objectidhex ( uuid ) e , err : = event . getbyid ( objid ) if err ! = nil { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } scheme , err : = permission . safeget ( e . allowed . scheme ) if err ! = nil { return err } allowed : = permission . check ( t , scheme , e . allowed . contexts ... ) if ! allowed { return permission . errunauthorized } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( e ) } 
func eventcancel ( w http . responsewriter , r * http . request , t auth . token ) error { uuid : = r . url . query ( ) . get ( " " ) if ! bson . isobjectidhex ( uuid ) { msg : = fmt . sprintf ( " " , uuid ) return & errors . http { code : http . statusbadrequest , message : msg } } objid : = bson . objectidhex ( uuid ) e , err : = event . getbyid ( objid ) if err ! = nil { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } reason : = inputvalue ( r , " " ) if reason == " " { return & errors . http { code : http . statusbadrequest , message : " " } } scheme , err : = permission . safeget ( e . allowedcancel . scheme ) if err ! = nil { return err } allowed : = permission . check ( t , scheme , e . allowedcancel . contexts ... ) if ! allowed { return permission . errunauthorized } err = e . trycancel ( reason , t . getusername ( ) ) if err ! = nil { if err == event . errnotcancelable { return & errors . http { code : http . statusbadrequest , message : err . error ( ) } } return err } w . writeheader ( http . statusnocontent ) return nil } 
func eventblocklist ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permeventblockread ) { return permission . errunauthorized } var active * bool if activestr : = inputvalue ( r , " " ) ; activestr ! = " " { b , : = strconv . parsebool ( activestr ) active = & b } blocks , err : = event . listblocks ( active ) if err ! = nil { return err } if len ( blocks ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( blocks ) } 
func eventblockadd ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permeventblockadd ) { return permission . errunauthorized } var block event . block err = parseinput ( r , & block ) if err ! = nil { return err } if block . reason == " " { return & errors . http { code : http . statusbadrequest , message : " " } } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeeventblock } , kind : permission . permeventblockadd , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permeventblockreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . target . value = block . id . hex ( ) evt . done ( err ) } ( ) return event . addblock ( & block ) } 
func eventblockremove ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permeventblockremove ) { return permission . errunauthorized } uuid : = r . url . query ( ) . get ( " " ) if ! bson . isobjectidhex ( uuid ) { msg : = fmt . sprintf ( " " , uuid ) return & errors . http { code : http . statusbadrequest , message : msg } } objid : = bson . objectidhex ( uuid ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeeventblock , value : objid . hex ( ) } , kind : permission . permeventblockremove , owner : t , customdata : [ ] map [ string ] interface { } { { " " : " " , " " : objid . hex ( ) } , } , allowed : event . allowed ( permission . permeventblockreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = event . removeblock ( objid ) if , ok : = err . ( * event . erractiveeventblocknotfound ) ; ok { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } 
func getuserquota ( w http . responsewriter , r * http . request , t auth . token ) error { allowed : = permission . check ( t , permission . permuserupdatequota ) if ! allowed { return permission . errunauthorized } email : = r . url . query ( ) . get ( " " ) user , err : = auth . getuserbyemail ( email ) if err == authtypes . errusernotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) , } } if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( user . quota ) } 
func changeappquota ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { appname : = r . url . query ( ) . get ( " " ) a , err : = getappfromcontext ( appname , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappadminquota , contextsforapp ( & a ) ... ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeapp , value : appname } , kind : permission . permappadminquota , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) limit , err : = strconv . atoi ( inputvalue ( r , " " ) ) if err ! = nil { return & errors . http { code : http . statusbadrequest , message : " " , } } err = a . setquotalimit ( limit ) if err == quota . errlimitlowerthanallocated { return & errors . http { code : http . statusforbidden , message : err . error ( ) , } } return err } 
func ( r * delayedrouter ) addall ( version , path string , h http . handler ) * mux . route { return r . addroute ( version , path , h , " " , " " , " " , " " ) } 
func samlrequesttimeout ( schemedata map [ string ] string ) int { p : = schemedata [ " " ] timeout , : = strconv . atoi ( p ) return timeout } 
func registerhandler ( path string , method string , h http . handler ) { registerhandlerversion ( " " , path , method , h ) } 
func registerhandlerversion ( version , path , method string , h http . handler ) { var th tsuruhandler th . version = version th . path = path th . method = method th . h = h tsuruhandlerlist = append ( tsuruhandlerlist , th ) } 
func validatetlscertificate ( c * tls . certificate , roots * x509 . certpool ) error { confighost , err : = config . getstring ( " " ) if err ! = nil { return err } urlhost , err : = url . parse ( confighost ) if err ! = nil { return err } hostname : = urlhost . hostname ( ) if c == nil | | len ( c . certificate ) == 0 { return errors . new ( " " ) } var intermediatecertpool * x509 . certpool if len ( c . certificate ) > 1 { intermediatecertpool = x509 . newcertpool ( ) for i : = 1 ; i < len ( c . certificate ) ; i ++ { var intermerdiatecert * x509 . certificate if intermerdiatecert , err = x509 . parsecertificate ( c . certificate [ i ] ) ; err ! = nil { return err } intermediatecertpool . addcert ( intermerdiatecert ) } } leafcert , err : = x509 . parsecertificate ( c . certificate [ 0 ] ) if err ! = nil { return err } , err = leafcert . verify ( x509 . verifyoptions { dnsname : hostname , roots : roots , intermediates : intermediatecertpool , } ) return err } 
func check ( names ... string ) [ ] result { results : = make ( [ ] result , 0 , len ( checkers ) ) nameset : = set . fromslice ( names ) isall : = nameset . includes ( " " ) for , checker : = range checkers { if ! isall && ! nameset . includes ( checker . name ) { continue } starttime : = time . now ( ) if err : = checker . check ( ) ; err ! = nil && err ! = errdisabledcomponent { results = append ( results , result { name : checker . name , status : " " + err . error ( ) , duration : time . since ( starttime ) , } ) } else if err == nil { results = append ( results , result { name : checker . name , status : healthcheckok , duration : time . since ( starttime ) , } ) } } return results } 
func indexhandler ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permdebug ) { return permission . errunauthorized } pprof . index ( w , r ) return nil } 
func cmdlinehandler ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permdebug ) { return permission . errunauthorized } pprof . cmdline ( w , r ) return nil } 
func profilehandler ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permdebug ) { return permission . errunauthorized } pprof . profile ( w , r ) return nil } 
func symbolhandler ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permdebug ) { return permission . errunauthorized } pprof . symbol ( w , r ) return nil } 
func tracehandler ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permdebug ) { return permission . errunauthorized } pprof . trace ( w , r ) return nil } 
func discoverrepositorypath ( dir string ) ( string , error ) { , err : = os . stat ( dir ) if os . isnotexist ( err ) { return " " , errrepositorynotfound } dir = filepath . join ( dir , " " ) for dir ! = " " { fi , err : = os . stat ( dir ) if err == nil && fi . isdir ( ) { return dir , nil } dir = filepath . join ( dir , " " , " " , " " ) } return " " , errrepositorynotfound } 
func openrepository ( p string ) ( * repository , error ) { if ! strings . hassuffix ( p , " " ) && ! strings . hassuffix ( p , " " ) { p = filepath . join ( p , " " ) } p = strings . trimright ( p , " " ) fi , err : = os . stat ( filepath . join ( p , " " ) ) if err == nil && ! fi . isdir ( ) { return & repository { path : p } , nil } return nil , errrepositorynotfound } 
func ( r * repository ) remoteurl ( name string ) ( string , error ) { config , err : = os . open ( filepath . join ( r . path , " " ) ) if err ! = nil { return " " , err } defer config . close ( ) line : = fmt . sprintf ( " " , name ) scanner : = bufio . newscanner ( config ) scanner . split ( bufio . scanlines ) for scanner . scan ( ) { if scanner . text ( ) == line { scanner . scan ( ) return strings . split ( scanner . text ( ) , " " ) [ 1 ] , nil } } return " " , errremotenotfound { name } } 
func tokenlist ( w http . responsewriter , r * http . request , t auth . token ) error { tokens , err : = servicemanager . teamtoken . findbyusertoken ( t ) if err ! = nil { return err } if len ( tokens ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( tokens ) } 
func tokeninfo ( w http . responsewriter , r * http . request , t auth . token ) error { tokenid : = r . url . query ( ) . get ( " " ) if tokenid == " " { w . writeheader ( http . statusbadrequest ) return nil } teamtoken , err : = servicemanager . teamtoken . info ( tokenid , t ) if err == authtypes . errteamtokennotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) , } } if err ! = nil { return err } allowed : = permission . check ( t , permission . permteamtokenread , permission . context ( permtypes . ctxteam , teamtoken . team ) , ) if ! allowed { return permission . errunauthorized } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( teamtoken ) } 
func tokencreate ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { var args authtypes . teamtokencreateargs err = parseinput ( r , & args ) if err ! = nil { return err } if args . team == " " { args . team , err = autoteamowner ( t , permission . permteamtokencreate ) if err ! = nil { return err } } allowed : = permission . check ( t , permission . permteamtokencreate , permission . context ( permtypes . ctxteam , args . team ) , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : teamtarget ( args . team ) , kind : permission . permteamtokencreate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permteamreadevents , permission . context ( permtypes . ctxteam , args . team ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) token , err : = servicemanager . teamtoken . create ( args , t ) if err ! = nil { return err } if err ! = nil { if err == authtypes . errteamtokenalreadyexists { return & errors . http { code : http . statusconflict , message : err . error ( ) , } } return err } w . writeheader ( http . statuscreated ) return json . newencoder ( w ) . encode ( token ) } 
func tokendelete ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { tokenid : = r . url . query ( ) . get ( " " ) teamtoken , err : = servicemanager . teamtoken . findbytokenid ( tokenid ) if err ! = nil { if err == authtypes . errteamtokennotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } teamname : = teamtoken . team allowed : = permission . check ( t , permission . permteamtokendelete , permission . context ( permtypes . ctxteam , teamname ) , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : teamtarget ( teamname ) , kind : permission . permteamtokendelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permteamreadevents , permission . context ( permtypes . ctxteam , teamname ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = servicemanager . teamtoken . delete ( tokenid ) if err == authtypes . errteamtokennotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } 
func addrole ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permrolecreate ) { return permission . errunauthorized } rolename : = inputvalue ( r , " " ) if rolename == " " { return & errors . http { code : http . statusbadrequest , message : permtypes . errinvalidrolename . error ( ) , } } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettyperole , value : rolename } , kind : permission . permrolecreate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permrolereadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) , err = permission . newrole ( rolename , inputvalue ( r , " " ) , inputvalue ( r , " " ) ) if err == permtypes . errinvalidrolename { return & errors . http { code : http . statusbadrequest , message : err . error ( ) , } } if err == permtypes . errrolealreadyexists { return & errors . http { code : http . statusconflict , message : err . error ( ) , } } if err == nil { w . writeheader ( http . statuscreated ) } return err } 
func removerole ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permroledelete ) { return permission . errunauthorized } rolename : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettyperole , value : rolename } , kind : permission . permroledelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permrolereadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) userswithrole , err : = auth . listuserswithrole ( rolename ) if err ! = nil { return err } if len ( userswithrole ) ! = 0 { return & errors . http { code : http . statuspreconditionfailed , message : permtypes . errremoverolewithusers . error ( ) } } err = permission . destroyrole ( rolename ) if err == permtypes . errrolenotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } 
func listroles ( w http . responsewriter , r * http . request , t auth . token ) error { if ! ( permission . check ( t , permission . permroleupdate ) | | permission . check ( t , permission . permroleupdateassign ) | | permission . check ( t , permission . permroleupdatedissociate ) | | permission . check ( t , permission . permrolecreate ) | | permission . check ( t , permission . permroledelete ) ) { return permission . errunauthorized } roles , err : = permission . listroles ( ) if err ! = nil { return err } b , err : = json . marshal ( roles ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) , err = w . write ( b ) return err } 
func roleinfo ( w http . responsewriter , r * http . request , t auth . token ) error { if ! ( permission . check ( t , permission . permroleupdate ) | | permission . check ( t , permission . permroleupdateassign ) | | permission . check ( t , permission . permroleupdatedissociate ) | | permission . check ( t , permission . permrolecreate ) | | permission . check ( t , permission . permroledelete ) ) { return permission . errunauthorized } rolename : = r . url . query ( ) . get ( " " ) role , err : = permission . findrole ( rolename ) if err == permtypes . errrolenotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) , } } if err ! = nil { return err } b , err : = json . marshal ( role ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) , err = w . write ( b ) return err } 
func removepermissions ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permroleupdatepermissionremove ) { return permission . errunauthorized } rolename : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettyperole , value : rolename } , kind : permission . permroleupdatepermissionremove , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permrolereadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) permname : = r . url . query ( ) . get ( " " ) role , err : = permission . findrole ( rolename ) if err ! = nil { if err == permtypes . errrolenotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } users , err : = auth . listuserswithrole ( rolename ) if err ! = nil { return err } err = runwithpermsync ( users , func ( ) error { return role . removepermissions ( permname ) } ) return err } 
func assignrole ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permroleupdateassign ) { return permission . errunauthorized } rolename : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettyperole , value : rolename } , kind : permission . permroleupdateassign , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permrolereadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) email : = inputvalue ( r , " " ) contextvalue : = inputvalue ( r , " " ) user , err : = auth . getuserbyemail ( email ) if err ! = nil { return err } err = canuserole ( t , rolename , contextvalue ) if err ! = nil { return err } err = runwithpermsync ( [ ] auth . user { * user } , func ( ) error { return user . addrole ( rolename , contextvalue ) } ) return err } 
func listpermissions ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permroleupdate ) { return permission . errunauthorized } lst : = permission . permissionregistry . permissions ( ) sort . sort ( lst ) permlist : = make ( [ ] permissionschemedata , len ( lst ) ) for i , perm : = range lst { contexts : = perm . allowedcontexts ( ) contextnames : = make ( [ ] string , len ( contexts ) ) for j , ctx : = range contexts { contextnames [ j ] = string ( ctx ) } permlist [ i ] = permissionschemedata { name : perm . fullname ( ) , contexts : contextnames , } } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( permlist ) } 
func listdefaultroles ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permroledefaultcreate ) && ! permission . check ( t , permission . permroledefaultdelete ) { return permission . errunauthorized } roles , err : = permission . listroleswithevents ( ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( roles ) } 
func assignroletotoken ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permroleupdateassign ) { return permission . errunauthorized } tokenid : = inputvalue ( r , " " ) contextvalue : = inputvalue ( r , " " ) rolename : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettyperole , value : rolename } , kind : permission . permroleupdateassign , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permrolereadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = canuserole ( t , rolename , contextvalue ) if err ! = nil { return err } err = servicemanager . teamtoken . addrole ( tokenid , rolename , contextvalue ) if err == authtypes . errteamtokennotfound { w . writeheader ( http . statusnotfound ) return nil } return err } 
func ( s * applister ) list ( selector labels . selector ) ( ret [ ] * v1 . app , err error ) { err = cache . listall ( s . indexer , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . app ) ) } ) return ret , err } 
func ( s * applister ) apps ( namespace string ) appnamespacelister { return appnamespacelister { indexer : s . indexer , namespace : namespace } } 
func ( s appnamespacelister ) list ( selector labels . selector ) ( ret [ ] * v1 . app , err error ) { err = cache . listallbynamespace ( s . indexer , s . namespace , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . app ) ) } ) return ret , err } 
func streamjsonresponse ( w io . writer , response * http . response ) error { if response == nil { return errors . new ( " " ) } defer response . body . close ( ) var err error output : = tsuruio . newstreamwriter ( w , nil ) for n : = int64 ( 1 ) ; n > 0 && err == nil ; n , err = io . copy ( output , response . body ) { } if err ! = nil { return err } unparsed : = output . remaining ( ) if len ( unparsed ) > 0 { return errors . errorf ( " " , string ( unparsed ) ) } return nil } 
func ( s * storage ) dropdatabase ( name string ) error { return s . session . db ( name ) . dropdatabase ( ) } 
func ( s * storage ) collection ( name string ) * collection { return & collection { collection : s . session . db ( s . dbname ) . c ( name ) } } 
func ( s * oauthscheme ) loadconfig ( ) ( oauth2 . config , error ) { if s . baseconfig . clientid ! = " " { return s . baseconfig , nil } if s . parser == nil { s . parser = s } var emptyconfig oauth2 . config clientid , err : = config . getstring ( " " ) if err ! = nil { return emptyconfig , err } clientsecret , err : = config . getstring ( " " ) if err ! = nil { return emptyconfig , err } scope , err : = config . getstring ( " " ) if err ! = nil { return emptyconfig , err } authurl , err : = config . getstring ( " " ) if err ! = nil { return emptyconfig , err } tokenurl , err : = config . getstring ( " " ) if err ! = nil { return emptyconfig , err } infourl , err : = config . getstring ( " " ) if err ! = nil { return emptyconfig , err } callbackport , err : = config . getint ( " " ) if err ! = nil { log . debugf ( " " , err ) } s . infourl = infourl s . callbackport = callbackport s . baseconfig = oauth2 . config { clientid : clientid , clientsecret : clientsecret , scopes : [ ] string { scope } , endpoint : oauth2 . endpoint { authurl : authurl , tokenurl : tokenurl , } , } return s . baseconfig , nil } 
func ( t * target ) setlogger ( l logger ) { t . mut . lock ( ) defer t . mut . unlock ( ) t . logger = l } 
func ( t * target ) error ( v error ) { t . mut . rlock ( ) defer t . mut . runlock ( ) if t . logger ! = nil { t . logger . errorf ( " " , v ) } } 
func ( t * target ) errorf ( format string , v ... interface { } ) { t . mut . rlock ( ) defer t . mut . runlock ( ) if t . logger ! = nil { t . logger . errorf ( format , v ... ) for , item : = range v { if , hasstack : = item . ( withstack ) ; hasstack { t . logger . errorf ( " " , item ) } } } } 
func ( t * target ) fatal ( v string ) { t . mut . rlock ( ) defer t . mut . runlock ( ) if t . logger ! = nil { t . logger . fatal ( v ) } } 
func ( t * target ) debugf ( format string , v ... interface { } ) { t . mut . rlock ( ) defer t . mut . runlock ( ) if t . logger ! = nil { t . logger . debugf ( format , v ... ) } } 
func ( t * target ) getstdlogger ( ) * log . logger { t . mut . rlock ( ) defer t . mut . runlock ( ) if t . logger ! = nil { return t . logger . getstdlogger ( ) } return nil } 
func ( c * clusterclient ) namespace ( ) string { if c . customdata ! = nil && c . customdata [ namespaceclusterkey ] ! = " " { return c . customdata [ namespaceclusterkey ] } return " " } 
func recreatecontainers ( p dockerprovisioner , w io . writer , nodes ... cluster . node ) error { return ensurecontainersstarted ( p , w , true , nil , nodes ... ) } 
func checkprovisioner ( ) error { if value , : = config . get ( " " ) ; value == defaultprovisionername | | value == " " { return checkdocker ( ) } return nil } 
func checkdocker ( ) error { if , err : = config . get ( " " ) ; err ! = nil { return errors . new ( " " ) } err : = checkdockerbasicconfig ( ) if err ! = nil { return err } err = checkscheduler ( ) if err ! = nil { return err } err = checkrouter ( ) if err ! = nil { return err } return checkcluster ( ) } 
func checkscheduler ( ) error { if servers , err : = config . get ( " " ) ; err == nil && servers ! = nil { return errors . errorf ( ' using docker : servers is deprecated , please remove it your config and use " tsuru docker - node - add " do add docker nodes . ' ) } issegregate , err : = config . getbool ( " " ) if err == nil { if issegregate { return config . newwarning ( ' setting " docker : segregate " is not necessary anymore , this is the default behavior from now on . ' ) } else { return errors . errorf ( ' you must remove " docker : segregate " from your config . ' ) } } return nil } 
func checkrouter ( ) error { defaultrouter , : = config . getstring ( " " ) if defaultrouter == " " { return errors . errorf ( ' you must configure a default router in " docker : router " . ' ) } ishipacheold : = false if defaultrouter == " " { hipacheold , : = config . get ( " " ) ishipacheold = hipacheold ! = nil } routerconf , : = config . get ( " " + defaultrouter ) if ishipacheold { return config . newwarning ( ) } if routerconf == nil { return errors . errorf ( ' you must configure your default router % q in " routers : %s " . ' , defaultrouter , defaultrouter ) } routertype , : = config . get ( " " + defaultrouter + " " ) if routertype == nil { return errors . errorf ( ' you must configure your default router type in " routers : %s : type " . ' , defaultrouter ) } return nil } 
func listplans ( w http . responsewriter , r * http . request , t auth . token ) error { plans , err : = servicemanager . plan . list ( ) if err ! = nil { return err } if len ( plans ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( plans ) } 
func removeplan ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . permplandelete ) if ! allowed { return permission . errunauthorized } planname : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeplan , value : planname } , kind : permission . permplandelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permplanreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = servicemanager . plan . remove ( planname ) if err == apptypes . errplannotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } 
func getbuildimage ( app provision . app ) ( string , error ) { if useplatformimage ( app ) { return getplatformimage ( app ) } appimagename , err : = appcurrentimagename ( app . getname ( ) ) if err ! = nil { return getplatformimage ( app ) } return appimagename , nil } 
func addpoolhandler ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . permpoolcreate ) if ! allowed { return permission . errunauthorized } var addopts pool . addpooloptions err = parseinput ( r , & addopts ) if err ! = nil { return err } if addopts . name == " " { return & terrors . http { code : http . statusbadrequest , message : pool . errpoolnameisrequired . error ( ) , } } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : addopts . name } , kind : permission . permpoolcreate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permpoolreadevents , permission . context ( permtypes . ctxpool , addopts . name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = pool . addpool ( addopts ) if err == pool . errdefaultpoolalreadyexists | | err == pool . errpoolalreadyexists { return & terrors . http { code : http . statusconflict , message : err . error ( ) , } } if err == pool . errpoolnameisrequired { return & terrors . http { code : http . statusbadrequest , message : err . error ( ) , } } if err == nil { w . writeheader ( http . statuscreated ) } return err } 
func removepoolhandler ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . permpooldelete ) if ! allowed { return permission . errunauthorized } poolname : = r . url . query ( ) . get ( " " ) filter : = & app . filter { } filter . pool = poolname apps , err : = app . list ( appfilterbycontext ( [ ] permtypes . permissioncontext { } , filter ) ) if err ! = nil { return err } if len ( apps ) > 0 { return & terrors . http { code : http . statusforbidden , message : " " } } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : poolname } , kind : permission . permpooldelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permpoolreadevents , permission . context ( permtypes . ctxpool , poolname ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = pool . removepool ( poolname ) if err == pool . errpoolnotfound { return & terrors . http { code : http . statusnotfound , message : err . error ( ) } } return err } 
func addteamtopoolhandler ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { poolname : = r . url . query ( ) . get ( " " ) allowed : = permission . check ( t , permission . permpoolupdateteamadd , permission . context ( permtypes . ctxpool , poolname ) ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : poolname } , kind : permission . permpoolupdateteamadd , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permpoolreadevents , permission . context ( permtypes . ctxpool , poolname ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) if teams , ok : = inputvalues ( r , " " ) ; ok { err : = pool . addteamstopool ( poolname , teams ) if err == pool . errpoolnotfound { return & terrors . http { code : http . statusnotfound , message : err . error ( ) } } return err } return & terrors . http { code : http . statusbadrequest , message : " " } } 
func poolupdatehandler ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . permpoolupdate ) if ! allowed { return permission . errunauthorized } poolname : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : poolname } , kind : permission . permpoolupdate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permpoolreadevents , permission . context ( permtypes . ctxpool , poolname ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) var updateopts pool . updatepooloptions err = parseinput ( r , & updateopts ) if err ! = nil { return err } err = pool . poolupdate ( poolname , updateopts ) if err == pool . errpoolnotfound { return & terrors . http { code : http . statusnotfound , message : err . error ( ) } } if err == pool . errdefaultpoolalreadyexists { return & terrors . http { code : http . statusconflict , message : err . error ( ) , } } return err } 
func poolconstraintlist ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permpoolreadconstraints ) { return permission . errunauthorized } constraints , err : = pool . listpoolsconstraints ( nil ) if err ! = nil { return err } if len ( constraints ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( constraints ) } 
func poolconstraintset ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permpoolupdateconstraintsset ) { return permission . errunauthorized } var poolconstraint pool . poolconstraint err = parseinput ( r , & poolconstraint ) if err ! = nil { return err } if poolconstraint . poolexpr == " " { return & terrors . http { code : http . statusbadrequest , message : " " , } } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : poolconstraint . poolexpr } , kind : permission . permpoolupdateconstraintsset , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permpoolreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) append : = false if appendstr : = inputvalue ( r , " " ) ; appendstr ! = " " { append , = strconv . parsebool ( appendstr ) } if append { return pool . appendpoolconstraint ( & poolconstraint ) } return pool . setpoolconstraint ( & poolconstraint ) } 
func ( u * unit ) available ( ) bool { return u . status == statusstarted | | u . status == statusstarting | | u . status == statuserror } 
func get ( name string ) ( provisioner , error ) { pfunc , ok : = provisioners [ name ] if ! ok { return nil , errors . errorf ( " " , name ) } return pfunc ( ) } 
func registry ( ) ( [ ] provisioner , error ) { registry : = make ( [ ] provisioner , 0 , len ( provisioners ) ) for , pfunc : = range provisioners { p , err : = pfunc ( ) if err ! = nil { return nil , err } registry = append ( registry , p ) } return registry , nil } 
func ( e * error ) error ( ) string { var err string if e . err ! = nil { err = e . err . error ( ) + " " + e . reason } else { err = e . reason } return err } 
func createuser ( w http . responsewriter , r * http . request ) error { registrationenabled , : = config . getbool ( " " ) if ! registrationenabled { token : = r . header . get ( " " ) t , err : = app . authscheme . auth ( token ) if err ! = nil { return createdisablederr } if ! permission . check ( t , permission . permusercreate ) { return createdisablederr } } email : = inputvalue ( r , " " ) password : = inputvalue ( r , " " ) evt , err : = event . new ( & event . opts { target : usertarget ( email ) , kind : permission . permusercreate , rawowner : event . owner { type : event . ownertypeuser , name : email } , customdata : event . formtocustomdata ( inputfields ( r , " " ) ) , allowed : event . allowed ( permission . permuserreadevents , permission . context ( permtypes . ctxuser , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) u : = auth . user { email : email , password : password , } , err = app . authscheme . create ( & u ) if err ! = nil { return handleautherror ( err ) } w . writeheader ( http . statuscreated ) return nil } 
func login ( w http . responsewriter , r * http . request ) ( err error ) { params : = map [ string ] string { " " : r . url . query ( ) . get ( " " ) , } fields : = inputfields ( r ) for key , values : = range fields { params [ key ] = values [ 0 ] } token , err : = app . authscheme . login ( params ) if err ! = nil { return handleautherror ( err ) } return json . newencoder ( w ) . encode ( map [ string ] string { " " : token . getvalue ( ) } ) } 
func logout ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { return app . authscheme . logout ( t . getvalue ( ) ) } 
func changepassword ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { managed , ok : = app . authscheme . ( auth . managedscheme ) if ! ok { return & errors . http { code : http . statusbadrequest , message : nonmanagedschememsg } } evt , err : = event . new ( & event . opts { target : usertarget ( t . getusername ( ) ) , kind : permission . permuserupdatepassword , owner : t , allowed : event . allowed ( permission . permuserreadevents , permission . context ( permtypes . ctxuser , t . getusername ( ) ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) oldpassword : = inputvalue ( r , " " ) newpassword : = inputvalue ( r , " " ) confirmpassword : = inputvalue ( r , " " ) if oldpassword == " " | | newpassword == " " { return & errors . http { code : http . statusbadrequest , message : " " , } } if newpassword ! = confirmpassword { return & errors . http { code : http . statusbadrequest , message : " " , } } err = managed . changepassword ( t , oldpassword , newpassword ) if err ! = nil { return handleautherror ( err ) } return nil } 
func resetpassword ( w http . responsewriter , r * http . request ) ( err error ) { managed , ok : = app . authscheme . ( auth . managedscheme ) if ! ok { return & errors . http { code : http . statusbadrequest , message : nonmanagedschememsg } } email : = r . url . query ( ) . get ( " " ) token : = inputvalue ( r , " " ) evt , err : = event . new ( & event . opts { target : usertarget ( email ) , kind : permission . permuserupdatereset , rawowner : event . owner { type : event . ownertypeuser , name : email } , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permuserreadevents , permission . context ( permtypes . ctxuser , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) u , err : = auth . getuserbyemail ( email ) if err ! = nil { if err == authtypes . errusernotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } if token == " " { return managed . startpasswordreset ( u ) } return managed . resetpassword ( u , token ) } 
func createteam ( w http . responsewriter , r * http . request , t auth . token ) error { allowed : = permission . check ( t , permission . permteamcreate ) if ! allowed { return permission . errunauthorized } var team authtypes . team if err : = parseinput ( r , & team ) ; err ! = nil { return err } tags , : = inputvalues ( r , " " ) team . tags = append ( team . tags , tags ... ) evt , err : = event . new ( & event . opts { target : teamtarget ( team . name ) , kind : permission . permteamcreate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permteamreadevents , permission . context ( permtypes . ctxteam , team . name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) u , err : = t . user ( ) if err ! = nil { return err } err = servicemanager . team . create ( team . name , team . tags , u ) switch err { case authtypes . errinvalidteamname : return & errors . http { code : http . statusbadrequest , message : err . error ( ) } case authtypes . errteamalreadyexists : return & errors . http { code : http . statusconflict , message : err . error ( ) } } if err == nil { w . writeheader ( http . statuscreated ) } return err } 
func removeteam ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { name : = r . url . query ( ) . get ( " " ) allowed : = permission . check ( t , permission . permteamdelete , permission . context ( permtypes . ctxteam , name ) , ) if ! allowed { return & errors . http { code : http . statusnotfound , message : fmt . sprintf ( ' team " %s " not found . ' , name ) } } evt , err : = event . new ( & event . opts { target : teamtarget ( name ) , kind : permission . permteamdelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permteamreadevents , permission . context ( permtypes . ctxteam , name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = servicemanager . team . remove ( name ) if err ! = nil { if , ok : = err . ( * authtypes . errteamstillused ) ; ok { msg : = fmt . sprintf ( " \n " , err ) return & errors . http { code : http . statusforbidden , message : msg } } if err == authtypes . errteamnotfound { return & errors . http { code : http . statusnotfound , message : fmt . sprintf ( ' team " %s " not found . ' , name ) } } return err } return nil } 
func teamlist ( w http . responsewriter , r * http . request , t auth . token ) error { permsforteam : = permission . permissionregistry . permissionswithcontexttype ( permtypes . ctxteam ) teams , err : = servicemanager . team . list ( ) if err ! = nil { return err } teamsmap : = map [ string ] authtypes . team { } permsmap : = map [ string ] [ ] string { } perms , err : = t . permissions ( ) if err ! = nil { return err } for , team : = range teams { teamsmap [ team . name ] = team teamctx : = permission . context ( permtypes . ctxteam , team . name ) var parent * permission . permissionscheme for , p : = range permsforteam { if parent ! = nil && parent . isparent ( p ) { continue } if permission . checkfrompermlist ( perms , p , teamctx ) { parent = p permsmap [ team . name ] = append ( permsmap [ team . name ] , p . fullname ( ) ) } } } if len ( permsmap ) == 0 { w . writeheader ( http . statusnocontent ) return nil } var result [ ] map [ string ] interface { } for name , permissions : = range permsmap { result = append ( result , map [ string ] interface { } { " " : name , " " : teamsmap [ name ] . tags , " " : permissions , } ) } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( result ) } 
func removekeyfromuser ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { key : = repository . key { name : r . url . query ( ) . get ( " " ) , } if key . name == " " { return & errors . http { code : http . statusbadrequest , message : " " } } allowed : = permission . check ( t , permission . permuserupdatekeyremove , permission . context ( permtypes . ctxuser , t . getusername ( ) ) , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : usertarget ( t . getusername ( ) ) , kind : permission . permuserupdatekeyremove , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permuserreadevents , permission . context ( permtypes . ctxuser , t . getusername ( ) ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) u , err : = auth . convertnewuser ( t . user ( ) ) if err ! = nil { return err } err = u . removekey ( key ) if err == authtypes . errkeydisabled { return & errors . http { code : http . statusbadrequest , message : err . error ( ) } } if err == repository . errkeynotfound { return & errors . http { code : http . statusnotfound , message : " " } } return err } 
func listkeys ( w http . responsewriter , r * http . request , t auth . token ) error { u , err : = auth . convertnewuser ( t . user ( ) ) if err ! = nil { return err } keys , err : = u . listkeys ( ) if err == authtypes . errkeydisabled { return & errors . http { code : http . statusbadrequest , message : err . error ( ) } } if err ! = nil { return err } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( keys ) } 
func removeuser ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { email : = r . url . query ( ) . get ( " " ) if email == " " { email = t . getusername ( ) } allowed : = permission . check ( t , permission . permuserdelete , permission . context ( permtypes . ctxuser , email ) , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : usertarget ( email ) , kind : permission . permuserdelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permuserreadevents , permission . context ( permtypes . ctxuser , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) u , err : = auth . getuserbyemail ( email ) if err ! = nil { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } appnames , err : = deployableapps ( u , make ( map [ string ] * permission . role ) ) if err ! = nil { return err } manager : = repository . manager ( ) for , name : = range appnames { manager . revokeaccess ( name , u . email ) } if err : = manager . removeuser ( u . email ) ; err ! = nil { log . errorf ( " " , err ) } return app . authscheme . remove ( u ) } 
func authscheme ( w http . responsewriter , r * http . request ) error { info , err : = app . authscheme . info ( ) if err ! = nil { return err } data : = schemedata { name : app . authscheme . name ( ) , data : info } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( data ) } 
func regenerateapitoken ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { email : = r . url . query ( ) . get ( " " ) if email == " " { email = t . getusername ( ) } allowed : = permission . check ( t , permission . permuserupdatetoken , permission . context ( permtypes . ctxuser , email ) , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : usertarget ( email ) , kind : permission . permuserupdatetoken , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permuserreadevents , permission . context ( permtypes . ctxuser , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) u , err : = auth . getuserbyemail ( email ) if err ! = nil { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } apikey , err : = u . regenerateapikey ( ) if err ! = nil { return err } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( apikey ) } 
func showapitoken ( w http . responsewriter , r * http . request , t auth . token ) error { u , err : = auth . convertnewuser ( t . user ( ) ) if err ! = nil { return err } email : = r . url . query ( ) . get ( " " ) if email ! = " " { if ! permission . check ( t , permission . permuserupdatetoken ) { return permission . errunauthorized } u , err = auth . getuserbyemail ( email ) if err ! = nil { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } } apikey , err : = u . showapikey ( ) if err ! = nil { return err } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( apikey ) } 
func userinfo ( w http . responsewriter , r * http . request , t auth . token ) error { user , err : = auth . convertnewuser ( t . user ( ) ) if err ! = nil { return err } perms , err : = t . permissions ( ) if err ! = nil { return err } userdata , err : = createapiuser ( perms , user , nil , true ) if err ! = nil { return err } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( userdata ) } 
func platformremove ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { candeleteplatform : = permission . check ( t , permission . permplatformdelete ) if ! candeleteplatform { return permission . errunauthorized } name : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeplatform , value : name } , kind : permission . permplatformdelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permplatformreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = servicemanager . platform . remove ( name ) if err == apptypes . errplatformnotfound { return & terrors . http { code : http . statusnotfound , message : err . error ( ) } } return err } 
func platformlist ( w http . responsewriter , r * http . request , t auth . token ) error { canuseplat : = permission . check ( t , permission . permplatformupdate ) | | permission . check ( t , permission . permplatformcreate ) platforms , err : = servicemanager . platform . list ( ! canuseplat ) if err ! = nil { return err } if len ( platforms ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( platforms ) } 
func platforminfo ( w http . responsewriter , r * http . request , t auth . token ) error { name : = r . url . query ( ) . get ( " " ) canuseplat : = permission . check ( t , permission . permplatformupdate ) | | permission . check ( t , permission . permplatformcreate ) if ! canuseplat { return permission . errunauthorized } platform , err : = servicemanager . platform . findbyname ( name ) if err == apptypes . errplatformnotfound { return & terrors . http { code : http . statusnotfound , message : err . error ( ) } } if err ! = nil { return err } images , err : = servicemanager . platformimage . listimagesordefault ( name ) if err ! = nil { return err } msg : = map [ string ] interface { } { " " : platform , " " : images , } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( msg ) } 
func logsconfiggethandler ( w http . responsewriter , r * http . request , t auth . token ) error { pools , err : = permission . listcontextvalues ( t , permission . permpoolupdatelogs , true ) if err ! = nil { return err } configentries , err : = container . logloadall ( ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) if len ( pools ) == 0 { return json . newencoder ( w ) . encode ( configentries ) } newmap : = map [ string ] container . dockerlogconfig { } for , p : = range pools { if entry , ok : = configentries [ p ] ; ok { newmap [ p ] = entry } } return json . newencoder ( w ) . encode ( newmap ) } 
func validateversion ( supported , current string ) bool { if supported == " " { return true } vsupported , err : = goversion . newversion ( supported ) if err ! = nil { return false } vcurrent , err : = goversion . newversion ( current ) if err ! = nil { return false } return vcurrent . compare ( vsupported ) >= 0 } 
func readtarget ( ) ( string , error ) { if target : = os . getenv ( " " ) ; target ! = " " { targets , err : = gettargets ( ) if err == nil { if val , ok : = targets [ target ] ; ok { return val , nil } } return target , nil } targetpath : = joinwithuserdir ( " " , " " ) target , err : = readtarget ( targetpath ) if err == errundefinedtarget { copytargetfiles ( ) target , err = readtarget ( joinwithuserdir ( " " ) ) } return target , err } 
func writetarget ( t string ) error { targetpath : = joinwithuserdir ( " " , " " ) targetfile , err : = filesystem ( ) . openfile ( targetpath , syscall . o wronly | syscall . o creat | syscall . o trunc , 0600 ) if err ! = nil { return err } defer targetfile . close ( ) n , err : = targetfile . writestring ( t ) if n ! = len ( t ) | | err ! = nil { return errors . new ( " " ) } return nil } 
func writeontargetlist ( label , target string ) error { label = strings . trimspace ( label ) target = strings . trimspace ( target ) targetexist , err : = checkiftargetlabelexists ( label ) if err ! = nil { return err } if targetexist { return errors . new ( " " ) } targetspath : = joinwithuserdir ( " " , " " ) targetsfile , err : = filesystem ( ) . openfile ( targetspath , syscall . o rdwr | syscall . o creat | syscall . o append , 0600 ) if err ! = nil { return err } defer targetsfile . close ( ) content : = label + " \ t " + target + " \n " n , err : = targetsfile . writestring ( content ) if n ! = len ( content ) | | err ! = nil { return errors . new ( " " ) } return nil } 
func buildhealthcheck ( routername string ) func ( ) error { return func ( ) error { routerconfig , err : = config . get ( " " ) if err ! = nil { return hc . errdisabledcomponent } routers , : = routerconfig . ( map [ interface { } ] interface { } ) checkcount : = 0 for ifacename : = range routers { name : = ifacename . ( string ) if name ! = routername { namedrouter : = routers [ name ] . ( map [ interface { } ] interface { } ) if tp , : = namedrouter [ " " ] . ( string ) ; tp ! = routername { continue } } checkcount ++ err : = healthcheck ( name ) if err ! = nil { return err } } if checkcount == 0 { return hc . errdisabledcomponent } return nil } } 
func conn ( ) ( * storage , error ) { var ( strg storage err error ) url , dbname : = dbconfig ( " " ) strg . storage , err = storage . open ( url , dbname ) return & strg , err } 
func ( s * storage ) apps ( ) * storage . collection { nameindex : = mgo . index { key : [ ] string { " " } , unique : true } c : = s . collection ( " " ) c . ensureindex ( nameindex ) return c } 
func ( s * storage ) poolsconstraints ( ) * storage . collection { poolconstraintindex : = mgo . index { key : [ ] string { " " , " " } , unique : true } c : = s . collection ( " " ) c . ensureindex ( poolconstraintindex ) return c } 
func ( s * storage ) users ( ) * storage . collection { emailindex : = mgo . index { key : [ ] string { " " } , unique : true } c : = s . collection ( " " ) c . ensureindex ( emailindex ) return c } 
func ( s * storage ) samlrequests ( ) * storage . collection { id : = mgo . index { key : [ ] string { " " } } coll : = s . collection ( " " ) coll . ensureindex ( id ) return coll } 
func ( s * logstorage ) applogcollection ( appname string ) * storage . collection { if appname == " " { return nil } return s . collection ( " " + appname ) } 
func ( s * logstorage ) createapplogcollection ( appname string ) ( * storage . collection , error ) { c : = s . applogcollection ( appname ) err : = c . create ( & logcappedinfo ) return c , err } 
func ( s * logstorage ) logscollections ( ) ( [ ] * storage . collection , error ) { var names [ ] struct { name string } conn , err : = conn ( ) if err ! = nil { return nil , err } defer conn . close ( ) err = conn . apps ( ) . find ( nil ) . all ( & names ) if err ! = nil { return nil , err } var colls [ ] * storage . collection for , name : = range names { colls = append ( colls , s . collection ( " " + name . name ) ) } return colls , nil } 
func archivebuildcmds ( app provision . app , archiveurl string ) [ ] string { return buildcmds ( app , " " , " " , archiveurl ) } 
func archivedeploycmds ( app provision . app , archiveurl string ) [ ] string { return buildcmds ( app , " " , " " , archiveurl ) } 
func deploycmds ( app provision . app ) [ ] string { uacmds : = unitagentcmds ( app ) uacmds = append ( uacmds , " " ) finalcmd : = strings . join ( uacmds , " " ) return [ ] string { " " , " " , finalcmd } } 
func runwithagentcmds ( app provision . app ) ( [ ] string , error ) { runcmd , err : = config . getstring ( " " ) if err ! = nil { runcmd = " " } host , : = config . getstring ( " " ) token : = app . envs ( ) [ " " ] . value return [ ] string { " " , host , token , app . getname ( ) , runcmd } , nil } 
func newapps ( c * tsuruv1client , namespace string ) * apps { return & apps { client : c . restclient ( ) , ns : namespace , } } 
func ( c * apps ) get ( name string , options meta v1 . getoptions ) ( result * v1 . app , err error ) { result = & v1 . app { } err = c . client . get ( ) . namespace ( c . ns ) . resource ( " " ) . name ( name ) . versionedparams ( & options , scheme . parametercodec ) . do ( ) . into ( result ) return } 
func ( c * apps ) list ( opts meta v1 . listoptions ) ( result * v1 . applist , err error ) { result = & v1 . applist { } err = c . client . get ( ) . namespace ( c . ns ) . resource ( " " ) . versionedparams ( & opts , scheme . parametercodec ) . do ( ) . into ( result ) return } 
func ( c * apps ) create ( app * v1 . app ) ( result * v1 . app , err error ) { result = & v1 . app { } err = c . client . post ( ) . namespace ( c . ns ) . resource ( " " ) . body ( app ) . do ( ) . into ( result ) return } 
func ( c * apps ) update ( app * v1 . app ) ( result * v1 . app , err error ) { result = & v1 . app { } err = c . client . put ( ) . namespace ( c . ns ) . resource ( " " ) . name ( app . name ) . body ( app ) . do ( ) . into ( result ) return } 
func ( c * apps ) delete ( name string , options * meta v1 . deleteoptions ) error { return c . client . delete ( ) . namespace ( c . ns ) . resource ( " " ) . name ( name ) . body ( options ) . do ( ) . error ( ) } 
func parsetoken ( header string ) ( string , error ) { s : = strings . split ( header , " " ) var value string if len ( s ) < 3 { value = s [ len ( s ) - 1 ] } if value ! = " " { return value , nil } return value , errinvalidtoken } 
func processtags ( tags [ ] string ) [ ] string { if tags == nil { return nil } processedtags : = [ ] string { } usedtags : = make ( map [ string ] bool ) for , tag : = range tags { tag = strings . trimspace ( tag ) if len ( tag ) > 0 && ! usedtags [ tag ] { processedtags = append ( processedtags , tag ) usedtags [ tag ] = true } } return processedtags } 
func ( s * segregatedscheduler ) aggregatecontainersby ( matcher bson . m ) ( map [ string ] int , error ) { coll : = s . provisioner . collection ( ) defer coll . close ( ) pipe : = coll . pipe ( [ ] bson . m { matcher , { " " : bson . m { " " : " " , " " : bson . m { " " : 1 } } } , } ) var results [ ] nodeaggregate err : = pipe . all ( & results ) if err ! = nil { return nil , err } countmap : = make ( map [ string ] int ) for , result : = range results { countmap [ result . hostaddr ] = result . count } return countmap , nil } 
func ( s * segregatedscheduler ) choosenodetoadd ( nodes [ ] cluster . node , contname string , appname , process string ) ( string , error ) { log . debugf ( " " , contname , nodes ) s . hostmutex . lock ( ) defer s . hostmutex . unlock ( ) chosennode , , err : = s . minmaxnodes ( nodes , appname , process ) if err ! = nil { return " " , err } log . debugf ( " " , contname , chosennode ) if contname ! = " " { coll : = s . provisioner . collection ( ) defer coll . close ( ) err = coll . update ( bson . m { " " : contname } , bson . m { " " : bson . m { " " : net . urltohost ( chosennode ) } } ) } return chosennode , err } 
func ( s * segregatedscheduler ) choosecontainertoremove ( nodes [ ] cluster . node , appname , process string ) ( string , error ) { , chosennode , err : = s . minmaxnodes ( nodes , appname , process ) if err ! = nil { return " " , err } log . debugf ( " " , chosennode ) containerid , err : = s . getcontainerpreferablyfromhost ( chosennode , appname , process ) if err ! = nil { return " " , err } return containerid , err } 
func listrouters ( w http . responsewriter , r * http . request , t auth . token ) error { contexts : = permission . contextsforpermission ( t , permission . permappcreate ) var teams [ ] string var global bool contexts : for , c : = range contexts { switch c . ctxtype { case permtypes . ctxglobal : global = true break contexts case permtypes . ctxteam : teams = append ( teams , c . value ) } } routers , err : = router . listwithinfo ( ) if err ! = nil { return err } filteredrouters : = routers if ! global { routersallowed : = make ( map [ string ] struct { } ) filteredrouters = [ ] router . planrouter { } pools , err : = pool . listpossiblepools ( teams ) if err ! = nil { return err } for , p : = range pools { rs , err : = p . getrouters ( ) if err ! = nil { return err } for , r : = range rs { routersallowed [ r ] = struct { } { } } } for , r : = range routers { if , ok : = routersallowed [ r . name ] ; ok { filteredrouters = append ( filteredrouters , r ) } } } if len ( filteredrouters ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( filteredrouters ) } 
func removeapprouter ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { appname : = r . url . query ( ) . get ( " " ) routername : = r . url . query ( ) . get ( " " ) a , err : = getappfromcontext ( appname , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappupdaterouterremove , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : apptarget ( appname ) , kind : permission . permappupdaterouterremove , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = a . removerouter ( routername ) if , isnotfound : = err . ( * router . errrouternotfound ) ; isnotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } 
func listapprouters ( w http . responsewriter , r * http . request , t auth . token ) error { a , err : = getappfromcontext ( r . url . query ( ) . get ( " " ) , r ) if err ! = nil { return err } canread : = permission . check ( t , permission . permappreadrouter , contextsforapp ( & a ) ... , ) if ! canread { return permission . errunauthorized } w . header ( ) . set ( " " , " " ) routers , err : = a . getrouterswithaddr ( ) if err ! = nil { return err } if len ( routers ) == 0 { w . writeheader ( http . statusnocontent ) return nil } return json . newencoder ( w ) . encode ( routers ) } 
func get ( name string ) ( router , error ) { routertype , prefix , err : = type ( name ) if err ! = nil { return nil , & errrouternotfound { name : name } } factory , ok : = routers [ routertype ] if ! ok { return nil , errors . errorf ( " " , routertype ) } r , err : = factory ( name , prefix ) if err ! = nil { return nil , err } return r , nil } 
func default ( ) ( string , error ) { plans , err : = list ( ) if err ! = nil { return " " , err } if len ( plans ) == 0 { return " " , errdefaultrouternotfound } if len ( plans ) == 1 { return plans [ 0 ] . name , nil } for , p : = range plans { if p . default { return p . name , nil } } return " " , errdefaultrouternotfound } 
func store ( appname , routername , kind string ) error { coll , err : = collection ( ) if err ! = nil { return err } defer coll . close ( ) data : = routerappentry { app : appname , router : routername , kind : kind , } , err = coll . upsert ( bson . m { " " : appname } , data ) return err } 
func servicelist ( w http . responsewriter , r * http . request , t auth . token ) error { contexts : = permission . contextsforpermission ( t , permission . permserviceread ) services , err : = provisionreadableservices ( t , contexts ) if err ! = nil { return err } sinstances , err : = service . getserviceinstancesbyservices ( services ) if err ! = nil { return err } results : = make ( [ ] service . servicemodel , len ( services ) ) for i , s : = range services { results [ i ] . service = s . name for , si : = range sinstances { if si . servicename == s . name { results [ i ] . instances = append ( results [ i ] . instances , si . name ) results [ i ] . serviceinstances = append ( results [ i ] . serviceinstances , si ) } } } if len ( results ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( results ) } 
func serviceupdate ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { d : = service . service { username : inputvalue ( r , " " ) , endpoint : map [ string ] string { " " : inputvalue ( r , " " ) } , password : inputvalue ( r , " " ) , name : r . url . query ( ) . get ( " " ) , } team : = inputvalue ( r , " " ) s , err : = getservice ( d . name ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceupdate , contextsforserviceprovision ( & s ) ... , ) if ! allowed { return permission . errunauthorized } delete ( r . form , " " ) evt , err : = event . new ( & event . opts { target : servicetarget ( s . name ) , kind : permission . permserviceupdate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permservicereadevents , contextsforserviceprovision ( & s ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) s . endpoint = d . endpoint s . password = d . password s . username = d . username if team ! = " " { s . ownerteams = [ ] string { team } } return service . update ( s ) } 
func servicedelete ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { s , err : = getservice ( r . url . query ( ) . get ( " " ) ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permservicedelete , contextsforserviceprovision ( & s ) ... , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : servicetarget ( s . name ) , kind : permission . permservicedelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permservicereadevents , contextsforserviceprovision ( & s ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) instances , err : = service . getserviceinstancesbyservices ( [ ] service . service { s } ) if err ! = nil { return err } if len ( instances ) > 0 { msg : = " \n " msg += " " return & errors . http { code : http . statusforbidden , message : msg } } return service . delete ( s ) } 
func serviceproxy ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { servicename : = r . url . query ( ) . get ( " " ) s , err : = getservice ( servicename ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceupdateproxy , contextsforserviceprovision ( & s ) ... , ) if ! allowed { return permission . errunauthorized } var evt * event . event if r . method ! = http . methodget && r . method ! = http . methodhead { evt , err = event . new ( & event . opts { target : servicetarget ( s . name ) , kind : permission . permserviceupdateproxy , owner : t , customdata : append ( event . formtocustomdata ( inputfields ( r ) ) , map [ string ] interface { } { " " : " " , " " : r . method , } ) , allowed : event . allowed ( permission . permservicereadevents , contextsforserviceprovision ( & s ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) } path : = r . url . query ( ) . get ( " " ) return service . proxy ( & s , path , evt , requestidheader ( r ) , w , r ) } 
func grantserviceaccess ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { servicename : = r . url . query ( ) . get ( " " ) s , err : = getservice ( servicename ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceupdategrantaccess , contextsforserviceprovision ( & s ) ... , ) if ! allowed { return permission . errunauthorized } teamname : = r . url . query ( ) . get ( " " ) team , err : = servicemanager . team . findbyname ( teamname ) if err ! = nil { if err == authtypes . errteamnotfound { return & errors . http { code : http . statusbadrequest , message : " " } } return err } evt , err : = event . new ( & event . opts { target : servicetarget ( s . name ) , kind : permission . permserviceupdategrantaccess , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permservicereadevents , contextsforserviceprovision ( & s ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = s . grantaccess ( team ) if err ! = nil { return & errors . http { code : http . statusconflict , message : err . error ( ) } } return service . update ( s ) } 
func serviceadddoc ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { servicename : = r . url . query ( ) . get ( " " ) s , err : = getservice ( servicename ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceupdatedoc , contextsforserviceprovision ( & s ) ... , ) if ! allowed { return permission . errunauthorized } s . doc = inputvalue ( r , " " ) evt , err : = event . new ( & event . opts { target : servicetarget ( s . name ) , kind : permission . permserviceupdatedoc , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permservicereadevents , contextsforserviceprovision ( & s ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) return service . update ( s ) } 
func newsimpleclientset ( objects ... runtime . object ) * clientset { o : = testing . newobjecttracker ( scheme , codecs . universaldecoder ( ) ) for , obj : = range objects { if err : = o . add ( obj ) ; err ! = nil { panic ( err ) } } fakeptr : = testing . fake { } fakeptr . addreactor ( " " , " " , testing . objectreaction ( o ) ) fakeptr . addwatchreactor ( " " , testing . defaultwatchreactor ( watch . newfake ( ) , nil ) ) return & clientset { fakeptr , & fakediscovery . fakediscovery { fake : & fakeptr } } } 
func ( c * clientset ) tsuruv1 ( ) tsuruv1 . tsuruv1interface { return & faketsuruv1 . faketsuruv1 { fake : & c . fake } } 
func ( c * clientset ) tsuru ( ) tsuruv1 . tsuruv1interface { return & faketsuruv1 . faketsuruv1 { fake : & c . fake } } 
func healthcheck ( w http . responsewriter , r * http . request ) { var checks [ ] string values : = r . url . query ( ) if values ! = nil { checks = values [ " " ] } fullhealthcheck ( w , checks ) } 
func newappinformer ( client versioned . interface , namespace string , resyncperiod time . duration , indexers cache . indexers ) cache . sharedindexinformer { return newfilteredappinformer ( client , namespace , resyncperiod , indexers , nil ) } 
func newfilteredappinformer ( client versioned . interface , namespace string , resyncperiod time . duration , indexers cache . indexers , tweaklistoptions internalinterfaces . tweaklistoptionsfunc ) cache . sharedindexinformer { return cache . newsharedindexinformer ( & cache . listwatch { listfunc : func ( options meta v1 . listoptions ) ( runtime . object , error ) { if tweaklistoptions ! = nil { tweaklistoptions ( & options ) } return client . tsuruv1 ( ) . apps ( namespace ) . list ( options ) } , watchfunc : func ( options meta v1 . listoptions ) ( watch . interface , error ) { if tweaklistoptions ! = nil { tweaklistoptions ( & options ) } return client . tsuruv1 ( ) . apps ( namespace ) . watch ( options ) } , } , & tsuru v1 . app { } , resyncperiod , indexers , ) } 
func ( c * fakeapps ) get ( name string , options v1 . getoptions ) ( result * tsuru v1 . app , err error ) { obj , err : = c . fake . invokes ( testing . newgetaction ( appsresource , c . ns , name ) , & tsuru v1 . app { } ) if obj == nil { return nil , err } return obj . ( * tsuru v1 . app ) , err } 
func ( c * fakeapps ) list ( opts v1 . listoptions ) ( result * tsuru v1 . applist , err error ) { obj , err : = c . fake . invokes ( testing . newlistaction ( appsresource , appskind , c . ns , opts ) , & tsuru v1 . applist { } ) if obj == nil { return nil , err } label , , : = testing . extractfromlistoptions ( opts ) if label == nil { label = labels . everything ( ) } list : = & tsuru v1 . applist { } for , item : = range obj . ( * tsuru v1 . applist ) . items { if label . matches ( labels . set ( item . labels ) ) { list . items = append ( list . items , item ) } } return list , err } 
func ( c * fakeapps ) watch ( opts v1 . listoptions ) ( watch . interface , error ) { return c . fake . invokeswatch ( testing . newwatchaction ( appsresource , c . ns , opts ) ) } 
func ( c * fakeapps ) create ( app * tsuru v1 . app ) ( result * tsuru v1 . app , err error ) { obj , err : = c . fake . invokes ( testing . newcreateaction ( appsresource , c . ns , app ) , & tsuru v1 . app { } ) if obj == nil { return nil , err } return obj . ( * tsuru v1 . app ) , err } 
func ( c * fakeapps ) update ( app * tsuru v1 . app ) ( result * tsuru v1 . app , err error ) { obj , err : = c . fake . invokes ( testing . newupdateaction ( appsresource , c . ns , app ) , & tsuru v1 . app { } ) if obj == nil { return nil , err } return obj . ( * tsuru v1 . app ) , err } 
func ( c * fakeapps ) delete ( name string , options * v1 . deleteoptions ) error { , err : = c . fake . invokes ( testing . newdeleteaction ( appsresource , c . ns , name ) , & tsuru v1 . app { } ) return err } 
func ( c * fakeapps ) deletecollection ( options * v1 . deleteoptions , listoptions v1 . listoptions ) error { action : = testing . newdeletecollectionaction ( appsresource , c . ns , listoptions ) , err : = c . fake . invokes ( action , & tsuru v1 . applist { } ) return err } 
func ( c * fakeapps ) patch ( name string , pt types . patchtype , data [ ] byte , subresources ... string ) ( result * tsuru v1 . app , err error ) { obj , err : = c . fake . invokes ( testing . newpatchsubresourceaction ( appsresource , c . ns , name , data , subresources ... ) , & tsuru v1 . app { } ) if obj == nil { return nil , err } return obj . ( * tsuru v1 . app ) , err } 
func newsharedinformerfactory ( client versioned . interface , defaultresync time . duration ) sharedinformerfactory { return newfilteredsharedinformerfactory ( client , defaultresync , v1 . namespaceall , nil ) } 
func newfilteredsharedinformerfactory ( client versioned . interface , defaultresync time . duration , namespace string , tweaklistoptions internalinterfaces . tweaklistoptionsfunc ) sharedinformerfactory { return & sharedinformerfactory { client : client , namespace : namespace , tweaklistoptions : tweaklistoptions , defaultresync : defaultresync , informers : make ( map [ reflect . type ] cache . sharedindexinformer ) , startedinformers : make ( map [ reflect . type ] bool ) , } } 
func webhooklist ( w http . responsewriter , r * http . request , t auth . token ) error { ctxs : = permission . contextsforpermission ( t , permission . permwebhookread , permtypes . ctxteam ) var teams [ ] string for , c : = range ctxs { if c . ctxtype == permtypes . ctxglobal { teams = nil break } teams = append ( teams , c . value ) } webhooks , err : = servicemanager . webhook . list ( teams ) if err ! = nil { return err } if len ( webhooks ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( webhooks ) } 
func webhookinfo ( w http . responsewriter , r * http . request , t auth . token ) error { webhookname : = r . url . query ( ) . get ( " " ) webhook , err : = servicemanager . webhook . find ( webhookname ) if err ! = nil { if err == eventtypes . errwebhooknotfound { w . writeheader ( http . statusnotfound ) } return err } ctx : = permission . context ( permtypes . ctxteam , webhook . teamowner ) if ! permission . check ( t , permission . permwebhookread , ctx ) { return permission . errunauthorized } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( webhook ) } 
func webhookcreate ( w http . responsewriter , r * http . request , t auth . token ) error { var webhook eventtypes . webhook err : = parseinput ( r , & webhook ) if err ! = nil { return err } if webhook . teamowner == " " { webhook . teamowner , err = autoteamowner ( t , permission . permwebhookcreate ) if err ! = nil { return err } } ctx : = permission . context ( permtypes . ctxteam , webhook . teamowner ) if ! permission . check ( t , permission . permwebhookcreate , ctx ) { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypewebhook , value : webhook . name } , kind : permission . permwebhookcreate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permwebhookreadevents , ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = servicemanager . webhook . create ( webhook ) if err == eventtypes . errwebhookalreadyexists { w . writeheader ( http . statusconflict ) } return err } 
func webhookupdate ( w http . responsewriter , r * http . request , t auth . token ) error { var webhook eventtypes . webhook err : = parseinput ( r , & webhook ) if err ! = nil { return err } webhook . name = r . url . query ( ) . get ( " " ) ctx : = permission . context ( permtypes . ctxteam , webhook . teamowner ) if ! permission . check ( t , permission . permwebhookupdate , ctx ) { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypewebhook , value : webhook . name } , kind : permission . permwebhookupdate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permwebhookreadevents , ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = servicemanager . webhook . update ( webhook ) if err == eventtypes . errwebhooknotfound { w . writeheader ( http . statusnotfound ) } return err } 
func ( b * brokerclient ) proxy ( path string , evt * event . event , requestid string , w http . responsewriter , r * http . request ) error { return fmt . errorf ( " " ) } 
func ( b * brokerclient ) unbindunit ( instance * serviceinstance , app bind . app , unit bind . unit ) error { return nil } 
func ( s * planservice ) create ( plan apptypes . plan ) error { if plan . name == " " { return apptypes . planvalidationerror { field : " " } } if plan . cpushare < 2 { return apptypes . errlimitofcpushare } if plan . memory > 0 && plan . memory < 4194304 { return apptypes . errlimitofmemory } return s . storage . insert ( plan ) } 
func ( s * planservice ) remove ( planname string ) error { return s . storage . delete ( apptypes . plan { name : planname } ) } 
func ( s * planservice ) ensuredefault ( ) error { plans , err : = s . storage . findall ( ) if err ! = nil { return err } if len ( plans ) > 0 { return nil } configmemory , : = config . getint ( " " ) configswap , : = config . getint ( " " ) dp : = apptypes . plan { name : " " , memory : int64 ( configmemory ) * 1024 * 1024 , swap : int64 ( configswap - configmemory ) * 1024 * 1024 , cpushare : 100 , default : true , } return s . storage . insert ( dp ) } 
func deleteinstance ( si * serviceinstance , evt * event . event , requestid string ) error { if len ( si . apps ) > 0 { return errserviceinstancebound } s , err : = get ( si . servicename ) if err ! = nil { return err } endpoint , err : = s . getclient ( " " ) if err == nil { endpoint . destroy ( si , evt , requestid ) } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) return conn . serviceinstances ( ) . remove ( bson . m { " " : si . name , " " : si . servicename } ) } 
func ( si * serviceinstance ) toinfo ( ) ( serviceinstancewithinfo , error ) { info , err : = si . info ( " " ) if err ! = nil { info = nil } return serviceinstancewithinfo { id : si . id , name : si . name , teams : si . teams , planname : si . planname , apps : si . apps , servicename : si . servicename , info : info , teamowner : si . teamowner , } , nil } 
func ( si * serviceinstance ) update ( service service , updatedata serviceinstance , evt * event . event , requestid string ) error { err : = validateserviceinstanceteamowner ( updatedata ) if err ! = nil { return err } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) tags : = processtags ( updatedata . tags ) if tags == nil { updatedata . tags = si . tags } else { updatedata . tags = tags } actions : = [ ] * action . action { & updateserviceinstance , & notifyupdateserviceinstance } pipeline : = action . newpipeline ( actions ... ) return pipeline . execute ( service , * si , updatedata , evt , requestid ) } 
func ( si * serviceinstance ) bindapp ( app bind . app , params bindappparameters , shouldrestart bool , writer io . writer , evt * event . event , requestid string ) error { args : = bindpipelineargs { serviceinstance : si , app : app , writer : writer , shouldrestart : shouldrestart , params : params , event : evt , requestid : requestid , } actions : = [ ] * action . action { bindappdbaction , bindappendpointaction , setboundenvsaction , bindunitsaction , } pipeline : = action . newpipeline ( actions ... ) return pipeline . execute ( & args ) } 
func ( si * serviceinstance ) unbindapp ( unbindargs unbindappargs ) error { if si . findapp ( unbindargs . app . getname ( ) ) == - 1 { return errappnotbound } args : = bindpipelineargs { serviceinstance : si , app : unbindargs . app , writer : unbindargs . event , shouldrestart : unbindargs . restart , event : unbindargs . event , requestid : unbindargs . requestid , forceremove : unbindargs . forceremove , } actions : = [ ] * action . action { & unbindunits , & unbindappdb , & unbindappendpoint , & removeboundenvs , } pipeline : = action . newpipeline ( actions ... ) return pipeline . execute ( & args ) } 
func ( si * serviceinstance ) status ( requestid string ) ( string , error ) { s , err : = get ( si . servicename ) if err ! = nil { return " " , err } endpoint , err : = s . getclient ( " " ) if err ! = nil { return " " , err } return endpoint . status ( si , requestid ) } 
func proxyinstance ( instance * serviceinstance , path string , evt * event . event , requestid string , w http . responsewriter , r * http . request ) error { service , err : = get ( instance . servicename ) if err ! = nil { return err } endpoint , err : = service . getclient ( " " ) if err ! = nil { return err } prefix : = fmt . sprintf ( " " , instance . getidentifier ( ) ) path = strings . trim ( strings . trimprefix ( path + " " , prefix ) , " " ) for , reserved : = range reservedproxypaths { if path == reserved && r . method ! = " " { return & tsuruerrors . validationerror { message : fmt . sprintf ( " " , r . method , path ) , } } } return endpoint . proxy ( fmt . sprintf ( " " , prefix , path ) , evt , requestid , w , r ) } 
func ( s * quotaservice ) inc ( appname string , quantity int ) error { quota , err : = s . storage . get ( appname ) if err ! = nil { return err } err = s . checklimit ( quota , quantity ) if err ! = nil { return err } return s . storage . inc ( appname , quantity ) } 
func ( s * quotaservice ) setlimit ( appname string , limit int ) error { q , err : = s . storage . get ( appname ) if err ! = nil { return err } if limit < 0 { limit = - 1 } else if limit < q . inuse { return quota . errlimitlowerthanallocated } return s . storage . setlimit ( appname , limit ) } 
func ( s * quotaservice ) set ( appname string , inuse int ) error { q , err : = s . storage . get ( appname ) if err ! = nil { return err } if inuse < 0 { return quota . errlessthanzero } if ! q . isunlimited ( ) && inuse > q . limit { return & quota . quotaexceedederror { requested : uint ( inuse ) , available : uint ( q . limit ) , } } return s . storage . set ( appname , inuse ) } 
func ( s * quotaservice ) get ( appname string ) ( * quota . quota , error ) { return s . storage . get ( appname ) } 
func installhostadd ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . perminstallmanage ) if ! allowed { return permission . errunauthorized } var host * install . host err = parseinput ( r , & host ) if err ! = nil { return err } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeinstallhost , value : host . name } , kind : permission . perminstallmanage , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . perminstallmanage ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) var rawdriver map [ string ] interface { } err = json . unmarshal ( [ ] byte ( r . form . get ( " " ) ) , & rawdriver ) if err ! = nil { return err } host . driver = rawdriver err = install . addhost ( host ) if err ! = nil { return err } w . writeheader ( http . statuscreated ) return nil } 
func installhostinfo ( w http . responsewriter , r * http . request , t auth . token ) error { allowed : = permission . check ( t , permission . perminstallmanage ) if ! allowed { return permission . errunauthorized } host , err : = install . gethostbyname ( r . url . query ( ) . get ( " " ) ) if errnf , ok : = err . ( * install . errhostnotfound ) ; ok { return & errors . http { code : http . statusnotfound , message : fmt . sprintf ( " " , errnf . name ) } } if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( & host ) } 
func installhostlist ( w http . responsewriter , r * http . request , t auth . token ) error { allowed : = permission . check ( t , permission . perminstallmanage ) if ! allowed { return permission . errunauthorized } hosts , err : = install . listhosts ( ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( & hosts ) } 
func removeimage ( imagename string ) error { registry , image , tag : = parseimage ( imagename ) if registry == " " { registry , = config . getstring ( " " ) } if registry == " " { return nil } if image == " " { return errors . errorf ( " " , imagename ) } r : = & dockerregistry { server : registry } digest , err : = r . getdigest ( image , tag ) if err ! = nil { return errors . wrapf ( err , " " , r . server , image , tag ) } err = r . removeimage ( image , digest ) if err ! = nil { return errors . wrapf ( err , " " , r . server , image , tag , digest ) } return nil } 
func removeappimages ( appname string ) error { registry , : = config . getstring ( " " ) if registry == " " { return nil } r : = & dockerregistry { server : registry } image : = fmt . sprintf ( " " , appname ) tags , err : = r . getimagetags ( image ) if err ! = nil { return err } multi : = tsuruerrors . newmultierror ( ) for , tag : = range tags { digest , err : = r . getdigest ( image , tag ) if err ! = nil { multi . add ( errors . wrapf ( err , " " , r . server , image , tag ) ) continue } err = r . removeimage ( image , digest ) if err ! = nil { multi . add ( errors . wrapf ( err , " " , r . server , image , tag , digest ) ) if errors . cause ( err ) == errdeletedisabled { break } } } return multi . toerror ( ) } 
func ( s * platformservice ) create ( opts apptypes . platformoptions ) error { p : = apptypes . platform { name : opts . name } if err : = s . validate ( p ) ; err ! = nil { return err } err : = s . storage . insert ( p ) if err ! = nil { return err } opts . imagename , err = servicemanager . platformimage . newimage ( opts . name ) if err ! = nil { return err } err = builder . platformadd ( opts ) if err ! = nil { if imgerr : = servicemanager . platformimage . deleteimages ( opts . name ) ; imgerr ! = nil { log . errorf ( " " , imgerr ) } dberr : = s . storage . delete ( p ) if dberr ! = nil { return tsuruerrors . newmultierror ( errors . wrapf ( dberr , " " ) , errors . wrapf ( err , " " ) , ) } return err } return servicemanager . platformimage . appendimage ( opts . name , opts . imagename ) } 
func ( s * platformservice ) list ( enabledonly bool ) ( [ ] apptypes . platform , error ) { if enabledonly { return s . storage . findenabled ( ) } return s . storage . findall ( ) } 
func ( s * platformservice ) findbyname ( name string ) ( * apptypes . platform , error ) { p , err : = s . storage . findbyname ( name ) if err ! = nil { return nil , apptypes . errinvalidplatform } return p , nil } 
func ( s * platformservice ) update ( opts apptypes . platformoptions ) error { if opts . name == " " { return apptypes . errplatformnamemissing } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) , err = s . findbyname ( opts . name ) if err ! = nil { return err } if opts . input ! = nil { data , err : = ioutil . readall ( opts . input ) if err ! = nil { return err } if len ( data ) == 0 { return apptypes . errmissingfilecontent } opts . data = data opts . imagename , err = servicemanager . platformimage . newimage ( opts . name ) if err ! = nil { return err } err = builder . platformupdate ( opts ) if err ! = nil { return err } err = servicemanager . platformimage . appendimage ( opts . name , opts . imagename ) if err ! = nil { return err } var apps [ ] app err = conn . apps ( ) . find ( bson . m { " " : opts . name } ) . all ( & apps ) if err ! = nil { return err } for , app : = range apps { app . setupdateplatform ( true ) } } if opts . args [ " " ] ! = " " { disablebool , err : = strconv . parsebool ( opts . args [ " " ] ) if err ! = nil { return err } return s . storage . update ( apptypes . platform { name : opts . name , disabled : disablebool } ) } return nil } 
func ( s * platformservice ) remove ( name string ) error { if name == " " { return apptypes . errplatformnamemissing } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) apps , : = conn . apps ( ) . find ( bson . m { " " : name } ) . count ( ) if apps > 0 { return apptypes . errdeleteplatformwithapps } err = builder . platformremove ( name ) if err ! = nil { log . errorf ( " " , err ) } images , err : = servicemanager . platformimage . listimagesordefault ( name ) if err == nil { for , img : = range images { if regerr : = registry . removeimage ( img ) ; regerr ! = nil { log . errorf ( " " , regerr ) } } } else { log . errorf ( " " , err ) } err = servicemanager . platformimage . deleteimages ( name ) if err ! = nil { log . errorf ( " " , err ) } return s . storage . delete ( apptypes . platform { name : name } ) } 
func ( s * platformservice ) rollback ( opts apptypes . platformoptions ) error { if opts . name == " " { return apptypes . errplatformnamemissing } if opts . imagename == " " { return apptypes . errplatformimagemissing } , err : = s . findbyname ( opts . name ) if err ! = nil { return err } image , err : = servicemanager . platformimage . findimage ( opts . name , opts . imagename ) if err ! = nil { return err } if image == " " { return fmt . errorf ( " " , opts . imagename , opts . name ) } opts . data = [ ] byte ( " " + image ) opts . imagename , err = servicemanager . platformimage . newimage ( opts . name ) if err ! = nil { return err } err = builder . platformupdate ( opts ) if err ! = nil { return err } err = servicemanager . platformimage . appendimage ( opts . name , opts . imagename ) if err ! = nil { return err } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) var apps [ ] app err = conn . apps ( ) . find ( bson . m { " " : opts . name } ) . all ( & apps ) if err ! = nil { return err } for , app : = range apps { app . setupdateplatform ( true ) } return nil } 
func index ( w http . responsewriter , r * http . request ) error { host , : = config . getstring ( " " ) usercreate , : = config . getbool ( " " ) scheme , : = config . getstring ( " " ) repomanager , : = config . getstring ( " " ) data : = map [ string ] interface { } { " " : host , " " : usercreate , " " : scheme == " " | | scheme == " " , " " : repomanager == " " | | repomanager == " " , } template , err : = gettemplate ( ) if err ! = nil { return err } return template . execute ( w , data ) } 
func getpoolbyname ( name string ) ( * pool , error ) { conn , err : = db . conn ( ) if err ! = nil { return nil , err } defer conn . close ( ) var p pool err = conn . pools ( ) . findid ( name ) . one ( & p ) if err ! = nil { if err == mgo . errnotfound { return nil , errpoolnotfound } return nil , err } return & p , nil } 
func manager ( ) repositorymanager { managername , err : = config . getstring ( " " ) if err ! = nil { managername = defaultmanager } if , ok : = managers [ managername ] ; ! ok { managername = " " } return managers [ managername ] } 
func register ( name string , manager repositorymanager ) { if managers == nil { managers = make ( map [ string ] repositorymanager ) } managers [ name ] = manager } 
func ( b * bindsyncer ) start ( ) error { if b . started { return errors . new ( " " ) } if b . applister == nil { return errors . new ( " " ) } if b . interval == 0 { b . interval = 5 * time . minute } b . shutdown = make ( chan struct { } , 1 ) b . done = make ( chan struct { } ) b . started = true log . debugf ( " \n " , b . interval ) go func ( d time . duration ) { for { select { case < - time . after ( d ) : start : = time . now ( ) log . debug ( " " ) apps , err : = b . applister ( ) if err ! = nil { log . errorf ( " " , err ) syncduration . set ( time . since ( start ) . seconds ( ) ) break } for , a : = range apps { err = b . sync ( a ) if err ! = nil { log . errorf ( " " , a . getname ( ) , err ) } if len ( b . shutdown ) > 0 { break } } log . debugf ( " " , len ( apps ) ) d = b . interval syncduration . set ( time . since ( start ) . seconds ( ) ) case < - b . shutdown : b . done < - struct { } { } return } } } ( time . millisecond * 100 ) return nil } 
func ( b * bindsyncer ) shutdown ( ctx context . context ) error { if ! b . started { return nil } b . shutdown < - struct { } { } select { case < - b . done : case < - ctx . done ( ) : } b . started = false return ctx . err ( ) } 
func getforprovisioner ( p provision . provisioner ) ( builder , error ) { builder , err : = get ( p . getname ( ) ) if err ! = nil { if , ok : = p . ( provision . builderdeploydockerclient ) ; ok { return get ( " " ) } else if , ok : = p . ( provision . builderdeploykubeclient ) ; ok { return get ( " " ) } } return builder , err } 
func get ( name string ) ( builder , error ) { b , ok : = builders [ name ] if ! ok { return nil , errors . errorf ( " " , name ) } return b , nil } 
func registry ( ) ( [ ] builder , error ) { registry : = make ( [ ] builder , 0 , len ( builders ) ) for , b : = range builders { registry = append ( registry , b ) } return registry , nil } 
func registerqueuetask ( p dockerprovisioner ) error { q , err : = queue . queue ( ) if err ! = nil { return err } return q . registertask ( & runbs { provisioner : p } ) } 
func healinghistoryhandler ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permhealingread ) { return permission . errunauthorized } filter : = r . url . query ( ) . get ( " " ) if filter ! = " " && filter ! = " " && filter ! = " " { return & tsuruerrors . http { code : http . statusbadrequest , message : " " , } } history , err : = healer . listhealinghistory ( filter ) if err ! = nil { return err } if len ( history ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( history ) } 
func ( v * version ) apps ( ) appinformer { return & appinformer { factory : v . factory , namespace : v . namespace , tweaklistoptions : v . tweaklistoptions } } 
func dumpgoroutines ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permdebug ) { return permission . errunauthorized } return pprof . lookup ( " " ) . writeto ( w , 2 ) } 
func ( in * app ) deepcopyinto ( out * app ) { * out = * in out . typemeta = in . typemeta in . objectmeta . deepcopyinto ( & out . objectmeta ) in . spec . deepcopyinto ( & out . spec ) return } 
func ( in * app ) deepcopy ( ) * app { if in == nil { return nil } out : = new ( app ) in . deepcopyinto ( out ) return out } 
func ( in * app ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func ( in * applist ) deepcopyinto ( out * applist ) { * out = * in out . typemeta = in . typemeta out . listmeta = in . listmeta if in . items ! = nil { in , out : = & in . items , & out . items * out = make ( [ ] app , len ( * in ) ) for i : = range * in { ( * in ) [ i ] . deepcopyinto ( & ( * out ) [ i ] ) } } return } 
func ( in * applist ) deepcopy ( ) * applist { if in == nil { return nil } out : = new ( applist ) in . deepcopyinto ( out ) return out } 
func ( in * applist ) deepcopyobject ( ) runtime . object { if c : = in . deepcopy ( ) ; c ! = nil { return c } return nil } 
func ( in * appspec ) deepcopyinto ( out * appspec ) { * out = * in if in . deployments ! = nil { in , out : = & in . deployments , & out . deployments * out = make ( map [ string ] [ ] string , len ( * in ) ) for key , val : = range * in { if val == nil { ( * out ) [ key ] = nil } else { ( * out ) [ key ] = make ( [ ] string , len ( val ) ) copy ( ( * out ) [ key ] , val ) } } } if in . services ! = nil { in , out : = & in . services , & out . services * out = make ( map [ string ] [ ] string , len ( * in ) ) for key , val : = range * in { if val == nil { ( * out ) [ key ] = nil } else { ( * out ) [ key ] = make ( [ ] string , len ( val ) ) copy ( ( * out ) [ key ] , val ) } } } return } 
func ( in * appspec ) deepcopy ( ) * appspec { if in == nil { return nil } out : = new ( appspec ) in . deepcopyinto ( out ) return out } 
func servicebrokerlist ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permservicebrokerread ) { return permission . errunauthorized } brokers , err : = servicemanager . servicebroker . list ( ) if err ! = nil { return err } if len ( brokers ) == 0 { w . writeheader ( http . statusnocontent ) return nil } return json . newencoder ( w ) . encode ( map [ string ] interface { } { " " : brokers , } ) } 
func servicebrokeradd ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permservicebrokercreate ) { return permission . errunauthorized } broker , err : = decodeservicebroker ( r ) if err ! = nil { return & errors . http { code : http . statusbadrequest , message : err . error ( ) } } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeservicebroker , value : broker . name } , kind : permission . permservicebrokercreate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permservicebrokerreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) if err = servicemanager . servicebroker . create ( * broker ) ; err ! = nil { if err == service . errservicebrokeralreadyexists { return & errors . http { code : http . statusconflict , message : " " } } return err } w . writeheader ( http . statuscreated ) return nil } 
func servicebrokerupdate ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permservicebrokerupdate ) { return permission . errunauthorized } brokername : = r . url . query ( ) . get ( " " ) if brokername == " " { return & errors . http { code : http . statusbadrequest , message : " " } } broker , err : = decodeservicebroker ( r ) if err ! = nil { return & errors . http { code : http . statusbadrequest , message : err . error ( ) } } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeservicebroker , value : broker . name } , kind : permission . permservicebrokerupdate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permservicebrokerreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) if err = servicemanager . servicebroker . update ( brokername , * broker ) ; err == service . errservicebrokernotfound { w . writeheader ( http . statusnotfound ) } return err } 
func ( w * logwriter ) write ( data [ ] byte ) ( int , error ) { w . finlk . rlock ( ) defer w . finlk . runlock ( ) if w . closed { return len ( data ) , nil } if w . msgch == nil { return len ( data ) , w . write ( data ) } copied : = make ( [ ] byte , len ( data ) ) copy ( copied , data ) w . msgch < - copied return len ( data ) , nil } 
func listclusters ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . permclusterread ) if ! allowed { return permission . errunauthorized } clusters , err : = servicemanager . cluster . list ( ) if err ! = nil { if err == provtypes . errnocluster { w . writeheader ( http . statusnocontent ) return nil } return err } for i : = range clusters { clusters [ i ] . clientkey = nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( clusters ) } 
func deletecluster ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . permclusterdelete ) if ! allowed { return permission . errunauthorized } clustername : = r . url . query ( ) . get ( " " ) evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypecluster , value : clustername } , kind : permission . permclusterdelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permclusterreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) streamresponse : = strings . hasprefix ( r . header . get ( " " ) , " " ) if streamresponse { w . header ( ) . set ( " " , " " ) keepalivewriter : = tsuruio . newkeepalivewriter ( w , 30 * time . second , " " ) defer keepalivewriter . stop ( ) writer : = & tsuruio . simplejsonmessageencoderwriter { encoder : json . newencoder ( keepalivewriter ) } evt . setlogwriter ( writer ) } err = servicemanager . cluster . delete ( provtypes . cluster { name : clustername , writer : evt } ) if err ! = nil { if errors . cause ( err ) == provtypes . errclusternotfound { return & tsuruerrors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } return nil } 
func provisionerlist ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowed : = permission . check ( t , permission . permclusterread ) if ! allowed { return permission . errunauthorized } provs , err : = provision . registry ( ) if err ! = nil { return err } info : = make ( [ ] provisionerinfo , len ( provs ) ) for i , p : = range provs { info [ i ] . name = p . getname ( ) if clusterprov , ok : = p . ( cluster . clusteredprovisioner ) ; ok { info [ i ] . clusterhelp = clusterprov . clusterhelp ( ) } } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( info ) } 
func listunitsbynode ( w http . responsewriter , r * http . request , t auth . token ) error { address : = r . url . query ( ) . get ( " " ) , node , err : = node . findnode ( address ) if err ! = nil { if err == provision . errnodenotfound { return & tsuruerrors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } hasaccess : = permission . check ( t , permission . permnoderead , permission . context ( permtypes . ctxpool , node . pool ( ) ) ) if ! hasaccess { return permission . errunauthorized } units , err : = node . units ( ) if err ! = nil { return err } if len ( units ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( units ) } 
func listunitsbyapp ( w http . responsewriter , r * http . request , t auth . token ) error { appname : = r . url . query ( ) . get ( " " ) a , err : = app . getbyname ( appname ) if err ! = nil { if err == apptypes . errappnotfound { return & tsuruerrors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } canread : = permission . check ( t , permission . permappread , contextsforapp ( a ) ... , ) if ! canread { return permission . errunauthorized } units , err : = a . units ( ) if err ! = nil { return err } if len ( units ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( units ) } 
func nodehealingread ( w http . responsewriter , r * http . request , t auth . token ) error { pools , err : = permission . listcontextvalues ( t , permission . permhealingread , true ) if err ! = nil { return err } configmap , err : = healer . getconfig ( ) if err ! = nil { return err } if len ( pools ) > 0 { allowedpoolset : = map [ string ] struct { } { } for , p : = range pools { allowedpoolset [ p ] = struct { } { } } for k : = range configmap { if k == " " { continue } if , ok : = allowedpoolset [ k ] ; ! ok { delete ( configmap , k ) } } } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( configmap ) } 
func nodehealingupdate ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { poolname : = inputvalue ( r , " " ) var ctxs [ ] permtypes . permissioncontext if poolname ! = " " { ctxs = append ( ctxs , permission . context ( permtypes . ctxpool , poolname ) ) } if ! permission . check ( t , permission . permhealingupdate , ctxs ... ) { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : poolname } , kind : permission . permhealingupdate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , disablelock : true , allowed : event . allowed ( permission . permpoolreadevents , ctxs ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) var config healer . nodehealerconfig err = parseinput ( r , & config ) if err ! = nil { return err } return healer . updateconfig ( poolname , config ) } 
func nodehealingdelete ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { poolname : = r . url . query ( ) . get ( " " ) var ctxs [ ] permtypes . permissioncontext if poolname ! = " " { ctxs = append ( ctxs , permission . context ( permtypes . ctxpool , poolname ) ) } if ! permission . check ( t , permission . permhealingdelete , ctxs ... ) { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : poolname } , kind : permission . permhealingdelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , disablelock : true , allowed : event . allowed ( permission . permpoolreadevents , ctxs ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) if len ( r . url . query ( ) [ " " ] ) == 0 { return healer . removeconfig ( poolname , " " ) } for , v : = range r . url . query ( ) [ " " ] { err : = healer . removeconfig ( poolname , v ) if err ! = nil { return err } } return nil } 
func ( s nativescheme ) resetpassword ( user * auth . user , resettoken string ) error { if resettoken == " " { return auth . errinvalidtoken } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) passtoken , err : = getpasswordtoken ( resettoken ) if err ! = nil { return err } if passtoken . useremail ! = user . email { return auth . errinvalidtoken } password : = generatepassword ( 12 ) user . password = password hashpassword ( user ) go sendnewpassword ( user , password ) passtoken . used = true conn . passwordtokens ( ) . updateid ( passtoken . token , passtoken ) return user . update ( ) } 
func diffdeploy ( w http . responsewriter , r * http . request , t auth . token ) error { writer : = tsuruio . newkeepalivewriter ( w , 30 * time . second , " " ) defer writer . stop ( ) fmt . fprint ( w , " \n " ) appname : = r . url . query ( ) . get ( " " ) diff : = inputvalue ( r , " " ) instance , err : = app . getbyname ( appname ) if err ! = nil { return & tsuruerrors . http { code : http . statusnotfound , message : err . error ( ) } } if t . getappname ( ) ! = app . internalappname { candiffdeploy : = permission . check ( t , permission . permappreaddeploy , contextsforapp ( instance ) ... ) if ! candiffdeploy { return & tsuruerrors . http { code : http . statusforbidden , message : permission . errunauthorized . error ( ) } } } evt , err : = event . getrunning ( apptarget ( appname ) , permission . permappdeploy . fullname ( ) ) if err ! = nil { return err } return evt . setothercustomdata ( map [ string ] string { " " : diff , } ) } 
func deployslist ( w http . responsewriter , r * http . request , t auth . token ) error { contexts : = permission . contextsforpermission ( t , permission . permappreaddeploy ) if len ( contexts ) == 0 { w . writeheader ( http . statusnocontent ) return nil } filter : = appfilterbycontext ( contexts , nil ) filter . name = r . url . query ( ) . get ( " " ) skip : = r . url . query ( ) . get ( " " ) limit : = r . url . query ( ) . get ( " " ) skipint , : = strconv . atoi ( skip ) limitint , : = strconv . atoi ( limit ) deploys , err : = app . listdeploys ( filter , skipint , limitint ) if err ! = nil { return err } if len ( deploys ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( deploys ) } 
func deployinfo ( w http . responsewriter , r * http . request , t auth . token ) error { depid : = r . url . query ( ) . get ( " " ) deploy , err : = app . getdeploy ( depid ) if err ! = nil { if err == event . erreventnotfound { return & tsuruerrors . http { code : http . statusnotfound , message : " " } } return err } dbapp , err : = app . getbyname ( deploy . app ) if err ! = nil { return err } canget : = permission . check ( t , permission . permappreaddeploy , contextsforapp ( dbapp ) ... ) if ! canget { return & tsuruerrors . http { code : http . statusnotfound , message : " " } } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( deploy ) } 
func buildhealthcheck ( providername string ) func ( ) error { return func ( ) error { iaasconfig , err : = config . get ( " " ) if err ! = nil { return hc . errdisabledcomponent } iaases , : = iaasconfig . ( map [ interface { } ] interface { } ) for ifacename : = range iaases { name : = ifacename . ( string ) if name == " " { customiaases : = iaases [ name ] . ( map [ interface { } ] interface { } ) for ifacename : = range customiaases { iaas : = customiaases [ ifacename . ( string ) ] . ( map [ interface { } ] interface { } ) if iaas [ " " ] . ( string ) ! = providername { continue } name = ifacename . ( string ) } } else if name ! = providername { continue } err : = healthcheck ( name ) if err ! = nil { return err } } return nil } } 
func getbrokeredservice ( name string ) ( service , error ) { catalogname , servicename , err : = splitbrokerservice ( name ) if err ! = nil { return service { } , err } client , err : = newbrokeredserviceclient ( name ) if err ! = nil { return service { } , err } s , , err : = client . getservice ( servicename , catalogname ) return s , err } 
func machineslist ( w http . responsewriter , r * http . request , token auth . token ) error { machines , err : = iaas . listmachines ( ) if err ! = nil { return err } contexts : = permission . contextsforpermission ( token , permission . permmachineread ) allowediaas : = map [ string ] struct { } { } for , c : = range contexts { if c . ctxtype == permtypes . ctxglobal { allowediaas = nil break } if c . ctxtype == permtypes . ctxiaas { allowediaas [ c . value ] = struct { } { } } } for i : = 0 ; allowediaas ! = nil && i < len ( machines ) ; i ++ { if , ok : = allowediaas [ machines [ i ] . iaas ] ; ! ok { machines = append ( machines [ : i ] , machines [ i + 1 : ] ... ) i -- } } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( machines ) } 
func machinedestroy ( w http . responsewriter , r * http . request , token auth . token ) ( err error ) { machineid : = r . url . query ( ) . get ( " " ) if machineid == " " { return & errors . http { code : http . statusbadrequest , message : " " } } m , err : = iaas . findmachinebyid ( machineid ) if err ! = nil { if err == iaas . errmachinenotfound { return & errors . http { code : http . statusnotfound , message : " " } } return err } iaasctx : = permission . context ( permtypes . ctxiaas , m . iaas ) allowed : = permission . check ( token , permission . permmachinedelete , iaasctx ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeiaas , value : m . iaas } , kind : permission . permmachinedelete , owner : token , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permmachinereadevents , iaasctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) return m . destroy ( ) } 
func templateslist ( w http . responsewriter , r * http . request , token auth . token ) error { templates , err : = iaas . listtemplates ( ) if err ! = nil { return err } contexts : = permission . contextsforpermission ( token , permission . permmachinetemplateread ) allowediaas : = map [ string ] struct { } { } for , c : = range contexts { if c . ctxtype == permtypes . ctxglobal { allowediaas = nil break } if c . ctxtype == permtypes . ctxiaas { allowediaas [ c . value ] = struct { } { } } } for i : = 0 ; allowediaas ! = nil && i < len ( templates ) ; i ++ { if , ok : = allowediaas [ templates [ i ] . iaasname ] ; ! ok { templates = append ( templates [ : i ] , templates [ i + 1 : ] ... ) i -- } } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( templates ) } 
func templatecreate ( w http . responsewriter , r * http . request , token auth . token ) ( err error ) { var paramtemplate iaas . template err = parseinput ( r , & paramtemplate ) if err ! = nil { return err } iaasctx : = permission . context ( permtypes . ctxiaas , paramtemplate . iaasname ) allowed : = permission . check ( token , permission . permmachinetemplatecreate , iaasctx ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeiaas , value : paramtemplate . iaasname } , kind : permission . permmachinetemplatecreate , owner : token , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permmachinereadevents , iaasctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) , err = iaas . findtemplate ( paramtemplate . name ) if err ! = nil && err ! = mgo . errnotfound { return err } if err == nil { return & errors . http { code : http . statusconflict , message : fmt . sprintf ( " " " " , paramtemplate . name ) } } err = paramtemplate . save ( ) if err ! = nil { return err } w . writeheader ( http . statuscreated ) return nil } 
func templatedestroy ( w http . responsewriter , r * http . request , token auth . token ) ( err error ) { templatename : = r . url . query ( ) . get ( " " ) t , err : = iaas . findtemplate ( templatename ) if err ! = nil { if err == mgo . errnotfound { return & errors . http { code : http . statusnotfound , message : " " } } return err } iaasctx : = permission . context ( permtypes . ctxiaas , t . iaasname ) allowed : = permission . check ( token , permission . permmachinetemplatedelete , iaasctx ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeiaas , value : t . iaasname } , kind : permission . permmachinetemplatedelete , owner : token , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permmachinereadevents , iaasctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) return iaas . destroytemplate ( templatename ) } 
func templateupdate ( w http . responsewriter , r * http . request , token auth . token ) ( err error ) { var paramtemplate iaas . template err = parseinput ( r , & paramtemplate ) if err ! = nil { return err } templatename : = r . url . query ( ) . get ( " " ) dbtpl , err : = iaas . findtemplate ( templatename ) if err ! = nil { if err == mgo . errnotfound { return & errors . http { code : http . statusnotfound , message : " " } } return err } iaasvalue : = inputvalue ( r , " " ) if iaasvalue ! = " " { dbtpl . iaasname = iaasvalue } iaasctx : = permission . context ( permtypes . ctxiaas , dbtpl . iaasname ) allowed : = permission . check ( token , permission . permmachinetemplateupdate , iaasctx ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypeiaas , value : dbtpl . iaasname } , kind : permission . permmachinetemplateupdate , owner : token , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permmachinereadevents , iaasctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) return dbtpl . update ( & paramtemplate ) } 
func ( c * tsuruv1client ) restclient ( ) rest . interface { if c == nil { return nil } return c . restclient } 
func addknowntypes ( scheme * runtime . scheme ) error { scheme . addknowntypes ( schemegroupversion , & app { } , & applist { } , ) scheme . addknowntypes ( schemegroupversion , & metav1 . status { } , ) metav1 . addtogroupversion ( scheme , schemegroupversion ) return nil } 
func samlmetadata ( w http . responsewriter , r * http . request ) error { if app . authscheme . name ( ) ! = " " { return & errors . http { code : http . statusbadrequest , message : " " , } } page , err : = saml . metadata ( ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) w . write ( [ ] byte ( page ) ) return nil } 
func samlcallbacklogin ( w http . responsewriter , r * http . request ) error { if app . authscheme . name ( ) ! = " " { return & errors . http { code : http . statusbadrequest , message : " " , } } params : = map [ string ] string { } content : = r . postformvalue ( " " ) if content == " " { return & errors . http { code : http . statusbadrequest , message : " " } } params [ " " ] = " " params [ " " ] = content scheme , : = auth . getscheme ( " " ) , err : = scheme . login ( params ) if err ! = nil { msg : = fmt . sprintf ( cmd . samlcallbackfailuremessage ( ) , err . error ( ) ) fmt . fprint ( w , msg ) } else { fmt . fprint ( w , cmd . samlcallbacksuccessmessage ( ) ) } return nil } 
func volumeslist ( w http . responsewriter , r * http . request , t auth . token ) error { contexts : = permission . contextsforpermission ( t , permission . permvolumeread ) if len ( contexts ) == 0 { w . writeheader ( http . statusnocontent ) return nil } volumes , err : = volume . listbyfilter ( volumefilterbycontext ( contexts ) ) if err ! = nil { return err } if len ( volumes ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( volumes ) } 
func volumeinfo ( w http . responsewriter , r * http . request , t auth . token ) error { v , err : = volume . load ( r . url . query ( ) . get ( " " ) ) if err ! = nil { if err == volume . errvolumenotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } canread : = permission . check ( t , permission . permvolumeread , contextsforvolume ( v ) ... ) if ! canread { return permission . errunauthorized } , err = v . loadbinds ( ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( & v ) } 
func volumecreate ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { var inputvolume volume . volume err = parseinput ( r , & inputvolume ) if err ! = nil { return err } inputvolume . plan . opts = nil inputvolume . status = " " cancreate : = permission . check ( t , permission . permvolumecreate , permission . context ( permtypes . ctxteam , inputvolume . teamowner ) , permission . context ( permtypes . ctxpool , inputvolume . pool ) , ) if ! cancreate { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypevolume , value : inputvolume . name } , kind : permission . permvolumecreate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permvolumereadevents , contextsforvolume ( & inputvolume ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) , err = volume . load ( inputvolume . name ) if err == nil { return & errors . http { code : http . statusconflict , message : " " } } err = inputvolume . create ( ) if err ! = nil { return err } w . writeheader ( http . statuscreated ) return nil } 
func volumeupdate ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { var inputvolume volume . volume err = parseinput ( r , & inputvolume ) if err ! = nil { return err } inputvolume . plan . opts = nil inputvolume . status = " " inputvolume . name = r . url . query ( ) . get ( " " ) dbvolume , err : = volume . load ( inputvolume . name ) if err ! = nil { if err == volume . errvolumenotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } canupdate : = permission . check ( t , permission . permvolumeupdate , contextsforvolume ( dbvolume ) ... ) if ! canupdate { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypevolume , value : inputvolume . name } , kind : permission . permvolumeupdate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permvolumereadevents , contextsforvolume ( dbvolume ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) return inputvolume . update ( ) } 
func volumeplanslist ( w http . responsewriter , r * http . request , t auth . token ) error { contexts : = permission . contextsforpermission ( t , permission . permvolumecreate ) if len ( contexts ) == 0 { return permission . errunauthorized } plansprovisioners , err : = volume . listplans ( ) if err ! = nil { return err } if len ( plansprovisioners ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( plansprovisioners ) } 
func volumedelete ( w http . responsewriter , r * http . request , t auth . token ) error { volumename : = r . url . query ( ) . get ( " " ) dbvolume , err : = volume . load ( volumename ) if err ! = nil { if err == volume . errvolumenotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } candelete : = permission . check ( t , permission . permvolumedelete , contextsforvolume ( dbvolume ) ... ) if ! candelete { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypevolume , value : volumename } , kind : permission . permvolumedelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permvolumereadevents , contextsforvolume ( dbvolume ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) return dbvolume . delete ( ) } 
func autoscalegetconfig ( w http . responsewriter , r * http . request , t auth . token ) error { allowedgetconfig : = permission . check ( t , permission . permnodeautoscaleread ) if ! allowedgetconfig { return permission . errunauthorized } config , err : = autoscale . currentconfig ( ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( config ) } 
func autoscalelistrules ( w http . responsewriter , r * http . request , t auth . token ) error { allowedlistrule : = permission . check ( t , permission . permnodeautoscaleread ) if ! allowedlistrule { return permission . errunauthorized } rules , err : = autoscale . listrules ( ) if err ! = nil { return err } if len ( rules ) == 0 { w . writeheader ( http . statusnocontent ) return nil } return json . newencoder ( w ) . encode ( & rules ) } 
func autoscalesetrule ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { allowedsetrule : = permission . check ( t , permission . permnodeautoscaleupdate ) if ! allowedsetrule { return permission . errunauthorized } var rule autoscale . rule err = parseinput ( r , & rule ) if err ! = nil { return err } var ctxs [ ] permtypes . permissioncontext if rule . metadatafilter ! = " " { ctxs = append ( ctxs , permission . context ( permtypes . ctxpool , rule . metadatafilter ) ) } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : rule . metadatafilter } , kind : permission . permnodeautoscaleupdate , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permpoolreadevents , ctxs ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) return rule . update ( ) } 
func autoscaledeleterule ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { alloweddeleterule : = permission . check ( t , permission . permnodeautoscale ) if ! alloweddeleterule { return permission . errunauthorized } rulepool : = r . url . query ( ) . get ( " " ) var ctxs [ ] permtypes . permissioncontext if rulepool ! = " " { ctxs = append ( ctxs , permission . context ( permtypes . ctxpool , rulepool ) ) } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool , value : rulepool } , kind : permission . permnodeautoscaledelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permpoolreadevents , ctxs ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = autoscale . deleterule ( rulepool ) if err == mgo . errnotfound { return & tsuruerrors . http { code : http . statusnotfound , message : " " } } return nil } 
func autoscalehistoryhandler ( w http . responsewriter , r * http . request , t auth . token ) error { if ! permission . check ( t , permission . permnodeautoscale ) { return permission . errunauthorized } skip , : = strconv . atoi ( r . url . query ( ) . get ( " " ) ) limit , : = strconv . atoi ( r . url . query ( ) . get ( " " ) ) history , err : = autoscale . listautoscaleevents ( skip , limit ) if err ! = nil { return err } if len ( history ) == 0 { w . writeheader ( http . statusnocontent ) return nil } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( & history ) } 
func autoscalerunhandler ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { if ! permission . check ( t , permission . permnodeautoscaleupdaterun ) { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : event . target { type : event . targettypepool } , kind : permission . permnodeautoscaleupdaterun , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , disablelock : true , allowed : event . allowed ( permission . permpoolreadevents ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) w . header ( ) . set ( " " , " " ) w . writeheader ( http . statusok ) keepalivewriter : = tsuruio . newkeepalivewriter ( w , 15 * time . second , " " ) defer keepalivewriter . stop ( ) writer : = & tsuruio . simplejsonmessageencoderwriter { encoder : json . newencoder ( keepalivewriter ) , } return autoscale . runonce ( writer ) } 
func serviceinstancestatus ( w http . responsewriter , r * http . request , t auth . token ) error { instancename : = r . url . query ( ) . get ( " " ) servicename : = r . url . query ( ) . get ( " " ) serviceinstance , err : = getserviceinstanceorerror ( servicename , instancename ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceinstancereadstatus , contextsforserviceinstance ( serviceinstance , servicename ) ... , ) if ! allowed { return permission . errunauthorized } var b string requestid : = requestidheader ( r ) if b , err = serviceinstance . status ( requestid ) ; err ! = nil { return errors . wrap ( err , " " ) } , err = fmt . fprintf ( w , ' service instance " %s " is %s ' , instancename , b ) return err } 
func serviceinstance ( w http . responsewriter , r * http . request , t auth . token ) error { instancename : = r . url . query ( ) . get ( " " ) servicename : = r . url . query ( ) . get ( " " ) svc , err : = getservice ( servicename ) if err ! = nil { return err } serviceinstance , err : = getserviceinstanceorerror ( servicename , instancename ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceinstanceread , contextsforserviceinstance ( serviceinstance , servicename ) ... , ) if ! allowed { return permission . errunauthorized } requestid : = requestidheader ( r ) info , err : = serviceinstance . info ( requestid ) if err ! = nil { return err } plan , err : = service . getplanbyserviceandplanname ( svc , serviceinstance . planname , requestid ) if err ! = nil { return err } sinfo : = serviceinstanceinfo { apps : serviceinstance . apps , teams : serviceinstance . teams , teamowner : serviceinstance . teamowner , description : serviceinstance . description , planname : plan . name , plandescription : plan . description , custominfo : info , tags : serviceinstance . tags , } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( sinfo ) } 
func serviceinfo ( w http . responsewriter , r * http . request , t auth . token ) error { servicename : = r . url . query ( ) . get ( " " ) , err : = getservice ( servicename ) if err ! = nil { return err } contexts : = permission . contextsforpermission ( t , permission . permserviceinstanceread ) instances , err : = readableinstances ( t , contexts , " " , servicename ) if err ! = nil { return err } var result [ ] service . serviceinstancewithinfo for , instance : = range instances { infodata , err : = instance . toinfo ( ) if err ! = nil { return err } result = append ( result , infodata ) } return json . newencoder ( w ) . encode ( result ) } 
func servicedoc ( w http . responsewriter , r * http . request , t auth . token ) error { servicename : = r . url . query ( ) . get ( " " ) s , err : = getservice ( servicename ) if err ! = nil { return err } if s . isrestricted { allowed : = permission . check ( t , permission . permservicereaddoc , contextsforservice ( & s ) ... , ) if ! allowed { return permission . errunauthorized } } w . write ( [ ] byte ( s . doc ) ) return nil } 
func serviceplans ( w http . responsewriter , r * http . request , t auth . token ) error { servicename : = r . url . query ( ) . get ( " " ) s , err : = getservice ( servicename ) if err ! = nil { return err } if s . isrestricted { allowed : = permission . check ( t , permission . permservicereadplans , contextsforservice ( & s ) ... , ) if ! allowed { return permission . errunauthorized } } requestid : = requestidheader ( r ) plans , err : = service . getplansbyservice ( s , requestid ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( plans ) } 
func serviceinstanceproxy ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { servicename : = r . url . query ( ) . get ( " " ) instancename : = r . url . query ( ) . get ( " " ) serviceinstance , err : = getserviceinstanceorerror ( servicename , instancename ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceinstanceupdateproxy , contextsforserviceinstance ( serviceinstance , servicename ) ... , ) if ! allowed { return permission . errunauthorized } path : = r . url . query ( ) . get ( " " ) var evt * event . event if r . method ! = http . methodget && r . method ! = http . methodhead { evt , err = event . new ( & event . opts { target : serviceinstancetarget ( servicename , instancename ) , kind : permission . permserviceinstanceupdateproxy , owner : t , customdata : append ( event . formtocustomdata ( inputfields ( r ) ) , map [ string ] interface { } { " " : " " , " " : r . method , } ) , allowed : event . allowed ( permission . permserviceinstancereadevents , contextsforserviceinstance ( serviceinstance , servicename ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) } return service . proxyinstance ( serviceinstance , path , evt , requestidheader ( r ) , w , r ) } 
func serviceinstancegrantteam ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { instancename : = r . url . query ( ) . get ( " " ) servicename : = r . url . query ( ) . get ( " " ) serviceinstance , err : = getserviceinstanceorerror ( servicename , instancename ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permserviceinstanceupdategrant , contextsforserviceinstance ( serviceinstance , servicename ) ... , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : serviceinstancetarget ( servicename , instancename ) , kind : permission . permserviceinstanceupdategrant , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permserviceinstancereadevents , contextsforserviceinstance ( serviceinstance , servicename ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) teamname : = r . url . query ( ) . get ( " " ) return serviceinstance . grant ( teamname ) } 
func register ( s shutdownable ) { lock . lock ( ) defer lock . unlock ( ) registered = append ( registered , s ) } 
func do ( ctx context . context , w io . writer ) error { lock . lock ( ) defer lock . unlock ( ) done : = make ( chan bool ) wg : = sync . waitgroup { } for , h : = range registered { wg . add ( 1 ) go func ( h shutdownable ) { defer wg . done ( ) var name string if , ok : = h . ( fmt . stringer ) ; ok { name = fmt . sprintf ( " " , h ) } else { name = fmt . sprintf ( " " , h ) } fmt . fprintf ( w , " \n " , name ) err : = h . shutdown ( ctx ) if err ! = nil { fmt . fprintf ( w , " " , name , err ) return } fmt . fprintf ( w , " \n " , name ) } ( h ) } go func ( ) { wg . wait ( ) close ( done ) } ( ) select { case < - ctx . done ( ) : return ctx . err ( ) case < - done : } return nil } 
func ( s * platformimageservice ) listimagesordefault ( platformname string ) ( [ ] string , error ) { imgs , err : = s . listimages ( platformname ) if err ! = nil && err == imagetypes . errplatformimagenotfound { return [ ] string { platformbasicimagename ( platformname ) } , nil } return imgs , err } 
func ( c * endpointclient ) info ( instance * serviceinstance , requestid string ) ( [ ] map [ string ] string , error ) { log . debugf ( " " , instance . name , instance . servicename ) url : = " " + instance . getidentifier ( ) resp , err : = c . issuerequest ( url , " " , nil , requestid ) if err ! = nil { return nil , err } defer resp . body . close ( ) if resp . statuscode ! = http . statusok { return nil , nil } result : = [ ] map [ string ] string { } err = c . jsonfromresponse ( resp , & result ) if err ! = nil { return nil , err } return result , nil } 
func ( c * endpointclient ) plans ( requestid string ) ( [ ] plan , error ) { url : = " " resp , err : = c . issuerequest ( url , " " , nil , requestid ) if err ! = nil { return nil , err } defer resp . body . close ( ) if resp . statuscode ! = http . statusok { return nil , nil } result : = [ ] plan { } err = c . jsonfromresponse ( resp , & result ) if err ! = nil { return nil , err } return result , nil } 
func ( c * endpointclient ) proxy ( path string , evt * event . event , requestid string , w http . responsewriter , r * http . request ) error { rawurl : = strings . trimright ( c . endpoint , " " ) + " " + strings . trim ( path , " " ) url , err : = url . parse ( rawurl ) if err ! = nil { log . errorf ( " " , rawurl , err ) return err } director : = func ( req * http . request ) { if evt ! = nil { req . header . set ( " " , evt . owner . name ) req . header . set ( " " , evt . uniqueid . hex ( ) ) } requestidheader , err : = config . getstring ( " " ) if err == nil && requestid ! = " " && requestidheader ! = " " { req . header . set ( requestidheader , requestid ) } req . setbasicauth ( c . username , c . password ) req . host = url . host req . url = url } proxy : = & httputil . reverseproxy { director : director } proxy . servehttp ( w , r ) return nil } 
func migrateappscrds ( ) error { config . set ( " " , false ) defer config . unset ( " " ) prov : = kubernetes . getprovisioner ( ) pools , err : = pool . listallpools ( ) if err ! = nil { return errors . wrap ( err , " " ) } var kubepools [ ] string for , p : = range pools { if p . provisioner == prov . getname ( ) { kubepools = append ( kubepools , p . name ) } } apps , err : = app . list ( & app . filter { pools : kubepools } ) if err ! = nil { return errors . wrap ( err , " " ) } multierr : = tsuruerrors . newmultierror ( ) for , a : = range apps { errprov : = prov . provision ( & a ) if errprov ! = nil { multierr . add ( errprov ) } } return multierr . toerror ( ) } 
func register ( name string , fn migratefunc ) error { return register ( name , false , fn ) } 
func registeroptional ( name string , fn migratefunc ) error { return register ( name , true , fn ) } 
func run ( args runargs ) error { if args . name ! = " " { return runoptional ( args ) } if args . force { return errcannotforcemandatory } return run ( args ) } 
func ( app * app ) units ( ) ( [ ] provision . unit , error ) { prov , err : = app . getprovisioner ( ) if err ! = nil { return [ ] provision . unit { } , err } units , err : = prov . units ( app ) if units == nil { units = [ ] provision . unit { } } return units , err } 
func acquireapplicationlock ( appname string , owner string , reason string ) ( bool , error ) { return acquireapplicationlockwait ( appname , owner , reason , 0 ) } 
func acquireapplicationlockwait ( appname string , owner string , reason string , timeout time . duration ) ( bool , error ) { timeoutchan : = time . after ( timeout ) for { applock : = apptypes . applock { locked : true , reason : reason , owner : owner , acquiredate : time . now ( ) . in ( time . utc ) , } conn , err : = db . conn ( ) if err ! = nil { return false , err } err = conn . apps ( ) . update ( bson . m { " " : appname , " " : bson . m { " " : [ ] interface { } { false , nil } } } , bson . m { " " : bson . m { " " : applock } } ) conn . close ( ) if err == nil { return true , nil } if err ! = mgo . errnotfound { return false , err } select { case < - timeoutchan : return false , nil case < - time . after ( 300 * time . millisecond ) : } } } 
func releaseapplicationlock ( appname string ) { var err error retries : = 3 for i : = 0 ; i < retries ; i ++ { err = releaseapplicationlockonce ( appname ) if err == nil { return } time . sleep ( time . second * time . duration ( i + 1 ) ) } log . error ( err ) } 
func getbyname ( name string ) ( * app , error ) { var app app conn , err : = db . conn ( ) if err ! = nil { return nil , err } defer conn . close ( ) err = conn . apps ( ) . find ( bson . m { " " : name } ) . one ( & app ) if err == mgo . errnotfound { return nil , apptypes . errappnotfound } return & app , err } 
func ( app * app ) unbind ( evt * event . event , requestid string ) error { instances , err : = service . getserviceinstancesboundtoapp ( app . name ) if err ! = nil { return err } var msg string var addmsg = func ( instancename string , reason error ) { if msg == " " { msg = " \n " } msg += fmt . sprintf ( " " , instancename , reason . error ( ) ) } for , instance : = range instances { err = instance . unbindapp ( service . unbindappargs { app : app , restart : false , forceremove : true , event : evt , requestid : requestid , } ) if err ! = nil { addmsg ( instance . name , err ) } } if msg ! = " " { return errors . new ( msg ) } return nil } 
func ( app * app ) addunits ( n uint , process string , w io . writer ) error { if n == 0 { return errors . new ( " " ) } units , err : = app . units ( ) if err ! = nil { return err } for , u : = range units { if ( u . status == provision . statusasleep ) | | ( u . status == provision . statusstopped ) { return errors . new ( " " ) } } w = app . withlogwriter ( w ) err = action . newpipeline ( & reserveunitstoadd , & provisionaddunits , ) . execute ( app , n , w , process ) rebuild . routesrebuildorenqueue ( app . name ) quotaerr : = app . fixquota ( ) if err ! = nil { return err } return quotaerr } 
func ( app * app ) removeunits ( n uint , process string , w io . writer ) error { prov , err : = app . getprovisioner ( ) if err ! = nil { return err } w = app . withlogwriter ( w ) err = prov . removeunits ( app , n , process , w ) rebuild . routesrebuildorenqueue ( app . name ) quotaerr : = app . fixquota ( ) if err ! = nil { return err } return quotaerr } 
func ( app * app ) setunitstatus ( unitname string , status provision . status ) error { units , err : = app . units ( ) if err ! = nil { return err } for , unit : = range units { if strings . hasprefix ( unit . id , unitname ) { prov , err : = app . getprovisioner ( ) if err ! = nil { return err } unitprov , ok : = prov . ( provision . unitstatusprovisioner ) if ! ok { return nil } return unitprov . setunitstatus ( unit , status ) } } return & provision . unitnotfounderror { id : unitname } } 
func ( app * app ) available ( ) bool { units , err : = app . units ( ) if err ! = nil { return false } for , unit : = range units { if unit . available ( ) { return true } } return false } 
func ( app * app ) grant ( team * authtypes . team ) error { if , found : = app . findteam ( team ) ; found { return erralreadyhaveaccess } app . teams = append ( app . teams , team . name ) conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) err = conn . apps ( ) . update ( bson . m { " " : app . name } , bson . m { " " : bson . m { " " : team . name } } ) if err ! = nil { return err } users , err : = auth . listuserswithpermissions ( permission . permission { scheme : permission . permappdeploy , context : permission . context ( permtypes . ctxteam , team . name ) , } ) if err ! = nil { conn . apps ( ) . update ( bson . m { " " : app . name } , bson . m { " " : bson . m { " " : team . name } } ) return err } for , user : = range users { err = repository . manager ( ) . grantaccess ( app . name , user . email ) if err ! = nil { conn . apps ( ) . update ( bson . m { " " : app . name } , bson . m { " " : bson . m { " " : team . name } } ) return err } } return nil } 
func ( app * app ) getteams ( ) [ ] authtypes . team { t , : = servicemanager . team . findbynames ( app . teams ) return t } 
func ( app * app ) setenv ( env bind . envvar ) { if app . env == nil { app . env = make ( map [ string ] bind . envvar ) } app . env [ env . name ] = env if env . public { app . log ( fmt . sprintf ( " " , env . name , env . value ) , " " , " " ) } } 
func ( app * app ) getenv ( name string ) ( bind . envvar , error ) { if env , ok : = app . env [ name ] ; ok { return env , nil } return bind . envvar { } , errors . new ( " " ) } 
func ( app * app ) validatenew ( ) error { if app . name == internalappname | | ! validation . validatename ( app . name ) { msg : = " " + " " + " " return & tsuruerrors . validationerror { message : msg } } return app . validate ( ) } 
func ( app * app ) validate ( ) error { err : = app . validatepool ( ) if err ! = nil { return err } return app . validateplan ( ) } 
func ( app * app ) instanceenvs ( servicename , instancename string ) map [ string ] bind . envvar { envs : = make ( map [ string ] bind . envvar ) for , env : = range app . serviceenvs { if env . servicename == servicename && env . instancename == instancename { envs [ env . name ] = env . envvar } } return envs } 
func ( app * app ) run ( cmd string , w io . writer , args provision . runargs ) error { if ! args . isolated && ! app . available ( ) { return errors . new ( " " ) } app . log ( fmt . sprintf ( " " , cmd ) , " " , " " ) logwriter : = logwriter { app : app , source : " " } logwriter . async ( ) defer logwriter . close ( ) return app . run ( cmd , io . multiwriter ( w , & logwriter ) , args ) } 
func ( app * app ) getunits ( ) ( [ ] bind . unit , error ) { provunits , err : = app . units ( ) if err ! = nil { return nil , err } units : = make ( [ ] bind . unit , len ( provunits ) ) for i : = range provunits { units [ i ] = & provunits [ i ] } return units , nil } 
func ( app * app ) getuuid ( ) ( string , error ) { if app . uuid ! = " " { return app . uuid , nil } uuidv4 , err : = uuid . newv4 ( ) if err ! = nil { return " " , errors . withmessage ( err , " " ) } conn , err : = db . conn ( ) if err ! = nil { return " " , err } defer conn . close ( ) err = conn . apps ( ) . update ( bson . m { " " : app . name } , bson . m { " " : bson . m { " " : uuidv4 . string ( ) } } ) if err ! = nil { return " " , err } app . uuid = uuidv4 . string ( ) return app . uuid , nil } 
func ( app * app ) envs ( ) map [ string ] bind . envvar { mergedenvs : = make ( map [ string ] bind . envvar , len ( app . env ) + len ( app . serviceenvs ) + 1 ) for , e : = range app . env { mergedenvs [ e . name ] = e } for , e : = range app . serviceenvs { mergedenvs [ e . name ] = e . envvar } mergedenvs [ tsuruservicesenvvar ] = serviceenvsfromenvvars ( app . serviceenvs ) return mergedenvs } 
func ( app * app ) setenvs ( setenvs bind . setenvargs ) error { if len ( setenvs . envs ) == 0 { return nil } for , env : = range setenvs . envs { err : = validateenv ( env . name ) if err ! = nil { return err } } if setenvs . writer ! = nil { fmt . fprintf ( setenvs . writer , " \n " , len ( setenvs . envs ) ) } for , env : = range setenvs . envs { app . setenv ( env ) } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) err = conn . apps ( ) . update ( bson . m { " " : app . name } , bson . m { " " : bson . m { " " : app . env } } ) if err ! = nil { return err } if setenvs . shouldrestart { return app . restartifunits ( setenvs . writer ) } return nil } 
func ( app * app ) unsetenvs ( unsetenvs bind . unsetenvargs ) error { if len ( unsetenvs . variablenames ) == 0 { return nil } if unsetenvs . writer ! = nil { fmt . fprintf ( unsetenvs . writer , " \n " , len ( unsetenvs . variablenames ) ) } for , name : = range unsetenvs . variablenames { delete ( app . env , name ) } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) err = conn . apps ( ) . update ( bson . m { " " : app . name } , bson . m { " " : bson . m { " " : app . env } } ) if err ! = nil { return err } if unsetenvs . shouldrestart { return app . restartifunits ( unsetenvs . writer ) } return nil } 
func ( app * app ) addcname ( cnames ... string ) error { actions : = [ ] * action . action { & validatenewcnames , & setnewcnamestoprovisioner , & savecnames , & updateapp , } err : = action . newpipeline ( actions ... ) . execute ( app , cnames ) rebuild . routesrebuildorenqueue ( app . name ) return err } 
func ( app * app ) log ( message , source , unit string ) error { messages : = strings . split ( message , " \n " ) logs : = make ( [ ] interface { } , 0 , len ( messages ) ) for , msg : = range messages { if msg ! = " " { l : = applog { date : time . now ( ) . in ( time . utc ) , message : msg , source : source , appname : app . name , unit : unit , } logs = append ( logs , l ) } } if len ( logs ) > 0 { conn , err : = db . logconn ( ) if err ! = nil { return err } defer conn . close ( ) return conn . applogcollection ( app . name ) . insert ( logs ... ) } return nil } 
func ( app * app ) lastlogs ( lines int , filterlog applog ) ( [ ] applog , error ) { return app . lastlogs ( lines , filterlog , false ) } 
func swap ( app1 , app2 * app , cnameonly bool ) error { a1routers : = app1 . getrouters ( ) a2routers : = app2 . getrouters ( ) if len ( a1routers ) ! = 1 | | len ( a2routers ) ! = 1 { return errors . new ( " " ) } r1 , err : = router . get ( a1routers [ 0 ] . name ) if err ! = nil { return err } r2 , err : = router . get ( a2routers [ 0 ] . name ) if err ! = nil { return err } defer func ( app1 , app2 * app ) { rebuild . routesrebuildorenqueue ( app1 . name ) rebuild . routesrebuildorenqueue ( app2 . name ) app1 . getrouterswithaddr ( ) app2 . getrouterswithaddr ( ) } ( app1 , app2 ) err = r1 . swap ( app1 . name , app2 . name , cnameonly ) if err ! = nil { return err } conn , err : = db . conn ( ) if err ! = nil { return err } defer conn . close ( ) app1 . cname , app2 . cname = app2 . cname , app1 . cname updatecname : = func ( app * app , r router . router ) error { return conn . apps ( ) . update ( bson . m { " " : app . name } , bson . m { " " : bson . m { " " : app . cname } } , ) } err = updatecname ( app1 , r1 ) if err ! = nil { return err } return updatecname ( app2 , r2 ) } 
func ( app * app ) start ( w io . writer , process string ) error { w = app . withlogwriter ( w ) msg : = fmt . sprintf ( " \n " , process ) if process == " " { msg = fmt . sprintf ( " \n " , app . name ) } fmt . fprintf ( w , " \n " , msg ) prov , err : = app . getprovisioner ( ) if err ! = nil { return err } err = prov . start ( app , process ) if err ! = nil { log . errorf ( " " , app . name , err ) return err } rebuild . routesrebuildorenqueue ( app . name ) return err } 
func getdbdriver ( name string ) ( * dbdriver , error ) { driver , ok : = dbdrivers [ name ] if ! ok { return nil , errors . errorf ( " " , name ) } return & driver , nil } 
func getcurrentdbdriver ( ) ( * dbdriver , error ) { driverlock . rlock ( ) if currentdbdriver ! = nil { driverlock . runlock ( ) return currentdbdriver , nil } driverlock . runlock ( ) driverlock . lock ( ) defer driverlock . unlock ( ) if currentdbdriver ! = nil { return currentdbdriver , nil } dbdrivername , err : = config . getstring ( " " ) if err ! = nil | | dbdrivername == " " { dbdrivername = defaultdbdrivername } currentdbdriver , err = getdbdriver ( dbdrivername ) if err ! = nil { return nil , err } return currentdbdriver , nil } 
func info ( w http . responsewriter , r * http . request ) error { data : = map [ string ] string { } data [ " " ] = version w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( data ) } 
func proxy ( service * service , path string , evt * event . event , requestid string , w http . responsewriter , r * http . request ) error { endpoint , err : = service . getclient ( " " ) if err ! = nil { return err } return endpoint . proxy ( path , evt , requestid , w , r ) } 
func appdelete ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { a , err : = getappfromcontext ( r . url . query ( ) . get ( " " ) , r ) if err ! = nil { return err } candelete : = permission . check ( t , permission . permappdelete , contextsforapp ( & a ) ... , ) if ! candelete { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : apptarget ( a . name ) , kind : permission . permappdelete , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) keepalivewriter : = tsuruio . newkeepalivewriter ( w , 30 * time . second , " " ) defer keepalivewriter . stop ( ) writer : = & tsuruio . simplejsonmessageencoderwriter { encoder : json . newencoder ( keepalivewriter ) } evt . setlogwriter ( writer ) w . header ( ) . set ( " " , " " ) return app . delete ( & a , evt , requestidheader ( r ) ) } 
func appinfo ( w http . responsewriter , r * http . request , t auth . token ) error { a , err : = getappfromcontext ( r . url . query ( ) . get ( " " ) , r ) if err ! = nil { return err } canread : = permission . check ( t , permission . permappread , contextsforapp ( & a ) ... , ) if ! canread { return permission . errunauthorized } err = a . fillinternaladdresses ( r . context ( ) ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( & a ) } 
func setunitstatus ( w http . responsewriter , r * http . request , t auth . token ) error { unitname : = r . url . query ( ) . get ( " " ) if unitname == " " { return & errors . http { code : http . statusbadrequest , message : " " , } } poststatus : = inputvalue ( r , " " ) status , err : = provision . parsestatus ( poststatus ) if err ! = nil { return & errors . http { code : http . statusbadrequest , message : err . error ( ) , } } appname : = r . url . query ( ) . get ( " " ) a , err : = app . getbyname ( appname ) if err ! = nil { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } allowed : = permission . check ( t , permission . permappupdateunitstatus , contextsforapp ( a ) ... , ) if ! allowed { return permission . errunauthorized } err = a . setunitstatus ( unitname , status ) if , ok : = err . ( * provision . unitnotfounderror ) ; ok { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } 
func setnodestatus ( w http . responsewriter , r * http . request , t auth . token ) error { if t . getappname ( ) ! = app . internalappname { return & errors . http { code : http . statusforbidden , message : " " } } var hostinput provision . nodestatusdata err : = parseinput ( r , & hostinput ) if err ! = nil { return err } result , err : = app . updatenodestatus ( hostinput ) if err ! = nil { if err == provision . errnodenotfound { return & errors . http { code : http . statusnotfound , message : err . error ( ) } } return err } w . header ( ) . add ( " " , " " ) return json . newencoder ( w ) . encode ( result ) } 
func grantappaccess ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { appname : = r . url . query ( ) . get ( " " ) teamname : = r . url . query ( ) . get ( " " ) a , err : = getappfromcontext ( appname , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappupdategrant , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : apptarget ( appname ) , kind : permission . permappupdategrant , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) team , err : = servicemanager . team . findbyname ( teamname ) if err ! = nil { return & errors . http { code : http . statusnotfound , message : " " } } err = a . grant ( team ) if err == app . erralreadyhaveaccess { return & errors . http { code : http . statusconflict , message : err . error ( ) } } return err } 
func getenv ( w http . responsewriter , r * http . request , t auth . token ) error { var variables [ ] string if envs , ok : = r . url . query ( ) [ " " ] ; ok { variables = envs } appname : = r . url . query ( ) . get ( " " ) a , err : = getappfromcontext ( appname , r ) if err ! = nil { return err } if ! t . isapptoken ( ) { allowed : = permission . check ( t , permission . permappreadenv , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } } return writeenvvars ( w , & a , variables ... ) } 
func setcname ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { cnamemsg : = " " cnames , : = inputvalues ( r , " " ) if len ( cnames ) == 0 { return & errors . http { code : http . statusbadrequest , message : cnamemsg } } appname : = r . url . query ( ) . get ( " " ) a , err : = getappfromcontext ( appname , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappupdatecnameadd , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : apptarget ( appname ) , kind : permission . permappupdatecnameadd , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) if err = a . addcname ( cnames ... ) ; err == nil { return nil } if err . error ( ) == " " { return & errors . http { code : http . statusbadrequest , message : err . error ( ) } } return err } 
func restart ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { process : = inputvalue ( r , " " ) appname : = r . url . query ( ) . get ( " " ) a , err : = getappfromcontext ( appname , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappupdaterestart , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : apptarget ( appname ) , kind : permission . permappupdaterestart , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) w . header ( ) . set ( " " , " " ) keepalivewriter : = tsuruio . newkeepalivewriter ( w , 30 * time . second , " " ) defer keepalivewriter . stop ( ) writer : = & tsuruio . simplejsonmessageencoderwriter { encoder : json . newencoder ( keepalivewriter ) } evt . setlogwriter ( writer ) return a . restart ( process , evt ) } 
func addlog ( w http . responsewriter , r * http . request , t auth . token ) error { a , err : = app . getbyname ( r . url . query ( ) . get ( " " ) ) if err ! = nil { return err } if t . getappname ( ) ! = app . internalappname { allowed : = permission . check ( t , permission . permappupdatelog , contextsforapp ( a ) ... , ) if ! allowed { return permission . errunauthorized } } logs , : = inputvalues ( r , " " ) source : = inputvalue ( r , " " ) if source == " " { source = " " } unit : = inputvalue ( r , " " ) for , log : = range logs { err : = a . log ( log , source , unit ) if err ! = nil { return err } } return nil } 
func forcedeletelock ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { appname : = r . url . query ( ) . get ( " " ) a , err : = getappfromcontext ( appname , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappadminunlock , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } evt , err : = event . new ( & event . opts { target : apptarget ( appname ) , kind : permission . permappadminunlock , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) app . releaseapplicationlock ( a . name ) return nil } 
func appmetricenvs ( w http . responsewriter , r * http . request , t auth . token ) error { a , err : = getappfromcontext ( r . url . query ( ) . get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappreadmetric , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } w . header ( ) . set ( " " , " " ) metricmap , err : = a . metricenvs ( ) if err ! = nil { return err } return json . newencoder ( w ) . encode ( metricmap ) } 
func apprebuildroutes ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { a , err : = getappfromcontext ( r . url . query ( ) . get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappadminroutes , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } dry , : = strconv . parsebool ( inputvalue ( r , " " ) ) evt , err : = event . new ( & event . opts { target : apptarget ( a . name ) , kind : permission . permappadminroutes , owner : t , customdata : event . formtocustomdata ( inputfields ( r ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } result : = map [ string ] rebuild . rebuildroutesresult { } defer func ( ) { evt . donecustomdata ( err , result ) } ( ) w . header ( ) . set ( " " , " " ) result , err = rebuild . rebuildroutes ( & a , dry ) if err ! = nil { return err } return json . newencoder ( w ) . encode ( & result ) } 
func setcertificate ( w http . responsewriter , r * http . request , t auth . token ) ( err error ) { a , err : = getappfromcontext ( r . url . query ( ) . get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappupdatecertificateset , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } cname : = inputvalue ( r , " " ) certificate : = inputvalue ( r , " " ) key : = inputvalue ( r , " " ) if cname == " " { return & errors . http { code : http . statusbadrequest , message : " " } } evt , err : = event . new ( & event . opts { target : apptarget ( a . name ) , kind : permission . permappupdatecertificateset , owner : t , customdata : event . formtocustomdata ( inputfields ( r , " " ) ) , allowed : event . allowed ( permission . permappreadevents , contextsforapp ( & a ) ... ) , } ) if err ! = nil { return err } defer func ( ) { evt . done ( err ) } ( ) err = a . setcertificate ( cname , certificate , key ) if err ! = nil { return & errors . http { code : http . statusbadrequest , message : err . error ( ) } } return nil } 
func listcertificates ( w http . responsewriter , r * http . request , t auth . token ) error { a , err : = getappfromcontext ( r . url . query ( ) . get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . check ( t , permission . permappreadcertificate , contextsforapp ( & a ) ... , ) if ! allowed { return permission . errunauthorized } w . header ( ) . set ( " " , " " ) result , err : = a . getcertificates ( ) if err ! = nil { return err } return json . newencoder ( w ) . encode ( & result ) } 
func newforconfig ( c * rest . config ) ( * clientset , error ) { configshallowcopy : = * c if configshallowcopy . ratelimiter == nil && configshallowcopy . qps > 0 { configshallowcopy . ratelimiter = flowcontrol . newtokenbucketratelimiter ( configshallowcopy . qps , configshallowcopy . burst ) } var cs clientset var err error cs . tsuruv1 , err = tsuruv1 . newforconfig ( & configshallowcopy ) if err ! = nil { return nil , err } cs . discoveryclient , err = discovery . newdiscoveryclientforconfig ( & configshallowcopy ) if err ! = nil { glog . errorf ( " " , err ) return nil , err } return & cs , nil } 
func newforconfigordie ( c * rest . config ) * clientset { var cs clientset cs . tsuruv1 = tsuruv1 . newforconfigordie ( c ) cs . discoveryclient = discovery . newdiscoveryclientforconfigordie ( c ) return & cs } 
func new ( c rest . interface ) * clientset { var cs clientset cs . tsuruv1 = tsuruv1 . new ( c ) cs . discoveryclient = discovery . newdiscoveryclient ( c ) return & cs } 
func nodecontainerlist ( w http . responsewriter , r * http . request , t auth . token ) error { pools , err : = permission . listcontextvalues ( t , permission . permnodecontainerread , true ) if err ! = nil { return err } lst , err : = nodecontainer . allnodecontainers ( ) if err ! = nil { return err } if pools ! = nil { poolmap : = map [ string ] struct { } { } for , p : = range pools { poolmap [ p ] = struct { } { } } for i , entry : = range lst { for poolname : = range entry . configpools { if poolname == " " { continue } if , ok : = poolmap [ poolname ] ; ! ok { delete ( entry . configpools , poolname ) } } lst [ i ] = entry } } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( lst ) } 
func nodecontainerinfo ( w http . responsewriter , r * http . request , t auth . token ) error { pools , err : = permission . listcontextvalues ( t , permission . permnodecontainerread , true ) if err ! = nil { return err } name : = r . url . query ( ) . get ( " " ) configmap , err : = nodecontainer . loadnodecontainersforpools ( name ) if err ! = nil { if err == nodecontainer . errnodecontainernotfound { return & tsuruerrors . http { code : http . statusnotfound , message : err . error ( ) , } } return err } if pools ! = nil { poolmap : = map [ string ] struct { } { } for , p : = range pools { poolmap [ p ] = struct { } { } } for poolname : = range configmap { if poolname == " " { continue } if , ok : = poolmap [ poolname ] ; ! ok { delete ( configmap , poolname ) } } } w . header ( ) . set ( " " , " " ) return json . newencoder ( w ) . encode ( configmap ) } 
func ( p * dockerprovisioner ) getappfromunitid ( unitid string ) ( provision . app , error ) { cnt , err : = p . getcontainer ( unitid ) if err ! = nil { return nil , err } a , err : = app . getbyname ( cnt . appname ) if err ! = nil { return nil , err } return a , nil } 
func validatelength ( value string , min , max int ) bool { l : = len ( value ) if min > 0 && l < min { return false } if max > 0 && l > max { return false } return true } 
func newpipeline ( actions ... * action ) * pipeline { newactions : = make ( [ ] * action , len ( actions ) ) for i , action : = range actions { newaction : = & action { name : action . name , forward : action . forward , backward : action . backward , minparams : action . minparams , onerror : action . onerror , } newactions [ i ] = newaction } return & pipeline { actions : newactions } } 
func ( p * pipeline ) result ( ) result { action : = p . actions [ len ( p . actions ) - 1 ] action . rmutex . lock ( ) defer action . rmutex . unlock ( ) return action . result } 
func ( p * pipeline ) execute ( params ... interface { } ) ( err error ) { var r result if len ( p . actions ) == 0 { return errpipelinenoactions } fwctx : = fwcontext { params : params } var i int var a * action defer func ( ) { if r : = recover ( ) ; r ! = nil { log . errorf ( " " , a . name , r ) err = fmt . errorf ( " " , a . name , r ) if a . onerror ! = nil { a . onerror ( fwctx , err ) } p . rollback ( i - 1 , params ) } } ( ) for i , a = range p . actions { log . debugf ( " " , a . name ) if a . forward == nil { err = errpipelineforwardmissing } else if len ( fwctx . params ) < a . minparams { err = errpipelinefewparameters } else { r , err = a . forward ( fwctx ) a . rmutex . lock ( ) a . result = r a . rmutex . unlock ( ) fwctx . previous = r } if err ! = nil { log . errorf ( " " , a . name , err ) if a . onerror ! = nil { a . onerror ( fwctx , err ) } p . rollback ( i - 1 , params ) return err } } return nil } 
func map ( dst , src interface { } , opts ... func ( * config ) ) error { return map ( dst , src , opts ... ) } 
func mapwithoverwrite ( dst , src interface { } , opts ... func ( * config ) ) error { return map ( dst , src , append ( opts , withoverride ) ... ) } 
func merge ( dst , src interface { } , opts ... func ( * config ) ) error { return merge ( dst , src , opts ... ) } 
func mergewithoverwrite ( dst , src interface { } , opts ... func ( * config ) ) error { return merge ( dst , src , append ( opts , withoverride ) ... ) } 
func ( r * request ) decodejsonpayload ( v interface { } ) error { content , err : = ioutil . readall ( r . body ) r . body . close ( ) if err ! = nil { return err } if len ( content ) == 0 { return errjsonpayloadempty } err = json . unmarshal ( content , v ) if err ! = nil { return err } return nil } 
func ( r * request ) baseurl ( ) * url . url { scheme : = r . url . scheme if scheme == " " { scheme = " " } if scheme == " " && r . tls ! = nil { scheme = " " } host : = r . host if len ( host ) > 0 && host [ len ( host ) - 1 ] == ' / ' { host = host [ : len ( host ) - 1 ] } return & url . url { scheme : scheme , host : host , } } 
func ( r * request ) urlfor ( path string , queryparams map [ string ] [ ] string ) * url . url { baseurl : = r . baseurl ( ) baseurl . path = path if queryparams ! = nil { query : = url . values { } for k , v : = range queryparams { for , vv : = range v { query . add ( k , vv ) } } baseurl . rawquery = query . encode ( ) } return baseurl } 
func ( r * request ) getcorsinfo ( ) * corsinfo { origin : = r . header . get ( " " ) var originurl * url . url var iscors bool if origin == " " { iscors = false } else if origin == " " { iscors = true } else { var err error originurl , err = url . parserequesturi ( origin ) iscors = err == nil && r . host ! = originurl . host } reqmethod : = r . header . get ( " " ) reqheaders : = [ ] string { } rawreqheaders : = r . header [ http . canonicalheaderkey ( " " ) ] for , rawreqheader : = range rawreqheaders { if len ( rawreqheader ) == 0 { continue } for , reqheader : = range strings . split ( rawreqheader , " " ) { reqheaders = append ( reqheaders , http . canonicalheaderkey ( strings . trimspace ( reqheader ) ) ) } } ispreflight : = iscors && r . method == " " && reqmethod ! = " " return & corsinfo { iscors : iscors , ispreflight : ispreflight , origin : origin , originurl : originurl , accesscontrolrequestmethod : strings . toupper ( reqmethod ) , accesscontrolrequestheaders : reqheaders , } } 
func ( mw * recordermiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { return func ( w responsewriter , r * request ) { writer : = & recorderresponsewriter { w , 0 , false , 0 } h ( writer , r ) r . env [ " " ] = writer . statuscode r . env [ " " ] = writer . byteswritten } } 
func ( w * recorderresponsewriter ) writeheader ( code int ) { w . responsewriter . writeheader ( code ) if w . wroteheader { return } w . statuscode = code w . wroteheader = true } 
func ( w * recorderresponsewriter ) writejson ( v interface { } ) error { b , err : = w . encodejson ( v ) if err ! = nil { return err } , err = w . write ( b ) if err ! = nil { return err } return nil } 
func makerouter ( routes ... * route ) ( app , error ) { r : = & router { routes : routes , } err : = r . start ( ) if err ! = nil { return nil , err } return r , nil } 
func ( rt * router ) appfunc ( ) handlerfunc { return func ( writer responsewriter , request * request ) { route , params , pathmatched : = rt . findroutefromurl ( request . method , request . url ) if route == nil { if pathmatched { error ( writer , " " , http . statusmethodnotallowed ) return } notfound ( writer , request ) return } request . pathparams = params handler : = route . func handler ( writer , request ) } } 
func escapedpath ( urlobj * url . url ) string { parts : = strings . splitn ( urlobj . requesturi ( ) , " " , 2 ) return parts [ 0 ] } 
func escapedpathexp ( pathexp string ) ( string , error ) { if pathexp == " " { return " " , errors . new ( " " ) } if pathexp [ 0 ] ! = ' / ' { return " " , errors . new ( " " ) } if strings . contains ( pathexp , " " ) { return " " , errors . new ( " " ) } pathexp = preescape . replace ( pathexp ) urlobj , err : = url . parse ( pathexp ) if err ! = nil { return " " , err } pathexp = urlobj . requesturi ( ) pathexp = postescape . replace ( pathexp ) return pathexp , nil } 
func ( rt * router ) start ( ) error { rt . trie = trie . new ( ) rt . index = map [ * route ] int { } for i , route : = range rt . routes { pathexp , err : = escapedpathexp ( route . pathexp ) if err ! = nil { return err } err = rt . trie . addroute ( strings . toupper ( route . httpmethod ) , pathexp , route , ) if err ! = nil { return err } rt . index [ route ] = i } if rt . disabletriecompression == false { rt . trie . compress ( ) } return nil } 
func ( rt * router ) offirstdefinedroute ( matches [ ] * trie . match ) * trie . match { minindex : = - 1 var bestmatch * trie . match for , result : = range matches { route : = result . route . ( * route ) routeindex : = rt . index [ route ] if minindex == - 1 | | routeindex < minindex { minindex = routeindex bestmatch = result } } return bestmatch } 
func ( rt * router ) findroutefromurl ( httpmethod string , urlobj * url . url ) ( * route , map [ string ] string , bool ) { matches , pathmatched : = rt . trie . findroutesandpathmatched ( strings . toupper ( httpmethod ) , escapedpath ( urlobj ) , ) if len ( matches ) == 0 { return nil , nil , pathmatched } if len ( matches ) == 1 { return matches [ 0 ] . route . ( * route ) , matches [ 0 ] . params , pathmatched } result : = rt . offirstdefinedroute ( matches ) return result . route . ( * route ) , result . params , pathmatched } 
func ( rt * router ) findroute ( httpmethod , urlstr string ) ( * route , map [ string ] string , bool , error ) { urlobj , err : = url . parse ( urlstr ) if err ! = nil { return nil , nil , false , err } route , params , pathmatched : = rt . findroutefromurl ( httpmethod , urlobj ) return route , params , pathmatched , nil } 
func ( mw * contenttypecheckermiddleware ) middlewarefunc ( handler handlerfunc ) handlerfunc { return func ( w responsewriter , r * request ) { mediatype , params , : = mime . parsemediatype ( r . header . get ( " " ) ) charset , ok : = params [ " " ] if ! ok { charset = " " } if r . contentlength > 0 && ! ( mediatype == " " && strings . toupper ( charset ) == " " ) { error ( w , " " , http . statusunsupportedmediatype , ) return } handler ( w , r ) } } 
func ( mw * accesslogapachemiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { if mw . logger == nil { mw . logger = log . new ( os . stderr , " " , 0 ) } if mw . format == " " { mw . format = defaultlogformat } mw . convertformat ( ) return func ( w responsewriter , r * request ) { h ( w , r ) util : = & accesslogutil { w , r } mw . logger . print ( mw . executetexttemplate ( util ) ) } } 
func ( mw * accesslogapachemiddleware ) convertformat ( ) { tmpltext : = apacheadapter . replace ( string ( mw . format ) ) funcmap : = template . funcmap { " " : func ( value string ) string { if value == " " { return " " } return value } , " " : func ( value int64 ) string { if value == 0 { return " " } return fmt . sprintf ( " " , value ) } , " " : func ( dur * time . duration ) string { if dur ! = nil { return fmt . sprintf ( " " , dur . nanoseconds ( ) / 1000 ) } return " " } , " " : func ( statuscode int ) string { if statuscode >= 400 && statuscode < 500 { return " " } else if statuscode >= 500 { return " " } return " " } , } var err error mw . texttemplate , err = template . new ( " " ) . funcs ( funcmap ) . parse ( tmpltext ) if err ! = nil { panic ( err ) } } 
func ( mw * accesslogapachemiddleware ) executetexttemplate ( util * accesslogutil ) string { buf : = bytes . newbufferstring ( " " ) err : = mw . texttemplate . execute ( buf , util ) if err ! = nil { panic ( err ) } return buf . string ( ) } 
func ( u * accesslogutil ) remoteuser ( ) string { if u . r . env [ " " ] ! = nil { return u . r . env [ " " ] . ( string ) } return " " } 
func ( u * accesslogutil ) apachequerystring ( ) string { if u . r . url . rawquery ! = " " { return " " + u . r . url . rawquery } return " " } 
func ( u * accesslogutil ) starttime ( ) * time . time { if u . r . env [ " " ] ! = nil { return u . r . env [ " " ] . ( * time . time ) } return nil } 
func ( u * accesslogutil ) apacheremoteaddr ( ) string { remoteaddr : = u . r . remoteaddr if remoteaddr ! = " " { if ip , , err : = net . splithostport ( remoteaddr ) ; err == nil { return ip } } return " " } 
func ( u * accesslogutil ) statuscode ( ) int { if u . r . env [ " " ] ! = nil { return u . r . env [ " " ] . ( int ) } return 0 } 
func ( u * accesslogutil ) responsetime ( ) * time . duration { if u . r . env [ " " ] ! = nil { return u . r . env [ " " ] . ( * time . duration ) } return nil } 
func ( u * accesslogutil ) byteswritten ( ) int64 { if u . r . env [ " " ] ! = nil { return u . r . env [ " " ] . ( int64 ) } return 0 } 
func ( mw * jsonindentmiddleware ) middlewarefunc ( handler handlerfunc ) handlerfunc { if mw . indent == " " { mw . indent = " " } return func ( w responsewriter , r * request ) { writer : = & jsonindentresponsewriter { w , false , mw . prefix , mw . indent } handler ( writer , r ) } } 
func ( w * jsonindentresponsewriter ) encodejson ( v interface { } ) ( [ ] byte , error ) { b , err : = json . marshalindent ( v , w . prefix , w . indent ) if err ! = nil { return nil , err } return b , nil } 
func ( w * jsonindentresponsewriter ) writeheader ( code int ) { w . responsewriter . writeheader ( code ) w . wroteheader = true } 
func ( route * route ) makepath ( pathparams map [ string ] string ) string { path : = route . pathexp for paramname , paramvalue : = range pathparams { paramplaceholder : = " " + paramname relaxedplaceholder : = " " + paramname splatplaceholder : = " " + paramname r : = strings . newreplacer ( paramplaceholder , paramvalue , splatplaceholder , paramvalue , relaxedplaceholder , paramvalue ) path = r . replace ( path ) } return path } 
func head ( pathexp string , handlerfunc handlerfunc ) * route { return & route { httpmethod : " " , pathexp : pathexp , func : handlerfunc , } } 
func ( mw * recovermiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { if mw . logger == nil { mw . logger = log . new ( os . stderr , " " , 0 ) } return func ( w responsewriter , r * request ) { defer func ( ) { if reco : = recover ( ) ; reco ! = nil { trace : = debug . stack ( ) message : = fmt . sprintf ( " \n " , reco , trace ) mw . logerror ( message ) if mw . enableresponsestacktrace { error ( w , message , http . statusinternalservererror ) } else { error ( w , " " , http . statusinternalservererror ) } } } ( ) h ( w , r ) } } 
func wrapmiddlewares ( middlewares [ ] middleware , handler handlerfunc ) handlerfunc { wrapped : = handler for i : = len ( middlewares ) - 1 ; i >= 0 ; i -- { wrapped = middlewares [ i ] . middlewarefunc ( wrapped ) } return wrapped } 
func ( mw * timermiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { return func ( w responsewriter , r * request ) { start : = time . now ( ) r . env [ " " ] = & start h ( w , r ) end : = time . now ( ) elapsed : = end . sub ( start ) r . env [ " " ] = & elapsed } } 
func ( mw * gzipmiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { return func ( w responsewriter , r * request ) { cangzip : = strings . contains ( r . header . get ( " " ) , " " ) writer : = & gzipresponsewriter { w , false , cangzip , nil } defer func ( ) { if writer . gzipwriter ! = nil { writer . gzipwriter . close ( ) } } ( ) h ( writer , r ) } } 
func ( w * gzipresponsewriter ) writeheader ( code int ) { w . header ( ) . add ( " " , " " ) if w . cangzip { w . header ( ) . set ( " " , " " ) } w . responsewriter . writeheader ( code ) w . wroteheader = true } 
func ( mw * authbasicmiddleware ) middlewarefunc ( handler handlerfunc ) handlerfunc { if mw . realm == " " { log . fatal ( " " ) } if mw . authenticator == nil { log . fatal ( " " ) } if mw . authorizator == nil { mw . authorizator = func ( userid string , request * request ) bool { return true } } return func ( writer responsewriter , request * request ) { authheader : = request . header . get ( " " ) if authheader == " " { mw . unauthorized ( writer ) return } provideduserid , providedpassword , err : = mw . decodebasicauthheader ( authheader ) if err ! = nil { error ( writer , " " , http . statusbadrequest ) return } if ! mw . authenticator ( provideduserid , providedpassword ) { mw . unauthorized ( writer ) return } if ! mw . authorizator ( provideduserid , request ) { mw . unauthorized ( writer ) return } request . env [ " " ] = provideduserid handler ( writer , request ) } } 
func ( mw * ifmiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { if mw . condition == nil { log . fatal ( " " ) } var iftruehandler handlerfunc if mw . iftrue ! = nil { iftruehandler = mw . iftrue . middlewarefunc ( h ) } else { iftruehandler = h } var iffalsehandler handlerfunc if mw . iffalse ! = nil { iffalsehandler = mw . iffalse . middlewarefunc ( h ) } else { iffalsehandler = h } return func ( w responsewriter , r * request ) { if mw . condition ( r ) { iftruehandler ( w , r ) } else { iffalsehandler ( w , r ) } } } 
func ( n * node ) printdebug ( level int ) { level ++ if n . splatchild ! = nil { printfpadding ( level , " \n " ) n . splatchild . printdebug ( level ) } if n . paramchild ! = nil { printfpadding ( level , " \n " ) n . paramchild . printdebug ( level ) } if n . relaxedchild ! = nil { printfpadding ( level , " \n " ) n . relaxedchild . printdebug ( level ) } for key , node : = range n . children { printfpadding ( level , " " " \n " , key ) node . printdebug ( level ) } } 
func ( t * trie ) addroute ( httpmethod , pathexp string , route interface { } ) error { return t . root . addroute ( httpmethod , pathexp , route , [ ] string { } ) } 
func ( t * trie ) printdebug ( ) { fmt . print ( " \n " ) t . root . printdebug ( 0 ) fmt . print ( " \n " ) } 
func ( t * trie ) findroutesandpathmatched ( httpmethod , path string ) ( [ ] * match , bool ) { context : = newfindcontext ( ) pathmatched : = false matches : = [ ] * match { } context . matchfunc = func ( httpmethod , path string , node * node ) { pathmatched = true if node . httpmethodtoroute [ httpmethod ] ! = nil { matches = append ( matches , & match { route : node . httpmethodtoroute [ httpmethod ] , params : context . paramsasmap ( ) , } , ) } } t . root . find ( httpmethod , path , context ) return matches , pathmatched } 
func ( api * api ) use ( middlewares ... middleware ) { api . stack = append ( api . stack , middlewares ... ) } 
func ( mw * poweredbymiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { poweredby : = xpoweredbydefault if mw . xpoweredby ! = " " { poweredby = mw . xpoweredby } return func ( w responsewriter , r * request ) { w . header ( ) . add ( " " , poweredby ) h ( w , r ) } } 
func ( mw * statusmiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { mw . start = time . now ( ) mw . pid = os . getpid ( ) mw . responsecounts = map [ string ] int { } mw . totalresponsetime = time . time { } return func ( w responsewriter , r * request ) { h ( w , r ) if r . env [ " " ] == nil { log . fatal ( " " " " + " " ) } statuscode : = r . env [ " " ] . ( int ) if r . env [ " " ] == nil { log . fatal ( " " " " + " " ) } responsetime : = r . env [ " " ] . ( * time . duration ) mw . lock . lock ( ) mw . responsecounts [ fmt . sprintf ( " " , statuscode ) ] ++ mw . totalresponsetime = mw . totalresponsetime . add ( * responsetime ) mw . lock . unlock ( ) } } 
func ( mw * statusmiddleware ) getstatus ( ) * status { mw . lock . rlock ( ) now : = time . now ( ) uptime : = now . sub ( mw . start ) totalcount : = 0 for , count : = range mw . responsecounts { totalcount += count } totalresponsetime : = mw . totalresponsetime . sub ( time . time { } ) averageresponsetime : = time . duration ( 0 ) if totalcount > 0 { avgns : = int64 ( totalresponsetime ) / int64 ( totalcount ) averageresponsetime = time . duration ( avgns ) } status : = & status { pid : mw . pid , uptime : uptime . string ( ) , uptimesec : uptime . seconds ( ) , time : now . string ( ) , timeunix : now . unix ( ) , statuscodecount : mw . responsecounts , totalcount : totalcount , totalresponsetime : totalresponsetime . string ( ) , totalresponsetimesec : totalresponsetime . seconds ( ) , averageresponsetime : averageresponsetime . string ( ) , averageresponsetimesec : averageresponsetime . seconds ( ) , } mw . lock . runlock ( ) return status } 
func ( mw * jsonpmiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { if mw . callbacknamekey == " " { mw . callbacknamekey = " " } return func ( w responsewriter , r * request ) { callbackname : = r . url . query ( ) . get ( mw . callbacknamekey ) if callbackname ! = " " { writer : = & jsonpresponsewriter { w , false , callbackname } h ( writer , r ) } else { h ( w , r ) } } } 
func ( w * jsonpresponsewriter ) writeheader ( code int ) { w . header ( ) . set ( " " , " " ) w . responsewriter . writeheader ( code ) w . wroteheader = true } 
func ( w * jsonpresponsewriter ) writejson ( v interface { } ) error { b , err : = w . encodejson ( v ) if err ! = nil { return err } w . header ( ) . set ( " " , " " ) w . header ( ) . set ( " " , " " ) w . write ( [ ] byte ( " " + w . callbackname + " " ) ) w . write ( b ) w . write ( [ ] byte ( " " ) ) return nil } 
func ( mw * accesslogjsonmiddleware ) middlewarefunc ( h handlerfunc ) handlerfunc { if mw . logger == nil { mw . logger = log . new ( os . stderr , " " , 0 ) } return func ( w responsewriter , r * request ) { h ( w , r ) mw . logger . printf ( " " , makeaccesslogjsonrecord ( r ) . asjson ( ) ) } } 
func ( s * s3 ) init ( ) error { if s . bucket == " " { return errors . new ( " " ) } else if s . key == " " { return errors . new ( " " ) } if s . region == " " { s . region = " " } creds : = credentials . anonymouscredentials if s . access ! = " " { creds = credentials . newstaticcredentials ( s . access , s . secret , " " ) } else if os . getenv ( " " ) ! = " " { creds = credentials . newenvcredentials ( ) } config : = & aws . config { credentials : creds , region : & s . region , } s . client = s3 . new ( session . new ( config ) ) if s . interval == 0 { s . interval = 5 * time . minute } return nil } 
func ( s * s3 ) fetch ( ) ( io . reader , error ) { if s . delay { time . sleep ( s . interval ) } s . delay = true head , err : = s . client . headobject ( & s3 . headobjectinput { bucket : & s . bucket , key : & s . key } ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if s . lastetag == * head . etag { return nil , nil } s . lastetag = * head . etag get , err : = s . client . getobject ( & s3 . getobjectinput { bucket : & s . bucket , key : & s . key } ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if strings . hassuffix ( s . key , " " ) && aws . stringvalue ( get . contentencoding ) ! = " " { return gzip . newreader ( get . body ) } return get . body , nil } 
func run ( c config ) { err : = runerr ( & c ) if err ! = nil { if c . required { log . fatalf ( " " , err ) } else if c . debug | | ! c . nowarn { log . printf ( " " , err ) } c . program ( disabledstate ) return } os . exit ( 0 ) } 
func sanitycheck ( ) bool { if token : = os . getenv ( envbincheck ) ; token ! = " " { fmt . fprint ( os . stdout , token ) return true } if token : = os . getenv ( envbinchecklegacy ) ; token ! = " " { fmt . fprint ( os . stdout , token ) return true } return false } 
func prog ( state overseer . state ) { fmt . printf ( " \n " , buildid , state . id ) http . handle ( " " , http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { d , : = time . parseduration ( r . url . query ( ) . get ( " " ) ) time . sleep ( d ) fmt . fprintf ( w , " \n " , buildid , state . id ) } ) ) http . serve ( state . listener , nil ) fmt . printf ( " \n " , buildid , state . id ) } 
func main ( ) { overseer . run ( overseer . config { program : prog , address : " " , fetcher : & fetcher . file { path : " " } , debug : false , } ) } 
func ( l * overseerlistener ) release ( timeout time . duration ) { l . closeerror = l . listener . close ( ) waited : = make ( chan bool ) go func ( ) { l . wg . wait ( ) waited < - true } ( ) go func ( ) { select { case < - time . after ( timeout ) : close ( l . closebyforce ) case < - waited : } } ( ) } 
func ( mp * master ) fetchloop ( ) { min : = mp . config . minfetchinterval time . sleep ( min ) for { t0 : = time . now ( ) mp . fetch ( ) diff : = time . now ( ) . sub ( t0 ) if diff < min { delay : = min - diff time . sleep ( delay ) } } } 
func ( h * github ) init ( ) error { if h . user == " " { return fmt . errorf ( " " ) } if h . repo == " " { return fmt . errorf ( " " ) } if h . asset == nil { h . asset = h . defaultasset } h . releaseurl = " " + h . user + " " + h . repo + " " if h . interval == 0 { h . interval = 5 * time . minute } else if h . interval < 1 * time . minute { log . printf ( " " ) } return nil } 
func ( f * file ) init ( ) error { if f . path == " " { return fmt . errorf ( " " ) } if f . interval < 1 * time . second { f . interval = 1 * time . second } if err : = f . updatehash ( ) ; err ! = nil { return err } return nil } 
func ( f * file ) fetch ( ) ( io . reader , error ) { if f . delay { time . sleep ( f . interval ) } f . delay = true lasthash : = f . hash if err : = f . updatehash ( ) ; err ! = nil { return nil , err } if lasthash == f . hash { return nil , nil } file , err : = os . open ( f . path ) if err ! = nil { return nil , err } const rate = 250 * time . millisecond const total = int ( 5 * time . second / rate ) attempt : = 1 for { if attempt == total { file . close ( ) return nil , errors . new ( " " ) } attempt ++ time . sleep ( rate ) if err : = f . updatehash ( ) ; err ! = nil { file . close ( ) return nil , err } if lasthash == f . hash { break } lasthash = f . hash } return file , nil } 
func ( h * http ) init ( ) error { if h . url == " " { return fmt . errorf ( " " ) } h . lasts = map [ string ] string { } if h . interval == 0 { h . interval = 5 * time . minute } if h . checkheaders == nil { h . checkheaders = defaulthttpcheckheaders } return nil } 
func ( h * http ) fetch ( ) ( io . reader , error ) { if h . delay { time . sleep ( h . interval ) } h . delay = true resp , err : = http . head ( h . url ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } resp . body . close ( ) if resp . statuscode ! = http . statusok { return nil , fmt . errorf ( " " , resp . statuscode ) } matches , total : = 0 , 0 for , header : = range h . checkheaders { if curr : = resp . header . get ( header ) ; curr ! = " " { if last , ok : = h . lasts [ header ] ; ok && last == curr { matches ++ } h . lasts [ header ] = curr total ++ } } if matches == total { return nil , nil } resp , err = http . get ( h . url ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if resp . statuscode ! = http . statusok { return nil , fmt . errorf ( " " , resp . statuscode ) } if strings . hassuffix ( h . url , " " ) && resp . header . get ( " " ) ! = " " { return gzip . newreader ( resp . body ) } return resp . body , nil } 
func newconfig ( ) * config { c : = & config { config : * sarama . newconfig ( ) , } c . group . partitionstrategy = strategyrange c . group . offsets . retry . max = 3 c . group . offsets . synchronization . dwelltime = c . consumer . maxprocessingtime c . group . session . timeout = 30 * time . second c . group . heartbeat . interval = 3 * time . second c . config . version = minversion return c } 
func newclient ( addrs [ ] string , config * config ) ( * client , error ) { if config == nil { config = newconfig ( ) } if err : = config . validate ( ) ; err ! = nil { return nil , err } client , err : = sarama . newclient ( addrs , & config . config ) if err ! = nil { return nil , err } return & client { client : client , config : * config } , nil } 
func ( c * partitionconsumer ) asyncclose ( ) { c . closeonce . do ( func ( ) { c . closeerr = c . partitionconsumer . close ( ) close ( c . dying ) } ) } 
func ( c * partitionconsumer ) close ( ) error { c . asyncclose ( ) < - c . dead return c . closeerr } 
func ( c * partitionconsumer ) markoffset ( offset int64 , metadata string ) { c . mu . lock ( ) if next : = offset + 1 ; next > c . state . info . offset { c . state . info . offset = next c . state . info . metadata = metadata c . state . dirty = true } c . mu . unlock ( ) } 
func newconsumer ( addrs [ ] string , groupid string , topics [ ] string , config * config ) ( * consumer , error ) { client , err : = newclient ( addrs , config ) if err ! = nil { return nil , err } consumer , err : = newconsumerfromclient ( client , groupid , topics ) if err ! = nil { return nil , err } consumer . ownclient = true return consumer , nil } 
func ( c * consumer ) markpartitionoffset ( topic string , partition int32 , offset int64 , metadata string ) { if sub : = c . subs . fetch ( topic , partition ) ; sub ! = nil { sub . markoffset ( offset , metadata ) } } 
func ( c * consumer ) markoffsets ( s * offsetstash ) { s . mu . lock ( ) defer s . mu . unlock ( ) for tp , info : = range s . offsets { if sub : = c . subs . fetch ( tp . topic , tp . partition ) ; sub ! = nil { sub . markoffset ( info . offset , info . metadata ) } delete ( s . offsets , tp ) } } 
func ( c * consumer ) resetoffset ( msg * sarama . consumermessage , metadata string ) { if sub : = c . subs . fetch ( msg . topic , msg . partition ) ; sub ! = nil { sub . resetoffset ( msg . offset , metadata ) } } 
func ( c * consumer ) resetpartitionoffset ( topic string , partition int32 , offset int64 , metadata string ) { sub : = c . subs . fetch ( topic , partition ) if sub ! = nil { sub . resetoffset ( offset , metadata ) } } 
func ( c * consumer ) commitoffsets ( ) error { c . commitmu . lock ( ) defer c . commitmu . unlock ( ) memberid , generationid : = c . membership ( ) req : = & sarama . offsetcommitrequest { version : 2 , consumergroup : c . groupid , consumergroupgeneration : generationid , consumerid : memberid , retentiontime : - 1 , } if ns : = c . client . config . consumer . offsets . retention ; ns ! = 0 { req . retentiontime = int64 ( ns / time . millisecond ) } snap : = c . subs . snapshot ( ) dirty : = false for tp , state : = range snap { if state . dirty { dirty = true req . addblock ( tp . topic , tp . partition , state . info . offset , 0 , state . info . metadata ) } } if ! dirty { return nil } broker , err : = c . client . coordinator ( c . groupid ) if err ! = nil { c . closecoordinator ( broker , err ) return err } resp , err : = broker . commitoffset ( req ) if err ! = nil { c . closecoordinator ( broker , err ) return err } for topic , errs : = range resp . errors { for partition , kerr : = range errs { if kerr ! = sarama . errnoerror { err = kerr } else if state , ok : = snap [ topicpartition { topic , partition } ] ; ok { if sub : = c . subs . fetch ( topic , partition ) ; sub ! = nil { sub . markcommitted ( state . info . offset ) } } } } return err } 
func ( c * consumer ) close ( ) ( err error ) { c . closeonce . do ( func ( ) { close ( c . dying ) < - c . dead if e : = c . release ( ) ; e ! = nil { err = e } if e : = c . consumer . close ( ) ; e ! = nil { err = e } close ( c . messages ) close ( c . errors ) if e : = c . leavegroup ( ) ; e ! = nil { err = e } close ( c . partitions ) close ( c . notifications ) for range c . messages { } for range c . errors { } for p : = range c . partitions { = p . close ( ) } for range c . notifications { } c . client . release ( ) if c . ownclient { if e : = c . client . close ( ) ; e ! = nil { err = e } } } ) return } 
func ( c * consumer ) hbloop ( stopped < - chan none ) { ticker : = time . newticker ( c . client . config . group . heartbeat . interval ) defer ticker . stop ( ) for { select { case < - ticker . c : switch err : = c . heartbeat ( ) ; err { case nil , sarama . errnoerror : case sarama . errnotcoordinatorforconsumer , sarama . errrebalanceinprogress : return default : c . handleerror ( & error { ctx : " " , error : err } ) return } case < - stopped : return case < - c . dying : return } } } 
func ( c * consumer ) twloop ( stopped < - chan none ) { ticker : = time . newticker ( c . client . config . metadata . refreshfrequency / 2 ) defer ticker . stop ( ) for { select { case < - ticker . c : topics , err : = c . client . topics ( ) if err ! = nil { c . handleerror ( & error { ctx : " " , error : err } ) return } for , topic : = range topics { if ! c . isknowncoretopic ( topic ) && ! c . isknownextratopic ( topic ) && c . ispotentialextratopic ( topic ) { return } } case < - stopped : return case < - c . dying : return } } } 
func ( c * consumer ) cmloop ( stopped < - chan none ) { ticker : = time . newticker ( c . client . config . consumer . offsets . commitinterval ) defer ticker . stop ( ) for { select { case < - ticker . c : if err : = c . commitoffsetswithretry ( c . client . config . group . offsets . retry . max ) ; err ! = nil { c . handleerror ( & error { ctx : " " , error : err } ) return } case < - stopped : return case < - c . dying : return } } } 
func ( c * consumer ) release ( ) ( err error ) { c . subs . stop ( ) defer c . subs . clear ( ) timeout : = time . newtimer ( c . client . config . group . offsets . synchronization . dwelltime ) defer timeout . stop ( ) select { case < - c . dying : case < - timeout . c : } if e : = c . commitoffsetswithretry ( c . client . config . group . offsets . retry . max ) ; e ! = nil { err = e } return } 
func ( c * consumer ) rebalance ( ) ( map [ string ] [ ] int32 , error ) { memberid , : = c . membership ( ) sarama . logger . printf ( " \n " , memberid ) alltopics , err : = c . client . topics ( ) if err ! = nil { return nil , err } c . extratopics = c . selectextratopics ( alltopics ) sort . strings ( c . extratopics ) strategy , err : = c . joingroup ( ) switch { case err == sarama . errunknownmemberid : c . membershipmu . lock ( ) c . memberid = " " c . membershipmu . unlock ( ) return nil , err case err ! = nil : return nil , err } subs , err : = c . syncgroup ( strategy ) switch { case err == sarama . errrebalanceinprogress : return nil , err case err ! = nil : = c . leavegroup ( ) return nil , err } return subs , nil } 
func ( c * consumer ) subscribe ( tomb * looptomb , subs map [ string ] [ ] int32 ) error { offsets , err : = c . fetchoffsets ( subs ) if err ! = nil { = c . leavegroup ( ) return err } var mu sync . mutex var wg sync . waitgroup for topic , partitions : = range subs { for , partition : = range partitions { wg . add ( 1 ) info : = offsets [ topic ] [ partition ] go func ( topic string , partition int32 ) { if e : = c . createconsumer ( tomb , topic , partition , info ) ; e ! = nil { mu . lock ( ) err = e mu . unlock ( ) } wg . done ( ) } ( topic , partition ) } } wg . wait ( ) if err ! = nil { = c . release ( ) = c . leavegroup ( ) } return err } 
func ( c * consumer ) syncgroup ( strategy * balancer ) ( map [ string ] [ ] int32 , error ) { memberid , generationid : = c . membership ( ) req : = & sarama . syncgrouprequest { groupid : c . groupid , memberid : memberid , generationid : generationid , } if strategy ! = nil { for memberid , topics : = range strategy . perform ( ) { if err : = req . addgroupassignmentmember ( memberid , & sarama . consumergroupmemberassignment { topics : topics , } ) ; err ! = nil { return nil , err } } } broker , err : = c . client . coordinator ( c . groupid ) if err ! = nil { c . closecoordinator ( broker , err ) return nil , err } resp , err : = broker . syncgroup ( req ) if err ! = nil { c . closecoordinator ( broker , err ) return nil , err } else if resp . err ! = sarama . errnoerror { c . closecoordinator ( broker , resp . err ) return nil , resp . err } if len ( resp . memberassignment ) == 0 { return nil , nil } members , err : = resp . getmemberassignment ( ) if err ! = nil { return nil , err } for topic : = range members . topics { sort . sort ( int32slice ( members . topics [ topic ] ) ) } return members . topics , nil } 
func ( c * consumer ) fetchoffsets ( subs map [ string ] [ ] int32 ) ( map [ string ] map [ int32 ] offsetinfo , error ) { offsets : = make ( map [ string ] map [ int32 ] offsetinfo , len ( subs ) ) req : = & sarama . offsetfetchrequest { version : 1 , consumergroup : c . groupid , } for topic , partitions : = range subs { offsets [ topic ] = make ( map [ int32 ] offsetinfo , len ( partitions ) ) for , partition : = range partitions { offsets [ topic ] [ partition ] = offsetinfo { offset : - 1 } req . addpartition ( topic , partition ) } } broker , err : = c . client . coordinator ( c . groupid ) if err ! = nil { c . closecoordinator ( broker , err ) return nil , err } resp , err : = broker . fetchoffset ( req ) if err ! = nil { c . closecoordinator ( broker , err ) return nil , err } for topic , partitions : = range subs { for , partition : = range partitions { block : = resp . getblock ( topic , partition ) if block == nil { return nil , sarama . errincompleteresponse } if block . err == sarama . errnoerror { offsets [ topic ] [ partition ] = offsetinfo { offset : block . offset , metadata : block . metadata } } else { return nil , block . err } } } return offsets , nil } 
func ( c * consumer ) leavegroup ( ) error { broker , err : = c . client . coordinator ( c . groupid ) if err ! = nil { c . closecoordinator ( broker , err ) return err } memberid , : = c . membership ( ) if , err = broker . leavegroup ( & sarama . leavegrouprequest { groupid : c . groupid , memberid : memberid , } ) ; err ! = nil { c . closecoordinator ( broker , err ) } return err } 
func ( s * offsetstash ) markoffset ( msg * sarama . consumermessage , metadata string ) { s . markpartitionoffset ( msg . topic , msg . partition , msg . offset , metadata ) } 
func ( s * offsetstash ) markpartitionoffset ( topic string , partition int32 , offset int64 , metadata string ) { s . mu . lock ( ) defer s . mu . unlock ( ) key : = topicpartition { topic : topic , partition : partition } if info : = s . offsets [ key ] ; offset >= info . offset { info . offset = offset info . metadata = metadata s . offsets [ key ] = info } } 
func ( s * offsetstash ) resetoffset ( msg * sarama . consumermessage , metadata string ) { s . resetpartitionoffset ( msg . topic , msg . partition , msg . offset , metadata ) } 
func ( s * offsetstash ) offsets ( ) map [ string ] int64 { s . mu . lock ( ) defer s . mu . unlock ( ) res : = make ( map [ string ] int64 , len ( s . offsets ) ) for tp , info : = range s . offsets { res [ tp . string ( ) ] = info . offset } return res } 
func ( r * instancegroup ) actual ( immutable * cluster . cluster ) ( * cluster . cluster , cloud . resource , error ) { logger . debug ( " " ) if r . cachedactual ! = nil { logger . debug ( " " ) return immutable , r . cachedactual , nil } newresource : = & instancegroup { shared : shared { name : r . name , cloudid : r . serverpool . identifier , } , } project , err : = sdk . service . projects . get ( immutable . providerconfig ( ) . cloudid ) . do ( ) if err ! = nil && project ! = nil { instances , err : = sdk . service . instances . list ( immutable . providerconfig ( ) . cloudid , immutable . providerconfig ( ) . location ) . do ( ) if err ! = nil { return nil , nil , err } count : = len ( instances . items ) if count > 0 { newresource . count = count instance : = instances . items [ 0 ] newresource . name = instance . name newresource . cloudid = string ( instance . id ) newresource . size = instance . kind newresource . image = r . image newresource . location = instance . zone } } newresource . bootstrapscripts = r . serverpool . bootstrapscripts newresource . sshfingerprint = immutable . providerconfig ( ) . ssh . publickeyfingerprint newresource . name = r . name r . cachedactual = newresource return immutable , newresource , nil } 
func ( r * instancegroup ) expected ( immutable * cluster . cluster ) ( * cluster . cluster , cloud . resource , error ) { logger . debug ( " " ) if r . cachedexpected ! = nil { logger . debug ( " " ) return immutable , r . cachedexpected , nil } expected : = & instancegroup { shared : shared { name : r . name , cloudid : r . serverpool . identifier , } , size : r . serverpool . size , location : immutable . providerconfig ( ) . location , image : r . serverpool . image , count : r . serverpool . maxcount , sshfingerprint : immutable . providerconfig ( ) . ssh . publickeyfingerprint , bootstrapscripts : r . serverpool . bootstrapscripts , } r . cachedexpected = expected return immutable , expected , nil } 
func getversion ( ) * version { return & version { version : kubicornversion , gitcommit : gitsha , builddate : time . now ( ) . utc ( ) . string ( ) , goversion : runtime . version ( ) , goos : runtime . goos , goarch : runtime . goarch , } } 
func getversionjson ( ) string { verbytes , err : = json . marshal ( getversion ( ) ) if err ! = nil { logger . critical ( " " , err ) } return string ( verbytes ) } 
func ( r * resourcegroup ) actual ( immutable * cluster . cluster ) ( * cluster . cluster , cloud . resource , error ) { logger . debug ( " " ) newresource : = & resourcegroup { shared : shared { name : r . name , tags : r . tags , identifier : immutable . providerconfig ( ) . groupidentifier , } , location : r . location , } if r . identifier ! = " " { group , err : = sdk . resourcegroup . get ( immutable . name ) if err ! = nil { return nil , nil , err } newresource . location = * group . location newresource . name = * group . name newresource . identifier = * group . id } newcluster : = r . immutablerender ( newresource , immutable ) return newcluster , newresource , nil } 
func ( r * resourcegroup ) expected ( immutable * cluster . cluster ) ( * cluster . cluster , cloud . resource , error ) { logger . debug ( " " ) newresource : = & resourcegroup { shared : shared { name : immutable . name , tags : r . tags , identifier : immutable . providerconfig ( ) . groupidentifier , } , location : immutable . providerconfig ( ) . location , } newcluster : = r . immutablerender ( newresource , immutable ) return newcluster , newresource , nil } 
func newsdk ( ) ( * sdk , error ) { sdk : = & sdk { } apitoken : = gettoken ( ) if apitoken == " " { return nil , fmt . errorf ( " " ) } sdk . client = packngo . newclient ( " " , apitoken , nil ) return sdk , nil } 
func ( c * cluster ) providerconfig ( ) * controlplaneproviderconfig { raw : = c . clusterapi . spec . providerconfig providerconfig : = & controlplaneproviderconfig { } err : = json . unmarshal ( [ ] byte ( raw ) , providerconfig ) if err ! = nil { logger . critical ( " " , err ) } return providerconfig } 
func ( c * cluster ) setproviderconfig ( config * controlplaneproviderconfig ) error { bytes , err : = json . marshal ( config ) if err ! = nil { logger . critical ( " " , err ) return err } str : = string ( bytes ) c . clusterapi . spec . providerconfig = str return nil } 
func ( c * cluster ) machineproviderconfigs ( ) [ ] * machineproviderconfig { var providerconfigs [ ] * machineproviderconfig for , machineset : = range c . machinesets { raw : = machineset . spec . template . spec . providerconfig providerconfig : = & machineproviderconfig { } err : = json . unmarshal ( [ ] byte ( raw ) , providerconfig ) if err ! = nil { logger . critical ( " " , err ) } providerconfigs = append ( providerconfigs , providerconfig ) } return providerconfigs } 
func ( c * cluster ) setmachineproviderconfigs ( providerconfigs [ ] * machineproviderconfig ) { for , providerconfig : = range providerconfigs { name : = providerconfig . serverpool . name found : = false for , machineset : = range c . machinesets { if machineset . name == name { bytes , err : = json . marshal ( providerconfig ) if err ! = nil { logger . critical ( " " ) continue } str : = string ( bytes ) machineset . spec . template . spec . providerconfig = str found = true } } if ! found { logger . warning ( " " , name ) } } } 
func newcluster ( name string ) * cluster { return & cluster { name : name , clusterapi : & clusterv1 . cluster { objectmeta : metav1 . objectmeta { name : name , } , spec : clusterv1 . clusterspec { } , } , controlplane : & clusterv1 . machineset { } , } } 
func deploycontrollercmd ( ) * cobra . command { var dco = & cli . deploycontrolleroptions { } var deploycontrollercmd = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { switch len ( args ) { case 0 : dco . name = viper . getstring ( keykubicornname ) case 1 : dco . name = args [ 0 ] default : logger . critical ( " " ) os . exit ( 1 ) } if err : = rundeploycontroller ( dco ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } fs : = deploycontrollercmd . flags ( ) bindcommonstatestoreflags ( & dco . statestoreoptions , fs ) bindcommonawsflags ( & dco . awsoptions , fs ) fs . stringvar ( & dco . gitremote , keygitconfig , viper . getstring ( keygitconfig ) , descgitconfig ) return deploycontrollercmd } 
func newretrier ( retries , sleepseconds int , retryable retryable ) * retrier { return & retrier { retries : retries , sleepseconds : sleepseconds , retryable : retryable , } } 
func ( r * retrier ) runretry ( ) error { sighandler : = signals . newsignalhandler ( 10 ) go sighandler . register ( ) finish : = make ( chan bool , 1 ) go func ( ) { select { case < - finish : return case < - time . after ( 10 * time . second ) : return default : for { if sighandler . getstate ( ) ! = 0 { logger . critical ( " " ) os . exit ( 1 ) } } } } ( ) for i : = 0 ; i < r . retries ; i ++ { err : = r . retryable . try ( ) if err ! = nil { logger . info ( " " , err ) time . sleep ( time . duration ( r . sleepseconds ) * time . second ) continue } finish < - true return nil } finish < - true return fmt . errorf ( " " , r . retries , r . sleepseconds ) } 
func mustgeneraterandombytes ( length int ) [ ] byte { res , err : = generaterandombytes ( length ) if err ! = nil { panic ( " " ) } return res } 
func generaterandombytes ( length int ) ( [ ] byte , error ) { b : = make ( [ ] byte , length ) , err : = rand . read ( b ) return b , err } 
func generaterandomint ( min , max int ) int { return int ( generaterandomint64 ( int64 ( min ) , int64 ( max ) ) ) } 
func generaterandomint64 ( min , max int64 ) int64 { upper : = max - min nbig , err : = rand . int ( rand . reader , big . newint ( upper ) ) if err ! = nil { panic ( err ) } return nbig . int64 ( ) + min } 
func explaincmd ( ) * cobra . command { var exo = & cli . explainoptions { } var cmd = & cobra . command { use : " " , short : " " , long : ' output expected and actual state of the given cluster ' , run : func ( cmd * cobra . command , args [ ] string ) { switch len ( args ) { case 0 : exo . name = viper . getstring ( keykubicornname ) case 1 : exo . name = args [ 0 ] default : logger . critical ( " " ) os . exit ( 1 ) } if err : = runexplain ( exo ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } fs : = cmd . flags ( ) bindcommonstatestoreflags ( & exo . statestoreoptions , fs ) bindcommonawsflags ( & exo . awsoptions , fs ) fs . stringvarp ( & exo . output , keyoutput , " " , viper . getstring ( keyoutput ) , descoutput ) fs . stringvar ( & exo . gitremote , keygitconfig , viper . getstring ( keygitconfig ) , descgitconfig ) return cmd } 
func timeordereduuid ( ) string { unixtime : = uint32 ( time . now ( ) . utc ( ) . unix ( ) ) return fmt . sprintf ( " " , unixtime , rand . mustgeneraterandombytes ( 2 ) , rand . mustgeneraterandombytes ( 2 ) , rand . mustgeneraterandombytes ( 2 ) , rand . mustgeneraterandombytes ( 2 ) , rand . mustgeneraterandombytes ( 4 ) ) } 
func getconfigcmd ( ) * cobra . command { var cro = & cli . getconfigoptions { } var getconfigcmd = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { switch len ( args ) { case 0 : cro . name = viper . getstring ( keykubicornname ) case 1 : cro . name = args [ 0 ] default : logger . critical ( " " ) os . exit ( 1 ) } if err : = rungetconfig ( cro ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } fs : = getconfigcmd . flags ( ) bindcommonstatestoreflags ( & cro . statestoreoptions , fs ) bindcommonawsflags ( & cro . awsoptions , fs ) fs . stringvar ( & cro . gitremote , keygitconfig , viper . getstring ( keygitconfig ) , descgitconfig ) return getconfigcmd } 
func promptcmd ( ) * cobra . command { return & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { logger . critical ( " " ) os . exit ( 1 ) } , } } 
func runannotated ( task task , description string , symbol string , options ... interface { } ) error { donech : = make ( chan bool ) errch : = make ( chan error ) l : = logger . log t : = defaultticker for , o : = range options { if value , ok : = o . ( logger . logger ) ; ok { l = value } else if value , ok : = o . ( * time . ticker ) ; ok { t = value } } go func ( ) { errch < - task ( ) } ( ) l ( description ) logactivity ( symbol , l , t , donech ) err : = < - errch donech < - true return err } 
func logactivity ( symbol string , logger logger . logger , ticker * time . ticker , quitch < - chan bool ) { go func ( ) { for { select { case < - ticker . c : logger ( symbol ) case < - quitch : ticker . stop ( ) return } } } ( ) } 
func listcmd ( ) * cobra . command { var lo = & cli . listoptions { } var cmd = & cobra . command { use : " " , short : " " , long : ' list the states available in the state directory ' , run : func ( cmd * cobra . command , args [ ] string ) { if err : = runlist ( lo ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } fs : = cmd . flags ( ) bindcommonstatestoreflags ( & lo . statestoreoptions , fs ) bindcommonawsflags ( & lo . awsoptions , fs ) fs . boolvarp ( & noheaders , keynoheaders , " " , viper . getbool ( keynoheaders ) , desnoheaders ) return cmd } 
func newubuntucluster ( name string ) * cluster . cluster { controlplaneproviderconfig : = & cluster . controlplaneproviderconfig { cloud : cluster . cloudpacket , project : & cluster . project { name : fmt . sprintf ( " " , name ) , } , location : " " , ssh : & cluster . ssh { publickeypath : " " , user : " " , } , kubernetesapi : & cluster . kubernetesapi { port : " " , } , values : & cluster . values { itemmap : map [ string ] string { " " : kubeadm . getrandomtoken ( ) , } , } , } machinesetsproviderconfigs : = [ ] * cluster . machineproviderconfig { { serverpool : & cluster . serverpool { type : cluster . serverpooltypemaster , name : fmt . sprintf ( " " , name ) , maxcount : 1 , mincount : 1 , image : " " , size : " " , bootstrapscripts : [ ] string { " " , } , } , } , { serverpool : & cluster . serverpool { type : cluster . serverpooltypenode , name : fmt . sprintf ( " " , name ) , maxcount : 1 , mincount : 1 , image : " " , size : " " , bootstrapscripts : [ ] string { " " , } , } , } , } c : = cluster . newcluster ( name ) c . setproviderconfig ( controlplaneproviderconfig ) c . newmachinesetsfromproviderconfigs ( machinesetsproviderconfigs ) return c } 
func newsdk ( region string ) ( * sdk , error ) { sdk : = & sdk { } authopts , err : = openstack . authoptionsfromenv ( ) if err ! = nil { return nil , err } authopts . allowreauth = true client , err : = openstack . authenticatedclient ( authopts ) if err ! = nil { return nil , err } endpointopts : = gophercloud . endpointopts { region : region , } if sdk . compute , err = openstack . newcomputev2 ( client , endpointopts ) ; err ! = nil { return nil , err } if sdk . network , err = openstack . newnetworkv2 ( client , endpointopts ) ; err ! = nil { return nil , err } if sdk . objectstorage , err = openstack . newobjectstoragev1 ( client , endpointopts ) ; err ! = nil { return nil , err } return sdk , nil } 
func editcmd ( ) * cobra . command { var eo = & cli . editoptions { } var editcmd = & cobra . command { use : " " , short : " " , long : ' use this command to edit a state . ' , run : func ( cmd * cobra . command , args [ ] string ) { switch len ( args ) { case 0 : eo . name = viper . getstring ( keykubicornname ) case 1 : eo . name = args [ 0 ] default : logger . critical ( " " ) os . exit ( 1 ) } if err : = runedit ( eo ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } fs : = editcmd . flags ( ) bindcommonstatestoreflags ( & eo . statestoreoptions , fs ) bindcommonawsflags ( & eo . awsoptions , fs ) fs . stringvarp ( & eo . editor , keyeditor , " " , viper . getstring ( keyeditor ) , desceditor ) fs . stringvar ( & eo . gitremote , keygitconfig , viper . getstring ( keygitconfig ) , descgitconfig ) return editcmd } 
func ( k * keyring ) removekey ( key ssh . publickey ) error { return k . agent . remove ( key ) } 
func ( k * keyring ) removekeyusingfile ( pubkey string ) error { p , err : = ioutil . readfile ( pubkey ) if err ! = nil { return err } key , , , , : = ssh . parseauthorizedkey ( p ) if err ! = nil { return err } return k . removekey ( key ) } 
func ( r * firewall ) actual ( immutable * cluster . cluster ) ( * cluster . cluster , cloud . resource , error ) { logger . debug ( " " ) newresource : = defaultfirewallstruct ( ) firewalls , , err : = sdk . client . firewalls . list ( context . todo ( ) , & godo . listoptions { } ) if err ! = nil { return nil , nil , fmt . errorf ( " " ) } for , firewall : = range firewalls { if firewall . name == r . name { firewallbytes , err : = json . marshal ( firewall ) if err ! = nil { return nil , nil , fmt . errorf ( " " , err ) } if err : = json . unmarshal ( firewallbytes , newresource ) ; err ! = nil { return nil , nil , fmt . errorf ( " " , err ) } for i : = 0 ; i < len ( newresource . outboundrules ) ; i ++ { if newresource . outboundrules [ i ] . portrange == " " { newresource . outboundrules [ i ] . portrange = " " } } for i : = 0 ; i < len ( newresource . inboundrules ) ; i ++ { if newresource . inboundrules [ i ] . portrange == " " { newresource . inboundrules [ i ] . portrange = " " } } } } newcluster : = r . immutablerender ( newresource , immutable ) return newcluster , newresource , nil } 
func ( r * firewall ) expected ( immutable * cluster . cluster ) ( * cluster . cluster , cloud . resource , error ) { logger . debug ( " " ) newresource : = & firewall { shared : shared { name : r . name , cloudid : r . serverpool . identifier , } , inboundrules : r . inboundrules , outboundrules : r . outboundrules , dropletids : r . dropletids , tags : r . tags , firewallid : r . firewallid , status : r . status , created : r . created , } newcluster : = r . immutablerender ( newresource , immutable ) return newcluster , newresource , nil } 
func ( r * firewall ) delete ( actual cloud . resource , immutable * cluster . cluster ) ( * cluster . cluster , cloud . resource , error ) { logger . debug ( " " ) deleteresource , ok : = actual . ( * firewall ) if ! ok { return nil , nil , fmt . errorf ( " " ) } if deleteresource . name == " " { return immutable , nil , nil return nil , nil , fmt . errorf ( " " , deleteresource . name ) } if , err : = sdk . client . firewalls . delete ( context . todo ( ) , deleteresource . firewallid ) ; err ! = nil { return nil , nil , fmt . errorf ( " " , deleteresource . name , err ) } logger . success ( " " , deleteresource . firewallid ) newresource : = & firewall { shared : shared { name : r . name , tags : r . tags , } , inboundrules : r . inboundrules , outboundrules : r . outboundrules , created : r . created , } newcluster : = r . immutablerender ( newresource , immutable ) return newcluster , newresource , nil } 
func deletecmd ( ) * cobra . command { var do = & cli . deleteoptions { } var deletecmd = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { switch len ( args ) { case 0 : do . name = viper . getstring ( keykubicornname ) case 1 : do . name = args [ 0 ] default : logger . critical ( " " ) os . exit ( 1 ) } if err : = rundelete ( do ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } fs : = deletecmd . flags ( ) bindcommonstatestoreflags ( & do . statestoreoptions , fs ) bindcommonawsflags ( & do . awsoptions , fs ) fs . stringvar ( & do . awsprofile , keyawsprofile , viper . getstring ( keyawsprofile ) , descawsprofile ) fs . stringvar ( & do . gitremote , keygitconfig , viper . getstring ( keygitconfig ) , descgitconfig ) fs . boolvarp ( & do . purge , keypurge , " " , viper . getbool ( keypurge ) , descpurge ) return deletecmd } 
func ( git * jsongitstore ) commit ( c * cluster . cluster ) error { if c == nil { return fmt . errorf ( " " ) } bytes , err : = json . marshal ( c ) if err ! = nil { return err } git . write ( state . clusterjsonfile , bytes ) r , err : = g . newfilesystemrepository ( state . clusterjsonfile ) if err ! = nil { return err } , err = r . createremote ( & config . remoteconfig { name : git . clustername , url : git . options . commitconfig . remote , } ) , err = r . commits ( ) if err ! = nil { return err } return nil } 
func applycmd ( ) * cobra . command { var ao = & cli . applyoptions { } var applycmd = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { switch len ( args ) { case 0 : ao . name = viper . getstring ( keykubicornname ) case 1 : ao . name = args [ 0 ] default : logger . critical ( " " ) os . exit ( 1 ) } if err : = runapply ( ao ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } fs : = applycmd . flags ( ) bindcommonstatestoreflags ( & ao . statestoreoptions , fs ) bindcommonawsflags ( & ao . awsoptions , fs ) fs . stringarrayvarp ( & ao . set , keykubicornset , " " , viper . getstringslice ( keykubicornset ) , descset ) fs . stringvar ( & ao . awsprofile , keyawsprofile , viper . getstring ( keyawsprofile ) , descawsprofile ) fs . stringvar ( & ao . gitremote , keygitconfig , viper . getstring ( keygitconfig ) , descgitconfig ) return applycmd } 
func promptcmd ( ) * cobra . command { var promptcmd = & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { if len ( args ) > 0 { logger . critical ( " " ) os . exit ( 1 ) } if err : = runprompt ( ) ; err ! = nil { logger . critical ( err . error ( ) ) os . exit ( 1 ) } } , } initializeprompt ( ) return promptcmd } 
func expandpath ( path string ) string { switch path { case " " : wd , err : = os . getwd ( ) if err ! = nil { logger . critical ( " " , err ) return " " } path = wd case " " : homevar : = os . getenv ( " " ) if homevar == " " { homeuser , err : = user . current ( ) if err ! = nil { logger . critical ( " " , err ) return " " } path = homeuser . homedir } } return path } 
func completioncmd ( ) * cobra . command { return & cobra . command { use : " " , short : " " , long : , rune : func ( cmd * cobra . command , args [ ] string ) error { if logger . fabulous { cmd . setoutput ( logger . fabulouswriter ) } if viper . getstring ( keytruecolor ) ! = " " { cmd . setoutput ( logger . fabulouswriter ) } switch len ( args ) { case 0 : return fmt . errorf ( " " ) default : switch args [ 0 ] { case " " : return runbashgeneration ( ) case " " : return runzshgeneration ( ) default : return fmt . errorf ( " " ) } } } , } } 
func adoptcmd ( ) * cobra . command { return & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { fmt . println ( " " ) } , } } 
func strenvdef ( env string , def string ) string { val : = os . getenv ( env ) if val == " " { return def } return val } 
func intenvdef ( env string , def int ) int { val : = os . getenv ( env ) if val == " " { return def } ival , err : = strconv . atoi ( val ) if err ! = nil { return def } return ival } 
func boolenvdef ( env string , def bool ) bool { val : = os . getenv ( env ) if val == " " { return def } b , err : = strconv . parsebool ( val ) if err ! = nil { return def } return b } 
func readfromfs ( sourcepath string ) ( string , error ) { if strings . hasprefix ( sourcepath , " " ) { homedir : = os . getenv ( " " ) if homedir == " " { return " " , fmt . errorf ( " " ) } sourcepath = filepath . join ( homedir , sourcepath [ 1 : ] ) } bytes , err : = ioutil . readfile ( sourcepath ) if err ! = nil { return " " , err } return string ( bytes ) , nil } 
func versioncmd ( ) * cobra . command { return & cobra . command { use : " " , short : " " , long : , run : func ( cmd * cobra . command , args [ ] string ) { fmt . printf ( " \n " , version . getversionjson ( ) ) } , } } 
func newsignalhandler ( timeoutseconds int ) * handler { signals : = make ( chan os . signal ) signal . notify ( signals , os . interrupt , os . kill ) return & handler { timeoutseconds : timeoutseconds , signals : signals , signalreceived : 0 , } } 
func ( h * handler ) register ( ) { go func ( ) { h . timer = time . newtimer ( time . duration ( h . timeoutseconds ) * time . second ) for { select { case s : = < - h . signals : switch { case s == os . interrupt : if h . signalreceived == 0 { h . signalreceived = 1 logger . debug ( " " ) continue } h . signalreceived = signalterminate debug . printstack ( ) os . exit ( 130 ) break case s == syscall . sigquit : h . signalreceived = signalabort break case s == syscall . sigterm : h . signalreceived = signalterminate os . exit ( 3 ) break } case < - h . timer . c : os . exit ( 4 ) break } } } ( ) } 
func newsdk ( ) ( * sdk , error ) { sdk : = & sdk { } client , err : = google . defaultclient ( context . todo ( ) , compute . computescope ) if err ! = nil { return nil , err } service , err : = compute . new ( client ) if err ! = nil { return nil , err } sdk . service = service return sdk , nil } 
func ( now * now ) beginningofhour ( ) time . time { y , m , d : = now . date ( ) return time . date ( y , m , d , now . time . hour ( ) , 0 , 0 , 0 , now . time . location ( ) ) } 
func ( now * now ) beginningofday ( ) time . time { y , m , d : = now . date ( ) return time . date ( y , m , d , 0 , 0 , 0 , 0 , now . time . location ( ) ) } 
func ( now * now ) beginningofweek ( ) time . time { t : = now . beginningofday ( ) weekday : = int ( t . weekday ( ) ) if weekstartday ! = time . sunday { weekstartdayint : = int ( weekstartday ) if weekday < weekstartdayint { weekday = weekday + 7 - weekstartdayint } else { weekday = weekday - weekstartdayint } } return t . adddate ( 0 , 0 , - weekday ) } 
func ( now * now ) beginningofmonth ( ) time . time { y , m , : = now . date ( ) return time . date ( y , m , 1 , 0 , 0 , 0 , 0 , now . location ( ) ) } 
func ( now * now ) beginningofquarter ( ) time . time { month : = now . beginningofmonth ( ) offset : = ( int ( month . month ( ) ) - 1 ) % 3 return month . adddate ( 0 , - offset , 0 ) } 
func ( now * now ) beginningofyear ( ) time . time { y , , : = now . date ( ) return time . date ( y , time . january , 1 , 0 , 0 , 0 , 0 , now . location ( ) ) } 
func ( now * now ) endofminute ( ) time . time { return now . beginningofminute ( ) . add ( time . minute - time . nanosecond ) } 
func ( now * now ) endofhour ( ) time . time { return now . beginningofhour ( ) . add ( time . hour - time . nanosecond ) } 
func ( now * now ) endofday ( ) time . time { y , m , d : = now . date ( ) return time . date ( y , m , d , 23 , 59 , 59 , int ( time . second - time . nanosecond ) , now . location ( ) ) } 
func ( now * now ) endofweek ( ) time . time { return now . beginningofweek ( ) . adddate ( 0 , 0 , 7 ) . add ( - time . nanosecond ) } 
func ( now * now ) endofmonth ( ) time . time { return now . beginningofmonth ( ) . adddate ( 0 , 1 , 0 ) . add ( - time . nanosecond ) } 
func ( now * now ) endofquarter ( ) time . time { return now . beginningofquarter ( ) . adddate ( 0 , 3 , 0 ) . add ( - time . nanosecond ) } 
func ( now * now ) endofyear ( ) time . time { return now . beginningofyear ( ) . adddate ( 1 , 0 , 0 ) . add ( - time . nanosecond ) } 
func ( now * now ) mustparse ( strs ... string ) ( t time . time ) { t , err : = now . parse ( strs ... ) if err ! = nil { panic ( err ) } return t } 
func ( now * now ) between ( begin , end string ) bool { begintime : = now . mustparse ( begin ) endtime : = now . mustparse ( end ) return now . after ( begintime ) && now . before ( endtime ) } 
func parse ( strs ... string ) ( time . time , error ) { return new ( time . now ( ) ) . parse ( strs ... ) } 
func parseinlocation ( loc * time . location , strs ... string ) ( time . time , error ) { return new ( time . now ( ) . in ( loc ) ) . parse ( strs ... ) } 
func mustparse ( strs ... string ) time . time { return new ( time . now ( ) ) . mustparse ( strs ... ) } 
func mustparseinlocation ( loc * time . location , strs ... string ) time . time { return new ( time . now ( ) . in ( loc ) ) . mustparse ( strs ... ) } 
func between ( time1 , time2 string ) bool { return new ( time . now ( ) ) . between ( time1 , time2 ) } 
func ( b * memorybackend ) log ( level level , calldepth int , rec * record ) error { var size int32 n : = & node { record : rec } np : = unsafe . pointer ( n ) for { tailp : = b . tail swapped : = atomic . compareandswappointer ( & b . tail , tailp , np , ) if swapped == true { if tailp == nil { b . head = np } else { ( * node ) ( tailp ) . next = n } size = atomic . addint32 ( & b . size , 1 ) break } } if b . maxsize > 0 && size > b . maxsize { for { headp : = b . head head : = ( * node ) ( b . head ) if head . next == nil { break } swapped : = atomic . compareandswappointer ( & b . head , headp , unsafe . pointer ( head . next ) , ) if swapped == true { atomic . addint32 ( & b . size , - 1 ) break } } } return nil } 
func newchannelmemorybackend ( size int ) * channelmemorybackend { backend : = & channelmemorybackend { maxsize : size , incoming : make ( chan * record , 1024 ) , events : make ( chan event ) , } backend . start ( ) return backend } 
func ( b * channelmemorybackend ) start ( ) { b . mu . lock ( ) defer b . mu . unlock ( ) if b . running ! = true { b . running = true b . stopwg . add ( 1 ) go b . process ( ) } } 
func ( b * channelmemorybackend ) flush ( ) { b . flushwg . add ( 1 ) b . events < - eventflush b . flushwg . wait ( ) } 
func ( b * channelmemorybackend ) stop ( ) { b . mu . lock ( ) if b . running == true { b . running = false b . events < - eventstop } b . mu . unlock ( ) b . stopwg . wait ( ) } 
func ( b * channelmemorybackend ) log ( level level , calldepth int , rec * record ) error { b . incoming < - rec return nil } 
func ( r * record ) formatted ( calldepth int ) string { if r . formatted == " " { var buf bytes . buffer r . formatter . format ( calldepth + 1 , r , & buf ) r . formatted = buf . string ( ) } return r . formatted } 
func ( r * record ) message ( ) string { if r . message == nil { for i , arg : = range r . args { if redactor , ok : = arg . ( redactor ) ; ok == true { r . args [ i ] = redactor . redacted ( ) } } var buf bytes . buffer if r . fmt ! = nil { fmt . fprintf ( & buf , * r . fmt , r . args ... ) } else { fmt . fprintln ( & buf , r . args ... ) buf . truncate ( buf . len ( ) - 1 ) } msg : = buf . string ( ) r . message = & msg } return * r . message } 
func ( l * logger ) setbackend ( backend leveledbackend ) { l . backend = backend l . havebackend = true } 
func mustgetlogger ( module string ) * logger { logger , err : = getlogger ( module ) if err ! = nil { panic ( " " + module + " " + err . error ( ) ) } return logger } 
func reset ( ) { sequenceno = 0 b : = setbackend ( newlogbackend ( os . stderr , " " , log . lstdflags ) ) b . setlevel ( debug , " " ) setformatter ( defaultformatter ) timenow = time . now } 
func ( l * logger ) isenabledfor ( level level ) bool { return defaultbackend . isenabledfor ( level , l . module ) } 
func ( l * logger ) fatal ( args ... interface { } ) { l . log ( critical , nil , args ... ) os . exit ( 1 ) } 
func ( l * logger ) fatalf ( format string , args ... interface { } ) { l . log ( critical , & format , args ... ) os . exit ( 1 ) } 
func ( l * logger ) panic ( args ... interface { } ) { l . log ( critical , nil , args ... ) panic ( fmt . sprint ( args ... ) ) } 
func ( l * logger ) panicf ( format string , args ... interface { } ) { l . log ( critical , & format , args ... ) panic ( fmt . sprintf ( format , args ... ) ) } 
func ( l * logger ) criticalf ( format string , args ... interface { } ) { l . log ( critical , & format , args ... ) } 
func ( l * logger ) warningf ( format string , args ... interface { } ) { l . log ( warning , & format , args ... ) } 
func ( l * logger ) noticef ( format string , args ... interface { } ) { l . log ( notice , & format , args ... ) } 
func ( l * logger ) infof ( format string , args ... interface { } ) { l . log ( info , & format , args ... ) } 
func newlogbackend ( out io . writer , prefix string , flag int ) * logbackend { b : = & logbackend { logger : log . new ( out , prefix , flag ) } if f , ok : = out . ( file ) ; ok { b . f = f } return b } 
func setformatter ( f formatter ) { formatter . lock ( ) defer formatter . unlock ( ) formatter . def = f } 
func muststringformatter ( format string ) formatter { f , err : = newstringformatter ( format ) if err ! = nil { panic ( " " + err . error ( ) ) } return f } 
func formatfuncname ( v fmtverb , f string ) string { i : = strings . lastindex ( f , " " ) j : = strings . index ( f [ i + 1 : ] , " " ) if j < 1 { return " " } pkg , fun : = f [ : i + j + 1 ] , f [ i + j + 2 : ] switch v { case fmtverblongpkg : return pkg case fmtverbshortpkg : return path . base ( pkg ) case fmtverblongfunc : return fun case fmtverbshortfunc : i = strings . lastindex ( fun , " " ) return fun [ i + 1 : ] } panic ( " " ) } 
func ( bf * backendformatter ) log ( level level , calldepth int , r * record ) error { r2 : = * r r2 . formatter = bf . f return bf . b . log ( level , calldepth + 1 , & r2 ) } 
func loglevel ( level string ) ( level , error ) { for i , name : = range levelnames { if strings . equalfold ( name , level ) { return level ( i ) , nil } } return error , errinvalidloglevel } 
func addmodulelevel ( backend backend ) leveledbackend { var leveled leveledbackend var ok bool if leveled , ok = backend . ( leveledbackend ) ; ! ok { leveled = & moduleleveled { levels : make ( map [ string ] level ) , backend : backend , } } return leveled } 
func ( l * moduleleveled ) getlevel ( module string ) level { level , exists : = l . levels [ module ] if exists == false { level , exists = l . levels [ " " ] if exists == false { level = debug } } return level } 
func ( l * moduleleveled ) setlevel ( level level , module string ) { l . levels [ module ] = level } 
func ( l * moduleleveled ) isenabledfor ( level level , module string ) bool { return level <= l . getlevel ( module ) } 
func multilogger ( backends ... backend ) leveledbackend { var leveledbackends [ ] leveledbackend for , backend : = range backends { leveledbackends = append ( leveledbackends , addmodulelevel ( backend ) ) } return & multilogger { leveledbackends } } 
func ( b * multilogger ) log ( level level , calldepth int , rec * record ) ( err error ) { for , backend : = range b . backends { if backend . isenabledfor ( level , rec . module ) { r2 : = * rec if e : = backend . log ( level , calldepth + 1 , & r2 ) ; e ! = nil { err = e } } } return } 
func ( b * multilogger ) getlevel ( module string ) level { var level level for , backend : = range b . backends { if backendlevel : = backend . getlevel ( module ) ; backendlevel > level { level = backendlevel } } return level } 
func ( b * multilogger ) setlevel ( level level , module string ) { for , backend : = range b . backends { backend . setlevel ( level , module ) } } 
func ( b * multilogger ) isenabledfor ( level level , module string ) bool { for , backend : = range b . backends { if backend . isenabledfor ( level , module ) { return true } } return false } 
func newlogbackend ( out io . writer , prefix string , flag int ) * logbackend { return & logbackend { logger : log . new ( out , prefix , flag ) } } 
func ( b * logbackend ) log ( level level , calldepth int , rec * record ) error { if b . color { col : = colors [ level ] if len ( b . colorconfig ) > int ( level ) && b . colorconfig [ level ] ! = " " { col = b . colorconfig [ level ] } buf : = & bytes . buffer { } buf . write ( [ ] byte ( col ) ) buf . write ( [ ] byte ( rec . formatted ( calldepth + 1 ) ) ) buf . write ( [ ] byte ( " \ 033 " ) ) return b . logger . output ( calldepth + 2 , buf . string ( ) ) } return b . logger . output ( calldepth + 2 , rec . formatted ( calldepth + 1 ) ) } 
func convertcolors ( colors [ ] int , bold bool ) [ ] string { converted : = [ ] string { } for , i : = range colors { if bold { converted = append ( converted , colorseqbold ( color ( i ) ) ) } else { converted = append ( converted , colorseq ( color ( i ) ) ) } } return converted } 
func newsyslogbackend ( prefix string ) ( b * syslogbackend , err error ) { var w * syslog . writer w , err = syslog . new ( syslog . log crit , prefix ) return & syslogbackend { w } , err } 
func newsyslogbackendpriority ( prefix string , priority syslog . priority ) ( b * syslogbackend , err error ) { var w * syslog . writer w , err = syslog . new ( priority , prefix ) return & syslogbackend { w } , err } 
func ( b * syslogbackend ) log ( level level , calldepth int , rec * record ) error { line : = rec . formatted ( calldepth + 1 ) switch level { case critical : return b . writer . crit ( line ) case error : return b . writer . err ( line ) case warning : return b . writer . warning ( line ) case notice : return b . writer . notice ( line ) case info : return b . writer . info ( line ) case debug : return b . writer . debug ( line ) default : } panic ( " " ) } 
func setbackend ( backends ... backend ) leveledbackend { var backend backend if len ( backends ) == 1 { backend = backends [ 0 ] } else { backend = multilogger ( backends ... ) } defaultbackend = addmodulelevel ( backend ) return defaultbackend } 
func newcommander ( toplevelflags * flag . flagset , name string ) * commander { cdr : = & commander { topflags : toplevelflags , name : name , output : os . stdout , error : os . stderr , } toplevelflags . usage = func ( ) { cdr . explain ( cdr . error ) } return cdr } 
func ( cdr * commander ) register ( cmd command , group string ) { for , g : = range cdr . commands { if g . name == group { g . commands = append ( g . commands , cmd ) return } } cdr . commands = append ( cdr . commands , & commandgroup { name : group , commands : [ ] command { cmd } , } ) } 
func ( cdr * commander ) importantflag ( name string ) { cdr . important = append ( cdr . important , name ) } 
func ( cdr * commander ) execute ( ctx context . context , args ... interface { } ) exitstatus { if cdr . topflags . narg ( ) < 1 { cdr . topflags . usage ( ) return exitusageerror } name : = cdr . topflags . arg ( 0 ) for , group : = range cdr . commands { for , cmd : = range group . commands { if name ! = cmd . name ( ) { continue } f : = flag . newflagset ( name , flag . continueonerror ) f . usage = func ( ) { explain ( cdr . error , cmd ) } cmd . setflags ( f ) if f . parse ( cdr . topflags . args ( ) [ 1 : ] ) ! = nil { return exitusageerror } return cmd . execute ( ctx , f , args ... ) } } cdr . topflags . usage ( ) return exitusageerror } 
func ( cdr * commander ) explain ( w io . writer ) { fmt . fprintf ( w , " \n \n " , cdr . name ) sort . sort ( bygroupname ( cdr . commands ) ) for , group : = range cdr . commands { explaingroup ( w , group ) } if cdr . topflags == nil { fmt . fprintln ( w , " \n " ) return } if len ( cdr . important ) == 0 { fmt . fprintf ( w , " \n " " \n " , cdr . name ) return } fmt . fprintf ( w , " \n " " \n " , cdr . name ) for , name : = range cdr . important { f : = cdr . topflags . lookup ( name ) if f == nil { panic ( fmt . sprintf ( " " , name ) ) } fmt . fprintf ( w , " \n " , f . name , f . defvalue , f . usage ) } } 
func explaingroup ( w io . writer , group * commandgroup ) { if len ( group . commands ) == 0 { return } if group . name == " " { fmt . fprintf ( w , " \n " ) } else { fmt . fprintf ( w , " \n " , group . name ) } sort . sort ( group ) aliases : = make ( map [ string ] [ ] string ) for , cmd : = range group . commands { if alias , ok : = cmd . ( * aliaser ) ; ok { root : = dealias ( alias ) . name ( ) if , ok : = aliases [ root ] ; ! ok { aliases [ root ] = [ ] string { } } aliases [ root ] = append ( aliases [ root ] , alias . name ( ) ) } } for , cmd : = range group . commands { if , ok : = cmd . ( * aliaser ) ; ok { continue } name : = cmd . name ( ) names : = [ ] string { name } if a , ok : = aliases [ name ] ; ok { names = append ( names , a ... ) } fmt . fprintf ( w , " \ t \n " , strings . join ( names , " " ) , cmd . synopsis ( ) ) } fmt . fprintln ( w ) } 
func explain ( w io . writer , cmd command ) { fmt . fprintf ( w , " " , cmd . usage ( ) ) subflags : = flag . newflagset ( cmd . name ( ) , flag . paniconerror ) subflags . setoutput ( w ) cmd . setflags ( subflags ) subflags . printdefaults ( ) } 
func dealias ( cmd command ) command { if alias , ok : = cmd . ( * aliaser ) ; ok { return dealias ( alias . command ) } return cmd } 
func execute ( ctx context . context , args ... interface { } ) exitstatus { return defaultcommander . execute ( ctx , args ... ) } 
func loadfromdata ( data [ ] byte ) ( c * configfile , err error ) { tmpname : = path . join ( os . tempdir ( ) , " " , fmt . sprintf ( " " , time . now ( ) . nanosecond ( ) ) ) if err = os . mkdirall ( path . dir ( tmpname ) , os . modeperm ) ; err ! = nil { return nil , err } if err = ioutil . writefile ( tmpname , data , 0655 ) ; err ! = nil { return nil , err } c = newconfigfile ( [ ] string { tmpname } ) err = c . read ( bytes . newbuffer ( data ) ) return c , err } 
func loadfromreader ( in io . reader ) ( c * configfile , err error ) { c = newconfigfile ( [ ] string { " " } ) err = c . read ( in ) return c , err } 
func ( c * configfile ) reloaddata ( in io . reader ) ( err error ) { var cfg * configfile if len ( c . filenames ) ! = 1 { return fmt . errorf ( " " ) } cfg , err = loadfromreader ( in ) if err == nil { * c = * cfg } return err } 
func ( c * configfile ) appendfiles ( files ... string ) error { if len ( c . filenames ) == 1 && c . filenames [ 0 ] == " " { return fmt . errorf ( " " ) } c . filenames = append ( c . filenames , files ... ) return c . reload ( ) } 
func ( c * configfile ) getkeylist ( section string ) [ ] string { if len ( section ) == 0 { section = default section } if c . blockmode { c . lock . rlock ( ) defer c . lock . runlock ( ) } if , ok : = c . data [ section ] ; ! ok { return nil } list : = make ( [ ] string , 0 , len ( c . keylist [ section ] ) ) for , key : = range c . keylist [ section ] { if key ! = " " { list = append ( list , key ) } } return list } 
func saveconfigfile ( c * configfile , filename string ) ( err error ) { var f * os . file if f , err = os . create ( filename ) ; err ! = nil { return err } if err : = saveconfigdata ( c , f ) ; err ! = nil { return err } return f . close ( ) } 
func ( s * selectable ) find ( selector string ) * selection { return newselection ( s . session , s . selectors . append ( target . css , selector ) . single ( ) ) } 
func ( s * selectable ) findbyxpath ( selector string ) * selection { return newselection ( s . session , s . selectors . append ( target . xpath , selector ) . single ( ) ) } 
func ( s * selectable ) findbylink ( text string ) * selection { return newselection ( s . session , s . selectors . append ( target . link , text ) . single ( ) ) } 
func ( s * selectable ) findbylabel ( text string ) * selection { return newselection ( s . session , s . selectors . append ( target . label , text ) . single ( ) ) } 
func ( s * selectable ) findbybutton ( text string ) * selection { return newselection ( s . session , s . selectors . append ( target . button , text ) . single ( ) ) } 
func ( s * selectable ) findbyname ( name string ) * selection { return newselection ( s . session , s . selectors . append ( target . name , name ) . single ( ) ) } 
func ( s * selectable ) findbyclass ( text string ) * selection { return newselection ( s . session , s . selectors . append ( target . class , text ) . single ( ) ) } 
func ( s * selectable ) findbyid ( id string ) * selection { return newselection ( s . session , s . selectors . append ( target . id , id ) . single ( ) ) } 
func ( s * selectable ) first ( selector string ) * selection { return newselection ( s . session , s . selectors . append ( target . css , selector ) . at ( 0 ) ) } 
func ( s * selectable ) firstbyxpath ( selector string ) * selection { return newselection ( s . session , s . selectors . append ( target . xpath , selector ) . at ( 0 ) ) } 
func ( s * selectable ) firstbylink ( text string ) * selection { return newselection ( s . session , s . selectors . append ( target . link , text ) . at ( 0 ) ) } 
func ( s * selectable ) firstbylabel ( text string ) * selection { return newselection ( s . session , s . selectors . append ( target . label , text ) . at ( 0 ) ) } 
func ( s * selectable ) firstbybutton ( text string ) * selection { return newselection ( s . session , s . selectors . append ( target . button , text ) . at ( 0 ) ) } 
func ( s * selectable ) firstbyname ( name string ) * selection { return newselection ( s . session , s . selectors . append ( target . name , name ) . at ( 0 ) ) } 
func ( s * selectable ) all ( selector string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . css , selector ) ) } 
func ( s * selectable ) allbyxpath ( selector string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . xpath , selector ) ) } 
func ( s * selectable ) allbylink ( text string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . link , text ) ) } 
func ( s * selectable ) allbylabel ( text string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . label , text ) ) } 
func ( s * selectable ) allbybutton ( text string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . button , text ) ) } 
func ( s * selectable ) allbyname ( name string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . name , name ) ) } 
func ( s * selectable ) allbyclass ( text string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . class , text ) ) } 
func ( s * selectable ) allbyid ( text string ) * multiselection { return newmultiselection ( s . session , s . selectors . append ( target . id , text ) ) } 
func ( s * selectable ) findforappium ( selectortype string , text string ) * selection { return newselection ( s . session , s . selectors . append ( target . class , text ) . at ( 0 ) ) } 
func timeout ( seconds int ) option { return func ( c * config ) { c . timeout = time . duration ( seconds ) * time . second } } 
func chromeoptions ( opt string , value interface { } ) option { return func ( c * config ) { if c . chromeoptions == nil { c . chromeoptions = make ( map [ string ] interface { } ) } c . chromeoptions [ opt ] = value } } 
func newpage ( url string , options ... option ) ( * page , error ) { pageoptions : = config { } . merge ( options ) session , err : = api . openwithclient ( url , pageoptions . capabilities ( ) , pageoptions . httpclient ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return newpage ( session ) , nil } 
func joinpage ( url string , options ... option ) * page { pageoptions : = config { } . merge ( options ) session : = api . newwithclient ( url , pageoptions . httpclient ) return newpage ( session ) } 
func ( p * page ) destroy ( ) error { if err : = p . session . delete ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) reset ( ) error { p . confirmpopup ( ) url , err : = p . url ( ) if err ! = nil { return err } if url == " " { return nil } if err : = p . clearcookies ( ) ; err ! = nil { return err } if err : = p . session . deletelocalstorage ( ) ; err ! = nil { if err : = p . runscript ( " " , nil , nil ) ; err ! = nil { return err } } if err : = p . session . deletesessionstorage ( ) ; err ! = nil { if err : = p . runscript ( " " , nil , nil ) ; err ! = nil { return err } } return p . navigate ( " " ) } 
func ( p * page ) navigate ( url string ) error { if err : = p . session . seturl ( url ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) getcookies ( ) ( [ ] * http . cookie , error ) { apicookies , err : = p . session . getcookies ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } cookies : = [ ] * http . cookie { } for , apicookie : = range apicookies { expseconds : = int64 ( apicookie . expiry ) expnano : = int64 ( apicookie . expiry - float64 ( expseconds ) ) * 1000000000 cookie : = & http . cookie { name : apicookie . name , value : apicookie . value , path : apicookie . path , domain : apicookie . domain , secure : apicookie . secure , httponly : apicookie . httponly , expires : time . unix ( expseconds , expnano ) , } cookies = append ( cookies , cookie ) } return cookies , nil } 
func ( p * page ) setcookie ( cookie * http . cookie ) error { if cookie == nil { return errors . new ( " " ) } var expiry int64 if ! cookie . expires . iszero ( ) { expiry = cookie . expires . unix ( ) } apicookie : = & api . cookie { name : cookie . name , value : cookie . value , path : cookie . path , domain : cookie . domain , secure : cookie . secure , httponly : cookie . httponly , expiry : float64 ( expiry ) , } if err : = p . session . setcookie ( apicookie ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) deletecookie ( name string ) error { if err : = p . session . deletecookie ( name ) ; err ! = nil { return fmt . errorf ( " " , name , err ) } return nil } 
func ( p * page ) clearcookies ( ) error { if err : = p . session . deletecookies ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) url ( ) ( string , error ) { url , err : = p . session . geturl ( ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } return url , nil } 
func ( p * page ) size ( width , height int ) error { window , err : = p . session . getwindow ( ) if err ! = nil { return fmt . errorf ( " " , err ) } if err : = window . setsize ( width , height ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) screenshot ( filename string ) error { absfilepath , err : = filepath . abs ( filename ) if err ! = nil { return fmt . errorf ( " " , err ) } screenshot , err : = p . session . getscreenshot ( ) if err ! = nil { return fmt . errorf ( " " , err ) } if err : = ioutil . writefile ( absfilepath , screenshot , 0666 ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) title ( ) ( string , error ) { title , err : = p . session . gettitle ( ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } return title , nil } 
func ( p * page ) html ( ) ( string , error ) { html , err : = p . session . getsource ( ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } return html , nil } 
func ( p * page ) runscript ( body string , arguments map [ string ] interface { } , result interface { } ) error { var ( keys [ ] string values [ ] interface { } ) for key , value : = range arguments { keys = append ( keys , key ) values = append ( values , value ) } argumentlist : = strings . join ( keys , " " ) cleanbody : = fmt . sprintf ( " " , argumentlist , body ) if err : = p . session . execute ( cleanbody , values , result ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) popuptext ( ) ( string , error ) { text , err : = p . session . getalerttext ( ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } return text , nil } 
func ( p * page ) enterpopuptext ( text string ) error { if err : = p . session . setalerttext ( text ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) confirmpopup ( ) error { if err : = p . session . acceptalert ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) cancelpopup ( ) error { if err : = p . session . dismissalert ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) switchtoparentframe ( ) error { if err : = p . session . frameparent ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) switchtorootframe ( ) error { if err : = p . session . frame ( nil ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) switchtowindow ( name string ) error { if err : = p . session . setwindowbyname ( name ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) nextwindow ( ) error { windows , err : = p . session . getwindows ( ) if err ! = nil { return fmt . errorf ( " " , err ) } var windowids [ ] string for , window : = range windows { windowids = append ( windowids , window . id ) } sort . strings ( windowids ) activewindow , err : = p . session . getwindow ( ) if err ! = nil { return fmt . errorf ( " " , err ) } for position , windowid : = range windowids { if windowid == activewindow . id { activewindow . id = windowids [ ( position + 1 ) % len ( windowids ) ] break } } if err : = p . session . setwindow ( activewindow ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) closewindow ( ) error { if err : = p . session . deletewindow ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) windowcount ( ) ( int , error ) { windows , err : = p . session . getwindows ( ) if err ! = nil { return 0 , fmt . errorf ( " " , err ) } return len ( windows ) , nil } 
func ( p * page ) logtypes ( ) ( [ ] string , error ) { types , err : = p . session . getlogtypes ( ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return types , nil } 
func ( p * page ) readnewlogs ( logtype string ) ( [ ] log , error ) { if p . logs == nil { p . logs = map [ string ] [ ] log { } } clientlogs , err : = p . session . newlogs ( logtype ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } messagematcher : = regexp . mustcompile ( ' ^ ( ?s : ( . + ) ) \ s \ ( ( [ ^ ) ] * : \ w * ) \ ) $ ' ) var logs [ ] log for , clientlog : = range clientlogs { matches : = messagematcher . findstringsubmatch ( clientlog . message ) message , location : = clientlog . message , " " if len ( matches ) > 2 { message , location = matches [ 1 ] , matches [ 2 ] } log : = log { message , location , clientlog . level , mstotime ( clientlog . timestamp ) } logs = append ( logs , log ) } p . logs [ logtype ] = append ( p . logs [ logtype ] , logs ... ) return logs , nil } 
func ( p * page ) readalllogs ( logtype string ) ( [ ] log , error ) { if , err : = p . readnewlogs ( logtype ) ; err ! = nil { return nil , err } return append ( [ ] log ( nil ) , p . logs [ logtype ] ... ) , nil } 
func ( p * page ) movemouseby ( xoffset , yoffset int ) error { if err : = p . session . moveto ( nil , api . xyoffset { x : xoffset , y : yoffset } ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) doubleclick ( ) error { if err : = p . session . doubleclick ( ) ; err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func ( p * page ) click ( event click , button button ) error { var err error switch event { case singleclick : err = p . session . click ( api . button ( button ) ) case holdclick : err = p . session . buttondown ( api . button ( button ) ) case releaseclick : err = p . session . buttonup ( api . button ( button ) ) default : err = errors . new ( " " ) } if err ! = nil { return fmt . errorf ( " " , event , button , err ) } return nil } 
func ( p * page ) setimplicitwait ( timeout int ) error { return p . session . setimplicitwait ( timeout ) } 
func ( p * page ) setpageload ( timeout int ) error { return p . session . setpageload ( timeout ) } 
func ( p * page ) setscripttimeout ( timeout int ) error { return p . session . setscripttimeout ( timeout ) } 
func ( s * selection ) click ( ) error { return s . foreachelement ( func ( selectedelement element . element ) error { if err : = selectedelement . click ( ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } ) } 
func ( s * selection ) doubleclick ( ) error { return s . foreachelement ( func ( selectedelement element . element ) error { if err : = s . session . moveto ( selectedelement . ( * api . element ) , nil ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } if err : = s . session . doubleclick ( ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } ) } 
func ( s * selection ) fill ( text string ) error { return s . foreachelement ( func ( selectedelement element . element ) error { if err : = selectedelement . clear ( ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } if err : = selectedelement . value ( text ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } ) } 
func ( s * selection ) uploadfile ( filename string ) error { absfilepath , err : = filepath . abs ( filename ) if err ! = nil { return fmt . errorf ( " " , err ) } return s . foreachelement ( func ( selectedelement element . element ) error { tagname , err : = selectedelement . getname ( ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if tagname ! = " " { return fmt . errorf ( " " , s ) } inputtype , err : = selectedelement . getattribute ( " " ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if inputtype ! = " " { return fmt . errorf ( " " , s ) } if err : = selectedelement . value ( absfilepath ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } ) } 
func ( s * selection ) select ( text string ) error { return s . foreachelement ( func ( selectedelement element . element ) error { optionxpath : = fmt . sprintf ( ' . / option [ normalize - space ( ) = " %s " ] ' , text ) optiontoselect : = target . selector { type : target . xpath , value : optionxpath } options , err : = selectedelement . getelements ( optiontoselect . api ( ) ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if len ( options ) == 0 { return fmt . errorf ( ' no options with text " %s " found for %s ' , text , s ) } for , option : = range options { if err : = option . click ( ) ; err ! = nil { return fmt . errorf ( ' failed to click on option with text " %s " for %s : %s ' , text , s , err ) } } return nil } ) } 
func ( s * selection ) tap ( event tap ) error { var touchfunc func ( * api . element ) error switch event { case singletap : touchfunc = s . session . touchclick case doubletap : touchfunc = s . session . touchdoubleclick case longtap : touchfunc = s . session . touchlongclick default : return fmt . errorf ( " " , event , s ) } return s . foreachelement ( func ( selectedelement element . element ) error { if err : = touchfunc ( selectedelement . ( * api . element ) ) ; err ! = nil { return fmt . errorf ( " " , event , s , err ) } return nil } ) } 
func ( s * selection ) touch ( event touch ) error { var touchfunc func ( x , y int ) error switch event { case holdfinger : touchfunc = s . session . touchdown case releasefinger : touchfunc = s . session . touchup case movefinger : touchfunc = s . session . touchmove default : return fmt . errorf ( " " , event , s ) } return s . foreachelement ( func ( selectedelement element . element ) error { x , y , err : = selectedelement . getlocation ( ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if err : = touchfunc ( x , y ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } ) } 
func ( s * selection ) flickfinger ( xoffset , yoffset int , speed uint ) error { selectedelement , err : = s . elements . getexactlyone ( ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if err : = s . session . touchflick ( selectedelement . ( * api . element ) , api . xyoffset { x : xoffset , y : yoffset } , api . scalarspeed ( speed ) ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } 
func ( s * selection ) scrollfinger ( xoffset , yoffset int ) error { selectedelement , err : = s . elements . getexactlyone ( ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if err : = s . session . touchscroll ( selectedelement . ( * api . element ) , api . xyoffset { x : xoffset , y : yoffset } ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } 
func ( s * multiselection ) at ( index int ) * selection { return newselection ( s . session , s . selectors . at ( index ) ) } 
func newcapabilities ( features ... string ) capabilities { c : = capabilities { } for , feature : = range features { c . with ( feature ) } return c } 
func ( c capabilities ) with ( feature string ) capabilities { c [ feature ] = true return c } 
func ( c capabilities ) without ( feature string ) capabilities { c [ feature ] = false return c } 
func ( c capabilities ) json ( ) ( string , error ) { capabilitiesjson , err : = json . marshal ( c ) return string ( capabilitiesjson ) , err } 
func havetitle ( title string ) types . gomegamatcher { return & internal . valuematcher { method : " " , property : " " , expected : title } } 
func haveurl ( url string ) types . gomegamatcher { return & internal . valuematcher { method : " " , property : " " , expected : url } } 
func havepopuptext ( text string ) types . gomegamatcher { return & internal . valuematcher { method : " " , property : " " , expected : text } } 
func haveloggederror ( messages ... string ) types . gomegamatcher { return & internal . logmatcher { expectedmessages : messages , levels : [ ] string { " " , " " } , name : " " , type : " " , } } 
func ( s * selection ) text ( ) ( string , error ) { selectedelement , err : = s . elements . getexactlyone ( ) if err ! = nil { return " " , fmt . errorf ( " " , s , err ) } text , err : = selectedelement . gettext ( ) if err ! = nil { return " " , fmt . errorf ( " " , s , err ) } return text , nil } 
func ( s * selection ) active ( ) ( bool , error ) { selectedelement , err : = s . elements . getexactlyone ( ) if err ! = nil { return false , fmt . errorf ( " " , s , err ) } activeelement , err : = s . session . getactiveelement ( ) if err ! = nil { return false , fmt . errorf ( " " , err ) } equal , err : = selectedelement . isequalto ( activeelement ) if err ! = nil { return false , fmt . errorf ( " " , err ) } return equal , nil } 
func ( s * selection ) attribute ( attribute string ) ( string , error ) { return s . hasproperty ( element . element . getattribute , attribute , " " ) } 
func ( s * selection ) css ( property string ) ( string , error ) { return s . hasproperty ( element . element . getcss , property , " " ) } 
func ( s * selection ) selected ( ) ( bool , error ) { return s . hasstate ( element . element . isselected , " " ) } 
func ( s * selection ) visible ( ) ( bool , error ) { return s . hasstate ( element . element . isdisplayed , " " ) } 
func ( s * selection ) enabled ( ) ( bool , error ) { return s . hasstate ( element . element . isenabled , " " ) } 
func havecount ( count int ) types . gomegamatcher { return & internal . valuematcher { method : " " , property : " " , expected : count } } 
func haveattribute ( attribute string , value string ) types . gomegamatcher { return & internal . haveattributematcher { expectedattribute : attribute , expectedvalue : value } } 
func havecss ( property string , value string ) types . gomegamatcher { return & internal . havecssmatcher { expectedproperty : property , expectedvalue : value } } 
func phantomjs ( options ... option ) * webdriver { command : = [ ] string { " " , " " } defaultoptions : = config { } . merge ( options ) if ! defaultoptions . rejectinvalidssl { command = append ( command , " " ) } return newwebdriver ( " " , command , options ... ) } 
func edgedriver ( options ... option ) * webdriver { var binaryname string if runtime . goos == " " { binaryname = " " } else { return nil } command : = [ ] string { binaryname , " " } return newwebdriver ( " " , command , options ... ) } 
func selendroid ( jarfile string , options ... option ) * webdriver { absjarpath , err : = filepath . abs ( jarfile ) if err ! = nil { return nil } command : = [ ] string { " " , " " , absjarpath , " " , " " , } options = append ( [ ] option { timeout ( 90 ) , browser ( " " ) } , options ... ) return newwebdriver ( " " , command , options ... ) } 
func saucelabs ( name , platform , browser , version , username , accesskey string , options ... option ) ( * page , error ) { url : = fmt . sprintf ( " " , username , accesskey ) capabilities : = newcapabilities ( ) . browser ( browser ) . platform ( platform ) . version ( version ) capabilities [ " " ] = name return newpage ( url , append ( [ ] option { desired ( capabilities ) } , options ... ) ... ) } 
func ( s * selection ) switchtoframe ( ) error { selectedelement , err : = s . elements . getexactlyone ( ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if err : = s . session . frame ( selectedelement . ( * api . element ) ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } 
func ( s * selection ) count ( ) ( int , error ) { elements , err : = s . elements . get ( ) if err ! = nil { return 0 , fmt . errorf ( " " , s , err ) } return len ( elements ) , nil } 
func ( s * selection ) equalselement ( other interface { } ) ( bool , error ) { otherselection , ok : = other . ( * selection ) if ! ok { multiselection , ok : = other . ( * multiselection ) if ! ok { return false , fmt . errorf ( " " ) } otherselection = & multiselection . selection } selectedelement , err : = s . elements . getexactlyone ( ) if err ! = nil { return false , fmt . errorf ( " " , s , err ) } otherelement , err : = otherselection . elements . getexactlyone ( ) if err ! = nil { return false , fmt . errorf ( " " , other , err ) } equal , err : = selectedelement . isequalto ( otherelement . ( * api . element ) ) if err ! = nil { return false , fmt . errorf ( " " , s , other , err ) } return equal , nil } 
func ( s * selection ) mousetoelement ( ) error { selectedelement , err : = s . elements . getexactlyone ( ) if err ! = nil { return fmt . errorf ( " " , s , err ) } if err : = s . session . moveto ( selectedelement . ( * api . element ) , nil ) ; err ! = nil { return fmt . errorf ( " " , s , err ) } return nil } 
func loggingmiddleware ( next http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { log . printf ( " \n " , r . remoteaddr , r . requesturi ) next . servehttp ( w , r ) } ) } 
func chainhandlers ( mw ... middleware ) middleware { return func ( final http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { last : = final for i : = len ( mw ) - 1 ; i >= 0 ; i -- { last = mw [ i ] ( last ) } last . servehttp ( w , r ) } ) } } 
func ( i * installer ) checkinstallation ( ) error { for binary , versionrange : = range versionmap { log . println ( " " , binary , " " , versionrange ) version , err : = i . getversionforbinary ( binary ) if err ! = nil { return err } if err = i . checkversion ( binary , version ) ; err ! = nil { return err } } return nil } 
func ( i * installer ) checkversion ( binary , version string ) error { log . println ( " " , binary , " " , version ) v , err : = goversion . newversion ( version ) if err ! = nil { log . println ( " " , err ) return err } versionrange , ok : = versionmap [ binary ] if ! ok { return fmt . errorf ( " " , binary ) } log . println ( " " , v , " " , versionrange ) constraints , err : = goversion . newconstraint ( versionrange ) if constraints . check ( v ) { log . println ( " " , v , " " , v , constraints ) return nil } return fmt . errorf ( " " , version , binary , versionrange ) } 
func ( i * installer ) getversionforbinary ( binary string ) ( version string , err error ) { log . println ( " " , binary ) content , err : = i . commander . output ( binary , " " ) elements : = strings . split ( strings . trimspace ( string ( content ) ) , " \n " ) version = strings . trimspace ( elements [ len ( elements ) - 1 ] ) return version , err } 
func ( c * client ) getuser ( id string ) ( * ex . user , error ) { u : = fmt . sprintf ( " " , c . host , id ) req , err : = http . newrequest ( " " , u , nil ) req . header . set ( " " , " " ) req . header . set ( " " , c . token ) res , err : = http . defaultclient . do ( req ) if res . statuscode ! = 200 | | err ! = nil { return nil , fmt . errorf ( " " ) } data , err : = ioutil . readall ( res . body ) if err ! = nil { return nil , err } var response ex . user err = json . unmarshal ( data , & response ) if err ! = nil { return nil , err } return & response , err } 
func ( c * client ) login ( username string , password string ) ( * ex . user , error ) { loginrequest : = fmt . sprintf ( , username , password ) res , err : = http . post ( fmt . sprintf ( " " , c . host ) , " " , bytes . newreader ( [ ] byte ( loginrequest ) ) ) if res . statuscode ! = 200 | | err ! = nil { return nil , fmt . errorf ( " " ) } data , err : = ioutil . readall ( res . body ) if err ! = nil { return nil , err } var response loginresponse err = json . unmarshal ( data , & response ) if err ! = nil { return nil , err } return & response . user , err } 
func ( c * client ) loginhandler ( w http . responsewriter , r * http . request ) { username : = r . formvalue ( " " ) password : = r . formvalue ( " " ) user , err : = c . login ( username , password ) if err == nil && user ! = nil { c . user = user c . err = nil http . redirect ( w , r , " " , http . statusfound ) return } c . err = fmt . errorf ( " " ) http . redirect ( w , r , " " , http . statusfound ) return } 
func ( c * client ) logouthandler ( w http . responsewriter , r * http . request ) { c . user = nil c . err = nil http . redirect ( w , r , " " , http . statusfound ) return } 
func ( c * client ) viewhandler ( w http . responsewriter , r * http . request ) { data : = templatedata { user : c . user , error : c . err , } rendertemplate ( w , " " , data ) } 
func ( c * client ) run ( ) { http . handlefunc ( " " , c . loginhandler ) http . handlefunc ( " " , c . logouthandler ) http . handlefunc ( " " , c . viewhandler ) fmt . println ( " " ) http . listenandserve ( " " , nil ) } 
func ( i * interaction ) given ( state string ) * interaction { i . state = state return i } 
func ( i * interaction ) uponreceiving ( description string ) * interaction { i . description = description return i } 
func isjsonformattedobject ( stringorobject interface { } ) bool { switch content : = stringorobject . ( type ) { case [ ] byte : case string : var obj interface { } err : = json . unmarshal ( [ ] byte ( content ) , & obj ) if err ! = nil { return false } if , ok : = obj . ( map [ string ] interface { } ) ; ok { return true } } return false } 
func ( u * userrepository ) byusername ( username string ) ( * user , error ) { if user , ok : = u . users [ username ] ; ok { return user , nil } return nil , errnotfound } 
func ( u * userrepository ) byid ( id int ) ( * user , error ) { for , user : = range u . users { if user . id == id { return user , nil } } return nil , errnotfound } 
func isauthenticated ( h http . handlerfunc ) http . handlerfunc { return func ( w http . responsewriter , r * http . request ) { if r . header . get ( " " ) == fmt . sprintf ( " " , getauthtoken ( ) ) { h . servehttp ( w , r ) } else { w . header ( ) . set ( " " , " " ) w . writeheader ( http . statusunauthorized ) } } } 
func userlogin ( w http . responsewriter , r * http . request ) { var login types . loginrequest w . header ( ) . set ( " " , " " ) w . header ( ) . set ( " " , " " ) body , err : = ioutil . readall ( r . body ) defer r . body . close ( ) if err ! = nil { w . writeheader ( http . statusserviceunavailable ) return } err = json . unmarshal ( body , & login ) if err ! = nil { w . writeheader ( http . statusserviceunavailable ) return } user , err : = userrepository . byusername ( login . username ) if err ! = nil { w . writeheader ( http . statusnotfound ) } else if user . username ! = login . username | | user . password ! = login . password { w . writeheader ( http . statusunauthorized ) } else { w . header ( ) . set ( " " , getauthtoken ( ) ) w . writeheader ( http . statusok ) res : = types . loginresponse { user : user } resbody , : = json . marshal ( res ) w . write ( resbody ) } } 
func getuser ( w http . responsewriter , r * http . request ) { w . header ( ) . set ( " " , " " ) w . header ( ) . set ( " " , " " ) a : = strings . split ( r . url . path , " " ) id , : = strconv . atoi ( a [ len ( a ) - 1 ] ) user , err : = userrepository . byid ( id ) if err ! = nil { w . writeheader ( http . statusnotfound ) } else { w . writeheader ( http . statusok ) resbody , : = json . marshal ( user ) w . write ( resbody ) } } 
func newclient ( mockservicemanager client . service , verificationservicemanager client . service , messageservicemanager client . service , publishservicemanager client . service ) * pactclient { mockservicemanager . setup ( ) verificationservicemanager . setup ( ) messageservicemanager . setup ( ) publishservicemanager . setup ( ) return & pactclient { pactmocksvcmanager : mockservicemanager , verificationsvcmanager : verificationservicemanager , messagesvcmanager : messageservicemanager , publishsvcmanager : publishservicemanager , timeoutduration : 10 * time . second , } } 
func newclient ( ) * pactclient { return newclient ( & client . mockservice { } , & client . verificationservice { } , & client . messageservice { } , & client . publishservice { } ) } 
func ( p * pactclient ) startserver ( args [ ] string , port int ) * types . mockserver { log . println ( " " , args , " " , port ) args = append ( args , [ ] string { " " , strconv . itoa ( port ) } ... ) svc : = p . pactmocksvcmanager . newservice ( args ) cmd : = svc . start ( ) waitforport ( port , p . getnetworkinterface ( ) , p . address , p . timeoutduration , fmt . sprintf ( ' timed out waiting for mock server to start on port %d - are you sure it ' s running? ' , port ) ) return & types . mockserver { pid : cmd . process . pid , port : port , } } 
func ( p * pactclient ) listservers ( ) [ ] * types . mockserver { log . println ( " " ) var servers [ ] * types . mockserver for port , s : = range p . pactmocksvcmanager . list ( ) { servers = append ( servers , & types . mockserver { pid : s . process . pid , port : port , } ) } return servers } 
func ( p * pactclient ) stopserver ( server * types . mockserver ) ( * types . mockserver , error ) { log . println ( " " ) , server . error = p . pactmocksvcmanager . stop ( server . pid ) return server , server . error } 
func ( p * pactclient ) removeallservers ( server * types . mockserver ) [ ] * types . mockserver { log . println ( " " ) for , s : = range p . verificationsvcmanager . list ( ) { if s ! = nil { p . pactmocksvcmanager . stop ( s . process . pid ) } } return nil } 
func ( p * pactclient ) updatemessagepact ( request types . pactmessagerequest ) error { log . println ( " " ) err : = request . validate ( ) if err ! = nil { return err } svc : = p . messagesvcmanager . newservice ( request . args ) cmd : = svc . command ( ) stdoutpipe , err : = cmd . stdoutpipe ( ) if err ! = nil { return err } stderrpipe , err : = cmd . stderrpipe ( ) if err ! = nil { return err } err = cmd . start ( ) if err ! = nil { return err } stdout , err : = ioutil . readall ( stdoutpipe ) if err ! = nil { return err } stderr , err : = ioutil . readall ( stderrpipe ) if err ! = nil { return err } err = cmd . wait ( ) if err == nil { return nil } return fmt . errorf ( " \n \n \n \n \n \n " , err , stderr , stdout ) } 
func ( p * pactclient ) publishpacts ( request types . publishrequest ) error { svc : = p . publishsvcmanager . newservice ( request . args ) log . println ( " " ) cmd : = svc . start ( ) log . println ( " " ) err : = cmd . wait ( ) log . println ( " " , err ) return err } 
func ( p * pactclient ) reifymessage ( request * types . pactreificationrequest ) ( res * types . reificationresponse , err error ) { log . println ( " " ) var responseobject interface { } res = & types . reificationresponse { response : responseobject , } err = request . validate ( ) if err ! = nil { return } svc : = p . messagesvcmanager . newservice ( request . args ) cmd : = svc . command ( ) stdoutpipe , err : = cmd . stdoutpipe ( ) if err ! = nil { return } stderrpipe , err : = cmd . stderrpipe ( ) if err ! = nil { return } err = cmd . start ( ) if err ! = nil { return } stdout , err : = ioutil . readall ( stdoutpipe ) if err ! = nil { return } stderr , err : = ioutil . readall ( stderrpipe ) if err ! = nil { return } err = cmd . wait ( ) res . responseraw = stdout decoder : = json . newdecoder ( bytes . newreader ( stdout ) ) derr : = decoder . decode ( & res . response ) if derr == nil { return } if err == nil { err = derr } if err == nil { return } err = fmt . errorf ( " \n \n \n \n \n \n " , err , stderr , stdout ) return } 
func getport ( rawurl string ) int { parsedurl , err : = url . parse ( rawurl ) if err == nil { splithost : = strings . split ( parsedurl . host , " " ) if len ( splithost ) == 2 { port , err : = strconv . atoi ( splithost [ 1 ] ) if err == nil { return port } } if parsedurl . scheme == " " { return 443 } return 80 } return - 1 } 
func getaddress ( rawurl string ) string { parsedurl , err : = url . parse ( rawurl ) if err ! = nil { return " " } splithost : = strings . split ( parsedurl . host , " " ) return splithost [ 0 ] } 
func sanitiserubyresponse ( response string ) string { log . println ( " " , response ) r : = regexp . mustcompile ( " \ \ " ) s : = r . replaceallstring ( response , " " ) r = regexp . mustcompile ( " " ) s = r . replaceallstring ( s , " " ) r = regexp . mustcompile ( " \ \ " ) s = r . replaceallstring ( s , " \n " ) return s } 
func ( s * servicemock ) stop ( pid int ) ( bool , error ) { s . servicestopcount ++ return s . servicestopresult , s . servicestoperror } 
func ( s * servicemock ) start ( ) * exec . cmd { s . servicestartcount ++ cmd : = s . execfunc ( ) cmd . start ( ) if s . processes == nil { s . processes = make ( map [ int ] * exec . cmd ) } s . processes [ cmd . process . pid ] = cmd return cmd } 
func ( v * publishservice ) newservice ( args [ ] string ) service { log . printf ( " \n " , args ) v . args = [ ] string { " " , } v . args = append ( v . args , args ... ) v . cmd = getpublishercommandpath ( ) return v } 
func ( v * messageservice ) newservice ( args [ ] string ) service { v . args = args log . printf ( " \n " , v . args ) v . cmd = " " return v } 
func ( m * pactreificationrequest ) validate ( ) error { m . args = [ ] string { } body , err : = json . marshal ( m . message ) if err ! = nil { return err } m . args = append ( m . args , [ ] string { " " , string ( body ) , } ... ) return nil } 
func ( p * publisher ) publish ( request types . publishrequest ) error { log . println ( " " ) if p . pactclient == nil { c : = newclient ( ) p . pactclient = c } err : = request . validate ( ) if err ! = nil { return err } return p . pactclient . publishpacts ( request ) } 
func ( v * verifymessagerequest ) validate ( ) error { v . args = [ ] string { } if len ( v . pacturls ) ! = 0 { v . args = append ( v . args , v . pacturls ... ) } else { return fmt . errorf ( " " ) } v . args = append ( v . args , " " , " " ) if v . brokerusername ! = " " { v . args = append ( v . args , " " , v . brokerusername ) } if v . brokerpassword ! = " " { v . args = append ( v . args , " " , v . brokerpassword ) } if v . providerversion ! = " " { v . args = append ( v . args , " " , v . providerversion ) } if v . publishverificationresults { v . args = append ( v . args , " " , " " ) } return nil } 
func findportinrange ( s string ) ( int , error ) { if ! strings . contains ( s , " " ) { ports : = strings . split ( strings . trimspace ( s ) , " " ) for , p : = range ports { i , err : = strconv . atoi ( p ) if err ! = nil { return 0 , err } err = checkport ( i ) if err ! = nil { continue } return i , nil } return 0 , errors . new ( " " ) } ports : = strings . split ( strings . trimspace ( s ) , " " ) if len ( ports ) ! = 2 { return 0 , errors . new ( " " ) } lower , err : = strconv . atoi ( ports [ 0 ] ) if err ! = nil { return 0 , err } upper , err : = strconv . atoi ( ports [ 1 ] ) if err ! = nil { return 0 , err } if upper < lower { return 0 , errors . new ( " " ) } for i : = lower ; i <= upper ; i ++ { err = checkport ( i ) if err ! = nil { continue } return i , nil } return 0 , errors . new ( " " ) } 
func eachlike ( content interface { } , minrequired int ) matcher { return eachlike { contents : content , min : minrequired , } } 
func term ( generate string , matcher string ) matcher { return term { data : termdata { generate : generate , matcher : termmatcher { type : " " , o : 0 , regex : matcher , } , } , } } 
func ( m * mapmatcher ) unmarshaljson ( bytes [ ] byte ) ( err error ) { sk : = make ( map [ string ] string ) err = json . unmarshal ( bytes , & sk ) if err ! = nil { return } * m = make ( map [ string ] matcher ) for k , v : = range sk { ( * m ) [ k ] = string ( v ) } return } 
func objecttostring ( obj interface { } ) string { switch content : = obj . ( type ) { case string : return content default : jsonstring , err : = json . marshal ( obj ) if err ! = nil { log . println ( " " , err . error ( ) ) return " " } return string ( jsonstring ) } } 
func match ( srctype reflect . type , params params ) matcher { switch kind : = srctype . kind ( ) ; kind { case reflect . ptr : return match ( srctype . elem ( ) , params ) case reflect . slice , reflect . array : return eachlike ( match ( srctype . elem ( ) , getdefaults ( ) ) , params . slice . min ) case reflect . struct : result : = structmatcher { } for i : = 0 ; i < srctype . numfield ( ) ; i ++ { field : = srctype . field ( i ) result [ field . tag . get ( " " ) ] = match ( field . type , pluckparams ( field . type , field . tag . get ( " " ) ) ) } return result case reflect . string : if params . str . regex ! = " " { return term ( params . str . example , params . str . regex ) } if params . str . example ! = " " { return like ( params . str . example ) } return like ( " " ) case reflect . bool : return like ( true ) case reflect . int , reflect . int8 , reflect . int16 , reflect . int32 , reflect . int64 , reflect . uint , reflect . uint8 , reflect . uint16 , reflect . uint32 , reflect . uint64 : return like ( 1 ) case reflect . float32 , reflect . float64 : return like ( 1 . 1 ) default : panic ( fmt . sprintf ( " " , srctype ) ) } } 
func pluckparams ( srctype reflect . type , pacttag string ) params { params : = getdefaults ( ) if pacttag == " " { return params } switch kind : = srctype . kind ( ) ; kind { case reflect . slice : if , err : = fmt . sscanf ( pacttag , " " , & params . slice . min ) ; err ! = nil { triggerinvalidpacttagpanic ( pacttag , err ) } case reflect . string : fullregex , : = regexp . compile ( ' regex= ( . * ) $ ' ) exampleregex , : = regexp . compile ( ' ^ example= ( . * ) ' ) if fullregex . match ( [ ] byte ( pacttag ) ) { components : = strings . split ( pacttag , " " ) if len ( components [ 1 ] ) == 0 { triggerinvalidpacttagpanic ( pacttag , fmt . errorf ( " " ) ) } if , err : = fmt . sscanf ( components [ 0 ] , " " , & params . str . example ) ; err ! = nil { triggerinvalidpacttagpanic ( pacttag , err ) } params . str . regex = strings . replace ( components [ 1 ] , ' \ ' , ' \ \ ' , - 1 ) } else if exampleregex . match ( [ ] byte ( pacttag ) ) { components : = strings . split ( pacttag , " " ) if len ( components ) ! = 2 | | strings . trimspace ( components [ 1 ] ) == " " { triggerinvalidpacttagpanic ( pacttag , fmt . errorf ( " " ) ) } params . str . example = components [ 1 ] } } return params } 
func ( p * pact ) addmessage ( ) * message { log . println ( " " ) m : = & message { } p . messageinteractions = append ( p . messageinteractions , m ) return m } 
func ( p * pact ) addinteraction ( ) * interaction { p . setup ( true ) log . println ( " " ) i : = & interaction { } p . interactions = append ( p . interactions , i ) return i } 
func ( p * pact ) setuplogging ( ) { if p . logfilter == nil { if p . loglevel == " " { p . loglevel = " " } p . logfilter = & logutils . levelfilter { levels : [ ] logutils . loglevel { " " , " " , " " , " " } , minlevel : logutils . loglevel ( p . loglevel ) , writer : os . stderr , } log . setoutput ( p . logfilter ) } log . println ( " " ) } 
func ( p * pact ) teardown ( ) * pact { log . println ( " " ) if p . server ! = nil { server , err : = p . pactclient . stopserver ( p . server ) if err ! = nil { log . println ( " " , err ) } p . server = server } return p } 
func ( p * pact ) verify ( integrationtest func ( ) error ) error { p . setup ( true ) log . println ( " " ) if len ( p . interactions ) == 0 { return errors . new ( " " ) } mockserver : = & mockservice { baseurl : fmt . sprintf ( " " , p . host , p . server . port ) , consumer : p . consumer , provider : p . provider , } for , interaction : = range p . interactions { err : = mockserver . addinteraction ( interaction ) if err ! = nil { return err } } err : = integrationtest ( ) if err ! = nil { return err } err = mockserver . verify ( ) if err ! = nil { return err } p . interactions = make ( [ ] * interaction , 0 ) return mockserver . deleteinteractions ( ) } 
func ( p * pact ) writepact ( ) error { p . setup ( true ) log . println ( " " ) mockserver : = mockservice { baseurl : fmt . sprintf ( " " , p . host , p . server . port ) , consumer : p . consumer , provider : p . provider , pactfilewritemode : p . pactfilewritemode , } err : = mockserver . writepact ( ) if err ! = nil { return err } return nil } 
func ( p * pact ) verifyprovider ( t * testing . t , request types . verifyrequest ) ( types . providerverifierresponse , error ) { res , err : = p . verifyproviderraw ( request ) for , example : = range res . examples { t . run ( example . description , func ( st * testing . t ) { st . log ( example . fulldescription ) if example . status ! = " " { t . errorf ( " \n \n " , example . fulldescription , example . exception . message ) } } ) } return res , err } 
func aftereachmiddleware ( aftereach types . hook ) proxy . middleware { return func ( next http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { next . servehttp ( w , r ) if r . url . path ! = " " { log . println ( " " ) err : = aftereach ( ) if err ! = nil { log . println ( " " , err ) w . writeheader ( http . statusinternalservererror ) } } } ) } } 
func statehandlermiddleware ( statehandlers types . statehandlers ) proxy . middleware { return func ( next http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { if r . url . path == " " { var s * types . providerstate decoder : = json . newdecoder ( r . body ) decoder . decode ( & s ) for , state : = range s . states { sf , statefound : = statehandlers [ state ] if ! statefound { log . printf ( " " , state ) } else { if err : = sf ( ) ; err ! = nil { log . printf ( " " , state , err ) w . writeheader ( http . statusinternalservererror ) return } } } w . writeheader ( http . statusok ) return } log . println ( " " , r . requesturi ) next . servehttp ( w , r ) } ) } } 
func ( p * pact ) verifymessageprovider ( t * testing . t , request verifymessagerequest ) ( res types . providerverifierresponse , err error ) { res , err = p . verifymessageproviderraw ( request ) for , example : = range res . examples { t . run ( example . description , func ( st * testing . t ) { st . log ( example . fulldescription ) if example . status ! = " " { st . errorf ( " \n " , example . exception . message ) st . error ( " " ) } } ) } return } 
func ( p * pact ) verifymessageproviderraw ( request verifymessagerequest ) ( types . providerverifierresponse , error ) { p . setup ( false ) response : = types . providerverifierresponse { } mux : = http . newservemux ( ) port , err : = utils . getfreeport ( ) if err ! = nil { return response , fmt . errorf ( " " , err ) } verificationrequest : = types . verifyrequest { providerbaseurl : fmt . sprintf ( " " , port ) , pacturls : request . pacturls , brokerurl : request . brokerurl , tags : request . tags , brokerusername : request . brokerusername , brokerpassword : request . brokerpassword , brokertoken : request . brokertoken , publishverificationresults : request . publishverificationresults , providerversion : request . providerversion , provider : p . provider , } mux . handlefunc ( " " , messageverificationhandler ( request . messagehandlers , request . statehandlers ) ) ln , err : = net . listen ( " " , fmt . sprintf ( " " , port ) ) if err ! = nil { log . fatal ( err ) } defer ln . close ( ) log . printf ( " " , port , ln . addr ( ) ) go http . serve ( ln , mux ) porterr : = waitforport ( port , " " , " " , p . clienttimeout , fmt . sprintf ( ' timed out waiting for pact proxy on port %d - check for errors ' , port ) ) if porterr ! = nil { log . fatal ( " " , err ) return response , porterr } log . println ( " " ) return p . pactclient . verifyprovider ( verificationrequest ) } 
func ( p * pact ) verifymessageconsumerraw ( message * message , handler messageconsumer ) error { log . printf ( " " ) p . setup ( false ) reified , err : = p . pactclient . reifymessage ( & types . pactreificationrequest { message : message . content , } ) if err ! = nil { return fmt . errorf ( " " , err ) } t : = reflect . typeof ( message . type ) if t ! = nil && t . name ( ) ! = " " { log . println ( " " , t . name ( ) ) err = json . unmarshal ( reified . responseraw , & message . type ) if err ! = nil { return fmt . errorf ( " " , t . name ( ) , err ) } } generatedmessage : = message { content : message . type , states : message . states , description : message . description , metadata : message . metadata , } err = handler ( generatedmessage ) if err ! = nil { return err } return p . pactclient . updatemessagepact ( types . pactmessagerequest { message : message , consumer : p . consumer , provider : p . provider , pactdir : p . pactdir , } ) } 
func ( p * pact ) verifymessageconsumer ( t * testing . t , message * message , handler messageconsumer ) error { err : = p . verifymessageconsumerraw ( message , handler ) if err ! = nil { t . errorf ( " " , err ) } return err } 
func ( p * mockclient ) startserver ( args [ ] string , port int ) * types . mockserver { return p . mockserver } 
func ( p * mockclient ) stopserver ( server * types . mockserver ) ( * types . mockserver , error ) { return p . stopserverresponse , p . stopservererror } 
func ( p * mockclient ) removeallservers ( server * types . mockserver ) [ ] * types . mockserver { return p . removeallserversresponse } 
func ( p * mockclient ) verifyprovider ( request types . verifyrequest ) ( types . providerverifierresponse , error ) { return p . verifyproviderresponse , p . verifyprovidererror } 
func ( p * mockclient ) reifymessage ( request * types . pactreificationrequest ) ( res * types . reificationresponse , err error ) { return p . reifymessageresponse , p . reifymessageerror } 
func ( m * mockservice ) newservice ( args [ ] string ) service { m . args = [ ] string { " " , } m . args = append ( m . args , args ... ) m . cmd = getmockservicecommandpath ( ) return m } 
func ( s * servicemanager ) setup ( ) { log . println ( " " ) s . commandcreatedchan = make ( chan * exec . cmd ) s . commandcompletechan = make ( chan * exec . cmd ) s . processmap = processmap { processes : make ( map [ int ] * exec . cmd ) } go s . addservicemonitor ( ) go s . removeservicemonitor ( ) } 
func ( s * servicemanager ) addservicemonitor ( ) { log . println ( " " ) for { select { case p : = < - s . commandcreatedchan : if p ! = nil && p . process ! = nil { s . processmap . set ( p . process . pid , p ) } } } } 
func ( s * servicemanager ) removeservicemonitor ( ) { log . println ( " " ) var p * exec . cmd for { select { case p = < - s . commandcompletechan : if p ! = nil && p . process ! = nil { p . process . signal ( os . interrupt ) s . processmap . delete ( p . process . pid ) } } } } 
func ( s * servicemanager ) stop ( pid int ) ( bool , error ) { log . println ( " " , pid ) cmd : = s . processmap . get ( pid ) go func ( ) { s . commandcompletechan < - cmd } ( ) var err error done : = make ( chan error , 1 ) go func ( ) { done < - cmd . wait ( ) } ( ) select { case < - time . after ( 3 * time . second ) : if err = cmd . process . kill ( ) ; err ! = nil { log . println ( " " , pid ) return false , err } case err = < - done : if err ! = nil { log . println ( " " , err ) return false , err } } return true , nil } 
func ( s * servicemanager ) list ( ) map [ int ] * exec . cmd { log . println ( " " ) return s . processmap . processes } 
func ( s * servicemanager ) command ( ) * exec . cmd { cmd : = exec . command ( s . cmd , s . args ... ) env : = os . environ ( ) env = append ( env , s . env ... ) cmd . env = env return cmd } 
func ( s * servicemanager ) start ( ) * exec . cmd { log . println ( " " ) cmd : = exec . command ( s . cmd , s . args ... ) env : = os . environ ( ) env = append ( env , s . env ... ) cmd . env = env cmdreader , err : = cmd . stdoutpipe ( ) if err ! = nil { log . printf ( " \n " , err . error ( ) ) } cmdreadererr , err : = cmd . stderrpipe ( ) if err ! = nil { log . printf ( " \n " , err . error ( ) ) } scanner : = bufio . newscanner ( cmdreader ) go func ( ) { for scanner . scan ( ) { log . printf ( " \n " , scanner . text ( ) ) } } ( ) scanner2 : = bufio . newscanner ( cmdreadererr ) go func ( ) { for scanner2 . scan ( ) { log . printf ( " \n " , scanner2 . text ( ) ) } } ( ) err = cmd . start ( ) if err ! = nil { log . println ( " " , err . error ( ) ) } s . commandcreatedchan < - cmd return cmd } 
func ( m * mockservice ) call ( method string , url string , content interface { } ) error { body , err : = json . marshal ( content ) if err ! = nil { fmt . println ( err ) return err } client : = & http . client { } var req * http . request if method == " " { req , err = http . newrequest ( method , url , bytes . newreader ( body ) ) } else { req , err = http . newrequest ( method , url , nil ) } if err ! = nil { return err } req . header . set ( " " , " " ) req . header . set ( " " , " " ) res , err : = client . do ( req ) if err ! = nil { return err } responsebody , err : = ioutil . readall ( res . body ) res . body . close ( ) if res . statuscode < 200 | | res . statuscode >= 300 { return errors . new ( string ( responsebody ) ) } return err } 
func ( m * mockservice ) deleteinteractions ( ) error { log . println ( " " ) url : = fmt . sprintf ( " " , m . baseurl ) return m . call ( " " , url , nil ) } 
func ( m * mockservice ) addinteraction ( interaction * interaction ) error { log . println ( " " ) url : = fmt . sprintf ( " " , m . baseurl ) return m . call ( " " , url , interaction ) } 
func ( m * mockservice ) writepact ( ) error { log . println ( " " ) if m . consumer == " " | | m . provider == " " { return errors . new ( " " ) } if m . pactfilewritemode == " " { m . pactfilewritemode = " " } pact : = map [ string ] interface { } { " " : map [ string ] string { " " : m . consumer , } , " " : map [ string ] string { " " : m . provider , } , " " : m . pactfilewritemode , } url : = fmt . sprintf ( " " , m . baseurl ) return m . call ( " " , url , pact ) } 
func ( p * message ) given ( state string ) * message { p . states = [ ] state { state { name : state } } return p } 
func ( p * message ) expectstoreceive ( description string ) * message { p . description = description return p } 
func ( p * message ) withmetadata ( metadata mapmatcher ) * message { p . metadata = metadata return p } 
func ( p * message ) astype ( t interface { } ) * message { fmt . println ( " " , reflect . typeof ( t ) ) p . type = t return p } 
func isauthenticated ( ) gin . handlerfunc { return func ( c * gin . context ) { fmt . println ( c . getheader ( " " ) ) if c . getheader ( " " ) == fmt . sprintf ( " " , getauthtoken ( ) ) { c . next ( ) } else { c . json ( http . statusunauthorized , gin . h { " " : " " } ) } } } 
func userlogin ( c * gin . context ) { c . header ( " " , " " ) var json login if c . bindjson ( & json ) == nil { user , err : = userrepository . byusername ( json . user ) if err ! = nil { c . json ( http . statusnotfound , gin . h { " " : " " } ) } else if user . username ! = json . user | | user . password ! = json . password { c . json ( http . statusunauthorized , gin . h { " " : " " } ) } else { c . header ( " " , getauthtoken ( ) ) c . json ( http . statusok , types . loginresponse { user : user } ) } } } 
func getuser ( c * gin . context ) { fmt . println ( " " ) c . header ( " " , " " ) id , : = strconv . atoi ( c . param ( " " ) ) user , err : = userrepository . byid ( id ) if err ! = nil { c . json ( http . statusnotfound , gin . h { " " : " " } ) } else { c . json ( http . statusok , user ) } } 
func ( m * pactmessagerequest ) validate ( ) error { m . args = [ ] string { } body , err : = json . marshal ( m . message ) if err ! = nil { return err } m . args = append ( m . args , [ ] string { " " , string ( body ) , " " , m . consumer , " " , m . provider , " " , m . pactdir , " " , " " , } ... ) return nil } 
func ( v * verificationservice ) newservice ( args [ ] string ) service { log . printf ( " \n " , args ) v . args = args v . cmd = getverifiercommandpath ( ) v . env = append ( os . environ ( ) , ' pact interaction rerun command= " to re - run this specific test , set the following environment variables and run your test again : pact description= " < pact description > " pact provider state= " < pact provider state > " " ' ) return v } 
func ( s * s3 ) region ( ) string { region : = os . getenv ( " " ) switch s . domain { case " " , " " : return " " case " " : if region == " " { panic ( " " ) } return region default : regions : = regionmatcher . findstringsubmatch ( s . domain ) if len ( regions ) < 2 { if region == " " { panic ( " " ) } return region } return regions [ 1 ] } } 
func new ( domain string , keys keys ) * s3 { if domain == " " { domain = defaultdomain } return & s3 { domain , keys } } 
func ( s * s3 ) bucket ( name string ) * bucket { return & bucket { s3 : s , name : name , config : defaultconfig , } } 
func ( b * bucket ) putwriter ( path string , h http . header , c * config ) ( w io . writecloser , err error ) { if c == nil { c = b . conf ( ) } u , err : = b . url ( path , c ) if err ! = nil { return nil , err } return newputter ( * u , h , c , b ) } 
func ( b * bucket ) url ( bpath string , c * config ) ( * url . url , error ) { purl , err : = url . parse ( bpath ) if err ! = nil { return nil , err } var vals url . values if v : = purl . query ( ) . get ( versionparam ) ; v ! = " " { vals = make ( url . values ) vals . add ( versionparam , v ) bpath = strings . split ( bpath , " " ) [ 0 ] } if strings . contains ( b . name , " " ) | | c . pathstyle { return & url . url { host : b . s3 . domain , scheme : c . scheme , path : path . clean ( fmt . sprintf ( " " , b . name , bpath ) ) , rawquery : vals . encode ( ) , } , nil } else { return & url . url { scheme : c . scheme , path : path . clean ( fmt . sprintf ( " " , bpath ) ) , host : path . clean ( fmt . sprintf ( " " , b . name , b . s3 . domain ) ) , rawquery : vals . encode ( ) , } , nil } } 
func ( b * bucket ) delete ( path string ) error { if err : = b . delete ( path ) ; err ! = nil { return err } if b . md5check { if err : = b . delete ( fmt . sprintf ( " " , path ) ) ; err ! = nil { return err } } logger . printf ( " \n " , path , b . name ) return nil } 
func setlogger ( out io . writer , prefix string , flag int , debug bool ) { logger = internallogger { log . new ( out , prefix , flag ) , debug , } } 
func init ( ) { logger = internallogger { log . new ( ioutil . discard , " " , log . lstdflags ) , false , } } 
func instancekeys ( ) ( keys keys , err error ) { rolepath : = " " var creds mdcreds resp , err : = clientwithtimeout ( 2 * time . second ) . get ( rolepath ) if err ! = nil { return } defer checkclose ( resp . body , err ) if resp . statuscode ! = 200 { err = newresperror ( resp ) return } role , err : = ioutil . readall ( resp . body ) if err ! = nil { return } resp , err = http . get ( rolepath + string ( role ) ) if err ! = nil { return } defer checkclose ( resp . body , err ) if resp . statuscode ! = 200 { err = newresperror ( resp ) return } metadata , err : = ioutil . readall ( resp . body ) if err ! = nil { return } if err = json . unmarshal ( [ ] byte ( metadata ) , & creds ) ; err ! = nil { return } keys = keys { accesskey : creds . accesskeyid , secretkey : creds . secretaccesskey , securitytoken : creds . token , } return } 
func envkeys ( ) ( keys keys , err error ) { keys = keys { accesskey : os . getenv ( " " ) , secretkey : os . getenv ( " " ) , securitytoken : os . getenv ( " " ) , } if keys . accesskey == " " | | keys . secretkey == " " { err = fmt . errorf ( " " ) } return } 
func getawskeys ( ) ( keys s3gof3r . keys , err error ) { keys , err = s3gof3r . envkeys ( ) if err == nil { return } keys , err = s3gof3r . instancekeys ( ) if err == nil { return } err = errors . new ( " " ) return } 
func homedir ( ) ( string , error ) { if h : = os . getenv ( " " ) ; h ! = " " { return h , nil } h , err : = exec . command ( " " , " " , " " ) . output ( ) if err == nil && len ( h ) > 0 { return strings . trimspace ( string ( h ) ) , nil } return " " , fmt . errorf ( " " ) } 
func ( p * putter ) retryputpart ( part * part ) { defer p . wg . done ( ) var err error for i : = 0 ; i < p . c . ntry ; i ++ { err = p . putpart ( part ) if err == nil { p . sp . give < - part . b part . b = nil return } logger . debugprintf ( " " , i , part . partnumber , err ) time . sleep ( time . duration ( math . exp2 ( float64 ( i ) ) ) * 100 * time . millisecond ) } p . err = err } 
func ( p * putter ) putpart ( part * part ) error { v : = url . values { } v . set ( " " , strconv . itoa ( part . partnumber ) ) v . set ( " " , p . uploadid ) if , err : = part . r . seek ( 0 , 0 ) ; err ! = nil { return err } req , err : = http . newrequest ( " " , p . url . string ( ) + " " + v . encode ( ) , part . r ) if err ! = nil { return err } req . contentlength = part . len req . header . set ( md5header , part . md5 ) req . header . set ( sha256header , part . sha256 ) p . b . sign ( req ) resp , err : = p . c . client . do ( req ) if err ! = nil { return err } defer checkclose ( resp . body , err ) if resp . statuscode ! = 200 { return newresperror ( resp ) } s : = resp . header . get ( " " ) if len ( s ) < 2 { return fmt . errorf ( " " , s ) } s = s [ 1 : len ( s ) - 1 ] if part . etag ! = s { return fmt . errorf ( " " , s , p . etag ) } return nil } 
func ( p * putter ) abort ( ) { v : = url . values { } v . set ( " " , p . uploadid ) s : = p . url . string ( ) + " " + v . encode ( ) resp , err : = p . retryrequest ( " " , s , nil , nil ) if err ! = nil { logger . printf ( " \n " , err ) return } defer checkclose ( resp . body , err ) if resp . statuscode ! = 204 { logger . printf ( " " , newresperror ( resp ) ) } return } 
func growpartsize ( partindex int , partsize , putsz int64 ) bool { return ( maxobjsize - putsz ) / ( maxnpart - int64 ( partindex ) ) > partsize } 
func checkdisallowed ( prefix string , spec interface { } ) error { infos , err : = gatherinfo ( prefix , spec ) if err ! = nil { return err } vars : = make ( map [ string ] struct { } ) for , info : = range infos { vars [ info . key ] = struct { } { } } if prefix ! = " " { prefix = strings . toupper ( prefix ) + " " } for , env : = range os . environ ( ) { if ! strings . hasprefix ( env , prefix ) { continue } v : = strings . splitn ( env , " " , 2 ) [ 0 ] if , found : = vars [ v ] ; ! found { return fmt . errorf ( " " , v ) } } return nil } 
func process ( prefix string , spec interface { } ) error { infos , err : = gatherinfo ( prefix , spec ) for , info : = range infos { value , ok : = lookupenv ( info . key ) if ! ok && info . alt ! = " " { value , ok = lookupenv ( info . alt ) } def : = info . tags . get ( " " ) if def ! = " " && ! ok { value = def } req : = info . tags . get ( " " ) if ! ok && def == " " { if istrue ( req ) { return fmt . errorf ( " " , info . key ) } continue } err = processfield ( value , info . field ) if err ! = nil { return & parseerror { keyname : info . key , fieldname : info . name , typename : info . field . type ( ) . string ( ) , value : value , err : err , } } } return err } 
func mustprocess ( prefix string , spec interface { } ) { if err : = process ( prefix , spec ) ; err ! = nil { panic ( err ) } } 
func usage ( prefix string , spec interface { } ) error { tabs : = tabwriter . newwriter ( os . stdout , 1 , 0 , 4 , ' ' , 0 ) err : = usagef ( prefix , spec , tabs , defaulttableformat ) tabs . flush ( ) return err } 
func usagef ( prefix string , spec interface { } , out io . writer , format string ) error { functions : = template . funcmap { " " : func ( v varinfo ) string { return v . key } , " " : func ( v varinfo ) string { return v . tags . get ( " " ) } , " " : func ( v varinfo ) string { return totypedescription ( v . field . type ( ) ) } , " " : func ( v varinfo ) string { return v . tags . get ( " " ) } , " " : func ( v varinfo ) ( string , error ) { req : = v . tags . get ( " " ) if req ! = " " { reqb , err : = strconv . parsebool ( req ) if err ! = nil { return " " , err } if reqb { req = " " } } return req , nil } , } tmpl , err : = template . new ( " " ) . funcs ( functions ) . parse ( format ) if err ! = nil { return err } return usaget ( prefix , spec , out , tmpl ) } 
func usaget ( prefix string , spec interface { } , out io . writer , tmpl * template . template ) error { infos , err : = gatherinfo ( prefix , spec ) if err ! = nil { return err } return tmpl . execute ( out , infos ) } 
func ( t * time ) scan ( value interface { } ) error { var err error switch x : = value . ( type ) { case time . time : t . time = x case nil : t . valid = false return nil default : err = fmt . errorf ( " " , value , value ) } t . valid = err == nil return err } 
func ( t time ) value ( ) ( driver . value , error ) { if ! t . valid { return nil , nil } return t . time , nil } 
func newtime ( t time . time , valid bool ) time { return time { time : t , valid : valid , } } 
func timefromptr ( t * time . time ) time { if t == nil { return newtime ( time . time { } , false ) } return newtime ( * t , true ) } 
func ( t time ) valueorzero ( ) time . time { if ! t . valid { return time . time { } } return t . time } 
func ( t time ) marshaljson ( ) ( [ ] byte , error ) { if ! t . valid { return [ ] byte ( " " ) , nil } return t . time . marshaljson ( ) } 
func ( t * time ) unmarshaljson ( data [ ] byte ) error { var err error var v interface { } if err = json . unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case string : err = t . time . unmarshaljson ( data ) case map [ string ] interface { } : ti , tiok : = x [ " " ] . ( string ) valid , validok : = x [ " " ] . ( bool ) if ! tiok | | ! validok { return fmt . errorf ( ' json : unmarshalling object into go value of type null . time requires key " time " to be of type string and key " valid " to be of type bool ; found % t and % t , respectively ' , x [ " " ] , x [ " " ] ) } err = t . time . unmarshaltext ( [ ] byte ( ti ) ) t . valid = valid return err case nil : t . valid = false return nil default : err = fmt . errorf ( " " , reflect . typeof ( v ) . name ( ) ) } t . valid = err == nil return err } 
func ( t * time ) setvalid ( v time . time ) { t . time = v t . valid = true } 
func ( t time ) ptr ( ) * time . time { if ! t . valid { return nil } return & t . time } 
func newbool ( b bool , valid bool ) bool { return bool { nullbool : sql . nullbool { bool : b , valid : valid , } , } } 
func boolfromptr ( b * bool ) bool { if b == nil { return newbool ( false , false ) } return newbool ( * b , true ) } 
func ( b * bool ) unmarshaljson ( data [ ] byte ) error { var err error var v interface { } if err = json . unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case bool : b . bool = x case map [ string ] interface { } : err = json . unmarshal ( data , & b . nullbool ) case nil : b . valid = false return nil default : err = fmt . errorf ( " " , reflect . typeof ( v ) . name ( ) ) } b . valid = err == nil return err } 
func ( b * bool ) unmarshaltext ( text [ ] byte ) error { str : = string ( text ) switch str { case " " , " " : b . valid = false return nil case " " : b . bool = true case " " : b . bool = false default : b . valid = false return errors . new ( " " + str ) } b . valid = true return nil } 
func ( b bool ) marshaljson ( ) ( [ ] byte , error ) { if ! b . valid { return [ ] byte ( " " ) , nil } if ! b . bool { return [ ] byte ( " " ) , nil } return [ ] byte ( " " ) , nil } 
func ( b * bool ) setvalid ( v bool ) { b . bool = v b . valid = true } 
func newstring ( s string , valid bool ) string { return string { nullstring : sql . nullstring { string : s , valid : valid , } , } } 
func ( s * string ) unmarshaljson ( data [ ] byte ) error { var err error var v interface { } if err = json . unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case string : s . string = x case map [ string ] interface { } : err = json . unmarshal ( data , & s . nullstring ) case nil : s . valid = false return nil default : err = fmt . errorf ( " " , reflect . typeof ( v ) . name ( ) ) } s . valid = ( err == nil ) && ( s . string ! = " " ) return err } 
func ( s string ) marshaltext ( ) ( [ ] byte , error ) { if ! s . valid { return [ ] byte { } , nil } return [ ] byte ( s . string ) , nil } 
func ( s * string ) unmarshaltext ( text [ ] byte ) error { s . string = string ( text ) s . valid = s . string ! = " " return nil } 
func ( s * string ) setvalid ( v string ) { s . string = v s . valid = true } 
func stringfromptr ( s * string ) string { if s == nil { return newstring ( " " , false ) } return newstring ( * s , true ) } 
func ( s string ) marshaljson ( ) ( [ ] byte , error ) { if ! s . valid { return [ ] byte ( " " ) , nil } return json . marshal ( s . string ) } 
func newint ( i int64 , valid bool ) int { return int { nullint64 : sql . nullint64 { int64 : i , valid : valid , } , } } 
func intfromptr ( i * int64 ) int { if i == nil { return newint ( 0 , false ) } n : = newint ( * i , true ) return n } 
func ( i * int ) unmarshaljson ( data [ ] byte ) error { var err error var v interface { } if err = json . unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case float64 : err = json . unmarshal ( data , & i . int64 ) case string : str : = string ( x ) if len ( str ) == 0 { i . valid = false return nil } i . int64 , err = strconv . parseint ( str , 10 , 64 ) case map [ string ] interface { } : err = json . unmarshal ( data , & i . nullint64 ) case nil : i . valid = false return nil default : err = fmt . errorf ( " " , reflect . typeof ( v ) . name ( ) ) } i . valid = ( err == nil ) && ( i . int64 ! = 0 ) return err } 
func ( i int ) marshaltext ( ) ( [ ] byte , error ) { n : = i . int64 if ! i . valid { n = 0 } return [ ] byte ( strconv . formatint ( n , 10 ) ) , nil } 
func ( i * int ) setvalid ( n int64 ) { i . int64 = n i . valid = true } 
func ( i * int ) unmarshaltext ( text [ ] byte ) error { str : = string ( text ) if str == " " | | str == " " { i . valid = false return nil } var err error i . int64 , err = strconv . parseint ( string ( text ) , 10 , 64 ) i . valid = err == nil return err } 
func ( b bool ) marshaltext ( ) ( [ ] byte , error ) { if ! b . valid | | ! b . bool { return [ ] byte ( " " ) , nil } return [ ] byte ( " " ) , nil } 
func ( f * float ) setvalid ( v float64 ) { f . float64 = v f . valid = true } 
func timefromptr ( t * time . time ) time { if t == nil { return newtime ( time . time { } , false ) } return timefrom ( * t ) } 
func ( t time ) marshaljson ( ) ( [ ] byte , error ) { if ! t . valid { return ( time . time { } ) . marshaljson ( ) } return t . time . marshaljson ( ) } 
func ( f * float ) unmarshaljson ( data [ ] byte ) error { var err error var v interface { } if err = json . unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case float64 : f . float64 = float64 ( x ) case string : str : = string ( x ) if len ( str ) == 0 { f . valid = false return nil } f . float64 , err = strconv . parsefloat ( str , 64 ) case map [ string ] interface { } : err = json . unmarshal ( data , & f . nullfloat64 ) case nil : f . valid = false return nil default : err = fmt . errorf ( " " , reflect . typeof ( v ) . name ( ) ) } f . valid = err == nil return err } 
func ( f * float ) unmarshaltext ( text [ ] byte ) error { str : = string ( text ) if str == " " | | str == " " { f . valid = false return nil } var err error f . float64 , err = strconv . parsefloat ( string ( text ) , 64 ) f . valid = err == nil return err } 
func ( f float ) marshaljson ( ) ( [ ] byte , error ) { if ! f . valid { return [ ] byte ( " " ) , nil } if math . isinf ( f . float64 , 0 ) | | math . isnan ( f . float64 ) { return nil , & json . unsupportedvalueerror { value : reflect . valueof ( f . float64 ) , str : strconv . formatfloat ( f . float64 , ' g ' , - 1 , 64 ) , } } return [ ] byte ( strconv . formatfloat ( f . float64 , ' f ' , - 1 , 64 ) ) , nil } 
func newgossipchannel ( channelname string , ourself * localpeer , r * routes , g gossiper , logger logger ) * gossipchannel { return & gossipchannel { name : channelname , ourself : ourself , routes : r , gossiper : g , logger : logger , } } 
func ( c * gossipchannel ) gossipunicast ( dstpeername peername , msg [ ] byte ) error { return c . relayunicast ( dstpeername , gobencode ( c . name , c . ourself . name , dstpeername , msg ) ) } 
func ( c * gossipchannel ) gossipbroadcast ( update gossipdata ) { c . relaybroadcast ( c . ourself . name , update ) } 
func ( c * gossipchannel ) send ( data gossipdata ) { c . relay ( c . ourself . name , data ) } 
func ( c * gossipchannel ) senddown ( conn connection , data gossipdata ) { c . senderfor ( conn ) . send ( data ) } 
func gobencode ( items ... interface { } ) [ ] byte { buf : = new ( bytes . buffer ) enc : = gob . newencoder ( buf ) for , i : = range items { if err : = enc . encode ( i ) ; err ! = nil { panic ( err ) } } return buf . bytes ( ) } 
func newtokenbucket ( capacity int64 , tokeninterval time . duration ) * tokenbucket { tb : = tokenbucket { capacity : capacity , tokeninterval : tokeninterval , refillduration : tokeninterval * time . duration ( capacity ) } tb . earliestunspenttoken = tb . capacitytoken ( ) return & tb } 
func ( tb * tokenbucket ) wait ( ) { time . sleep ( time . until ( tb . earliestunspenttoken ) ) capacitytoken : = tb . capacitytoken ( ) if tb . earliestunspenttoken . before ( capacitytoken ) { tb . earliestunspenttoken = capacitytoken } tb . earliestunspenttoken = tb . earliestunspenttoken . add ( tb . tokeninterval ) } 
func ( tb * tokenbucket ) capacitytoken ( ) time . time { return time . now ( ) . add ( - tb . refillduration ) . truncate ( tb . tokeninterval ) } 
func prefixrangeend ( prefix [ ] byte ) [ ] byte { end : = make ( [ ] byte , len ( prefix ) ) copy ( end , prefix ) for i : = len ( end ) - 1 ; i >= 0 ; i -- { if end [ i ] < 0xff { end [ i ] = end [ i ] + 1 end = end [ : i + 1 ] return end } } return [ ] byte { 0 } } 
func newlocalpeer ( name peername , nickname string , router * router ) * localpeer { actionchan : = make ( chan localpeeraction , channelsize ) peer : = & localpeer { peer : newpeer ( name , nickname , randompeeruid ( ) , 0 , randompeershortid ( ) ) , router : router , actionchan : actionchan , } go peer . actorloop ( actionchan ) return peer } 
func ( peer * localpeer ) getconnections ( ) connectionset { connections : = make ( connectionset ) peer . rlock ( ) defer peer . runlock ( ) for , conn : = range peer . connections { connections [ conn ] = struct { } { } } return connections } 
func ( peer * localpeer ) connectionto ( name peername ) ( connection , bool ) { peer . rlock ( ) defer peer . runlock ( ) conn , found : = peer . connections [ name ] return conn , found } 
func ( peer * localpeer ) connectionsto ( names [ ] peername ) [ ] connection { if len ( names ) == 0 { return nil } conns : = make ( [ ] connection , 0 , len ( names ) ) peer . rlock ( ) defer peer . runlock ( ) for , name : = range names { conn , found : = peer . connections [ name ] if found { conns = append ( conns , conn ) } } return conns } 
func ( peer * localpeer ) createconnection ( localaddr string , peeraddr string , acceptnewpeer bool , logger logger ) error { if err : = peer . checkconnectionlimit ( ) ; err ! = nil { return err } localtcpaddr , err : = net . resolvetcpaddr ( " " , localaddr ) if err ! = nil { return err } remotetcpaddr , err : = net . resolvetcpaddr ( " " , peeraddr ) if err ! = nil { return err } tcpconn , err : = net . dialtcp ( " " , localtcpaddr , remotetcpaddr ) if err ! = nil { return err } connremote : = newremoteconnection ( peer . peer , nil , peeraddr , true , false ) startlocalconnection ( connremote , tcpconn , peer . router , acceptnewpeer , logger ) return nil } 
func ( peer * localpeer ) doaddconnection ( conn ourconnection , isrestartedpeer bool ) error { resultchan : = make ( chan error ) peer . actionchan < - func ( ) { resultchan < - peer . handleaddconnection ( conn , isrestartedpeer ) } return < - resultchan } 
func startlocalconnection ( connremote * remoteconnection , tcpconn * net . tcpconn , router * router , acceptnewpeer bool , logger logger ) { if connremote . local ! = router . ourself . peer { panic ( " " ) } errorchan : = make ( chan error , 1 ) finished : = make ( chan struct { } ) conn : = & localconnection { remoteconnection : * connremote , router : router , tcpconn : tcpconn , trustremote : router . trusts ( connremote ) , uid : randuint64 ( ) , errorchan : errorchan , finished : finished , logger : logger , } conn . senders = newgossipsenders ( conn , finished ) go conn . run ( errorchan , finished , acceptnewpeer ) } 
func ( conn * localconnection ) sendprotocolmsg ( m protocolmsg ) error { if err : = conn . sendprotocolmsg ( m ) ; err ! = nil { conn . shutdown ( err ) return err } return nil } 
func ( conn * localconnection ) shutdown ( err error ) { if err == nil { panic ( " " ) } select { case conn . errorchan < - err : default : } } 
func newstatus ( router * router ) * status { return & status { protocol : protocol , protocolminversion : int ( router . protocolminversion ) , protocolmaxversion : protocolmaxversion , encryption : router . usingpassword ( ) , peerdiscovery : router . peerdiscovery , name : router . ourself . name . string ( ) , nickname : router . ourself . nickname , port : router . port , peers : makepeerstatusslice ( router . peers ) , unicastroutes : makeunicastroutestatusslice ( router . routes ) , broadcastroutes : makebroadcastroutestatusslice ( router . routes ) , connections : makelocalconnectionstatusslice ( router . connectionmaker ) , terminationcount : router . connectionmaker . terminationcount , targets : router . connectionmaker . targets ( false ) , overlaydiagnostics : router . overlay . diagnostics ( ) , trustedsubnets : maketrustedsubnetsslice ( router . trustedsubnets ) , } } 
func makepeerstatusslice ( peers * peers ) [ ] peerstatus { var slice [ ] peerstatus peers . foreach ( func ( peer * peer ) { var connections [ ] connectionstatus if peer == peers . ourself . peer { for conn : = range peers . ourself . getconnections ( ) { connections = append ( connections , makeconnectionstatus ( conn ) ) } } else { for , conn : = range peer . connections { connections = append ( connections , makeconnectionstatus ( conn ) ) } } slice = append ( slice , peerstatus { peer . name . string ( ) , peer . nickname , peer . uid , peer . shortid , peer . version , connections , } ) } ) return slice } 
func makeunicastroutestatusslice ( r * routes ) [ ] unicastroutestatus { r . rlock ( ) defer r . runlock ( ) var slice [ ] unicastroutestatus for dest , via : = range r . unicast { slice = append ( slice , unicastroutestatus { dest . string ( ) , via . string ( ) } ) } return slice } 
func makebroadcastroutestatusslice ( r * routes ) [ ] broadcastroutestatus { r . rlock ( ) defer r . runlock ( ) var slice [ ] broadcastroutestatus for source , via : = range r . broadcast { var hops [ ] string for , hop : = range via { hops = append ( hops , hop . string ( ) ) } slice = append ( slice , broadcastroutestatus { source . string ( ) , hops } ) } return slice } 
func maketrustedsubnetsslice ( trustedsubnets [ ] * net . ipnet ) [ ] string { trustedsubnetstrs : = [ ] string { } for , trustedsubnet : = range trustedsubnets { trustedsubnetstrs = append ( trustedsubnetstrs , trustedsubnet . string ( ) ) } return trustedsubnetstrs } 
func ( s * etcdstore ) range ( ctx context . context , req * etcdserverpb . rangerequest ) ( * etcdserverpb . rangeresponse , error ) { ireq : = etcdserverpb . internalraftrequest { id : < - s . idgen , range : req } msgc , errc , err : = s . proposeinternalraftrequest ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . done ( ) : s . cancelinternalraftrequest ( ireq ) return nil , ctx . err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . rangeresponse ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , errstopped } } 
func ( s * etcdstore ) put ( ctx context . context , req * etcdserverpb . putrequest ) ( * etcdserverpb . putresponse , error ) { ireq : = etcdserverpb . internalraftrequest { id : < - s . idgen , put : req } msgc , errc , err : = s . proposeinternalraftrequest ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . done ( ) : s . cancelinternalraftrequest ( ireq ) return nil , ctx . err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . putresponse ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , errstopped } } 
func ( s * etcdstore ) deleterange ( ctx context . context , req * etcdserverpb . deleterangerequest ) ( * etcdserverpb . deleterangeresponse , error ) { ireq : = etcdserverpb . internalraftrequest { id : < - s . idgen , deleterange : req } msgc , errc , err : = s . proposeinternalraftrequest ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . done ( ) : s . cancelinternalraftrequest ( ireq ) return nil , ctx . err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . deleterangeresponse ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , errstopped } } 
func ( s * etcdstore ) txn ( ctx context . context , req * etcdserverpb . txnrequest ) ( * etcdserverpb . txnresponse , error ) { ireq : = etcdserverpb . internalraftrequest { id : < - s . idgen , txn : req } msgc , errc , err : = s . proposeinternalraftrequest ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . done ( ) : s . cancelinternalraftrequest ( ireq ) return nil , ctx . err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . txnresponse ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , errstopped } } 
func ( s * etcdstore ) compact ( ctx context . context , req * etcdserverpb . compactionrequest ) ( * etcdserverpb . compactionresponse , error ) { return nil , errors . new ( " " ) } 
func ( s * etcdstore ) proposeinternalraftrequest ( req etcdserverpb . internalraftrequest ) ( < - chan proto . message , < - chan error , error ) { data , err : = req . marshal ( ) if err ! = nil { return nil , nil , err } if len ( data ) > maxrequestbytes { return nil , nil , errtoobig } msgc , errc , err : = s . registerpending ( req . id ) if err ! = nil { return nil , nil , err } s . proposalc < - data return msgc , errc , nil } 
func ( s * etcdstore ) applyinternalraftrequest ( req etcdserverpb . internalraftrequest ) ( proto . message , error ) { switch { case req . range ! = nil : return applyrange ( notxn , s . kv , req . range ) case req . put ! = nil : return applyput ( notxn , s . kv , s . lessor , req . put ) case req . deleterange ! = nil : return applydeleterange ( notxn , s . kv , req . deleterange ) case req . txn ! = nil : return applytransaction ( s . kv , s . lessor , req . txn ) case req . compaction ! = nil : return applycompaction ( s . kv , req . compaction ) case req . leasegrant ! = nil : return applyleasegrant ( s . lessor , req . leasegrant ) case req . leaserevoke ! = nil : return applyleaserevoke ( s . lessor , req . leaserevoke ) default : return nil , fmt . errorf ( " " ) } } 
func ( peers * peers ) descriptions ( ) [ ] peerdescription { peers . rlock ( ) defer peers . runlock ( ) descriptions : = make ( [ ] peerdescription , 0 , len ( peers . byname ) ) for , peer : = range peers . byname { descriptions = append ( descriptions , peerdescription { name : peer . name , nickname : peer . peersummary . nickname , uid : peer . uid , self : peer . name == peers . ourself . name , numconnections : len ( peer . connections ) , } ) } return descriptions } 
func ( peers * peers ) ongc ( callback func ( * peer ) ) { peers . lock ( ) defer peers . unlock ( ) peers . ongc = append ( peers . ongc , callback ) } 
func ( peers * peers ) oninvalidateshortids ( callback func ( ) ) { peers . lock ( ) defer peers . unlock ( ) peers . oninvalidateshortids = append ( peers . oninvalidateshortids , callback ) } 
func ( peers * peers ) chooseshortid ( ) ( peershortid , bool ) { rng : = rand . new ( rand . newsource ( int64 ( randuint64 ( ) ) ) ) for i : = 0 ; i < 10 ; i ++ { shortid : = peershortid ( rng . intn ( 1 < < peershortidbits ) ) if peers . byshortid [ shortid ] . peer == nil { return shortid , true } } available : = int ( 1 < < peershortidbits ) for , entry : = range peers . byshortid { if entry . peer ! = nil { available -- } } if available == 0 { return 0 , false } n : = rng . intn ( available ) var i peershortid for { if peers . byshortid [ i ] . peer == nil { if n == 0 { return i , true } n -- } i ++ } } 
func ( peers * peers ) fetchwithdefault ( peer * peer ) * peer { peers . lock ( ) var pending peerspendingnotifications defer peers . unlockandnotify ( & pending ) if existingpeer , found : = peers . byname [ peer . name ] ; found { existingpeer . localrefcount ++ return existingpeer } peers . byname [ peer . name ] = peer peers . addbyshortid ( peer , & pending ) peer . localrefcount ++ return peer } 
func ( peers * peers ) fetch ( name peername ) * peer { peers . rlock ( ) defer peers . runlock ( ) return peers . byname [ name ] } 
func ( peers * peers ) fetchandaddref ( name peername ) * peer { peers . lock ( ) defer peers . unlock ( ) peer : = peers . byname [ name ] if peer ! = nil { peer . localrefcount ++ } return peer } 
func ( peers * peers ) fetchbyshortid ( shortid peershortid ) * peer { peers . rlock ( ) defer peers . runlock ( ) return peers . byshortid [ shortid ] . peer } 
func ( peers * peers ) dereference ( peer * peer ) { peers . lock ( ) defer peers . unlock ( ) peer . localrefcount -- } 
func ( peers * peers ) applyupdate ( update [ ] byte ) ( peernameset , peernameset , error ) { peers . lock ( ) var pending peerspendingnotifications defer peers . unlockandnotify ( & pending ) newpeers , decodedupdate , decodedconns , err : = peers . decodeupdate ( update ) if err ! = nil { return nil , nil , err } for name , newpeer : = range newpeers { peers . byname [ name ] = newpeer peers . addbyshortid ( newpeer , & pending ) } newupdate : = peers . applydecodedupdate ( decodedupdate , decodedconns , & pending ) peers . garbagecollect ( & pending ) for , peerremoved : = range pending . removed { delete ( newupdate , peerremoved . name ) } updatenames : = make ( peernameset ) for , peer : = range decodedupdate { updatenames [ peer . name ] = struct { } { } } return updatenames , newupdate , nil } 
func ( peers * peers ) garbagecollect ( ) { peers . lock ( ) var pending peerspendingnotifications defer peers . unlockandnotify ( & pending ) peers . garbagecollect ( & pending ) } 
func newroutes ( ourself * localpeer , peers * peers ) * routes { recalculate : = make ( chan * struct { } , 1 ) wait : = make ( chan chan struct { } ) action : = make ( chan func ( ) ) r : = & routes { ourself : ourself , peers : peers , unicast : unicastroutes { ourself . name : unknownpeername } , unicastall : unicastroutes { ourself . name : unknownpeername } , broadcast : broadcastroutes { ourself . name : [ ] peername { } } , broadcastall : broadcastroutes { ourself . name : [ ] peername { } } , recalc : recalculate , wait : wait , action : action , } go r . run ( recalculate , wait , action ) return r } 
func ( r * routes ) onchange ( callback func ( ) ) { r . lock ( ) defer r . unlock ( ) r . onchange = append ( r . onchange , callback ) } 
func ( r * routes ) unicast ( name peername ) ( peername , bool ) { r . rlock ( ) defer r . runlock ( ) hop , found : = r . unicast [ name ] return hop , found } 
func ( r * routes ) unicastall ( name peername ) ( peername , bool ) { r . rlock ( ) defer r . runlock ( ) hop , found : = r . unicastall [ name ] return hop , found } 
func ( r * routes ) broadcast ( name peername ) [ ] peername { return r . lookuporcalculate ( name , & r . broadcast , true ) } 
func ( r * routes ) broadcastall ( name peername ) [ ] peername { return r . lookuporcalculate ( name , & r . broadcastall , false ) } 
func ( r * routes ) randomneighbours ( except peername ) [ ] peername { destinations : = make ( peernameset ) r . rlock ( ) defer r . runlock ( ) count : = int ( math . log2 ( float64 ( len ( r . unicastall ) ) ) ) for , dst : = range r . unicastall { if dst ! = unknownpeername && dst ! = except { destinations [ dst ] = struct { } { } if len ( destinations ) >= count { break } } } res : = make ( [ ] peername , 0 , len ( destinations ) ) for dst : = range destinations { res = append ( res , dst ) } return res } 
func ( r * routes ) calculateunicast ( establishedandsymmetric bool ) unicastroutes { , unicast : = r . ourself . routes ( nil , establishedandsymmetric ) return unicast } 
func ( r * routes ) calculatebroadcast ( name peername , establishedandsymmetric bool ) [ ] peername { hops : = [ ] peername { } peer , found : = r . peers . byname [ name ] if ! found { return hops } if found , reached : = peer . routes ( r . ourself . peer , establishedandsymmetric ) ; found { r . ourself . foreachconnectedpeer ( establishedandsymmetric , reached , func ( remotepeer * peer ) { hops = append ( hops , remotepeer . name ) } ) } return hops } 
func newpeer ( name mesh . peername , uid mesh . peeruid , logger mesh . logger ) * peer { p : = & peer { name : name , uid : uid , gossip : nil , recv : make ( chan pkt ) , actions : make ( chan func ( ) ) , quit : make ( chan struct { } ) , logger : logger , } go p . loop ( ) return p } 
func ( p * peer ) register ( gossip mesh . gossip ) { p . actions < - func ( ) { p . gossip = gossip } } 
func ( p * peer ) readfrom ( b [ ] byte ) ( n int , remote net . addr , err error ) { c : = make ( chan struct { } ) p . actions < - func ( ) { go func ( ) { defer close ( c ) select { case pkt : = < - p . recv : n = copy ( b , pkt . buf ) remote = meshaddr { peername : pkt . srcname , peeruid : pkt . srcuid } if n < len ( pkt . buf ) { err = errshortread } case < - p . quit : err = errpeerclosed } } ( ) } < - c return n , remote , err } 
func ( p * peer ) writeto ( b [ ] byte , dst net . addr ) ( n int , err error ) { c : = make ( chan struct { } ) p . actions < - func ( ) { defer close ( c ) if p . gossip == nil { err = errgossipnotregistered return } meshaddr , ok : = dst . ( meshaddr ) if ! ok { err = errnotmeshaddr return } pkt : = pkt { srcname : p . name , srcuid : p . uid , buf : b } if meshaddr . peername == p . name { p . recv < - pkt return } buf : = pkt . encode ( ) n = len ( buf ) err = p . gossip . gossipunicast ( meshaddr . peername , buf ) } < - c return n , err } 
func ( p * peer ) localaddr ( ) net . addr { return meshaddr { peername : p . name , peeruid : p . uid } } 
func ( p * peer ) ongossip ( buf [ ] byte ) ( delta mesh . gossipdata , err error ) { return pktslice { makepkt ( buf ) } , nil } 
func ( p * peer ) ongossipbroadcast ( mesh . peername , buf [ ] byte ) ( received mesh . gossipdata , err error ) { pkt : = makepkt ( buf ) p . recv < - pkt return pktslice { pkt } , nil } 
func ( p * peer ) ongossipunicast ( mesh . peername , buf [ ] byte ) error { pkt : = makepkt ( buf ) p . recv < - pkt return nil } 
func grpcserver ( s server , options ... grpc . serveroption ) * grpc . server { srv : = grpc . newserver ( options ... ) etcdserverpb . registerkvserver ( srv , s ) return srv } 
func newserver ( router * mesh . router , peer * meshconn . peer , minpeercount int , terminatec < - chan struct { } , terminatedc chan < - error , logger mesh . logger , ) server { c : = make ( chan server ) go servermanager ( router , peer , minpeercount , terminatec , terminatedc , logger , c ) return < - c } 
func newdefaultserver ( minpeercount int , terminatec < - chan struct { } , terminatedc chan < - error , logger mesh . logger , ) server { var ( peername = mustpeername ( ) nickname = musthostname ( ) host = " " port = 6379 password = " " channel = " " ) router : = mesh . newrouter ( mesh . config { host : host , port : port , protocolminversion : mesh . protocolminversion , password : [ ] byte ( password ) , connlimit : 64 , peerdiscovery : true , trustedsubnets : [ ] * net . ipnet { } , } , peername , nickname , mesh . nulloverlay { } , logger ) peer : = meshconn . newpeer ( router . ourself . peer . name , router . ourself . uid , logger ) gossip : = router . newgossip ( channel , peer ) peer . register ( gossip ) router . start ( ) return newserver ( router , peer , minpeercount , terminatec , terminatedc , logger ) } 
func peernamefromuserinput ( userinput string ) ( peername , error ) { namebyteary : = sha256 . sum256 ( [ ] byte ( userinput ) ) return peernamefrombin ( namebyteary [ : namesize ] ) , nil } 
func peernamefromstring ( namestr string ) ( peername , error ) { if , err : = hex . decodestring ( namestr ) ; err ! = nil { return unknownpeername , err } return peername ( namestr ) , nil } 
func ( name peername ) bytes ( ) [ ] byte { res , err : = hex . decodestring ( string ( name ) ) if err ! = nil { panic ( " " + name ) } return res } 
func newrouter ( config config , name peername , nickname string , overlay overlay , logger logger ) ( * router , error ) { router : = & router { config : config , gossipchannels : make ( gossipchannels ) } if overlay == nil { overlay = nulloverlay { } } router . overlay = overlay router . ourself = newlocalpeer ( name , nickname , router ) router . peers = newpeers ( router . ourself ) router . peers . ongc ( func ( peer * peer ) { logger . printf ( " " , peer ) } ) router . routes = newroutes ( router . ourself , router . peers ) router . connectionmaker = newconnectionmaker ( router . ourself , router . peers , net . joinhostport ( router . host , " " ) , router . port , router . peerdiscovery , logger ) router . logger = logger gossip , err : = router . newgossip ( " " , router ) if err ! = nil { return nil , err } router . topologygossip = gossip router . acceptlimiter = newtokenbucket ( acceptmaxtokens , accepttokendelay ) return router , nil } 
func ( router * router ) newgossip ( channelname string , g gossiper ) ( gossip , error ) { channel : = newgossipchannel ( channelname , router . ourself , router . routes , g , router . logger ) router . gossiplock . lock ( ) defer router . gossiplock . unlock ( ) if , found : = router . gossipchannels [ channelname ] ; found { return nil , fmt . errorf ( " " , channelname ) } router . gossipchannels [ channelname ] = channel return channel , nil } 
func ( router * router ) sendallgossip ( ) { for channel : = range router . gossipchannelset ( ) { if gossip : = channel . gossiper . gossip ( ) ; gossip ! = nil { channel . send ( gossip ) } } } 
func ( router * router ) sendallgossipdown ( conn connection ) { for channel : = range router . gossipchannelset ( ) { if gossip : = channel . gossiper . gossip ( ) ; gossip ! = nil { channel . senddown ( conn , gossip ) } } } 
func ( router * router ) broadcasttopologyupdate ( update [ ] * peer ) { names : = make ( peernameset ) for , p : = range update { names [ p . name ] = struct { } { } } router . topologygossip . gossipbroadcast ( & topologygossipdata { peers : router . peers , update : names } ) } 
func ( router * router ) ongossipunicast ( sender peername , msg [ ] byte ) error { return fmt . errorf ( " " , msg ) } 
func ( router * router ) ongossipbroadcast ( peername , update [ ] byte ) ( gossipdata , error ) { origupdate , , err : = router . applytopologyupdate ( update ) if err ! = nil | | len ( origupdate ) == 0 { return nil , err } return & topologygossipdata { peers : router . peers , update : origupdate } , nil } 
func ( router * router ) gossip ( ) gossipdata { return & topologygossipdata { peers : router . peers , update : router . peers . names ( ) } } 
func ( router * router ) ongossip ( update [ ] byte ) ( gossipdata , error ) { , newupdate , err : = router . applytopologyupdate ( update ) if err ! = nil | | len ( newupdate ) == 0 { return nil , err } return & topologygossipdata { peers : router . peers , update : newupdate } , nil } 
func ( d * topologygossipdata ) merge ( other gossipdata ) gossipdata { names : = make ( peernameset ) for name : = range d . update { names [ name ] = struct { } { } } for name : = range other . ( * topologygossipdata ) . update { names [ name ] = struct { } { } } return & topologygossipdata { peers : d . peers , update : names } } 
func ( d * topologygossipdata ) encode ( ) [ ] [ ] byte { return [ ] [ ] byte { d . peers . encodepeers ( d . update ) } } 
func newstate ( self mesh . peername ) * state { return & state { set : map [ mesh . peername ] int { } , self : self , } } 
func ( st * state ) merge ( other mesh . gossipdata ) ( complete mesh . gossipdata ) { return st . mergecomplete ( other . ( * state ) . copy ( ) . set ) } 
func ( st * state ) mergereceived ( set map [ mesh . peername ] int ) ( received mesh . gossipdata ) { st . mtx . lock ( ) defer st . mtx . unlock ( ) for peer , v : = range set { if v <= st . set [ peer ] { delete ( set , peer ) continue } st . set [ peer ] = v } return & state { set : set , } } 
func ( st * state ) mergedelta ( set map [ mesh . peername ] int ) ( delta mesh . gossipdata ) { st . mtx . lock ( ) defer st . mtx . unlock ( ) for peer , v : = range set { if v <= st . set [ peer ] { delete ( set , peer ) continue } st . set [ peer ] = v } if len ( set ) <= 0 { return nil } return & state { set : set , } } 
func ( st * state ) mergecomplete ( set map [ mesh . peername ] int ) ( complete mesh . gossipdata ) { st . mtx . lock ( ) defer st . mtx . unlock ( ) for peer , v : = range set { if v > st . set [ peer ] { st . set [ peer ] = v } } return & state { set : st . set , } } 
func ( * surrogategossiper ) ongossipbroadcast ( peername , update [ ] byte ) ( gossipdata , error ) { return newsurrogategossipdata ( update ) , nil } 
func ( s * surrogategossiper ) ongossip ( update [ ] byte ) ( gossipdata , error ) { hash : = fnv . new64a ( ) , = hash . write ( update ) updatehash : = hash . sum64 ( ) s . lock ( ) defer s . unlock ( ) for , p : = range s . prevupdates { if updatehash == p . hash && bytes . equal ( update , p . update ) { return nil , nil } } updatetime : = now ( ) deletebefore : = updatetime . add ( - gossipinterval ) keepfrom : = len ( s . prevupdates ) for i , p : = range s . prevupdates { if p . t . after ( deletebefore ) { keepfrom = i break } } s . prevupdates = append ( s . prevupdates [ keepfrom : ] , prevupdate { update , updatehash , updatetime } ) return newsurrogategossipdata ( update ) , nil } 
func ( d * surrogategossipdata ) merge ( other gossipdata ) gossipdata { o : = other . ( * surrogategossipdata ) messages : = make ( [ ] [ ] byte , 0 , len ( d . messages ) + len ( o . messages ) ) messages = append ( messages , d . messages ... ) messages = append ( messages , o . messages ... ) return & surrogategossipdata { messages : messages } } 
func generatekeypair ( ) ( publickey , privatekey * [ 32 ] byte , err error ) { return box . generatekey ( rand . reader ) } 
func formsessionkey ( remotepublickey , localprivatekey * [ 32 ] byte , secretkey [ ] byte ) * [ 32 ] byte { var sharedkey [ 32 ] byte box . precompute ( & sharedkey , remotepublickey , localprivatekey ) sharedkeyslice : = sharedkey [ : ] sharedkeyslice = append ( sharedkeyslice , secretkey ... ) sessionkey : = sha256 . sum256 ( sharedkeyslice ) return & sessionkey } 
func newtcpcryptostate ( sessionkey * [ 32 ] byte , outbound bool ) * tcpcryptostate { s : = & tcpcryptostate { sessionkey : sessionkey } if outbound { s . nonce [ 0 ] | = ( 1 < < 7 ) } s . nonce [ 0 ] | = ( 1 < < 6 ) return s } 
func ( sender * gobtcpsender ) send ( msg [ ] byte ) error { return sender . encoder . encode ( msg ) } 
func ( sender * lengthprefixtcpsender ) send ( msg [ ] byte ) error { l : = len ( msg ) if l > maxtcpmsgsize { return fmt . errorf ( " " , l , maxtcpmsgsize ) } prefixedmsg : = make ( [ ] byte , 4 + l ) binary . bigendian . putuint32 ( prefixedmsg , uint32 ( l ) ) copy ( prefixedmsg [ 4 : ] , msg ) , err : = sender . writer . write ( prefixedmsg ) return err } 
func ( sender * encryptedtcpsender ) send ( msg [ ] byte ) error { sender . lock ( ) defer sender . unlock ( ) encodedmsg : = secretbox . seal ( nil , msg , & sender . state . nonce , sender . state . sessionkey ) sender . state . advance ( ) return sender . sender . send ( encodedmsg ) } 
func ( receiver * gobtcpreceiver ) receive ( ) ( [ ] byte , error ) { var msg [ ] byte err : = receiver . decoder . decode ( & msg ) return msg , err } 
func ( receiver * lengthprefixtcpreceiver ) receive ( ) ( [ ] byte , error ) { lenprefix : = make ( [ ] byte , 4 ) if , err : = io . readfull ( receiver . reader , lenprefix ) ; err ! = nil { return nil , err } l : = binary . bigendian . uint32 ( lenprefix ) if l > maxtcpmsgsize { return nil , fmt . errorf ( " " , l , maxtcpmsgsize ) } msg : = make ( [ ] byte , l ) , err : = io . readfull ( receiver . reader , msg ) return msg , err } 
func ( receiver * encryptedtcpreceiver ) receive ( ) ( [ ] byte , error ) { msg , err : = receiver . receiver . receive ( ) if err ! = nil { return nil , err } decodedmsg , success : = secretbox . open ( nil , msg , & receiver . state . nonce , receiver . state . sessionkey ) if ! success { return nil , fmt . errorf ( " " ) } receiver . state . advance ( ) return decodedmsg , nil } 
func newpeer ( self mesh . peername , logger * log . logger ) * peer { actions : = make ( chan func ( ) ) p : = & peer { st : newstate ( self ) , send : nil , actions : actions , quit : make ( chan struct { } ) , logger : logger , } go p . loop ( actions ) return p } 
func ( p * peer ) incr ( ) ( result int ) { c : = make ( chan struct { } ) p . actions < - func ( ) { defer close ( c ) st : = p . st . incr ( ) if p . send ! = nil { p . send . gossipbroadcast ( st ) } else { p . logger . printf ( " " ) } result = st . get ( ) } < - c return result } 
func ( p * peer ) gossip ( ) ( complete mesh . gossipdata ) { complete = p . st . copy ( ) p . logger . printf ( " " , complete . ( * state ) . set ) return complete } 
func ( p * peer ) ongossip ( buf [ ] byte ) ( delta mesh . gossipdata , err error ) { var set map [ mesh . peername ] int if err : = gob . newdecoder ( bytes . newreader ( buf ) ) . decode ( & set ) ; err ! = nil { return nil , err } delta = p . st . mergedelta ( set ) if delta == nil { p . logger . printf ( " " , set , delta ) } else { p . logger . printf ( " " , set , delta . ( * state ) . set ) } return delta , nil } 
func ( p * peer ) ongossipbroadcast ( src mesh . peername , buf [ ] byte ) ( received mesh . gossipdata , err error ) { var set map [ mesh . peername ] int if err : = gob . newdecoder ( bytes . newreader ( buf ) ) . decode ( & set ) ; err ! = nil { return nil , err } received = p . st . mergereceived ( set ) if received == nil { p . logger . printf ( " " , src , set , received ) } else { p . logger . printf ( " " , src , set , received . ( * state ) . set ) } return received , nil } 
func ( p * peer ) ongossipunicast ( src mesh . peername , buf [ ] byte ) error { var set map [ mesh . peername ] int if err : = gob . newdecoder ( bytes . newreader ( buf ) ) . decode ( & set ) ; err ! = nil { return err } complete : = p . st . mergecomplete ( set ) p . logger . printf ( " " , src , set , complete ) return nil } 
func makeraftpeer ( addr net . addr ) raft . peer { return raft . peer { id : uint64 ( addr . ( meshconn . meshaddr ) . peeruid ) , context : nil , } } 
func ( peer * peer ) string ( ) string { return fmt . sprint ( peer . name , " " , peer . nickname , " " ) } 
func ( peer * peer ) routes ( stopat * peer , establishedandsymmetric bool ) ( bool , map [ peername ] peername ) { routes : = make ( unicastroutes ) routes [ peer . name ] = unknownpeername nextworklist : = [ ] * peer { peer } for len ( nextworklist ) > 0 { worklist : = nextworklist sort . sort ( listofpeers ( worklist ) ) nextworklist = [ ] * peer { } for , curpeer : = range worklist { if curpeer == stopat { return true , routes } curpeer . foreachconnectedpeer ( establishedandsymmetric , routes , func ( remotepeer * peer ) { nextworklist = append ( nextworklist , remotepeer ) remotename : = remotepeer . name if curpeer == peer { routes [ remotename ] = remotename } else { routes [ remotename ] = routes [ curpeer . name ] } } ) } } return false , routes } 
func ( peer * peer ) foreachconnectedpeer ( establishedandsymmetric bool , exclude map [ peername ] peername , f func ( * peer ) ) { for remotename , conn : = range peer . connections { if establishedandsymmetric && ! conn . isestablished ( ) { continue } if , found : = exclude [ remotename ] ; found { continue } remotepeer : = conn . remote ( ) if remoteconn , found : = remotepeer . connections [ peer . name ] ; ! establishedandsymmetric | | ( found && remoteconn . isestablished ( ) ) { f ( remotepeer ) } } } 
func parsepeeruid ( s string ) ( peeruid , error ) { uid , err : = strconv . parseuint ( s , 10 , 64 ) return peeruid ( uid ) , err } 
func ( lop listofpeers ) swap ( i , j int ) { lop [ i ] , lop [ j ] = lop [ j ] , lop [ i ] } 
func ( lop listofpeers ) less ( i , j int ) bool { return lop [ i ] . name < lop [ j ] . name } 
func ( params protocolintroparams ) dointro ( ) ( res protocolintroresults , err error ) { if err = params . conn . setdeadline ( time . now ( ) . add ( headertimeout ) ) ; err ! = nil { return } if res . version , err = params . exchangeprotocolheader ( ) ; err ! = nil { return } var pubkey , privkey * [ 32 ] byte if params . password ! = nil { if pubkey , privkey , err = generatekeypair ( ) ; err ! = nil { return } } if err = params . conn . setwritedeadline ( time . time { } ) ; err ! = nil { return } if err = params . conn . setreaddeadline ( time . now ( ) . add ( tcpheartbeat * 2 ) ) ; err ! = nil { return } switch res . version { case 1 : err = res . dointrov1 ( params , pubkey , privkey ) case 2 : err = res . dointrov2 ( params , pubkey , privkey ) default : panic ( " " ) } return } 
func ( res * protocolintroresults ) dointrov1 ( params protocolintroparams , pubkey , privkey * [ 32 ] byte ) error { features : = filterv1features ( params . features ) if pubkey ! = nil { features [ " " ] = hex . encodetostring ( pubkey [ : ] ) } enc : = gob . newencoder ( params . conn ) dec : = gob . newdecoder ( params . conn ) encodedone : = make ( chan error , 1 ) go func ( ) { encodedone < - enc . encode ( features ) } ( ) if err : = dec . decode ( & res . features ) ; err ! = nil { return err } if err : = < - encodedone ; err ! = nil { return err } res . sender = newgobtcpsender ( enc ) res . receiver = newgobtcpreceiver ( dec ) if pubkey == nil { if , present : = res . features [ " " ] ; present { return errexpectednocrypto } } else { remotepubkeystr , ok : = res . features [ " " ] if ! ok { return errexpectedcrypto } remotepubkey , err : = hex . decodestring ( remotepubkeystr ) if err ! = nil { return err } res . setupcrypto ( params , remotepubkey , privkey ) } res . features = filterv1features ( res . features ) return nil } 
func filterv1features ( intro map [ string ] string ) map [ string ] string { safe : = make ( map [ string ] string ) for , k : = range protocolv1features { if val , ok : = intro [ k ] ; ok { safe [ k ] = val } } return safe } 
func newconnectionmaker ( ourself * localpeer , peers * peers , localaddr string , port int , discovery bool , logger logger ) * connectionmaker { actionchan : = make ( chan connectionmakeraction , channelsize ) cm : = & connectionmaker { ourself : ourself , peers : peers , localaddr : localaddr , port : port , discovery : discovery , directpeers : peeraddrs { } , targets : make ( map [ string ] * target ) , connections : make ( map [ connection ] struct { } ) , actionchan : actionchan , logger : logger , } go cm . queryloop ( actionchan ) return cm } 
func ( cm * connectionmaker ) initiateconnections ( peers [ ] string , replace bool ) [ ] error { errors : = [ ] error { } addrs : = peeraddrs { } for , peer : = range peers { host , port , err : = net . splithostport ( peer ) if err ! = nil { host = peer port = " " } if host == " " | | ! isalnum ( port ) { errors = append ( errors , fmt . errorf ( " " , peer ) ) } else if addr , err : = net . resolvetcpaddr ( " " , fmt . sprintf ( " " , host , port ) ) ; err ! = nil { errors = append ( errors , err ) } else { addrs [ peer ] = addr } } cm . actionchan < - func ( ) bool { if replace { cm . directpeers = peeraddrs { } } for peer , addr : = range addrs { cm . directpeers [ peer ] = addr if target , found : = cm . targets [ cm . completeaddr ( * addr ) ] ; found { target . nexttrynow ( ) } } return true } return errors } 
func ( cm * connectionmaker ) forgetconnections ( peers [ ] string ) { cm . actionchan < - func ( ) bool { for , peer : = range peers { delete ( cm . directpeers , peer ) } return true } } 
func ( cm * connectionmaker ) targets ( activeonly bool ) [ ] string { resultchan : = make ( chan [ ] string ) cm . actionchan < - func ( ) bool { var slice [ ] string for peer , addr : = range cm . directpeers { if activeonly { if target , ok : = cm . targets [ cm . completeaddr ( * addr ) ] ; ok && target . tryafter . iszero ( ) { continue } } slice = append ( slice , peer ) } resultchan < - slice return false } return < - resultchan } 
func ( cm * connectionmaker ) connectionaborted ( address string , err error ) { cm . actionchan < - func ( ) bool { target : = cm . targets [ address ] target . state = targetwaiting target . lasterror = err target . nexttrylater ( ) return true } } 
func ( cm * connectionmaker ) connectioncreated ( conn connection ) { cm . actionchan < - func ( ) bool { cm . connections [ conn ] = struct { } { } if conn . isoutbound ( ) { target : = cm . targets [ conn . remotetcpaddress ( ) ] target . state = targetconnected } return false } } 
func ( cm * connectionmaker ) connectionterminated ( conn connection , err error ) { cm . actionchan < - func ( ) bool { if err ! = errconnecttoself { cm . terminationcount ++ } delete ( cm . connections , conn ) if conn . isoutbound ( ) { target : = cm . targets [ conn . remotetcpaddress ( ) ] target . state = targetwaiting target . lasterror = err , peernamecollision : = err . ( * peernamecollisionerror ) switch { case peernamecollision | | err == errconnecttoself : target . nexttrynever ( ) case time . now ( ) . after ( target . tryafter . add ( resetafter ) ) : target . nexttrynow ( ) default : target . nexttrylater ( ) } } return true } } 
func ( t * target ) nexttrylater ( ) { t . tryafter = time . now ( ) . add ( t . tryinterval / 2 + time . duration ( rand . int63n ( int64 ( t . tryinterval ) ) ) ) t . tryinterval = t . tryinterval * 3 / 2 if t . tryinterval > maxinterval { t . tryinterval = maxinterval } } 
func newgossipsender ( makemsg func ( msg [ ] byte ) protocolmsg , makebroadcastmsg func ( srcname peername , msg [ ] byte ) protocolmsg , sender protocolsender , stop < - chan struct { } , ) * gossipsender { more : = make ( chan struct { } , 1 ) flush : = make ( chan chan < - bool ) s : = & gossipsender { makemsg : makemsg , makebroadcastmsg : makebroadcastmsg , sender : sender , broadcasts : make ( map [ peername ] gossipdata ) , more : more , flush : flush , } go s . run ( stop , more , flush ) return s } 
func ( s * gossipsender ) send ( data gossipdata ) { s . lock ( ) defer s . unlock ( ) if s . empty ( ) { defer s . prod ( ) } if s . gossip == nil { s . gossip = data } else { s . gossip = s . gossip . merge ( data ) } } 
func ( s * gossipsender ) broadcast ( srcname peername , data gossipdata ) { s . lock ( ) defer s . unlock ( ) if s . empty ( ) { defer s . prod ( ) } d , found : = s . broadcasts [ srcname ] if ! found { s . broadcasts [ srcname ] = data } else { s . broadcasts [ srcname ] = d . merge ( data ) } } 
func ( s * gossipsender ) flush ( ) bool { ch : = make ( chan bool ) s . flush < - ch return < - ch } 
func newgossipsenders ( sender protocolsender , stop < - chan struct { } ) * gossipsenders { return & gossipsenders { sender : sender , stop : stop , senders : make ( map [ string ] * gossipsender ) , } } 
func ( gs * gossipsenders ) sender ( channelname string , makegossipsender func ( sender protocolsender , stop < - chan struct { } ) * gossipsender ) * gossipsender { gs . lock ( ) defer gs . unlock ( ) s , found : = gs . senders [ channelname ] if ! found { s = makegossipsender ( gs . sender , gs . stop ) gs . senders [ channelname ] = s } return s } 
func ( gs * gossipsenders ) flush ( ) bool { sent : = false gs . lock ( ) defer gs . unlock ( ) for , sender : = range gs . senders { sent = sender . flush ( ) | | sent } return sent } 
func findmainpath ( ) string { pc : = make ( [ ] uintptr , 100 ) n : = runtime . callers ( 2 , pc ) frames : = runtime . callersframes ( pc [ : n ] ) for { frame , more : = frames . next ( ) if frame . function == " " | | frame . function == " " { return frame . file } if ! more { break } } return " " } 
func create ( c context . context , clientid string ) ( token string , err error ) { req : = & pb . createchannelrequest { applicationkey : & clientid , } resp : = & pb . createchannelresponse { } err = internal . call ( c , service , " " , req , resp ) token = resp . gettoken ( ) return token , remaperror ( err ) } 
func send ( c context . context , clientid , message string ) error { req : = & pb . sendmessagerequest { applicationkey : & clientid , message : & message , } resp : = & basepb . voidproto { } return remaperror ( internal . call ( c , service , " " , req , resp ) ) } 
func sendjson ( c context . context , clientid string , value interface { } ) error { m , err : = json . marshal ( value ) if err ! = nil { return err } return send ( c , clientid , string ( m ) ) } 
func remaperror ( err error ) error { if e , ok : = err . ( * internal . apierror ) ; ok { if e . service == " " { e . service = " " } } return err } 
func fullyqualifiedappid ( ctx netcontext . context ) string { if id , ok : = ctx . value ( & appidoverridekey ) . ( string ) ; ok { return id } return fullyqualifiedappid ( ctx ) } 
func namespacedcontext ( ctx netcontext . context , namespace string ) netcontext . context { return withnamespace ( ctx , namespace ) } 
func prototoitem ( p * pb . memcachegetresponse item ) * item { return & item { key : string ( p . key ) , value : p . value , flags : p . getflags ( ) , casid : p . getcasid ( ) , } } 
func singleerror ( err error ) error { if me , ok : = err . ( appengine . multierror ) ; ok { return me [ 0 ] } return err } 
func get ( c context . context , key string ) ( * item , error ) { m , err : = getmulti ( c , [ ] string { key } ) if err ! = nil { return nil , err } if , ok : = m [ key ] ; ! ok { return nil , errcachemiss } return m [ key ] , nil } 
func getmulti ( c context . context , key [ ] string ) ( map [ string ] * item , error ) { if len ( key ) == 0 { return nil , nil } keyasbytes : = make ( [ ] [ ] byte , len ( key ) ) for i , k : = range key { keyasbytes [ i ] = [ ] byte ( k ) } req : = & pb . memcachegetrequest { key : keyasbytes , forcas : proto . bool ( true ) , } res : = & pb . memcachegetresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } m : = make ( map [ string ] * item , len ( res . item ) ) for , p : = range res . item { t : = prototoitem ( p ) m [ t . key ] = t } return m , nil } 
func delete ( c context . context , key string ) error { return singleerror ( deletemulti ( c , [ ] string { key } ) ) } 
func deletemulti ( c context . context , key [ ] string ) error { if len ( key ) == 0 { return nil } req : = & pb . memcachedeleterequest { item : make ( [ ] * pb . memcachedeleterequest item , len ( key ) ) , } for i , k : = range key { req . item [ i ] = & pb . memcachedeleterequest item { key : [ ] byte ( k ) } } res : = & pb . memcachedeleteresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . deletestatus ) ! = len ( key ) { return errservererror } me , any : = make ( appengine . multierror , len ( key ) ) , false for i , s : = range res . deletestatus { switch s { case pb . memcachedeleteresponse deleted : case pb . memcachedeleteresponse not found : me [ i ] = errcachemiss any = true default : me [ i ] = errservererror any = true } } if any { return me } return nil } 
func increment ( c context . context , key string , delta int64 , initialvalue uint64 ) ( newvalue uint64 , err error ) { return incr ( c , key , delta , & initialvalue ) } 
func incrementexisting ( c context . context , key string , delta int64 ) ( newvalue uint64 , err error ) { return incr ( c , key , delta , nil ) } 
func set ( c context . context , item * item ) error { return singleerror ( set ( c , [ ] * item { item } , nil , pb . memcachesetrequest set ) ) } 
func setmulti ( c context . context , item [ ] * item ) error { return set ( c , item , nil , pb . memcachesetrequest set ) } 
func add ( c context . context , item * item ) error { return singleerror ( set ( c , [ ] * item { item } , nil , pb . memcachesetrequest add ) ) } 
func addmulti ( c context . context , item [ ] * item ) error { return set ( c , item , nil , pb . memcachesetrequest add ) } 
func compareandswap ( c context . context , item * item ) error { return singleerror ( set ( c , [ ] * item { item } , nil , pb . memcachesetrequest cas ) ) } 
func compareandswapmulti ( c context . context , item [ ] * item ) error { return set ( c , item , nil , pb . memcachesetrequest cas ) } 
func ( cd codec ) get ( c context . context , key string , v interface { } ) ( * item , error ) { i , err : = get ( c , key ) if err ! = nil { return nil , err } if err : = cd . unmarshal ( i . value , v ) ; err ! = nil { return nil , err } return i , nil } 
func ( cd codec ) set ( c context . context , item * item ) error { return singleerror ( cd . set ( c , [ ] * item { item } , pb . memcachesetrequest set ) ) } 
func ( cd codec ) setmulti ( c context . context , items [ ] * item ) error { return cd . set ( c , items , pb . memcachesetrequest set ) } 
func ( cd codec ) add ( c context . context , item * item ) error { return singleerror ( cd . set ( c , [ ] * item { item } , pb . memcachesetrequest add ) ) } 
func ( cd codec ) addmulti ( c context . context , items [ ] * item ) error { return cd . set ( c , items , pb . memcachesetrequest add ) } 
func ( cd codec ) compareandswap ( c context . context , item * item ) error { return singleerror ( cd . set ( c , [ ] * item { item } , pb . memcachesetrequest cas ) ) } 
func ( cd codec ) compareandswapmulti ( c context . context , items [ ] * item ) error { return cd . set ( c , items , pb . memcachesetrequest cas ) } 
func stats ( c context . context ) ( * statistics , error ) { req : = & pb . memcachestatsrequest { } res : = & pb . memcachestatsresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } if res . stats == nil { return nil , errnostats } return & statistics { hits : * res . stats . hits , misses : * res . stats . misses , bytehits : * res . stats . bytehits , items : * res . stats . items , bytes : * res . stats . bytes , oldest : int64 ( * res . stats . oldestitemage ) , } , nil } 
func flush ( c context . context ) error { req : = & pb . memcacheflushrequest { } res : = & pb . memcacheflushresponse { } return internal . call ( c , " " , " " , req , res ) } 
func init ( ) { http . handlefunc ( " " , handlebackground ) sc : = make ( chan send ) rc : = make ( chan recv ) sendc , recvc = sc , rc go matchmaker ( sc , rc ) } 
func runinbackground ( c context . context , f func ( c context . context ) ) error { req : = & pb . startbackgroundrequestrequest { } res : = & pb . startbackgroundrequestresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } sendc < - send { res . getrequestid ( ) , f } return nil } 
func list ( c context . context ) ( [ ] string , error ) { req : = & pb . getmodulesrequest { } res : = & pb . getmodulesresponse { } err : = internal . call ( c , " " , " " , req , res ) return res . module , err } 
func numinstances ( c context . context , module , version string ) ( int , error ) { req : = & pb . getnuminstancesrequest { } if module ! = " " { req . module = & module } if version ! = " " { req . version = & version } res : = & pb . getnuminstancesresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return 0 , err } return int ( * res . instances ) , nil } 
func setnuminstances ( c context . context , module , version string , instances int ) error { req : = & pb . setnuminstancesrequest { } if module ! = " " { req . module = & module } if version ! = " " { req . version = & version } req . instances = proto . int64 ( int64 ( instances ) ) res : = & pb . setnuminstancesresponse { } return internal . call ( c , " " , " " , req , res ) } 
func versions ( c context . context , module string ) ( [ ] string , error ) { req : = & pb . getversionsrequest { } if module ! = " " { req . module = & module } res : = & pb . getversionsresponse { } err : = internal . call ( c , " " , " " , req , res ) return res . getversion ( ) , err } 
func defaultversion ( c context . context , module string ) ( string , error ) { req : = & pb . getdefaultversionrequest { } if module ! = " " { req . module = & module } res : = & pb . getdefaultversionresponse { } err : = internal . call ( c , " " , " " , req , res ) return res . getversion ( ) , err } 
func start ( c context . context , module , version string ) error { req : = & pb . startmodulerequest { } if module ! = " " { req . module = & module } if version ! = " " { req . version = & version } res : = & pb . startmoduleresponse { } return internal . call ( c , " " , " " , req , res ) } 
func stop ( c context . context , module , version string ) error { req : = & pb . stopmodulerequest { } if module ! = " " { req . module = & module } if version ! = " " { req . version = & version } res : = & pb . stopmoduleresponse { } return internal . call ( c , " " , " " , req , res ) } 
func ( q * query ) ancestor ( ancestor * key ) * query { q = q . clone ( ) if ancestor == nil { q . err = errors . new ( " " ) return q } q . ancestor = ancestor return q } 
func ( q * query ) eventualconsistency ( ) * query { q = q . clone ( ) q . eventual = true return q } 
func ( q * query ) filter ( filterstr string , value interface { } ) * query { q = q . clone ( ) filterstr = strings . trimspace ( filterstr ) if len ( filterstr ) < 1 { q . err = errors . new ( " " + filterstr ) return q } f : = filter { fieldname : strings . trimright ( filterstr , " " ) , value : value , } switch op : = strings . trimspace ( filterstr [ len ( f . fieldname ) : ] ) ; op { case " " : f . op = lesseq case " " : f . op = greatereq case " " : f . op = lessthan case " " : f . op = greaterthan case " " : f . op = equal default : q . err = fmt . errorf ( " " , op , filterstr ) return q } q . filter = append ( q . filter , f ) return q } 
func ( q * query ) order ( fieldname string ) * query { q = q . clone ( ) fieldname = strings . trimspace ( fieldname ) o : = order { direction : ascending , fieldname : fieldname , } if strings . hasprefix ( fieldname , " " ) { o . direction = descending o . fieldname = strings . trimspace ( fieldname [ 1 : ] ) } else if strings . hasprefix ( fieldname , " " ) { q . err = fmt . errorf ( " " , fieldname ) return q } if len ( o . fieldname ) == 0 { q . err = errors . new ( " " ) return q } q . order = append ( q . order , o ) return q } 
func ( q * query ) project ( fieldnames ... string ) * query { q = q . clone ( ) q . projection = append ( [ ] string ( nil ) , fieldnames ... ) return q } 
func ( q * query ) distinct ( ) * query { q = q . clone ( ) q . distinct = true return q } 
func ( q * query ) distincton ( fieldnames ... string ) * query { q = q . clone ( ) q . distincton = fieldnames return q } 
func ( q * query ) keysonly ( ) * query { q = q . clone ( ) q . keysonly = true return q } 
func ( q * query ) limit ( limit int ) * query { q = q . clone ( ) if limit < math . minint32 | | limit > math . maxint32 { q . err = errors . new ( " " ) return q } q . limit = int32 ( limit ) return q } 
func ( q * query ) offset ( offset int ) * query { q = q . clone ( ) if offset < 0 { q . err = errors . new ( " " ) return q } if offset > math . maxint32 { q . err = errors . new ( " " ) return q } q . offset = int32 ( offset ) return q } 
func ( q * query ) batchsize ( size int ) * query { q = q . clone ( ) if size <= 0 | | size > math . maxint32 { q . err = errors . new ( " " ) return q } q . count = int32 ( size ) return q } 
func ( q * query ) start ( c cursor ) * query { q = q . clone ( ) if c . cc == nil { q . err = errors . new ( " " ) return q } q . start = c . cc return q } 
func ( q * query ) end ( c cursor ) * query { q = q . clone ( ) if c . cc == nil { q . err = errors . new ( " " ) return q } q . end = c . cc return q } 
func ( q * query ) count ( c context . context ) ( int , error ) { if q . err ! = nil { return 0 , q . err } newq : = q . clone ( ) newq . keysonly = len ( newq . projection ) == 0 newq . limit = 0 if q . limit < 0 { newq . offset = math . maxint32 } else { newq . offset = q . offset + q . limit if newq . offset < 0 { newq . offset = math . maxint32 } } req : = & pb . query { } if err : = newq . toproto ( req , internal . fullyqualifiedappid ( c ) ) ; err ! = nil { return 0 , err } res : = & pb . queryresult { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return 0 , err } var n int32 for { if len ( res . result ) ! = 0 { return 0 , errors . new ( " " ) } n += res . getskippedresults ( ) if ! res . getmoreresults ( ) { break } if err : = callnext ( c , res , newq . offset - n , q . count ) ; err ! = nil { return 0 , err } } n - = q . offset if n < 0 { n = 0 } return int ( n ) , nil } 
func callnext ( c context . context , res * pb . queryresult , offset , count int32 ) error { if res . cursor == nil { return errors . new ( " " ) } req : = & pb . nextrequest { cursor : res . cursor , } if count >= 0 { req . count = proto . int32 ( count ) } if offset ! = 0 { req . offset = proto . int32 ( offset ) } if res . compiledcursor ! = nil { req . compile = proto . bool ( true ) } res . reset ( ) return internal . call ( c , " " , " " , req , res ) } 
func ( q * query ) getall ( c context . context , dst interface { } ) ( [ ] * key , error ) { var ( dv reflect . value mat multiargtype elemtype reflect . type errfieldmismatch error ) if ! q . keysonly { dv = reflect . valueof ( dst ) if dv . kind ( ) ! = reflect . ptr | | dv . isnil ( ) { return nil , errinvalidentitytype } dv = dv . elem ( ) mat , elemtype = checkmultiarg ( dv ) if mat == multiargtypeinvalid | | mat == multiargtypeinterface { return nil , errinvalidentitytype } } var keys [ ] * key for t : = q . run ( c ) ; ; { k , e , err : = t . next ( ) if err == done { break } if err ! = nil { return keys , err } if ! q . keysonly { ev : = reflect . new ( elemtype ) if elemtype . kind ( ) == reflect . map { x : = reflect . makemap ( elemtype ) ev . elem ( ) . set ( x ) } if err = loadentity ( ev . interface ( ) , e ) ; err ! = nil { if , ok : = err . ( * errfieldmismatch ) ; ok { errfieldmismatch = err } else { return keys , err } } if mat ! = multiargtypestructptr { ev = ev . elem ( ) } dv . set ( reflect . append ( dv , ev ) ) } keys = append ( keys , k ) } return keys , errfieldmismatch } 
func ( q * query ) run ( c context . context ) * iterator { if q . err ! = nil { return & iterator { err : q . err } } t : = & iterator { c : c , limit : q . limit , count : q . count , q : q , prevcc : q . start , } var req pb . query if err : = q . toproto ( & req , internal . fullyqualifiedappid ( c ) ) ; err ! = nil { t . err = err return t } if err : = internal . call ( c , " " , " " , & req , & t . res ) ; err ! = nil { t . err = err return t } offset : = q . offset - t . res . getskippedresults ( ) var count int32 if t . count > 0 && ( t . limit < 0 | | t . count < t . limit ) { count = t . count } else { count = t . limit } for offset > 0 && t . res . getmoreresults ( ) { t . prevcc = t . res . compiledcursor if err : = callnext ( t . c , & t . res , offset , count ) ; err ! = nil { t . err = err break } skip : = t . res . getskippedresults ( ) if skip < 0 { t . err = errors . new ( " " ) break } offset - = skip } if offset < 0 { t . err = errors . new ( " " ) } return t } 
func ( t * iterator ) next ( dst interface { } ) ( * key , error ) { k , e , err : = t . next ( ) if err ! = nil { return nil , err } if dst ! = nil && ! t . q . keysonly { err = loadentity ( dst , e ) } return k , err } 
func ( t * iterator ) cursor ( ) ( cursor , error ) { if t . err ! = nil && t . err ! = done { return cursor { } , t . err } skipped : = t . res . getskippedresults ( ) if t . i == 0 && skipped == 0 { if t . prevcc == nil { return cursor { & zerocc } , nil } return cursor { t . prevcc } , nil } if t . i == len ( t . res . result ) { return cursor { t . res . compiledcursor } , nil } q : = t . q . clone ( ) q . start = t . prevcc q . offset = skipped + int32 ( t . i ) q . limit = 0 q . keysonly = len ( q . projection ) == 0 t1 : = q . run ( t . c ) , , err : = t1 . next ( ) if err ! = done { if err == nil { err = fmt . errorf ( " " ) } return cursor { } , err } return cursor { t1 . res . compiledcursor } , nil } 
func ( c cursor ) string ( ) string { if c . cc == nil { return " " } b , err : = proto . marshal ( c . cc ) if err ! = nil { panic ( fmt . sprintf ( " " , err ) ) } return strings . trimright ( base64 . urlencoding . encodetostring ( b ) , " " ) } 
func decodecursor ( s string ) ( cursor , error ) { if s == " " { return cursor { & zerocc } , nil } if n : = len ( s ) % 4 ; n ! = 0 { s += strings . repeat ( " " , 4 - n ) } b , err : = base64 . urlencoding . decodestring ( s ) if err ! = nil { return cursor { } , err } cc : = & pb . compiledcursor { } if err : = proto . unmarshal ( b , cc ) ; err ! = nil { return cursor { } , err } return cursor { cc } , nil } 
func saveentity ( defaultappid string , key * key , src interface { } ) ( * pb . entityproto , error ) { var err error var props [ ] property if e , ok : = src . ( propertyloadsaver ) ; ok { props , err = e . save ( ) } else { props , err = savestruct ( src ) } if err ! = nil { return nil , err } return propertiestoproto ( defaultappid , key , props ) } 
func ( l * fieldlist ) load ( f [ ] field , * documentmetadata ) error { * l = append ( * l , f ... ) return nil } 
func ( m * appoverride ) getnummemcachegbackends ( ) int32 { if m ! = nil && m . nummemcachegbackends ! = nil { return * m . nummemcachegbackends } return 0 } 
func ( m * appoverride ) getignoreshardlock ( ) bool { if m ! = nil && m . ignoreshardlock ! = nil { return * m . ignoreshardlock } return false } 
func ( m * appoverride ) getmemcachepoolhint ( ) string { if m ! = nil && m . memcachepoolhint ! = nil { return * m . memcachepoolhint } return " " } 
func namespace ( c context . context , namespace string ) ( context . context , error ) { if ! validnamespace . matchstring ( namespace ) { return nil , fmt . errorf ( " " , namespace , validnamespace ) } return internal . namespacedcontext ( c , namespace ) , nil } 
func ( cfg * typeconfig ) typeof ( name string ) string { if cfg . var ! = nil { if t : = cfg . var [ name ] ; t ! = " " { return t } } if cfg . func ! = nil { if t : = cfg . func [ name ] ; t ! = " " { return " " + t } } return " " } 
func ( typ * type ) dot ( cfg * typeconfig , name string ) string { if typ . field ! = nil { if t : = typ . field [ name ] ; t ! = " " { return t } } if typ . method ! = nil { if t : = typ . method [ name ] ; t ! = " " { return t } } for , e : = range typ . embed { etyp : = cfg . type [ e ] if etyp ! = nil { if t : = etyp . dot ( cfg , name ) ; t ! = " " { return t } } } return " " } 
func splitfunc ( s string ) ( in , out [ ] string ) { if ! strings . hasprefix ( s , " " ) { return nil , nil } i : = len ( " " ) nparen : = 0 for j : = i ; j < len ( s ) ; j ++ { switch s [ j ] { case ' ( ' : nparen ++ case ' ) ' : nparen -- if nparen < 0 { out : = strings . trimspace ( s [ j + 1 : ] ) if len ( out ) >= 2 && out [ 0 ] == ' ( ' && out [ len ( out ) - 1 ] == ' ) ' { out = out [ 1 : len ( out ) - 1 ] } return split ( s [ i : j ] ) , split ( out ) } } } return nil , nil } 
func joinfunc ( in , out [ ] string ) string { outs : = " " if len ( out ) == 1 { outs = " " + out [ 0 ] } else if len ( out ) > 1 { outs = " " + join ( out ) + " " } return " " + join ( in ) + " " + outs } 
func split ( s string ) [ ] string { out : = [ ] string { } i : = 0 nparen : = 0 for j : = 0 ; j < len ( s ) ; j ++ { switch s [ j ] { case ' ' : if i == j { i ++ } case ' ( ' : nparen ++ case ' ) ' : nparen -- if nparen < 0 { return nil } case ' , ' : if nparen == 0 { if i < j { out = append ( out , s [ i : j ] ) } i = j + 1 } } } if nparen ! = 0 { return nil } if i < len ( s ) { out = append ( out , s [ i : ] ) } return out } 
func enabled ( ctx context . context , api , capability string ) bool { req : = & pb . isenabledrequest { package : & api , capability : [ ] string { capability } , } res : = & pb . isenabledresponse { } if err : = internal . call ( ctx , " " , " " , req , res ) ; err ! = nil { log . warningf ( ctx , " " , err ) return false } switch * res . summarystatus { case pb . isenabledresponse enabled , pb . isenabledresponse scheduled future , pb . isenabledresponse scheduled now : return true case pb . isenabledresponse unknown : log . errorf ( ctx , " " , api , capability ) return false default : return false } } 
func ( l * propertylist ) load ( p [ ] property ) error { * l = append ( * l , p ... ) return nil } 
func validpropertyname ( name string ) bool { if name == " " { return false } for , s : = range strings . split ( name , " " ) { if s == " " { return false } first : = true for , c : = range s { if first { first = false if c ! = ' ' && ! unicode . isletter ( c ) { return false } } else { if c ! = ' ' && ! unicode . isletter ( c ) && ! unicode . isdigit ( c ) { return false } } } } return true } 
func getstructcodec ( t reflect . type ) ( * structcodec , error ) { structcodecsmutex . lock ( ) defer structcodecsmutex . unlock ( ) return getstructcodeclocked ( t ) } 
func loadstruct ( dst interface { } , p [ ] property ) error { x , err : = newstructpls ( dst ) if err ! = nil { return err } return x . load ( p ) } 
func savestruct ( src interface { } ) ( [ ] property , error ) { x , err : = newstructpls ( src ) if err ! = nil { return nil , err } return x . save ( ) } 
func servingurl ( c context . context , key appengine . blobkey , opts * servingurloptions ) ( * url . url , error ) { req : = & pb . imagesgeturlbaserequest { blobkey : ( * string ) ( & key ) , } if opts ! = nil && opts . secure { req . createsecureurl = & opts . secure } res : = & pb . imagesgeturlbaseresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } u : = * res . url if opts ! = nil && opts . size > 0 { u += fmt . sprintf ( " " , opts . size ) if opts . crop { u += " " } } return url . parse ( u ) } 
func deleteservingurl ( c context . context , key appengine . blobkey ) error { req : = & pb . imagesdeleteurlbaserequest { blobkey : ( * string ) ( & key ) , } res : = & pb . imagesdeleteurlbaseresponse { } return internal . call ( c , " " , " " , req , res ) } 
func currentoauth ( c context . context , scopes ... string ) ( * user , error ) { req : = & pb . getoauthuserrequest { } if len ( scopes ) ! = 1 | | scopes [ 0 ] ! = " " { req . scopes = scopes } res : = & pb . getoauthuserresponse { } err : = internal . call ( c , " " , " " , req , res ) if err ! = nil { return nil , err } return & user { email : * res . email , authdomain : * res . authdomain , admin : res . getisadmin ( ) , id : * res . userid , clientid : res . getclientid ( ) , } , nil } 
func oauthconsumerkey ( c context . context ) ( string , error ) { req : = & pb . checkoauthsignaturerequest { } res : = & pb . checkoauthsignatureresponse { } err : = internal . call ( c , " " , " " , req , res ) if err ! = nil { return " " , err } return * res . oauthconsumerkey , err } 
func appid ( fullappid string ) string { , dom , dis : = parsefullappid ( fullappid ) if dom ! = " " { return dom + " " + dis } return dis } 
func ( u * user ) string ( ) string { if u . authdomain ! = " " && strings . hassuffix ( u . email , " " + u . authdomain ) { return u . email [ : len ( u . email ) - len ( " " + u . authdomain ) ] } if u . federatedidentity ! = " " { return u . federatedidentity } return u . email } 
func loginurl ( c context . context , dest string ) ( string , error ) { return loginurlfederated ( c , dest , " " ) } 
func loginurlfederated ( c context . context , dest , identity string ) ( string , error ) { req : = & pb . createloginurlrequest { destinationurl : proto . string ( dest ) , } if identity ! = " " { req . federatedidentity = proto . string ( identity ) } res : = & pb . createloginurlresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return * res . loginurl , nil } 
func logouturl ( c context . context , dest string ) ( string , error ) { req : = & pb . createlogouturlrequest { destinationurl : proto . string ( dest ) , } res : = & pb . createlogouturlresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return * res . logouturl , nil } 
func mappackage ( s string ) string { if stutterpackage { s += " " + path . base ( s ) } return newpackagebase + s } 
func newclient ( host string , client * http . client ) ( * client , error ) { wrapclient : = new ( http . client ) * wrapclient = * client t : = client . transport if t == nil { t = http . defaulttransport } wrapclient . transport = & headeraddingroundtripper { t } url : = url . url { scheme : " " , host : host , path : " " , } if host == " " | | strings . hasprefix ( host , " " ) { url . scheme = " " } u : = url . string ( ) appid , err : = getappid ( wrapclient , u ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } return & client { hc : wrapclient , url : u , appid : appid , } , nil } 
func ( c * client ) newcontext ( parent context . context ) context . context { ctx : = internal . withcalloverride ( parent , c . call ) ctx = internal . withlogoverride ( ctx , c . logf ) ctx = internal . withappidoverride ( ctx , c . appid ) return ctx } 
func newremotecontext ( host string , client * http . client ) ( context . context , error ) { c , err : = newclient ( host , client ) if err ! = nil { return nil , err } return c . newcontext ( context . background ( ) ) , nil } 
func debugf ( ctx context . context , format string , args ... interface { } ) { internal . logf ( ctx , 0 , format , args ... ) } 
func guestbookkey ( ctx context . context ) * datastore . key { return datastore . newkey ( ctx , " " , " " , 0 , nil ) } 
func ( opt * retryoptions ) toretryparameters ( ) * pb . taskqueueretryparameters { params : = & pb . taskqueueretryparameters { } if opt . retrylimit > 0 { params . retrylimit = proto . int32 ( opt . retrylimit ) } if opt . agelimit > 0 { params . agelimitsec = proto . int64 ( int64 ( opt . agelimit . seconds ( ) ) ) } if opt . minbackoff > 0 { params . minbackoffsec = proto . float64 ( opt . minbackoff . seconds ( ) ) } if opt . maxbackoff > 0 { params . maxbackoffsec = proto . float64 ( opt . maxbackoff . seconds ( ) ) } if opt . maxdoublings > 0 | | ( opt . maxdoublings == 0 && opt . applyzeromaxdoublings ) { params . maxdoublings = proto . int32 ( opt . maxdoublings ) } return params } 
func newposttask ( path string , params url . values ) * task { h : = make ( http . header ) h . set ( " " , " " ) return & task { path : path , payload : [ ] byte ( params . encode ( ) ) , header : h , method : " " , } } 
func add ( c context . context , task * task , queuename string ) ( * task , error ) { req , err : = newaddreq ( c , task , queuename ) if err ! = nil { return nil , err } res : = & pb . taskqueueaddresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { apierr , ok : = err . ( * internal . apierror ) if ok && alreadyaddederrors [ pb . taskqueueserviceerror errorcode ( apierr . code ) ] { return nil , errtaskalreadyadded } return nil , err } resulttask : = * task resulttask . method = task . method ( ) if task . name == " " { resulttask . name = string ( res . chosentaskname ) } return & resulttask , nil } 
func delete ( c context . context , task * task , queuename string ) error { err : = deletemulti ( c , [ ] * task { task } , queuename ) if me , ok : = err . ( appengine . multierror ) ; ok { return me [ 0 ] } return err } 
func deletemulti ( c context . context , tasks [ ] * task , queuename string ) error { tasknames : = make ( [ ] [ ] byte , len ( tasks ) ) for i , t : = range tasks { tasknames [ i ] = [ ] byte ( t . name ) } if queuename == " " { queuename = " " } req : = & pb . taskqueuedeleterequest { queuename : [ ] byte ( queuename ) , taskname : tasknames , } res : = & pb . taskqueuedeleteresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } if a , b : = len ( req . taskname ) , len ( res . result ) ; a ! = b { return fmt . errorf ( " " , a , b ) } me , any : = make ( appengine . multierror , len ( res . result ) ) , false for i , ec : = range res . result { if ec ! = pb . taskqueueserviceerror ok { me [ i ] = & internal . apierror { service : " " , code : int32 ( ec ) , } any = true } } if any { return me } return nil } 
func lease ( c context . context , maxtasks int , queuename string , leasetime int ) ( [ ] * task , error ) { return lease ( c , maxtasks , queuename , leasetime , false , nil ) } 
func leasebytag ( c context . context , maxtasks int , queuename string , leasetime int , tag string ) ( [ ] * task , error ) { return lease ( c , maxtasks , queuename , leasetime , true , [ ] byte ( tag ) ) } 
func purge ( c context . context , queuename string ) error { if queuename == " " { queuename = " " } req : = & pb . taskqueuepurgequeuerequest { queuename : [ ] byte ( queuename ) , } res : = & pb . taskqueuepurgequeueresponse { } return internal . call ( c , " " , " " , req , res ) } 
func modifylease ( c context . context , task * task , queuename string , leasetime int ) error { if queuename == " " { queuename = " " } req : = & pb . taskqueuemodifytaskleaserequest { queuename : [ ] byte ( queuename ) , taskname : [ ] byte ( task . name ) , etausec : proto . int64 ( task . eta . unixnano ( ) / 1e3 ) , leaseseconds : proto . float64 ( float64 ( leasetime ) ) , } res : = & pb . taskqueuemodifytaskleaseresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } task . eta = time . unix ( 0 , * res . updatedetausec * 1e3 ) return nil } 
func queuestats ( c context . context , queuenames [ ] string ) ( [ ] queuestatistics , error ) { req : = & pb . taskqueuefetchqueuestatsrequest { queuename : make ( [ ] [ ] byte , len ( queuenames ) ) , } for i , q : = range queuenames { if q == " " { q = " " } req . queuename [ i ] = [ ] byte ( q ) } res : = & pb . taskqueuefetchqueuestatsresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } qs : = make ( [ ] queuestatistics , len ( res . queuestats ) ) for i , qsg : = range res . queuestats { qs [ i ] = queuestatistics { tasks : int ( * qsg . numtasks ) , } if eta : = * qsg . oldestetausec ; eta > - 1 { qs [ i ] . oldesteta = time . unix ( 0 , eta * 1e3 ) } if si : = qsg . scannerinfo ; si ! = nil { qs [ i ] . executed1minute = int ( * si . executedlastminute ) qs [ i ] . inflight = int ( si . getrequestsinflight ( ) ) qs [ i ] . enforcedrate = si . getenforcedrate ( ) } } return qs , nil } 
func istimeouterror ( err error ) bool { if err == context . deadlineexceeded { return true } if t , ok : = err . ( interface { istimeout ( ) bool } ) ; ok { return t . istimeout ( ) } return false } 
func filekey ( file string ) ( string , error ) { if ! internal . issecondgen ( ) | | internal . mainpath == " " { return file , nil } if filepath . dir ( file ) == internal . mainpath { return filepath . base ( file ) , nil } s : = string ( filepath . separator ) for , s : = range [ ] string { filepath . join ( " " , " " ) + s , s + " " + s , filepath . join ( build . default . gopath , " " ) + s } { if idx : = strings . index ( file , s ) ; idx > 0 { return file [ idx + len ( s ) : ] , nil } } m : = " " if idx : = strings . index ( file , m ) ; idx > 0 { file = file [ idx + len ( m ) : ] } else { return file , fmt . errorf ( " " , file ) } return modversionpat . replaceallstring ( file , " " ) , nil } 
func func ( key string , i interface { } ) * function { f : = & function { fv : reflect . valueof ( i ) } , file , , : = runtime . caller ( 1 ) fk , err : = filekey ( file ) if err ! = nil { stdlog . printf ( " " , err ) } f . key = fk + " " + key t : = f . fv . type ( ) if t . kind ( ) ! = reflect . func { f . err = errors . new ( " " ) return f } if t . numin ( ) == 0 | | ! iscontext ( t . in ( 0 ) ) { f . err = errfirstarg return f } for i : = 0 ; i < t . numin ( ) ; i ++ { if t . in ( i ) . kind ( ) == reflect . interface { continue } gob . register ( reflect . zero ( t . in ( i ) ) . interface ( ) ) } if old : = funcs [ f . key ] ; old ! = nil { old . err = fmt . errorf ( " " , key , file ) } funcs [ f . key ] = f return f } 
func ( g geopoint ) valid ( ) bool { return - 90 <= g . lat && g . lat <= 90 && - 180 <= g . lng && g . lng <= 180 } 
func withapicallfunc ( ctx context . context , f apicallfunc ) context . context { return internal . withcalloverride ( ctx , internal . calloverridefunc ( f ) ) } 
func apicall ( ctx context . context , service , method string , in , out proto . message ) error { return internal . call ( ctx , service , method , in , out ) } 
func modulehostname ( c context . context , module , version , instance string ) ( string , error ) { req : = & modpb . gethostnamerequest { } if module ! = " " { req . module = & module } if version ! = " " { req . version = & version } if instance ! = " " { req . instance = & instance } res : = & modpb . gethostnameresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return * res . hostname , nil } 
func accesstoken ( c context . context , scopes ... string ) ( token string , expiry time . time , err error ) { req : = & pb . getaccesstokenrequest { scope : scopes } res : = & pb . getaccesstokenresponse { } err = internal . call ( c , " " , " " , req , res ) if err ! = nil { return " " , time . time { } , err } return res . getaccesstoken ( ) , time . unix ( res . getexpirationtime ( ) , 0 ) , nil } 
func publiccertificates ( c context . context ) ( [ ] certificate , error ) { req : = & pb . getpubliccertificateforapprequest { } res : = & pb . getpubliccertificateforappresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } var cs [ ] certificate for , pc : = range res . publiccertificatelist { cs = append ( cs , certificate { keyname : pc . getkeyname ( ) , data : [ ] byte ( pc . getx509certificatepem ( ) ) , } ) } return cs , nil } 
func serviceaccount ( c context . context ) ( string , error ) { req : = & pb . getserviceaccountnamerequest { } res : = & pb . getserviceaccountnameresponse { } err : = internal . call ( c , " " , " " , req , res ) if err ! = nil { return " " , err } return res . getserviceaccountname ( ) , err } 
func signbytes ( c context . context , bytes [ ] byte ) ( keyname string , signature [ ] byte , err error ) { req : = & pb . signforapprequest { bytestosign : bytes } res : = & pb . signforappresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return " " , nil , err } return res . getkeyname ( ) , res . getsignaturebytes ( ) , nil } 
func ( r * reader ) fetch ( off int64 ) error { req : = & blobpb . fetchdatarequest { blobkey : proto . string ( string ( r . blobkey ) ) , startindex : proto . int64 ( off ) , endindex : proto . int64 ( off + readbuffersize - 1 ) , } res : = & blobpb . fetchdataresponse { } if err : = internal . call ( r . c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . data ) == 0 { return io . eof } r . buf , r . r , r . off = res . data , 0 , off return nil } 
func ( r * reader ) seek ( off int64 ) ( int64 , error ) { delta : = off - r . off if delta >= 0 && delta < int64 ( len ( r . buf ) ) { r . r = int ( delta ) return off , nil } r . buf , r . r , r . off = nil , 0 , off return off , nil } 
func keytoproto ( defaultappid string , k * key ) * pb . reference { appid : = k . appid if appid == " " { appid = defaultappid } n : = 0 for i : = k ; i ! = nil ; i = i . parent { n ++ } e : = make ( [ ] * pb . path element , n ) for i : = k ; i ! = nil ; i = i . parent { n -- e [ n ] = & pb . path element { type : & i . kind , } if i . stringid ! = " " { e [ n ] . name = & i . stringid } else if i . intid ! = 0 { e [ n ] . id = & i . intid } } var namespace * string if k . namespace ! = " " { namespace = proto . string ( k . namespace ) } return & pb . reference { app : proto . string ( appid ) , namespace : namespace , path : & pb . path { element : e , } , } } 
func multikeytoproto ( appid string , key [ ] * key ) [ ] * pb . reference { ret : = make ( [ ] * pb . reference , len ( key ) ) for i , k : = range key { ret [ i ] = keytoproto ( appid , k ) } return ret } 
func multivalid ( key [ ] * key ) error { invalid : = false for , k : = range key { if ! k . valid ( ) { invalid = true break } } if ! invalid { return nil } err : = make ( appengine . multierror , len ( key ) ) for i , k : = range key { if ! k . valid ( ) { err [ i ] = errinvalidkey } } return err } 
func referencevaluetokey ( r * pb . propertyvalue referencevalue ) ( k * key , err error ) { appid : = r . getapp ( ) namespace : = r . getnamespace ( ) for , e : = range r . pathelement { k = & key { kind : e . gettype ( ) , stringid : e . getname ( ) , intid : e . getid ( ) , parent : k , appid : appid , namespace : namespace , } if ! k . valid ( ) { return nil , errinvalidkey } } return } 
func keytoreferencevalue ( defaultappid string , k * key ) * pb . propertyvalue referencevalue { ref : = keytoproto ( defaultappid , k ) pe : = make ( [ ] * pb . propertyvalue referencevalue pathelement , len ( ref . path . element ) ) for i , e : = range ref . path . element { pe [ i ] = & pb . propertyvalue referencevalue pathelement { type : e . type , id : e . id , name : e . name , } } return & pb . propertyvalue referencevalue { app : ref . app , namespace : ref . namespace , pathelement : pe , } } 
func checkmultiarg ( v reflect . value ) ( m multiargtype , elemtype reflect . type ) { if v . kind ( ) ! = reflect . slice { return multiargtypeinvalid , nil } if v . type ( ) == typeofpropertylist { return multiargtypeinvalid , nil } elemtype = v . type ( ) . elem ( ) if reflect . ptrto ( elemtype ) . implements ( typeofpropertyloadsaver ) { return multiargtypepropertyloadsaver , elemtype } switch elemtype . kind ( ) { case reflect . struct : return multiargtypestruct , elemtype case reflect . interface : return multiargtypeinterface , elemtype case reflect . ptr : elemtype = elemtype . elem ( ) if elemtype . kind ( ) == reflect . struct { return multiargtypestructptr , elemtype } } return multiargtypeinvalid , nil } 
func put ( c context . context , key * key , src interface { } ) ( * key , error ) { k , err : = putmulti ( c , [ ] * key { key } , [ ] interface { } { src } ) if err ! = nil { if me , ok : = err . ( appengine . multierror ) ; ok { return nil , me [ 0 ] } return nil , err } return k [ 0 ] , nil } 
func delete ( c context . context , key * key ) error { err : = deletemulti ( c , [ ] * key { key } ) if me , ok : = err . ( appengine . multierror ) ; ok { return me [ 0 ] } return err } 
func deletemulti ( c context . context , key [ ] * key ) error { if len ( key ) == 0 { return nil } if err : = multivalid ( key ) ; err ! = nil { return err } req : = & pb . deleterequest { key : multikeytoproto ( internal . fullyqualifiedappid ( c ) , key ) , } res : = & pb . deleteresponse { } return internal . call ( c , " " , " " , req , res ) } 
func deploy ( ) error { vlogf ( " " , flag . args ( ) ) cmd : = exec . command ( flag . arg ( 0 ) , flag . args ( ) [ 1 : ] ... ) cmd . stdin , cmd . stdout , cmd . stderr = os . stdin , os . stdout , os . stderr if err : = cmd . run ( ) ; err ! = nil { return fmt . errorf ( " " , strings . join ( flag . args ( ) , " " ) , err ) } return nil } 
func ( qr * result ) next ( ) ( * record , error ) { if qr . err ! = nil { return nil , qr . err } if len ( qr . logs ) > 0 { lr : = qr . logs [ 0 ] qr . logs = qr . logs [ 1 : ] return lr , nil } if qr . request . offset == nil && qr . resultsseen { return nil , done } if err : = qr . run ( ) ; err ! = nil { return nil , err } return qr . next ( ) } 
func prototoapplogs ( loglines [ ] * pb . logline ) [ ] applog { applogs : = make ( [ ] applog , len ( loglines ) ) for i , line : = range loglines { applogs [ i ] = applog { time : time . unix ( 0 , * line . time * 1e3 ) , level : int ( * line . level ) , message : * line . logmessage , } } return applogs } 
func ( params * query ) run ( c context . context ) * result { req , err : = makerequest ( params , internal . fullyqualifiedappid ( c ) , appengine . versionid ( c ) ) return & result { context : c , request : req , err : err , } } 
func ( r * result ) run ( ) error { res : = & pb . logreadresponse { } if err : = internal . call ( r . context , " " , " " , r . request , res ) ; err ! = nil { return err } r . logs = make ( [ ] * record , len ( res . log ) ) r . request . offset = res . offset r . resultsseen = true for i , log : = range res . log { r . logs [ i ] = prototorecord ( log ) } return nil } 
func current ( c context . context ) * user { h : = internal . incomingheaders ( c ) u : = & user { email : h . get ( " " ) , authdomain : h . get ( " " ) , id : h . get ( " " ) , admin : h . get ( " " ) == " " , federatedidentity : h . get ( " " ) , federatedprovider : h . get ( " " ) , } if u . email == " " && u . federatedidentity == " " { return nil } return u } 
func isadmin ( c context . context ) bool { h : = internal . incomingheaders ( c ) return h . get ( " " ) == " " } 
func iserrfieldmismatch ( err error ) bool { , ok : = err . ( * datastore . errfieldmismatch ) return ok } 
func stat ( c context . context , blobkey appengine . blobkey ) ( * blobinfo , error ) { c , = appengine . namespace ( c , " " ) dskey : = datastore . newkey ( c , blobinfokind , string ( blobkey ) , 0 , nil ) bi : = & blobinfo { blobkey : blobkey , } if err : = datastore . get ( c , dskey , bi ) ; err ! = nil && ! iserrfieldmismatch ( err ) { return nil , err } return bi , nil } 
func send ( response http . responsewriter , blobkey appengine . blobkey ) { hdr : = response . header ( ) hdr . set ( " " , string ( blobkey ) ) if hdr . get ( " " ) == " " { hdr . set ( " " , " " ) } } 
func uploadurl ( c context . context , successpath string , opts * uploadurloptions ) ( * url . url , error ) { req : = & blobpb . createuploadurlrequest { successpath : proto . string ( successpath ) , } if opts ! = nil { if n : = opts . maxuploadbytes ; n ! = 0 { req . maxuploadsizebytes = & n } if n : = opts . maxuploadbytesperblob ; n ! = 0 { req . maxuploadsizeperblobbytes = & n } if s : = opts . storagebucket ; s ! = " " { req . gsbucketname = & s } } res : = & blobpb . createuploadurlresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } return url . parse ( * res . url ) } 
func delete ( c context . context , blobkey appengine . blobkey ) error { return deletemulti ( c , [ ] appengine . blobkey { blobkey } ) } 
func deletemulti ( c context . context , blobkey [ ] appengine . blobkey ) error { s : = make ( [ ] string , len ( blobkey ) ) for i , b : = range blobkey { s [ i ] = string ( b ) } req : = & blobpb . deleteblobrequest { blobkey : s , } res : = & basepb . voidproto { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } return nil } 
func newreader ( c context . context , blobkey appengine . blobkey ) reader { return openblob ( c , blobkey ) } 
func blobkeyforfile ( c context . context , filename string ) ( appengine . blobkey , error ) { req : = & blobpb . createencodedgooglestoragekeyrequest { filename : & filename , } res : = & blobpb . createencodedgooglestoragekeyresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return appengine . blobkey ( * res . blobkey ) , nil } 
func handle ( f func ( c context . context , m * message ) ) { http . handlefunc ( " " , func ( http . responsewriter , r * http . request ) { f ( appengine . newcontext ( r ) , & message { sender : r . formvalue ( " " ) , to : [ ] string { r . formvalue ( " " ) } , body : r . formvalue ( " " ) , } ) } ) } 
func ( m * message ) send ( c context . context ) error { req : = & pb . xmppmessagerequest { jid : m . to , body : & m . body , rawxml : & m . rawxml , } if m . type ! = " " && m . type ! = " " { req . type = & m . type } if m . sender ! = " " { req . fromjid = & m . sender } res : = & pb . xmppmessageresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . status ) ! = len ( req . jid ) { return fmt . errorf ( " " , len ( req . jid ) , len ( res . status ) ) } me , any : = make ( appengine . multierror , len ( req . jid ) ) , false for i , st : = range res . status { if st ! = pb . xmppmessageresponse no error { me [ i ] = errors . new ( st . string ( ) ) any = true } } if any { return me } return nil } 
func invite ( c context . context , to , from string ) error { req : = & pb . xmppinviterequest { jid : & to , } if from ! = " " { req . fromjid = & from } res : = & pb . xmppinviteresponse { } return internal . call ( c , " " , " " , req , res ) } 
func ( p * presence ) send ( c context . context ) error { req : = & pb . xmppsendpresencerequest { jid : & p . to , } if p . state ! = " " { req . show = & p . state } if p . type ! = " " { req . type = & p . type } if p . sender ! = " " { req . fromjid = & p . sender } if p . status ! = " " { req . status = & p . status } res : = & pb . xmppsendpresenceresponse { } return internal . call ( c , " " , " " , req , res ) } 
func getpresence ( c context . context , to string , from string ) ( string , error ) { req : = & pb . presencerequest { jid : & to , } if from ! = " " { req . fromjid = & from } res : = & pb . presenceresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } if ! * res . isavailable | | res . presence == nil { return " " , errpresenceunavailable } presence , ok : = presencemap [ * res . presence ] if ok { return presence , nil } return " " , fmt . errorf ( " " , * res . presence ) } 
func getpresencemulti ( c context . context , to [ ] string , from string ) ( [ ] string , error ) { req : = & pb . bulkpresencerequest { jid : to , } if from ! = " " { req . fromjid = & from } res : = & pb . bulkpresenceresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } presences : = make ( [ ] string , 0 , len ( res . presenceresponse ) ) errs : = appengine . multierror { } addresult : = func ( presence string , err error ) { presences = append ( presences , presence ) errs = append ( errs , err ) } anyerr : = false for , subres : = range res . presenceresponse { if ! subres . getvalid ( ) { anyerr = true addresult ( " " , errinvalidjid ) continue } if ! * subres . isavailable | | subres . presence == nil { anyerr = true addresult ( " " , errpresenceunavailable ) continue } presence , ok : = presencemap [ * subres . presence ] if ok { addresult ( presence , nil ) } else { anyerr = true addresult ( " " , fmt . errorf ( " " , * subres . presence ) ) } } if anyerr { return presences , errs } return presences , nil } 
func dial ( ctx context . context , protocol , addr string ) ( * conn , error ) { conn , err : = net . dial ( protocol , addr ) if err ! = nil { return nil , err } return & conn { conn } , nil } 
func dialtimeout ( ctx context . context , protocol , addr string , timeout time . duration ) ( * conn , error ) { conn , err : = net . dialtimeout ( protocol , addr , timeout ) if err ! = nil { return nil , err } return & conn { conn } , nil } 
func lookupip ( ctx context . context , host string ) ( addrs [ ] net . ip , err error ) { return net . lookupip ( host ) } 
func newstructfls ( p interface { } ) ( fieldloadsaver , error ) { v : = reflect . valueof ( p ) if v . kind ( ) ! = reflect . ptr | | v . isnil ( ) | | v . elem ( ) . kind ( ) ! = reflect . struct { return nil , errinvaliddocumenttype } codec , err : = loadcodec ( v . elem ( ) . type ( ) ) if err ! = nil { return nil , err } return structfls { v . elem ( ) , codec } , nil } 
func savestruct ( src interface { } ) ( [ ] field , error ) { f , , err : = savestructwithmeta ( src ) return f , err } 
func namespaces ( ctx context . context ) ( [ ] string , error ) { q : = newquery ( namespacekind ) . keysonly ( ) keys , err : = q . getall ( ctx , nil ) if err ! = nil { return nil , err } return keynames ( keys ) , nil } 
func kinds ( ctx context . context ) ( [ ] string , error ) { q : = newquery ( kindkind ) . keysonly ( ) keys , err : = q . getall ( ctx , nil ) if err ! = nil { return nil , err } return keynames ( keys ) , nil } 
func keynames ( keys [ ] * key ) [ ] string { n : = make ( [ ] string , 0 , len ( keys ) ) for , k : = range keys { n = append ( n , k . stringid ( ) ) } return n } 
func kindproperties ( ctx context . context , kind string ) ( map [ string ] [ ] string , error ) { kindkey : = newkey ( ctx , kindkind , kind , 0 , nil ) q : = newquery ( propertykind ) . ancestor ( kindkey ) propmap : = map [ string ] [ ] string { } props : = [ ] struct { repr [ ] string ' datastore : " property representation " ' } { } keys , err : = q . getall ( ctx , & props ) if err ! = nil { return nil , err } for i , p : = range props { propmap [ keys [ i ] . stringid ( ) ] = p . repr } return propmap , nil } 
func mustgetmetadata ( key string ) [ ] byte { b , err : = getmetadata ( key ) if err ! = nil { panic ( fmt . sprintf ( " " , key , err ) ) } return b } 
func runintransaction ( c context . context , f func ( tc context . context ) error , opts * transactionoptions ) error { xg : = false if opts ! = nil { xg = opts . xg } readonly : = false if opts ! = nil { readonly = opts . readonly } attempts : = 3 if opts ! = nil && opts . attempts > 0 { attempts = opts . attempts } var t * pb . transaction var err error for i : = 0 ; i < attempts ; i ++ { if t , err = internal . runtransactiononce ( c , f , xg , readonly , t ) ; err ! = internal . errconcurrenttransaction { return err } } return errconcurrenttransaction } 
func imports ( f * ast . file , path string ) bool { return importspec ( f , path ) ! = nil } 
func importspec ( f * ast . file , path string ) * ast . importspec { for , s : = range f . imports { if importpath ( s ) == path { return s } } return nil } 
func declimports ( gen * ast . gendecl , path string ) bool { if gen . tok ! = token . import { return false } for , spec : = range gen . specs { impspec : = spec . ( * ast . importspec ) if importpath ( impspec ) == path { return true } } return false } 
func ispkgdot ( t ast . expr , pkg , name string ) bool { sel , ok : = t . ( * ast . selectorexpr ) return ok && istopname ( sel . x , pkg ) && sel . sel . string ( ) == name } 
func isptrpkgdot ( t ast . expr , pkg , name string ) bool { ptr , ok : = t . ( * ast . starexpr ) return ok && ispkgdot ( ptr . x , pkg , name ) } 
func istopname ( n ast . expr , name string ) bool { id , ok : = n . ( * ast . ident ) return ok && id . name == name && id . obj == nil } 
func isname ( n ast . expr , name string ) bool { id , ok : = n . ( * ast . ident ) return ok && id . string ( ) == name } 
func iscall ( t ast . expr , pkg , name string ) bool { call , ok : = t . ( * ast . callexpr ) return ok && ispkgdot ( call . fun , pkg , name ) } 
func isident ( n interface { } ) * ast . ident { id , : = n . ( * ast . ident ) return id } 
func refersto ( n ast . node , x * ast . ident ) bool { id , ok : = n . ( * ast . ident ) return ok && id . obj == x . obj && id . name == x . name } 
func isemptystring ( n ast . expr ) bool { lit , ok : = n . ( * ast . basiclit ) return ok && lit . kind == token . string && len ( lit . value ) == 2 } 
func countuses ( x * ast . ident , scope [ ] ast . stmt ) int { count : = 0 ff : = func ( n interface { } ) { if n , ok : = n . ( ast . node ) ; ok && refersto ( n , x ) { count ++ } } for , n : = range scope { walk ( n , ff ) } return count } 
func rewriteuses ( x * ast . ident , f , fnot func ( token . pos ) ast . expr , scope [ ] ast . stmt ) { var lastf ast . expr ff : = func ( n interface { } ) { ptr , ok : = n . ( * ast . expr ) if ! ok { return } nn : = * ptr not , ok : = nn . ( * ast . unaryexpr ) if ok && not . op == token . not && not . x == lastf { * ptr = fnot ( nn . pos ( ) ) return } if refersto ( nn , x ) { lastf = f ( nn . pos ( ) ) * ptr = lastf } } for , n : = range scope { walk ( n , ff ) } } 
func assignsto ( x * ast . ident , scope [ ] ast . stmt ) bool { assigned : = false ff : = func ( n interface { } ) { if assigned { return } switch n : = n . ( type ) { case * ast . unaryexpr : if n . op == token . and && refersto ( n . x , x ) { assigned = true return } case * ast . assignstmt : for , l : = range n . lhs { if refersto ( l , x ) { assigned = true return } } } } for , n : = range scope { if assigned { break } walk ( n , ff ) } return assigned } 
func newpkgdot ( pos token . pos , pkg , name string ) ast . expr { return & ast . selectorexpr { x : & ast . ident { namepos : pos , name : pkg , } , sel : & ast . ident { namepos : pos , name : name , } , } } 
func matchlen ( x , y string ) int { i : = 0 for i < len ( x ) && i < len ( y ) && x [ i ] == y [ i ] { i ++ } return i } 
func deleteimport ( f * ast . file , path string ) ( deleted bool ) { oldimport : = importspec ( f , path ) for i , decl : = range f . decls { gen , ok : = decl . ( * ast . gendecl ) if ! ok | | gen . tok ! = token . import { continue } for j , spec : = range gen . specs { impspec : = spec . ( * ast . importspec ) if oldimport ! = impspec { continue } deleted = true copy ( gen . specs [ j : ] , gen . specs [ j + 1 : ] ) gen . specs = gen . specs [ : len ( gen . specs ) - 1 ] if len ( gen . specs ) == 0 { copy ( f . decls [ i : ] , f . decls [ i + 1 : ] ) f . decls = f . decls [ : len ( f . decls ) - 1 ] } else if len ( gen . specs ) == 1 { gen . lparen = token . nopos } if j > 0 { gen . specs [ j - 1 ] . ( * ast . importspec ) . endpos = impspec . end ( ) } break } } for i , imp : = range f . imports { if imp == oldimport { copy ( f . imports [ i : ] , f . imports [ i + 1 : ] ) f . imports = f . imports [ : len ( f . imports ) - 1 ] break } } return } 
func rewriteimport ( f * ast . file , oldpath , newpath string ) ( rewrote bool ) { for , imp : = range f . imports { if importpath ( imp ) == oldpath { rewrote = true imp . endpos = imp . end ( ) imp . path . value = strconv . quote ( newpath ) } } return } 
func fromcontext ( ctx netcontext . context ) * context { c , : = ctx . value ( & contextkey ) . ( * context ) return c } 
func defaultticket ( ) string { defaultticketonce . do ( func ( ) { if isdevappserver ( ) { defaultticket = " " + defaultticketsuffix return } appid : = partitionlessappid ( ) escappid : = strings . replace ( strings . replace ( appid , " " , " " , - 1 ) , " " , " " , - 1 ) majversion : = versionid ( nil ) if i : = strings . index ( majversion , " " ) ; i > 0 { majversion = majversion [ : i ] } defaultticket = fmt . sprintf ( " " , escappid , modulename ( nil ) , majversion , instanceid ( ) ) } ) return defaultticket } 
func ( c * context ) flushlog ( force bool ) ( flushed bool ) { c . pendinglogs . lock ( ) n , rem : = 0 , 30 < < 20 for ; n < len ( c . pendinglogs . lines ) ; n ++ { ll : = c . pendinglogs . lines [ n ] nb : = proto . size ( ll ) + 3 if nb > rem { break } rem - = nb } lines : = c . pendinglogs . lines [ : n ] c . pendinglogs . lines = c . pendinglogs . lines [ n : ] c . pendinglogs . unlock ( ) if len ( lines ) == 0 && ! force { return false } rescuelogs : = false defer func ( ) { if rescuelogs { c . pendinglogs . lock ( ) c . pendinglogs . lines = append ( lines , c . pendinglogs . lines ... ) c . pendinglogs . unlock ( ) } } ( ) buf , err : = proto . marshal ( & logpb . userapploggroup { logline : lines , } ) if err ! = nil { log . printf ( " " , err ) rescuelogs = true return false } req : = & logpb . flushrequest { logs : buf , } res : = & basepb . voidproto { } c . pendinglogs . lock ( ) c . pendinglogs . flushes ++ c . pendinglogs . unlock ( ) if err : = call ( tocontext ( c ) , " " , " " , req , res ) ; err ! = nil { log . printf ( " " , err ) rescuelogs = true return false } return true } 
func dial ( ctx context . context , protocol , addr string ) ( * conn , error ) { return dialtimeout ( ctx , protocol , addr , 0 ) } 
func lookupip ( ctx context . context , host string ) ( addrs [ ] net . ip , err error ) { packedaddrs , , err : = resolve ( ctx , ipfamilies , host ) if err ! = nil { return nil , fmt . errorf ( " " , host , err ) } addrs = make ( [ ] net . ip , len ( packedaddrs ) ) for i , pa : = range packedaddrs { addrs [ i ] = net . ip ( pa ) } return addrs , nil } 
func withdeadline ( parent context . context , deadline time . time ) ( context . context , context . cancelfunc ) { if deadline . iszero ( ) { return parent , func ( ) { } } return context . withdeadline ( parent , deadline ) } 
func ( cn * conn ) keepalive ( ) error { req : = & pb . getsocketnamerequest { socketdescriptor : & cn . desc , } res : = & pb . getsocketnamereply { } return internal . call ( cn . ctx , " " , " " , req , res ) } 
func registertransactionsetter ( f interface { } ) { v : = reflect . valueof ( f ) transactionsetters [ v . type ( ) . in ( 0 ) ] = v } 
func applytransaction ( pb proto . message , t * pb . transaction ) { v : = reflect . valueof ( pb ) if f , ok : = transactionsetters [ v . type ( ) ] ; ok { f . call ( [ ] reflect . value { v , reflect . valueof ( t ) } ) } } 
func analyze ( tags [ ] string ) ( * app , error ) { ctxt : = buildcontext ( tags ) hasmain , appfiles , err : = checkmain ( ctxt ) if err ! = nil { return nil , err } gopath : = filepath . splitlist ( ctxt . gopath ) im , err : = imports ( ctxt , * rootdir , gopath ) return & app { hasmain : hasmain , appfiles : appfiles , imports : im , } , err } 
func buildcontext ( tags [ ] string ) * build . context { return & build . context { goarch : build . default . goarch , goos : build . default . goos , goroot : build . default . goroot , gopath : build . default . gopath , compiler : build . default . compiler , buildtags : append ( build . default . buildtags , tags ... ) , } } 
func ( s * app ) bundle ( tarfile string ) ( err error ) { var out io . writer if tarfile == " " { out = os . stdout } else { f , err : = os . create ( tarfile ) if err ! = nil { return err } defer func ( ) { if cerr : = f . close ( ) ; err == nil { err = cerr } } ( ) out = f } tw : = tar . newwriter ( out ) for srcdir , importname : = range s . imports { dstdir : = " " + importname if err = copytree ( tw , dstdir , srcdir ) ; err ! = nil { return fmt . errorf ( " " , srcdir , dstdir , err ) } } if err : = copytree ( tw , " " , * rootdir ) ; err ! = nil { return fmt . errorf ( " " , err ) } if ! s . hasmain { if err : = synthesizemain ( tw , s . appfiles ) ; err ! = nil { return fmt . errorf ( " " , err ) } } if err : = tw . close ( ) ; err ! = nil { return fmt . errorf ( " " , tarfile , err ) } return nil } 
func synthesizemain ( tw * tar . writer , appfiles [ ] string ) error { appmap : = make ( map [ string ] bool ) for , f : = range appfiles { appmap [ f ] = true } var f string for i : = 0 ; i < 100 ; i ++ { f = fmt . sprintf ( " " , i ) if ! appmap [ filepath . join ( * rootdir , f ) ] { break } } if appmap [ filepath . join ( * rootdir , f ) ] { return fmt . errorf ( " " , f ) } hdr : = & tar . header { name : f , mode : 0644 , size : int64 ( len ( newmain ) ) , } if err : = tw . writeheader ( hdr ) ; err ! = nil { return fmt . errorf ( " " , f , err ) } if , err : = tw . write ( [ ] byte ( newmain ) ) ; err ! = nil { return fmt . errorf ( " " , f , err ) } return nil } 
func imports ( ctxt * build . context , srcdir string , gopath [ ] string ) ( map [ string ] string , error ) { pkg , err : = ctxt . importdir ( srcdir , 0 ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } result : = make ( map [ string ] string ) for , v : = range pkg . imports { if ! strings . contains ( v , " " ) { continue } src , err : = findingopath ( v , gopath ) if err ! = nil { return nil , fmt . errorf ( " " , v , gopath , err ) } result [ src ] = v im , err : = imports ( ctxt , src , gopath ) if err ! = nil { return nil , fmt . errorf ( " " , src , err ) } for k , v : = range im { result [ k ] = v } } return result , nil } 
func findingopath ( dir string , gopath [ ] string ) ( string , error ) { for , v : = range gopath { dst : = filepath . join ( v , " " , dir ) if , err : = os . stat ( dst ) ; err == nil { return dst , nil } } return " " , fmt . errorf ( " " , dir , gopath ) } 
func copytree ( tw * tar . writer , dstdir , srcdir string ) error { entries , err : = ioutil . readdir ( srcdir ) if err ! = nil { return fmt . errorf ( " " , srcdir , err ) } for , entry : = range entries { n : = entry . name ( ) if skipfiles [ n ] { continue } s : = filepath . join ( srcdir , n ) d : = filepath . join ( dstdir , n ) if entry . isdir ( ) { if err : = copytree ( tw , d , s ) ; err ! = nil { return fmt . errorf ( " " , s , d , err ) } continue } if err : = copyfile ( tw , d , s ) ; err ! = nil { return fmt . errorf ( " " , s , d , err ) } } return nil } 
func copyfile ( tw * tar . writer , dst , src string ) error { s , err : = os . open ( src ) if err ! = nil { return fmt . errorf ( " " , src , err ) } defer s . close ( ) fi , err : = s . stat ( ) if err ! = nil { return fmt . errorf ( " " , src , err ) } hdr , err : = tar . fileinfoheader ( fi , dst ) if err ! = nil { return fmt . errorf ( " " , dst , err ) } hdr . name = dst if err : = tw . writeheader ( hdr ) ; err ! = nil { return fmt . errorf ( " " , dst , err ) } , err = io . copy ( tw , s ) if err ! = nil { return fmt . errorf ( " " , src , dst , err ) } return nil } 
func checkmain ( ctxt * build . context ) ( bool , [ ] string , error ) { pkg , err : = ctxt . importdir ( * rootdir , 0 ) if err ! = nil { return false , nil , fmt . errorf ( " " , err ) } if ! pkg . iscommand ( ) { errorf ( " " " \n " , pkg . name ) } var hasmain bool var appfiles [ ] string for , f : = range pkg . gofiles { n : = filepath . join ( * rootdir , f ) appfiles = append ( appfiles , n ) if hasmain , err = readfile ( n ) ; err ! = nil { return false , nil , fmt . errorf ( " " , n , err ) } } return hasmain , appfiles , nil } 
func ismain ( f * ast . funcdecl ) bool { ft : = f . type return f . name . name == " " && f . recv == nil && ft . params . numfields ( ) == 0 && ft . results . numfields ( ) == 0 } 
func readfile ( filename string ) ( hasmain bool , err error ) { var src [ ] byte src , err = ioutil . readfile ( filename ) if err ! = nil { return } fset : = token . newfileset ( ) file , err : = parser . parsefile ( fset , filename , src , 0 ) for , decl : = range file . decls { funcdecl , ok : = decl . ( * ast . funcdecl ) if ! ok { continue } if ! ismain ( funcdecl ) { continue } hasmain = true break } return } 
func initfield ( val reflect . value , index [ ] int ) reflect . value { for , i : = range index [ : len ( index ) - 1 ] { val = val . field ( i ) if val . kind ( ) == reflect . ptr { if val . isnil ( ) { val . set ( reflect . new ( val . type ( ) . elem ( ) ) ) } val = val . elem ( ) } } return val . field ( index [ len ( index ) - 1 ] ) } 
func loadentity ( dst interface { } , src * pb . entityproto ) ( err error ) { ent , err : = prototoentity ( src ) if err ! = nil { return err } if e , ok : = dst . ( propertyloadsaver ) ; ok { return e . load ( ent . properties ) } return loadstruct ( dst , ent . properties ) } 
func validindexnameordocid ( s string ) bool { if strings . hasprefix ( s , " " ) { return false } for , c : = range s { if c < 0x21 | | 0x7f <= c { return false } } return true } 
func open ( name string ) ( * index , error ) { if ! validindexnameordocid ( name ) { return nil , fmt . errorf ( " " , name ) } return & index { spec : pb . indexspec { name : & name , } , } , nil } 
func ( x * index ) put ( c context . context , id string , src interface { } ) ( string , error ) { ids , err : = x . putmulti ( c , [ ] string { id } , [ ] interface { } { src } ) if err ! = nil { return " " , err } return ids [ 0 ] , nil } 
func ( x * index ) get ( c context . context , id string , dst interface { } ) error { if id == " " | | ! validindexnameordocid ( id ) { return fmt . errorf ( " " , id ) } req : = & pb . listdocumentsrequest { params : & pb . listdocumentsparams { indexspec : & x . spec , startdocid : proto . string ( id ) , limit : proto . int32 ( 1 ) , } , } res : = & pb . listdocumentsresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } if res . status == nil | | res . status . getcode ( ) ! = pb . searchserviceerror ok { return fmt . errorf ( " " , res . status . getcode ( ) , res . status . geterrordetail ( ) ) } if len ( res . document ) ! = 1 | | res . document [ 0 ] . getid ( ) ! = id { return errnosuchdocument } return loaddoc ( dst , res . document [ 0 ] , nil ) } 
func ( x * index ) delete ( c context . context , id string ) error { return x . deletemulti ( c , [ ] string { id } ) } 
func ( x * index ) deletemulti ( c context . context , ids [ ] string ) error { if len ( ids ) > maxdocumentsperputdelete { return errtoomanydocuments } req : = & pb . deletedocumentrequest { params : & pb . deletedocumentparams { docid : ids , indexspec : & x . spec , } , } res : = & pb . deletedocumentresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . status ) ! = len ( ids ) { return fmt . errorf ( " " , len ( res . status ) , len ( ids ) ) } multierr , haserr : = make ( appengine . multierror , len ( ids ) ) , false for i , s : = range res . status { if s . getcode ( ) ! = pb . searchserviceerror ok { multierr [ i ] = fmt . errorf ( " " , s . getcode ( ) , s . geterrordetail ( ) ) haserr = true } } if haserr { return multierr } return nil } 
func ( x * index ) search ( c context . context , query string , opts * searchoptions ) * iterator { t : = & iterator { c : c , index : x , searchquery : query , more : moresearch , } if opts ! = nil { if opts . cursor ! = " " { if opts . offset ! = 0 { return erriter ( " " ) } t . searchcursor = proto . string ( string ( opts . cursor ) ) } t . limit = opts . limit t . fields = opts . fields t . idsonly = opts . idsonly t . sort = opts . sort t . exprs = opts . expressions t . refinements = opts . refinements t . facetopts = opts . facets t . searchoffset = opts . offset t . countaccuracy = opts . countaccuracy } return t } 
func ( t * iterator ) fetchmore ( ) { if t . err == nil && len ( t . listres ) + len ( t . searchres ) == 0 && t . more ! = nil { t . err = t . more ( t ) } } 
func ( t * iterator ) next ( dst interface { } ) ( string , error ) { t . fetchmore ( ) if t . err ! = nil { return " " , t . err } var doc * pb . document var exprs [ ] * pb . field switch { case len ( t . listres ) ! = 0 : doc = t . listres [ 0 ] t . listres = t . listres [ 1 : ] case len ( t . searchres ) ! = 0 : doc = t . searchres [ 0 ] . document exprs = t . searchres [ 0 ] . expression t . searchcursor = t . searchres [ 0 ] . cursor t . searchres = t . searchres [ 1 : ] default : return " " , done } if doc == nil { return " " , errors . new ( " " ) } if ! t . idsonly && dst ! = nil { if err : = loaddoc ( dst , doc , exprs ) ; err ! = nil { return " " , err } } return doc . getid ( ) , nil } 
func ( t * iterator ) cursor ( ) cursor { if t . searchcursor == nil { return " " } return cursor ( * t . searchcursor ) } 
func ( t * iterator ) facets ( ) ( [ ] [ ] facetresult , error ) { t . fetchmore ( ) if t . err ! = nil && t . err ! = done { return nil , t . err } var facets [ ] [ ] facetresult for , f : = range t . facetres { fres : = make ( [ ] facetresult , 0 , len ( f . value ) ) for , v : = range f . value { ref : = v . refinement facet : = facetresult { facet : facet { name : ref . getname ( ) } , count : int ( v . getcount ( ) ) , } if ref . value ! = nil { facet . value = atom ( * ref . value ) } else { facet . value = prototorange ( ref . range ) } fres = append ( fres , facet ) } facets = append ( facets , fres ) } return facets , nil } 
func savedoc ( src interface { } ) ( * pb . document , error ) { var err error var fields [ ] field var meta * documentmetadata switch x : = src . ( type ) { case fieldloadsaver : fields , meta , err = x . save ( ) default : fields , meta , err = savestructwithmeta ( src ) } if err ! = nil { return nil , err } fieldsproto , err : = fieldstoproto ( fields ) if err ! = nil { return nil , err } d : = & pb . document { field : fieldsproto , orderid : proto . int32 ( int32 ( time . since ( orderidepoch ) . seconds ( ) ) ) , orderidsource : pb . document defaulted . enum ( ) , } if meta ! = nil { if meta . rank ! = 0 { if ! validdocrank ( meta . rank ) { return nil , fmt . errorf ( " " , meta . rank ) } * d . orderid = int32 ( meta . rank ) d . orderidsource = pb . document supplied . enum ( ) } if len ( meta . facets ) > 0 { facets , err : = facetstoproto ( meta . facets ) if err ! = nil { return nil , err } d . facet = facets } } return d , nil } 
func loaddoc ( dst interface { } , src * pb . document , exprs [ ] * pb . field ) ( err error ) { fields , err : = prototofields ( src . field ) if err ! = nil { return err } facets , err : = prototofacets ( src . facet ) if err ! = nil { return err } if len ( exprs ) > 0 { exprfields , err : = prototofields ( exprs ) if err ! = nil { return err } for i : = range exprfields { exprfields [ i ] . derived = true } fields = append ( fields , exprfields ... ) } meta : = & documentmetadata { rank : int ( src . getorderid ( ) ) , facets : facets , } switch x : = dst . ( type ) { case fieldloadsaver : return x . load ( fields , meta ) default : return loadstructwithmeta ( dst , fields , meta ) } } 
func defaultbucketname ( c context . context ) ( string , error ) { req : = & aipb . getdefaultgcsbucketnamerequest { } res : = & aipb . getdefaultgcsbucketnameresponse { } err : = internal . call ( c , " " , " " , req , res ) if err ! = nil { return " " , fmt . errorf ( " " , res ) } return res . getdefaultgcsbucketname ( ) , nil } 
func ( k * key ) valid ( ) bool { if k == nil { return false } for ; k ! = nil ; k = k . parent { if k . kind == " " | | k . appid == " " { return false } if k . stringid ! = " " && k . intid ! = 0 { return false } if k . parent ! = nil { if k . parent . incomplete ( ) { return false } if k . parent . appid ! = k . appid | | k . parent . namespace ! = k . namespace { return false } } } return true } 
func ( k * key ) equal ( o * key ) bool { for k ! = nil && o ! = nil { if k . kind ! = o . kind | | k . stringid ! = o . stringid | | k . intid ! = o . intid | | k . appid ! = o . appid | | k . namespace ! = o . namespace { return false } k , o = k . parent , o . parent } return k == o } 
func ( k * key ) root ( ) * key { for k . parent ! = nil { k = k . parent } return k } 
func ( k * key ) marshal ( b * bytes . buffer ) { if k . parent ! = nil { k . parent . marshal ( b ) } b . writebyte ( ' / ' ) b . writestring ( k . kind ) b . writebyte ( ' , ' ) if k . stringid ! = " " { b . writestring ( k . stringid ) } else { b . writestring ( strconv . formatint ( k . intid , 10 ) ) } } 
func ( k * key ) string ( ) string { if k == nil { return " " } b : = bytes . newbuffer ( make ( [ ] byte , 0 , 512 ) ) k . marshal ( b ) return b . string ( ) } 
func ( k * key ) encode ( ) string { ref : = keytoproto ( " " , k ) b , err : = proto . marshal ( ref ) if err ! = nil { panic ( err ) } return strings . trimright ( base64 . urlencoding . encodetostring ( b ) , " " ) } 
func decodekey ( encoded string ) ( * key , error ) { if m : = len ( encoded ) % 4 ; m ! = 0 { encoded += strings . repeat ( " " , 4 - m ) } b , err : = base64 . urlencoding . decodestring ( encoded ) if err ! = nil { return nil , err } ref : = new ( pb . reference ) if err : = proto . unmarshal ( b , ref ) ; err ! = nil { return nil , err } return prototokey ( ref ) } 
func newincompletekey ( c context . context , kind string , parent * key ) * key { return newkey ( c , kind , " " , 0 , parent ) } 
func newkey ( c context . context , kind , stringid string , intid int64 , parent * key ) * key { var namespace string if parent ! = nil { namespace = parent . namespace } else { namespace = internal . namespacefromcontext ( c ) } return & key { kind : kind , stringid : stringid , intid : intid , parent : parent , appid : internal . fullyqualifiedappid ( c ) , namespace : namespace , } } 
func allocateids ( c context . context , kind string , parent * key , n int ) ( low , high int64 , err error ) { if kind == " " { return 0 , 0 , errors . new ( " " ) } if n < 0 { return 0 , 0 , fmt . errorf ( " " , n ) } if n == 0 { return 0 , 0 , nil } req : = & pb . allocateidsrequest { modelkey : keytoproto ( " " , newincompletekey ( c , kind , parent ) ) , size : proto . int64 ( int64 ( n ) ) , } res : = & pb . allocateidsresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return 0 , 0 , err } low = res . getstart ( ) high = res . getend ( ) + 1 if low + int64 ( n ) ! = high { return 0 , 0 , fmt . errorf ( " " , n ) } return low , high , nil } 
func allocateidrange ( c context . context , kind string , parent * key , start , end int64 ) ( err error ) { if kind == " " { return errors . new ( " " ) } if start < 1 | | end < 1 { return errors . new ( " " ) } if start > end { return errors . new ( " " ) } req : = & pb . allocateidsrequest { modelkey : keytoproto ( " " , newincompletekey ( c , kind , parent ) ) , max : proto . int64 ( end ) , } res : = & pb . allocateidsresponse { } if err : = internal . call ( c , " " , " " , req , res ) ; err ! = nil { return err } q : = newquery ( kind ) . filter ( " " , newkey ( c , kind , " " , start , parent ) ) . filter ( " " , newkey ( c , kind , " " , end , parent ) ) . keysonly ( ) . limit ( 1 ) keys , err : = q . getall ( c , nil ) if err ! = nil { return err } if len ( keys ) ! = 0 { return & keyrangecollisionerror { start : start , end : end } } if start < res . getstart ( ) { return & keyrangecontentionerror { start : start , end : end } } return nil } 
func ( m * indexdocumentparams ) getfreshness ( ) indexdocumentparams freshness { if m ! = nil && m . freshness ! = nil { return * m . freshness } return default indexdocumentparams freshness } 
func isoverquota ( err error ) bool { callerr , ok : = err . ( * internal . callerror ) return ok && callerr . code == 4 } 
func fromcontext ( ctx netcontext . context ) appengine . context { c , : = ctx . value ( & contextkey ) . ( appengine . context ) return c } 
func classiccontextfromcontext ( ctx netcontext . context ) ( appengine . context , error ) { c : = fromcontext ( ctx ) if c == nil { return nil , errnotappenginecontext } return c , nil } 
func send ( c context . context , msg * message ) error { return send ( c , " " , msg ) } 
func sendtoadmins ( c context . context , msg * message ) error { return send ( c , " " , msg ) } 
func ( r * report ) failures ( ) int { count : = 0 for , p : = range r . packages { for , t : = range p . tests { if t . result == fail { count ++ } } } return count } 
func checktyp3 ( rt reflect . type , typ typ3 , fopts fieldoptions ) ( err error ) { typwanted : = typetotyp3 ( rt , fopts ) if typ ! = typwanted { err = fmt . errorf ( " " , typwanted , typ ) } return } 
func decodenumnilbytes ( bz [ ] byte ) ( numnil int64 , n int , err error ) { if len ( bz ) == 0 { err = errors . new ( " " ) return } if bz [ 0 ] == 0x00 { numnil , n = 0 , 1 return } if bz [ 0 ] == 0x01 { numnil , n = 1 , 1 return } n , err = 0 , fmt . errorf ( " " , bz [ 0 ] ) return } 
func newprefixbytes ( prefixbytes [ ] byte ) prefixbytes { pb : = prefixbytes { } copy ( pb [ : ] , prefixbytes ) return pb } 
func ( cdc * codec ) registerinterface ( ptr interface { } , iopts * interfaceoptions ) { cdc . assertnotsealed ( ) rt : = gettypefrompointer ( ptr ) if rt . kind ( ) ! = reflect . interface { panic ( fmt . sprintf ( " " , rt ) ) } var info = cdc . newtypeinfofrominterfacetype ( rt , iopts ) func ( ) { cdc . mtx . lock ( ) defer cdc . mtx . unlock ( ) cdc . collectimplementers nolock ( info ) err : = cdc . checkconflictsinprio nolock ( info ) if err ! = nil { panic ( err ) } cdc . settypeinfo nolock ( info ) } ( ) } 
func ( cdc * codec ) registerconcrete ( o interface { } , name string , copts * concreteoptions ) { cdc . assertnotsealed ( ) var pointerpreferred bool rt : = reflect . typeof ( o ) if rt . kind ( ) == reflect . interface { panic ( fmt . sprintf ( " " , rt ) ) } if rt . kind ( ) == reflect . ptr { rt = rt . elem ( ) if rt . kind ( ) == reflect . ptr { panic ( fmt . sprintf ( " " , rt ) ) } if rt . kind ( ) == reflect . interface { panic ( fmt . sprintf ( " " , rt ) ) } pointerpreferred = true } var info = cdc . newtypeinfofromregisteredconcretetype ( rt , pointerpreferred , name , copts ) func ( ) { cdc . mtx . lock ( ) defer cdc . mtx . unlock ( ) cdc . addcheckconflictswithconcrete nolock ( info ) cdc . settypeinfo nolock ( info ) } ( ) } 
func getlengthstr ( info * typeinfo ) string { switch info . type . kind ( ) { case reflect . array , reflect . int8 , reflect . int16 , reflect . int32 , reflect . int64 , reflect . float32 , reflect . float64 , reflect . complex64 , reflect . complex128 : s : = info . type . size ( ) return fmt . sprintf ( " " , s ) default : return " " } } 
func ( cdc * codec ) gettypeinfofromprefix rlock ( iinfo * typeinfo , pb prefixbytes ) ( info * typeinfo , err error ) { cdc . mtx . rlock ( ) infos , ok : = iinfo . implementers [ pb ] if ! ok { err = fmt . errorf ( " " , pb ) cdc . mtx . runlock ( ) return } if len ( infos ) > 1 { err = fmt . errorf ( " " , pb , infos [ 0 ] . type , infos [ 1 ] . type ) cdc . mtx . runlock ( ) return } info = infos [ 0 ] cdc . mtx . runlock ( ) return } 
func ( cdc * codec ) newtypeinfounregistered ( rt reflect . type ) * typeinfo { if rt . kind ( ) == reflect . ptr { panic ( " " ) } if rt . kind ( ) == reflect . interface { panic ( " " ) } var info = new ( typeinfo ) info . type = rt info . ptrtotype = reflect . ptrto ( rt ) info . zerovalue = reflect . zero ( rt ) info . zeroproto = reflect . zero ( rt ) . interface ( ) if rt . kind ( ) == reflect . struct { info . structinfo = cdc . parsestructinfo ( rt ) } if rm , ok : = rt . methodbyname ( " " ) ; ok { info . concreteinfo . isaminomarshaler = true info . concreteinfo . aminomarshalreprtype = marshalaminoreprtype ( rm ) } if rm , ok : = reflect . ptrto ( rt ) . methodbyname ( " " ) ; ok { info . concreteinfo . isaminounmarshaler = true info . concreteinfo . aminounmarshalreprtype = unmarshalaminoreprtype ( rm ) } return info } 
func ( cdc * codec ) collectimplementers nolock ( info * typeinfo ) { for , cinfo : = range cdc . concreteinfos { if cinfo . ptrtotype . implements ( info . type ) { info . implementers [ cinfo . prefix ] = append ( info . implementers [ cinfo . prefix ] , cinfo ) } } } 
func ( cdc * codec ) checkconflictsinprio nolock ( iinfo * typeinfo ) error { for , cinfos : = range iinfo . implementers { if len ( cinfos ) < 2 { continue } for , cinfo : = range cinfos { var inprio = false for , disfix : = range iinfo . interfaceinfo . priority { if cinfo . getdisfix ( ) == disfix { inprio = true } } if ! inprio { return fmt . errorf ( " " , cinfo . type , len ( cinfos ) , iinfo . type ) } } } return nil } 
func decodeinterfacejson ( bz [ ] byte ) ( name string , data [ ] byte , err error ) { dfw : = new ( disfixwrapper ) err = json . unmarshal ( bz , dfw ) if err ! = nil { err = fmt . errorf ( " " , err ) return } if dfw . name == " " { err = errors . new ( " " ) return } name = dfw . name if len ( dfw . data ) == 0 { err = errors . new ( " " ) return } data = dfw . data return } 
func slide ( bz * [ ] byte , n * int , n int ) bool { if n < 0 | | n > len ( * bz ) { panic ( fmt . sprintf ( " " , len ( * bz ) , n ) ) } * bz = ( * bz ) [ n : ] if n ! = nil { * n += n } return true } 
func derefpointers ( rv reflect . value ) ( drv reflect . value , isptr bool , isnilptr bool ) { for rv . kind ( ) == reflect . ptr { isptr = true if rv . isnil ( ) { isnilptr = true return } rv = rv . elem ( ) } drv = rv return } 
func derefpointerszero ( rv reflect . value ) ( drv reflect . value , isptr bool , isnilptr bool ) { for rv . kind ( ) == reflect . ptr { isptr = true if rv . isnil ( ) { isnilptr = true rt : = rv . type ( ) . elem ( ) for rt . kind ( ) == reflect . ptr { rt = rt . elem ( ) } drv = reflect . new ( rt ) . elem ( ) return } rv = rv . elem ( ) } drv = rv return } 
func isdefaultvalue ( rv reflect . value ) ( erv reflect . value , isdefaultvalue bool ) { rv , , isnilptr : = derefpointers ( rv ) if isnilptr { return rv , true } else { switch rv . kind ( ) { case reflect . bool : return rv , rv . bool ( ) == false case reflect . int , reflect . int8 , reflect . int16 , reflect . int32 , reflect . int64 : return rv , rv . int ( ) == 0 case reflect . uint , reflect . uint8 , reflect . uint16 , reflect . uint32 , reflect . uint64 : return rv , rv . uint ( ) == 0 case reflect . string : return rv , rv . len ( ) == 0 case reflect . chan , reflect . map , reflect . slice : return rv , rv . isnil ( ) | | rv . len ( ) == 0 case reflect . func , reflect . interface : return rv , rv . isnil ( ) default : return rv , false } } } 
func defaultvalue ( rt reflect . type ) ( rv reflect . value ) { switch rt . kind ( ) { case reflect . ptr : rt : = rt . elem ( ) for rt . kind ( ) == reflect . ptr { rt = rt . elem ( ) } switch rt { case timetype : rv = reflect . new ( rt ) . elem ( ) rt , rv : = rt , rv for rt . kind ( ) == reflect . ptr { newptr : = reflect . new ( rt . elem ( ) ) rv . set ( newptr ) rt = rt . elem ( ) rv = rv . elem ( ) } rv . set ( reflect . valueof ( zerotime ) ) return rv } case reflect . struct : switch rt { case timetype : rv = reflect . new ( rt ) . elem ( ) rv . set ( reflect . valueof ( zerotime ) ) return rv } } return reflect . zero ( rt ) } 
func constructconcretetype ( cinfo * typeinfo ) ( crv , irvset reflect . value ) { if cinfo . pointerpreferred { cptrrv : = reflect . new ( cinfo . type ) crv = cptrrv . elem ( ) irvset = cptrrv } else { crv = reflect . new ( cinfo . type ) . elem ( ) irvset = crv } return } 
func isempty ( rv reflect . value , zrv reflect . value ) bool { if ! rv . isvalid ( ) { return true } if reflect . deepequal ( rv . interface ( ) , zrv . interface ( ) ) { return true } switch rv . kind ( ) { case reflect . slice , reflect . array , reflect . string : if rv . len ( ) == 0 { return true } } return false } 
func encodeuvarint ( w io . writer , u uint64 ) ( err error ) { var buf [ 10 ] byte n : = binary . putuvarint ( buf [ : ] , u ) , err = w . write ( buf [ 0 : n ] ) return } 
func encodetime ( w io . writer , t time . time ) ( err error ) { s : = t . unix ( ) if s ! = 0 { if s < minseconds | | s >= maxseconds { return invalidtimeerr ( fmt . sprintf ( " " , minseconds , maxseconds , s ) ) } err = encodefieldnumberandtyp3 ( w , 1 , typ3 varint ) if err ! = nil { return } err = encodeuvarint ( w , uint64 ( s ) ) if err ! = nil { return } } ns : = int32 ( t . nanosecond ( ) ) if ns ! = 0 { if ns < 0 | | ns > maxnanos { return invalidtimeerr ( fmt . sprintf ( " " , maxnanos , s ) ) } err = encodefieldnumberandtyp3 ( w , 2 , typ3 varint ) if err ! = nil { return } err = encodeuvarint ( w , uint64 ( ns ) ) if err ! = nil { return } } return } 
func decodetime ( bz [ ] byte ) ( t time . time , n int , err error ) { t = zerotime var sec int64 var nsec int32 if len ( bz ) > 0 { sec , n , err = decodeseconds ( & bz ) if err ! = nil { return } } if len ( bz ) > 0 { nsec , err = decodenanos ( & bz , & n ) if err ! = nil { return } } t = time . unix ( sec , int64 ( nsec ) ) t = t . utc ( ) . truncate ( 0 ) return } 
func ( cdc * codec ) marshalbinarylengthprefixedwriter ( w io . writer , o interface { } ) ( n int64 , err error ) { var bz , n = [ ] byte ( nil ) , int ( 0 ) bz , err = cdc . marshalbinarylengthprefixed ( o ) if err ! = nil { return 0 , err } n , err = w . write ( bz ) n = int64 ( n ) return } 
func ( cdc * codec ) mustmarshalbinarylengthprefixed ( o interface { } ) [ ] byte { bz , err : = cdc . marshalbinarylengthprefixed ( o ) if err ! = nil { panic ( err ) } return bz } 
func ( cdc * codec ) marshalbinarybare ( o interface { } ) ( [ ] byte , error ) { var rv , , isnilptr = derefpointers ( reflect . valueof ( o ) ) if isnilptr { panic ( " " ) } var bz [ ] byte buf : = new ( bytes . buffer ) rt : = rv . type ( ) info , err : = cdc . gettypeinfo wlock ( rt ) if err ! = nil { return nil , err } err = cdc . encodereflectbinary ( buf , info , rv , fieldoptions { binfieldnum : 1 } , true ) if err ! = nil { return nil , err } bz = buf . bytes ( ) if info . registered { pb : = info . prefix . bytes ( ) bz = append ( pb , bz ... ) } return bz , nil } 
func ( cdc * codec ) mustmarshalbinarybare ( o interface { } ) [ ] byte { bz , err : = cdc . marshalbinarybare ( o ) if err ! = nil { panic ( err ) } return bz } 
func ( cdc * codec ) unmarshalbinarylengthprefixed ( bz [ ] byte , ptr interface { } ) error { if len ( bz ) == 0 { return errors . new ( " " ) } u64 , n : = binary . uvarint ( bz ) if n < 0 { return fmt . errorf ( " " , n ) } if u64 > uint64 ( len ( bz ) - n ) { return fmt . errorf ( " " , u64 , len ( bz ) - n ) } else if u64 < uint64 ( len ( bz ) - n ) { return fmt . errorf ( " " , u64 , len ( bz ) - n ) } bz = bz [ n : ] return cdc . unmarshalbinarybare ( bz , ptr ) } 
func ( cdc * codec ) unmarshalbinarylengthprefixedreader ( r io . reader , ptr interface { } , maxsize int64 ) ( n int64 , err error ) { if maxsize < 0 { panic ( " " ) } var l int64 var buf [ binary . maxvarintlen64 ] byte for i : = 0 ; i < len ( buf ) ; i ++ { , err = r . read ( buf [ i : i + 1 ] ) if err ! = nil { return } n += 1 if buf [ i ] & 0x80 == 0 { break } if n >= maxsize { err = fmt . errorf ( " " , maxsize ) } } u64 , : = binary . uvarint ( buf [ : ] ) if err ! = nil { return } if maxsize > 0 { if uint64 ( maxsize ) < u64 { err = fmt . errorf ( " " , maxsize , u64 ) return } if ( maxsize - n ) < int64 ( u64 ) { err = fmt . errorf ( " " , maxsize , n , u64 ) return } } l = int64 ( u64 ) if l < 0 { err = fmt . errorf ( " " ) } var bz = make ( [ ] byte , l , l ) , err = io . readfull ( r , bz ) if err ! = nil { return } n += l err = cdc . unmarshalbinarybare ( bz , ptr ) return } 
func ( cdc * codec ) mustunmarshalbinarylengthprefixed ( bz [ ] byte , ptr interface { } ) { err : = cdc . unmarshalbinarylengthprefixed ( bz , ptr ) if err ! = nil { panic ( err ) } } 
func ( cdc * codec ) unmarshalbinarybare ( bz [ ] byte , ptr interface { } ) error { rv : = reflect . valueof ( ptr ) if rv . kind ( ) ! = reflect . ptr { panic ( " " ) } rv = rv . elem ( ) rt : = rv . type ( ) info , err : = cdc . gettypeinfo wlock ( rt ) if err ! = nil { return err } if info . registered { pb : = info . prefix . bytes ( ) if len ( bz ) < 4 { return fmt . errorf ( " " , pb , bz ) } else if ! bytes . equal ( bz [ : 4 ] , pb ) { return fmt . errorf ( " " , pb , bz [ : 4 ] ) } bz = bz [ 4 : ] } n , err : = cdc . decodereflectbinary ( bz , info , rv , fieldoptions { binfieldnum : 1 } , true ) if err ! = nil { return fmt . errorf ( " " , info . type , n , err , bz ) } if n ! = len ( bz ) { return fmt . errorf ( " " , info . type , len ( bz ) , n , bz ) } return nil } 
func ( cdc * codec ) mustunmarshalbinarybare ( bz [ ] byte , ptr interface { } ) { err : = cdc . unmarshalbinarybare ( bz , ptr ) if err ! = nil { panic ( err ) } } 
func ( cdc * codec ) mustmarshaljson ( o interface { } ) [ ] byte { bz , err : = cdc . marshaljson ( o ) if err ! = nil { panic ( err ) } return bz } 
func ( cdc * codec ) mustunmarshaljson ( bz [ ] byte , ptr interface { } ) { if err : = cdc . unmarshaljson ( bz , ptr ) ; err ! = nil { panic ( err ) } } 
func ( cdc * codec ) marshaljsonindent ( o interface { } , prefix , indent string ) ( [ ] byte , error ) { bz , err : = cdc . marshaljson ( o ) if err ! = nil { return nil , err } var out bytes . buffer err = json . indent ( & out , bz , prefix , indent ) if err ! = nil { return nil , err } return out . bytes ( ) , nil } 
func dialto ( addr string ) ( * conn , error ) { const network = " " if " " == addr { addr = " " } conn , err : = net . dial ( network , addr ) if nil ! = err { return nil , err } datareader : = newdatareader ( conn ) datawriter : = newdatawriter ( conn ) clientconn : = conn { conn : conn , datareader : datareader , datawriter : datawriter , } return & clientconn , nil } 
func dialtotls ( addr string , tlsconfig * tls . config ) ( * conn , error ) { const network = " " if " " == addr { addr = " " } conn , err : = tls . dial ( network , addr , tlsconfig ) if nil ! = err { return nil , err } datareader : = newdatareader ( conn ) datawriter : = newdatawriter ( conn ) clientconn : = conn { conn : conn , datareader : datareader , datawriter : datawriter , } return & clientconn , nil } 
func ( clientconn * conn ) read ( p [ ] byte ) ( n int , err error ) { return clientconn . datareader . read ( p ) } 
func ( clientconn * conn ) write ( p [ ] byte ) ( n int , err error ) { return clientconn . datawriter . write ( p ) } 
func newdatareader ( r io . reader ) * internaldatareader { buffered : = bufio . newreader ( r ) reader : = internaldatareader { wrapped : r , buffered : buffered , } return & reader } 
func listenandservetls ( addr string , certfile string , keyfile string , handler handler ) error { server : = & server { addr : addr , handler : handler } return server . listenandservetls ( certfile , keyfile ) } 
func newdatawriter ( w io . writer ) * internaldatawriter { writer : = internaldatawriter { wrapped : w , } return & writer } 
func ( w * internaldatawriter ) write ( data [ ] byte ) ( n int , err error ) { var n64 int64 n64 , err = w . write64 ( data ) n = int ( n64 ) if int64 ( n ) ! = n64 { panic ( erroverflow ) } return n , err } 
func ( fn producerfunc ) produce ( ctx telnet . context , name string , args ... string ) handler { return fn ( ctx , name , args ... ) } 
func promotehandlerfunc ( fn handlerfunc , args ... string ) handler { stdin , stdinpipe : = io . pipe ( ) stdoutpipe , stdout : = io . pipe ( ) stderrpipe , stderr : = io . pipe ( ) argscopy : = make ( [ ] string , len ( args ) ) for i , datum : = range args { argscopy [ i ] = datum } handler : = internalpromotedhandlerfunc { err : nil , fn : fn , stdin : stdin , stdout : stdout , stderr : stderr , stdinpipe : stdinpipe , stdoutpipe : stdoutpipe , stderrpipe : stderrpipe , args : argscopy , } return & handler } 
func serve ( listener net . listener , handler handler ) error { server : = & server { handler : handler } return server . serve ( listener ) } 
func ( server * server ) listenandserve ( ) error { addr : = server . addr if " " == addr { addr = " " } listener , err : = net . listen ( " " , addr ) if nil ! = err { return err } return server . serve ( listener ) } 
func ( server * server ) serve ( listener net . listener ) error { defer listener . close ( ) logger : = server . logger ( ) handler : = server . handler if nil == handler { logger . debug ( " " ) handler = echohandler } for { logger . debugf ( " " , listener . addr ( ) ) conn , err : = listener . accept ( ) if err ! = nil { return err } logger . debugf ( " " , conn . remoteaddr ( ) ) go server . handle ( conn , handler ) logger . debugf ( " " , conn . remoteaddr ( ) ) } } 
func ( p * parser ) fail ( msg string ) { p . writeusage ( os . stderr ) fmt . fprintln ( os . stderr , " " , msg ) os . exit ( - 1 ) } 
func ( p * parser ) writeusage ( w io . writer ) { var positionals , options [ ] * spec for , spec : = range p . specs { if spec . positional { positionals = append ( positionals , spec ) } else { options = append ( options , spec ) } } if p . version ! = " " { fmt . fprintln ( w , p . version ) } fmt . fprintf ( w , " " , p . config . program ) for , spec : = range options { fmt . fprint ( w , " " ) if ! spec . required { fmt . fprint ( w , " " ) } fmt . fprint ( w , synopsis ( spec , " " + spec . long ) ) if ! spec . required { fmt . fprint ( w , " " ) } } for , spec : = range positionals { fmt . fprint ( w , " " ) up : = strings . toupper ( spec . long ) if spec . multiple { if ! spec . required { fmt . fprint ( w , " " ) } fmt . fprintf ( w , " " , up , up ) if ! spec . required { fmt . fprint ( w , " " ) } } else { fmt . fprint ( w , up ) } } fmt . fprint ( w , " \n " ) } 
func mustparse ( dest ... interface { } ) * parser { p , err : = newparser ( config { } , dest ... ) if err ! = nil { fmt . println ( err ) os . exit ( - 1 ) } err = p . parse ( flags ( ) ) if err == errhelp { p . writehelp ( os . stdout ) os . exit ( 0 ) } if err == errversion { fmt . println ( p . version ) os . exit ( 0 ) } if err ! = nil { p . fail ( err . error ( ) ) } return p } 
func parse ( dest ... interface { } ) error { p , err : = newparser ( config { } , dest ... ) if err ! = nil { return err } return p . parse ( flags ( ) ) } 
func walkfields ( v reflect . value , visit func ( field reflect . structfield , val reflect . value , owner reflect . type ) bool ) { t : = v . type ( ) for i : = 0 ; i < t . numfield ( ) ; i ++ { field : = t . field ( i ) val : = v . field ( i ) expand : = visit ( field , val , t ) if expand && field . type . kind ( ) == reflect . struct { walkfields ( val , visit ) } } } 
func ( p * parser ) parse ( args [ ] string ) error { for , arg : = range args { if arg == " " | | arg == " " { return errhelp } if arg == " " { return errversion } if arg == " " { break } } return process ( p . specs , args ) } 
func isflag ( s string ) bool { return strings . hasprefix ( s , " " ) && strings . trimleft ( s , " " ) ! = " " } 
func setslice ( dest reflect . value , values [ ] string , trunc bool ) error { if ! dest . canset ( ) { return fmt . errorf ( " " ) } var ptr bool elem : = dest . type ( ) . elem ( ) if elem . kind ( ) == reflect . ptr && ! elem . implements ( textunmarshalertype ) { ptr = true elem = elem . elem ( ) } if trunc && ! dest . isnil ( ) { dest . setlen ( 0 ) } for , s : = range values { v : = reflect . new ( elem ) if err : = scalar . parsevalue ( v . elem ( ) , s ) ; err ! = nil { return err } if ! ptr { v = v . elem ( ) } dest . set ( reflect . append ( dest , v ) ) } return nil } 
func canparse ( t reflect . type ) ( parseable , boolean , multiple bool ) { parseable = scalar . canparse ( t ) boolean = isboolean ( t ) if parseable { return } if t . kind ( ) == reflect . ptr { t = t . elem ( ) } if t . kind ( ) == reflect . slice { multiple = true t = t . elem ( ) } parseable = scalar . canparse ( t ) boolean = isboolean ( t ) if parseable { return } if t . kind ( ) == reflect . ptr { t = t . elem ( ) } parseable = scalar . canparse ( t ) boolean = isboolean ( t ) if parseable { return } return false , false , false } 
func isboolean ( t reflect . type ) bool { switch { case t . implements ( textunmarshalertype ) : return false case t . kind ( ) == reflect . bool : return true case t . kind ( ) == reflect . ptr && t . elem ( ) . kind ( ) == reflect . bool : return true default : return false } } 
func newfrommap ( m map [ string ] interface { } ) * tree { t : = & tree { root : & node { } } for k , v : = range m { t . insert ( k , v ) } return t } 
func ( t * tree ) delete ( s string ) ( interface { } , bool ) { var parent * node var label byte n : = t . root search : = s for { if len ( search ) == 0 { if ! n . isleaf ( ) { break } goto delete } parent = n label = search [ 0 ] n = n . getedge ( label ) if n == nil { break } if strings . hasprefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else { break } } return nil , false delete : leaf : = n . leaf n . leaf = nil t . size -- if parent ! = nil && len ( n . edges ) == 0 { parent . deledge ( label ) } if n ! = t . root && len ( n . edges ) == 1 { n . mergechild ( ) } if parent ! = nil && parent ! = t . root && len ( parent . edges ) == 1 && ! parent . isleaf ( ) { parent . mergechild ( ) } return leaf . val , true } 
func ( t * tree ) deleteprefix ( s string ) int { return t . deleteprefix ( nil , t . root , s ) } 
func ( t * tree ) deleteprefix ( parent , n * node , prefix string ) int { if len ( prefix ) == 0 { subtreesize : = 0 recursivewalk ( n , func ( s string , v interface { } ) bool { subtreesize ++ return false } ) if n . isleaf ( ) { n . leaf = nil } n . edges = nil if parent ! = nil && parent ! = t . root && len ( parent . edges ) == 1 && ! parent . isleaf ( ) { parent . mergechild ( ) } t . size - = subtreesize return subtreesize } label : = prefix [ 0 ] child : = n . getedge ( label ) if child == nil | | ( ! strings . hasprefix ( child . prefix , prefix ) && ! strings . hasprefix ( prefix , child . prefix ) ) { return 0 } if len ( child . prefix ) > len ( prefix ) { prefix = prefix [ len ( prefix ) : ] } else { prefix = prefix [ len ( child . prefix ) : ] } return t . deleteprefix ( n , child , prefix ) } 
func ( t * tree ) get ( s string ) ( interface { } , bool ) { n : = t . root search : = s for { if len ( search ) == 0 { if n . isleaf ( ) { return n . leaf . val , true } break } n = n . getedge ( search [ 0 ] ) if n == nil { break } if strings . hasprefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else { break } } return nil , false } 
func ( t * tree ) longestprefix ( s string ) ( string , interface { } , bool ) { var last * leafnode n : = t . root search : = s for { if n . isleaf ( ) { last = n . leaf } if len ( search ) == 0 { break } n = n . getedge ( search [ 0 ] ) if n == nil { break } if strings . hasprefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else { break } } if last ! = nil { return last . key , last . val , true } return " " , nil , false } 
func ( t * tree ) minimum ( ) ( string , interface { } , bool ) { n : = t . root for { if n . isleaf ( ) { return n . leaf . key , n . leaf . val , true } if len ( n . edges ) > 0 { n = n . edges [ 0 ] . node } else { break } } return " " , nil , false } 
func ( t * tree ) walkprefix ( prefix string , fn walkfn ) { n : = t . root search : = prefix for { if len ( search ) == 0 { recursivewalk ( n , fn ) return } n = n . getedge ( search [ 0 ] ) if n == nil { break } if strings . hasprefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else if strings . hasprefix ( n . prefix , search ) { recursivewalk ( n , fn ) return } else { break } } } 
func ( t * tree ) walkpath ( path string , fn walkfn ) { n : = t . root search : = path for { if n . leaf ! = nil && fn ( n . leaf . key , n . leaf . val ) { return } if len ( search ) == 0 { return } n = n . getedge ( search [ 0 ] ) if n == nil { return } if strings . hasprefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else { break } } } 
func recursivewalk ( n * node , fn walkfn ) bool { if n . leaf ! = nil && fn ( n . leaf . key , n . leaf . val ) { return true } for , e : = range n . edges { if recursivewalk ( e . node , fn ) { return true } } return false } 
func ( t * tree ) tomap ( ) map [ string ] interface { } { out : = make ( map [ string ] interface { } , t . size ) t . walk ( func ( k string , v interface { } ) bool { out [ k ] = v return false } ) return out } 
func checkip ( ip string ) ( iptype uint32 , ipnum * big . int , ipindex uint32 ) { iptype = 0 ipnum = big . newint ( 0 ) ipnumtmp : = big . newint ( 0 ) ipindex = 0 ipaddress : = net . parseip ( ip ) if ipaddress ! = nil { v4 : = ipaddress . to4 ( ) if v4 ! = nil { iptype = 4 ipnum . setbytes ( v4 ) } else { v6 : = ipaddress . to16 ( ) if v6 ! = nil { iptype = 6 ipnum . setbytes ( v6 ) } } } if iptype == 4 { if meta . ipv4indexbaseaddr > 0 { ipnumtmp . rsh ( ipnum , 16 ) ipnumtmp . lsh ( ipnumtmp , 3 ) ipindex = uint32 ( ipnumtmp . add ( ipnumtmp , big . newint ( int64 ( meta . ipv4indexbaseaddr ) ) ) . uint64 ( ) ) } } else if iptype == 6 { if meta . ipv6indexbaseaddr > 0 { ipnumtmp . rsh ( ipnum , 112 ) ipnumtmp . lsh ( ipnumtmp , 3 ) ipindex = uint32 ( ipnumtmp . add ( ipnumtmp , big . newint ( int64 ( meta . ipv6indexbaseaddr ) ) ) . uint64 ( ) ) } } return } 
func readuint32 ( pos uint32 ) uint32 { pos2 : = int64 ( pos ) var retval uint32 data : = make ( [ ] byte , 4 ) , err : = f . readat ( data , pos2 - 1 ) if err ! = nil { fmt . println ( " " , err ) } buf : = bytes . newreader ( data ) err = binary . read ( buf , binary . littleendian , & retval ) if err ! = nil { fmt . println ( " " , err ) } return retval } 
func readuint128 ( pos uint32 ) * big . int { pos2 : = int64 ( pos ) retval : = big . newint ( 0 ) data : = make ( [ ] byte , 16 ) , err : = f . readat ( data , pos2 - 1 ) if err ! = nil { fmt . println ( " " , err ) } for i , j : = 0 , len ( data ) - 1 ; i < j ; i , j = i + 1 , j - 1 { data [ i ] , data [ j ] = data [ j ] , data [ i ] } retval . setbytes ( data ) return retval } 
func loadmessage ( mesg string ) ip2locationrecord { var x ip2locationrecord x . country short = mesg x . country long = mesg x . region = mesg x . city = mesg x . isp = mesg x . domain = mesg x . zipcode = mesg x . timezone = mesg x . netspeed = mesg x . iddcode = mesg x . areacode = mesg x . weatherstationcode = mesg x . weatherstationname = mesg x . mcc = mesg x . mnc = mesg x . mobilebrand = mesg x . usagetype = mesg return x } 
func printrecord ( x ip2locationrecord ) { fmt . printf ( " \n " , x . country short ) fmt . printf ( " \n " , x . country long ) fmt . printf ( " \n " , x . region ) fmt . printf ( " \n " , x . city ) fmt . printf ( " \n " , x . isp ) fmt . printf ( " \n " , x . latitude ) fmt . printf ( " \n " , x . longitude ) fmt . printf ( " \n " , x . domain ) fmt . printf ( " \n " , x . zipcode ) fmt . printf ( " \n " , x . timezone ) fmt . printf ( " \n " , x . netspeed ) fmt . printf ( " \n " , x . iddcode ) fmt . printf ( " \n " , x . areacode ) fmt . printf ( " \n " , x . weatherstationcode ) fmt . printf ( " \n " , x . weatherstationname ) fmt . printf ( " \n " , x . mcc ) fmt . printf ( " \n " , x . mnc ) fmt . printf ( " \n " , x . mobilebrand ) fmt . printf ( " \n " , x . elevation ) fmt . printf ( " \n " , x . usagetype ) } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { gc . save ( ) gc . scale ( 0 . 5 , 0 . 5 ) draw ( gc ) gc . restore ( ) return samples . output ( " " , ext ) , nil } 
func rectangle ( path draw2d . pathbuilder , x1 , y1 , x2 , y2 float64 ) { path . moveto ( x1 , y1 ) path . lineto ( x2 , y1 ) path . lineto ( x2 , y2 ) path . lineto ( x1 , y2 ) path . close ( ) } 
func roundedrectangle ( path draw2d . pathbuilder , x1 , y1 , x2 , y2 , arcwidth , archeight float64 ) { arcwidth = arcwidth / 2 archeight = archeight / 2 path . moveto ( x1 , y1 + archeight ) path . quadcurveto ( x1 , y1 , x1 + arcwidth , y1 ) path . lineto ( x2 - arcwidth , y1 ) path . quadcurveto ( x2 , y1 , x2 , y1 + archeight ) path . lineto ( x2 , y2 - archeight ) path . quadcurveto ( x2 , y2 , x2 - arcwidth , y2 ) path . lineto ( x1 + arcwidth , y2 ) path . quadcurveto ( x1 , y2 , x1 , y2 - archeight ) path . close ( ) } 
func ellipse ( path draw2d . pathbuilder , cx , cy , rx , ry float64 ) { path . arcto ( cx , cy , rx , ry , 0 , - math . pi * 2 ) path . close ( ) } 
func circle ( path draw2d . pathbuilder , cx , cy , radius float64 ) { path . arcto ( cx , cy , radius , radius , 0 , - math . pi * 2 ) path . close ( ) } 
func savetopdffile ( filepath string , pdf * gofpdf . fpdf ) error { return pdf . outputfileandclose ( filepath ) } 
func ( p * path ) moveto ( x , y float64 ) { p . appendtopath ( movetocmp , x , y ) p . x = x p . y = y } 
func ( p * path ) cubiccurveto ( cx1 , cy1 , cx2 , cy2 , x , y float64 ) { if len ( p . components ) == 0 { p . moveto ( x , y ) } else { p . appendtopath ( cubiccurvetocmp , cx1 , cy1 , cx2 , cy2 , x , y ) } p . x = x p . y = y } 
func ( p * path ) arcto ( cx , cy , rx , ry , startangle , angle float64 ) { endangle : = startangle + angle clockwise : = true if angle < 0 { clockwise = false } if clockwise { for endangle < startangle { endangle += math . pi * 2 . 0 } } else { for startangle < endangle { startangle += math . pi * 2 . 0 } } startx : = cx + math . cos ( startangle ) * rx starty : = cy + math . sin ( startangle ) * ry if len ( p . components ) > 0 { p . lineto ( startx , starty ) } else { p . moveto ( startx , starty ) } p . appendtopath ( arctocmp , cx , cy , rx , ry , startangle , angle ) p . x = cx + math . cos ( endangle ) * rx p . y = cy + math . sin ( endangle ) * ry } 
func ( path * path ) verticalflip ( ) * path { p : = path . copy ( ) j : = 0 for , cmd : = range p . components { switch cmd { case movetocmp , linetocmp : p . points [ j + 1 ] = - p . points [ j + 1 ] j = j + 2 case quadcurvetocmp : p . points [ j + 1 ] = - p . points [ j + 1 ] p . points [ j + 3 ] = - p . points [ j + 3 ] j = j + 4 case cubiccurvetocmp : p . points [ j + 1 ] = - p . points [ j + 1 ] p . points [ j + 3 ] = - p . points [ j + 3 ] p . points [ j + 5 ] = - p . points [ j + 5 ] j = j + 6 case arctocmp : p . points [ j + 1 ] = - p . points [ j + 1 ] p . points [ j + 3 ] = - p . points [ j + 3 ] p . points [ j + 4 ] = - p . points [ j + 4 ] p . points [ j + 5 ] = - p . points [ j + 5 ] j = j + 6 case closecmp : } } p . y = - p . y return p } 
func newglyphcache ( ) * glyphcacheimp { glyphs : = make ( map [ string ] map [ rune ] * glyph ) return & glyphcacheimp { glyphs : glyphs , } } 
func ( glyphcache * glyphcacheimp ) fetch ( gc draw2d . graphiccontext , fontname string , chr rune ) * glyph { if glyphcache . glyphs [ fontname ] == nil { glyphcache . glyphs [ fontname ] = make ( map [ rune ] * glyph , 60 ) } if glyphcache . glyphs [ fontname ] [ chr ] == nil { glyphcache . glyphs [ fontname ] [ chr ] = renderglyph ( gc , fontname , chr ) } return glyphcache . glyphs [ fontname ] [ chr ] . copy ( ) } 
func renderglyph ( gc draw2d . graphiccontext , fontname string , chr rune ) * glyph { gc . save ( ) defer gc . restore ( ) gc . beginpath ( ) width : = gc . createstringpath ( string ( chr ) , 0 , 0 ) path : = gc . getpath ( ) return & glyph { path : & path , width : width , } } 
func ( g * glyph ) copy ( ) * glyph { return & glyph { path : g . path . copy ( ) , width : g . width , } } 
func ( g * glyph ) fill ( gc draw2d . graphiccontext , x , y float64 ) float64 { gc . save ( ) gc . beginpath ( ) gc . translate ( x , y ) gc . fill ( g . path ) gc . restore ( ) return g . width } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { gc . setfillrule ( draw2d . fillrulewinding ) gc . clear ( ) for x : = 5 . 0 ; x < 297 ; x += 10 { draw ( gc , x , 0 , x , 210 ) } gc . clearrect ( 100 , 75 , 197 , 135 ) draw2dkit . ellipse ( gc , 148 . 5 , 105 , 35 , 25 ) gc . setfillcolor ( color . rgba { 0xff , 0xff , 0x44 , 0xff } ) gc . fillstroke ( ) return samples . output ( " " , ext ) , nil } 
func draw ( gc draw2d . graphiccontext , x0 , y0 , x1 , y1 float64 ) { gc . moveto ( x0 , y0 ) gc . lineto ( x1 , y1 ) gc . stroke ( ) } 
func optisprintf ( format string , a ... interface { } ) string { chunks : = strings . split ( format , " " ) newchunks : = make ( [ ] string , len ( chunks ) ) for i , chunk : = range chunks { if i ! = 0 { verb : = chunk [ 0 ] if verb == ' f ' | | verb == ' f ' { num : = a [ i - 1 ] . ( float64 ) p : = strconv . itoa ( getprec ( num , verb == ' f ' ) ) chunk = strings . replace ( chunk , string ( verb ) , " " + p + " " , 1 ) } } newchunks [ i ] = chunk } format = strings . join ( newchunks , " " ) return fmt . sprintf ( format , a ... ) } 
func getprec ( num float64 , better bool ) int { max : = 3 eps : = 0 . 0005 if better { max = 6 eps = 0 . 0000005 } prec : = 0 for math . mod ( num , 1 ) > eps { num * = 10 eps * = 10 prec ++ } if max < prec { return max } return prec } 
func ( p * painter ) setcolor ( c color . color ) { r , g , b , a : = c . rgba ( ) if a == 0 { p . cr = 0 p . cg = 0 p . cb = 0 p . ca = a } else { p . cr = uint8 ( ( r * m16 / a ) > > 8 ) p . cg = uint8 ( ( g * m16 / a ) > > 8 ) p . cb = uint8 ( ( b * m16 / a ) > > 8 ) p . ca = a } } 
func newpainter ( ) * painter { p : = new ( painter ) p . vertices = make ( [ ] int32 , 0 , 1024 ) p . colors = make ( [ ] uint8 , 0 , 1024 ) return p } 
func newgraphiccontext ( width , height int ) * graphiccontext { gc : = & graphiccontext { draw2dbase . newstackgraphiccontext ( ) , newpainter ( ) , raster . newrasterizer ( width , height ) , raster . newrasterizer ( width , height ) , draw2d . getglobalfontcache ( ) , draw2dbase . newglyphcache ( ) , & truetype . glyphbuf { } , 92 , } return gc } 
func ( gc * graphiccontext ) fillstring ( text string ) ( width float64 ) { return gc . fillstringat ( text , 0 , 0 ) } 
func ( gc * graphiccontext ) fillstringat ( text string , x , y float64 ) ( width float64 ) { f , err : = gc . loadcurrentfont ( ) if err ! = nil { log . println ( err ) return 0 . 0 } startx : = x prev , hasprev : = truetype . index ( 0 ) , false fontname : = gc . getfontname ( ) for , r : = range text { index : = f . index ( r ) if hasprev { x += funitstofloat64 ( f . kern ( fixed . int26 6 ( gc . current . scale ) , prev , index ) ) } glyph : = gc . glyphcache . fetch ( gc , fontname , r ) x += glyph . fill ( gc , x , y ) prev , hasprev = index , true } return x - startx } 
func ( gc * graphiccontext ) strokestring ( text string ) ( width float64 ) { return gc . strokestringat ( text , 0 , 0 ) } 
func ( gc * graphiccontext ) recalc ( ) { gc . current . scale = gc . current . fontsize * float64 ( gc . dpi ) * ( 64 . 0 / 72 . 0 ) } 
func ( gc * graphiccontext ) setfont ( font * truetype . font ) { gc . current . font = font } 
func ( gc * graphiccontext ) setfontsize ( fontsize float64 ) { gc . current . fontsize = fontsize gc . recalc ( ) } 
func ( gc * graphiccontext ) stroke ( paths ... * draw2d . path ) { gc . drawpaths ( stroked , paths ... ) gc . current . path . clear ( ) } 
func ( gc * graphiccontext ) fill ( paths ... * draw2d . path ) { gc . drawpaths ( filled , paths ... ) gc . current . path . clear ( ) } 
func ( gc * graphiccontext ) fillstroke ( paths ... * draw2d . path ) { gc . drawpaths ( filled | stroked , paths ... ) gc . current . path . clear ( ) } 
func ( gc * graphiccontext ) fillstring ( text string ) ( cursor float64 ) { return gc . fillstringat ( text , 0 , 0 ) } 
func ( gc * graphiccontext ) fillstringat ( text string , x , y float64 ) ( cursor float64 ) { return gc . drawstring ( text , filled , x , y ) } 
func ( gc * graphiccontext ) strokestring ( text string ) ( cursor float64 ) { return gc . strokestringat ( text , 0 , 0 ) } 
func ( gc * graphiccontext ) strokestringat ( text string , x , y float64 ) ( cursor float64 ) { return gc . drawstring ( text , stroked , x , y ) } 
func ( gc * graphiccontext ) drawimage ( image image . image ) { bounds : = image . bounds ( ) svgimage : = & image { href : imagetosvghref ( image ) } svgimage . x = float64 ( bounds . min . x ) svgimage . y = float64 ( bounds . min . y ) svgimage . width = tosvglength ( float64 ( bounds . max . x - bounds . min . x ) ) svgimage . height = tosvglength ( float64 ( bounds . max . y - bounds . min . y ) ) gc . newgroup ( 0 ) . image = svgimage } 
func ( gc * graphiccontext ) clearrect ( x1 , y1 , x2 , y2 int ) { mask : = gc . newmask ( x1 , y1 , x2 - x1 , y2 - y1 ) newgroup : = & group { groups : gc . svg . groups , mask : " " + mask . id + " " , } gc . svg . groups = [ ] * group { newgroup } } 
func ( gc * graphiccontext ) drawpaths ( drawtype drawtype , paths ... * draw2d . path ) { svgpath : = path { } group : = gc . newgroup ( drawtype ) paths = append ( paths , gc . current . path ) svgpathsdesc : = make ( [ ] string , len ( paths ) ) for i , path : = range paths { svgpathsdesc [ i ] = tosvgpathdesc ( path ) } svgpath . desc = strings . join ( svgpathsdesc , " " ) group . paths = [ ] * path { & svgpath } } 
func ( gc * graphiccontext ) drawstring ( text string , drawtype drawtype , x , y float64 ) float64 { switch gc . svg . fontmode { case pathfontmode : w : = gc . createstringpath ( text , x , y ) gc . drawpaths ( drawtype ) gc . current . path . clear ( ) return w case svgfontmode : gc . embedsvgfont ( text ) } svgtext : = text { } group : = gc . newgroup ( drawtype ) svgtext . text = text svgtext . fontsize = gc . current . fontsize svgtext . x = x svgtext . y = y svgtext . fontfamily = gc . current . fontdata . name group . texts = [ ] * text { & svgtext } left , , right , : = gc . getstringbounds ( text ) return right - left } 
func ( gc * graphiccontext ) newgroup ( drawtype drawtype ) * group { group : = group { } if drawtype & stroked == stroked { group . stroke = tosvgrgba ( gc . current . strokecolor ) group . strokewidth = tosvglength ( gc . current . linewidth ) group . strokelinecap = gc . current . cap . string ( ) group . strokelinejoin = gc . current . join . string ( ) if len ( gc . current . dash ) > 0 { group . strokedasharray = tosvgarray ( gc . current . dash ) group . strokedashoffset = tosvglength ( gc . current . dashoffset ) } } if drawtype & filled == filled { group . fill = tosvgrgba ( gc . current . fillcolor ) group . fillrule = tosvgfillrule ( gc . current . fillrule ) } group . transform = tosvgtransform ( gc . current . tr ) gc . svg . groups = append ( gc . svg . groups , & group ) return & group } 
func ( gc * graphiccontext ) newmask ( x , y , width , height int ) * mask { mask : = & mask { } mask . x = float64 ( x ) mask . y = float64 ( y ) mask . width = tosvglength ( float64 ( width ) ) mask . height = tosvglength ( float64 ( height ) ) gc . svg . masks = append ( gc . svg . masks , mask ) mask . id = " " + strconv . itoa ( len ( gc . svg . masks ) ) return mask } 
func ( gc * graphiccontext ) embedsvgfont ( text string ) * font { fontname : = gc . current . fontdata . name gc . loadcurrentfont ( ) svgfont : = ( * font ) ( nil ) for , font : = range gc . svg . fonts { if font . name == fontname { svgfont = font break } } if svgfont == nil { svgfont = & font { } gc . svg . fonts = append ( gc . svg . fonts , svgfont ) } gc . save ( ) defer gc . restore ( ) gc . setfontsize ( 2048 ) defer gc . setdpi ( gc . getdpi ( ) ) gc . setdpi ( 92 ) filling : for , rune : = range text { for , g : = range svgfont . glyphs { if g . rune == rune ( rune ) { continue filling } } glyph : = gc . glyphcache . fetch ( gc , gc . getfontname ( ) , rune ) glyppath : = glyph . path . verticalflip ( ) svgfont . glyphs = append ( svgfont . glyphs , & glyph { rune : rune ( rune ) , desc : tosvgpathdesc ( glyppath ) , horizadvx : glyph . width , } ) } svgfont . id = " " + strconv . itoa ( len ( gc . svg . fonts ) ) svgfont . name = fontname svgfont . face = & face { family : fontname , units : 2048 , horizadvx : 2048 } return svgfont } 
func tracequad ( t liner , quad [ ] float64 , flatteningthreshold float64 ) error { if len ( quad ) < 6 { return errors . new ( " " ) } var curves [ curverecursionlimit * 6 ] float64 copy ( curves [ 0 : 6 ] , quad [ 0 : 6 ] ) i : = 0 var c [ ] float64 var dx , dy , d float64 for i >= 0 { c = curves [ i : ] dx = c [ 4 ] - c [ 0 ] dy = c [ 5 ] - c [ 1 ] d = math . abs ( ( ( c [ 2 ] - c [ 4 ] ) * dy - ( c [ 3 ] - c [ 5 ] ) * dx ) ) if ( d * d ) <= flatteningthreshold * ( dx * dx + dy * dy ) | | i == len ( curves ) - 6 { t . lineto ( c [ 4 ] , c [ 5 ] ) i - = 6 } else { subdividequad ( c , curves [ i + 6 : ] , curves [ i : ] ) i += 6 } } return nil } 
func ( cs * contextstack ) getfontname ( ) string { fontdata : = cs . fontdata return fmt . sprintf ( " " , fontdata . name , fontdata . family , fontdata . style , cs . fontsize ) } 
func newstackgraphiccontext ( ) * stackgraphiccontext { gc : = & stackgraphiccontext { } gc . current = new ( contextstack ) gc . current . tr = draw2d . newidentitymatrix ( ) gc . current . path = new ( draw2d . path ) gc . current . linewidth = 1 . 0 gc . current . strokecolor = image . black gc . current . fillcolor = image . white gc . current . cap = draw2d . roundcap gc . current . fillrule = draw2d . fillruleevenodd gc . current . join = draw2d . roundjoin gc . current . fontsize = 10 gc . current . fontdata = defaultfontdata return gc } 
func newfolderfontcache ( folder string ) * folderfontcache { return & folderfontcache { fonts : make ( map [ string ] * truetype . font ) , folder : folder , namer : fontfilename , } } 
func ( cache * folderfontcache ) load ( fontdata fontdata ) ( font * truetype . font , err error ) { if font = cache . fonts [ cache . namer ( fontdata ) ] ; font ! = nil { return font , nil } var data [ ] byte var file = cache . namer ( fontdata ) if data , err = ioutil . readfile ( filepath . join ( cache . folder , file ) ) ; err ! = nil { return } if font , err = truetype . parse ( data ) ; err ! = nil { return } cache . fonts [ file ] = font return } 
func ( cache * folderfontcache ) store ( fontdata fontdata , font * truetype . font ) { cache . fonts [ cache . namer ( fontdata ) ] = font } 
func newsyncfolderfontcache ( folder string ) * syncfolderfontcache { return & syncfolderfontcache { fonts : make ( map [ string ] * truetype . font ) , folder : folder , namer : fontfilename , } } 
func ( cache * syncfolderfontcache ) load ( fontdata fontdata ) ( font * truetype . font , err error ) { cache . rlock ( ) font = cache . fonts [ cache . namer ( fontdata ) ] cache . runlock ( ) if font ! = nil { return font , nil } var data [ ] byte var file = cache . namer ( fontdata ) if data , err = ioutil . readfile ( filepath . join ( cache . folder , file ) ) ; err ! = nil { return } if font , err = truetype . parse ( data ) ; err ! = nil { return } cache . lock ( ) cache . fonts [ file ] = font cache . unlock ( ) return } 
func ( cache * syncfolderfontcache ) store ( fontdata fontdata , font * truetype . font ) { cache . lock ( ) cache . fonts [ cache . namer ( fontdata ) ] = font cache . unlock ( ) } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { gc . setstrokecolor ( image . black ) gc . setfillcolor ( image . white ) gc . save ( ) gc . translate ( - 60 , 65 ) gc . rotate ( - 30 * ( math . pi / 180 . 0 ) ) draw ( gc , 48 , 48 , 240 , 72 ) gc . restore ( ) return samples . output ( " " , ext ) , nil } 
func newpdf ( orientationstr , unitstr , sizestr string ) * gofpdf . fpdf { pdf : = gofpdf . new ( orientationstr , unitstr , sizestr , draw2d . getfontfolder ( ) ) pdf . setmargins ( 0 , 0 , 0 ) pdf . setdrawcolor ( 0 , 0 , 0 ) pdf . setfillcolor ( 255 , 255 , 255 ) pdf . setlinecapstyle ( " " ) pdf . setlinejoinstyle ( " " ) pdf . setlinewidth ( 1 ) pdf . addpage ( ) return pdf } 
func rgb ( c color . color ) ( int , int , int ) { r , g , b , : = c . rgba ( ) return int ( float64 ( r ) * c255 ) , int ( float64 ( g ) * c255 ) , int ( float64 ( b ) * c255 ) } 
func clearrect ( gc * graphiccontext , x1 , y1 , x2 , y2 float64 ) { f : = gc . current . fillcolor x , y : = gc . pdf . getxy ( ) gc . setfillcolor ( white ) draw2dkit . rectangle ( gc , x1 , y1 , x2 , y2 ) gc . fill ( ) gc . setfillcolor ( f ) gc . pdf . moveto ( x , y ) } 
func newgraphiccontext ( pdf * gofpdf . fpdf ) * graphiccontext { gc : = & graphiccontext { draw2dbase . newstackgraphiccontext ( ) , pdf , dpi } gc . setdpi ( dpi ) return gc } 
func ( gc * graphiccontext ) drawimage ( image image . image ) { name : = strconv . itoa ( int ( imagecount ) ) imagecount ++ tp : = " " b : = & bytes . buffer { } png . encode ( b , image ) gc . pdf . registerimagereader ( name , tp , b ) bounds : = image . bounds ( ) x0 , y0 : = float64 ( bounds . min . x ) , float64 ( bounds . min . y ) w , h : = float64 ( bounds . dx ( ) ) , float64 ( bounds . dy ( ) ) gc . pdf . image ( name , x0 , y0 , w , h , false , tp , 0 , " " ) } 
func ( gc * graphiccontext ) clear ( ) { width , height : = gc . pdf . getpagesize ( ) clearrect ( gc , 0 , 0 , width , height ) } 
func ( gc * graphiccontext ) clearrect ( x1 , y1 , x2 , y2 int ) { clearrect ( gc , float64 ( x1 ) , float64 ( y1 ) , float64 ( x2 ) , float64 ( y2 ) ) } 
func ( gc * graphiccontext ) getstringbounds ( s string ) ( left , top , right , bottom float64 ) { , h : = gc . pdf . getfontsize ( ) d : = gc . pdf . getfontdesc ( " " , " " ) if d . ascent == 0 { top = 0 . 81 * h } else { top = - float64 ( d . ascent ) * h / float64 ( d . ascent - d . descent ) } return 0 , top , gc . pdf . getstringwidth ( s ) , top + h } 
func ( gc * graphiccontext ) createstringpath ( text string , x , y float64 ) ( cursor float64 ) { left , top , right , bottom : = gc . getstringbounds ( text ) w : = right - left h : = bottom - top margin : = gc . pdf . getcellmargin ( ) gc . pdf . moveto ( x - left - margin , y + top ) gc . pdf . cellformat ( w , h , text , " " , 0 , " " , false , 0 , " " ) return w } 
func ( gc * graphiccontext ) fillstringat ( text string , x , y float64 ) ( cursor float64 ) { return gc . createstringpath ( text , x , y ) } 
func ( gc * graphiccontext ) stroke ( paths ... * draw2d . path ) { , , , alphas : = gc . current . strokecolor . rgba ( ) gc . draw ( " " , alphas , paths ... ) gc . current . path . clear ( ) } 
func ( gc * graphiccontext ) fill ( paths ... * draw2d . path ) { style : = " " if gc . current . fillrule ! = draw2d . fillrulewinding { style += " " } , , , alphaf : = gc . current . fillcolor . rgba ( ) gc . draw ( style , alphaf , paths ... ) gc . current . path . clear ( ) } 
func ( gc * graphiccontext ) fillstroke ( paths ... * draw2d . path ) { var rule string if gc . current . fillrule ! = draw2d . fillrulewinding { rule = " " } , , , alphas : = gc . current . strokecolor . rgba ( ) , , , alphaf : = gc . current . fillcolor . rgba ( ) if alphas == alphaf { gc . draw ( " " + rule , alphaf , paths ... ) } else { gc . draw ( " " + rule , alphaf , paths ... ) gc . draw ( " " , alphas , paths ... ) } gc . current . path . clear ( ) } 
func ( gc * graphiccontext ) draw ( style string , alpha uint32 , paths ... * draw2d . path ) { paths = append ( paths , gc . current . path ) for , p : = range paths { convertpath ( p , gc . pdf ) } a : = float64 ( alpha ) / alphamax current , blendmode : = gc . pdf . getalpha ( ) if a ! = current { gc . pdf . setalpha ( a , blendmode ) } gc . pdf . drawpath ( style ) } 
func ( gc * graphiccontext ) setstrokecolor ( c color . color ) { gc . stackgraphiccontext . setstrokecolor ( c ) gc . pdf . setdrawcolor ( rgb ( c ) ) } 
func ( gc * graphiccontext ) setfillcolor ( c color . color ) { gc . stackgraphiccontext . setfillcolor ( c ) gc . pdf . setfillcolor ( rgb ( c ) ) gc . pdf . settextcolor ( rgb ( c ) ) } 
func ( gc * graphiccontext ) setfontsize ( fontsize float64 ) { gc . stackgraphiccontext . setfontsize ( fontsize ) gc . recalc ( ) gc . pdf . setfontsize ( fontsize * gc . current . scale ) } 
func ( gc * graphiccontext ) setlinedash ( dash [ ] float64 , dashoffset float64 ) { gc . stackgraphiccontext . setlinedash ( dash , dashoffset ) gc . pdf . setdashpattern ( dash , dashoffset ) } 
func ( gc * graphiccontext ) setlinewidth ( linewidth float64 ) { gc . stackgraphiccontext . setlinewidth ( linewidth ) gc . pdf . setlinewidth ( linewidth ) } 
func ( gc * graphiccontext ) setlinecap ( cap draw2d . linecap ) { gc . stackgraphiccontext . setlinecap ( cap ) gc . pdf . setlinecapstyle ( caps [ cap ] ) } 
func ( gc * graphiccontext ) setlinejoin ( join draw2d . linejoin ) { gc . stackgraphiccontext . setlinejoin ( join ) gc . pdf . setlinejoinstyle ( joins [ join ] ) } 
func ( gc * graphiccontext ) scale ( sx , sy float64 ) { gc . stackgraphiccontext . scale ( sx , sy ) gc . pdf . transformscale ( sx * 100 , sy * 100 , 0 , 0 ) } 
func ( gc * graphiccontext ) rotate ( angle float64 ) { gc . stackgraphiccontext . rotate ( angle ) gc . pdf . transformrotate ( - angle * 180 / math . pi , 0 , 0 ) } 
func ( gc * graphiccontext ) translate ( tx , ty float64 ) { gc . stackgraphiccontext . translate ( tx , ty ) gc . pdf . transformtranslate ( tx , ty ) } 
func ( gc * graphiccontext ) restore ( ) { gc . pdf . transformend ( ) gc . stackgraphiccontext . restore ( ) c : = gc . current gc . setfontsize ( c . fontsize ) gc . setlinewidth ( c . linewidth ) gc . setstrokecolor ( c . strokecolor ) gc . setfillcolor ( c . fillcolor ) gc . setfillrule ( c . fillrule ) gc . setlinecap ( c . cap ) gc . setlinejoin ( c . join ) } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { draw ( gc , fmt . sprintf ( " " , gc . getdpi ( ) ) ) return samples . output ( " " , ext ) , nil } 
func draw ( gc draw2d . graphiccontext , text string ) { draw2dkit . roundedrectangle ( gc , 5 , 5 , 135 , 95 , 10 , 10 ) gc . fillstroke ( ) gc . setfontdata ( draw2d . fontdata { name : " " , family : draw2d . fontfamilymono , style : draw2d . fontstylebold | draw2d . fontstyleitalic } ) gc . setfillcolor ( image . black ) gc . setfontsize ( 14 ) gc . fillstringat ( " " , 8 , 52 ) } 
func savetopngfile ( filepath string , m image . image ) error { f , err : = os . create ( filepath ) if err ! = nil { return err } defer f . close ( ) b : = bufio . newwriter ( f ) err = png . encode ( b , m ) if err ! = nil { return err } err = b . flush ( ) if err ! = nil { return err } return nil } 
func loadfrompngfile ( filepath string ) ( image . image , error ) { f , err : = os . openfile ( filepath , 0 , 0 ) if err ! = nil { return nil , err } defer f . close ( ) b : = bufio . newreader ( f ) img , err : = png . decode ( b ) if err ! = nil { return nil , err } return img , nil } 
func resource ( folder , filename , ext string ) string { var root string if ext == " " | | ext == " " { root = " " } return fmt . sprintf ( " " , root , folder , filename ) } 
func output ( name , ext string ) string { var root string if ext == " " | | ext == " " { root = " " } return fmt . sprintf ( " " , root , name , ext ) } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { gc . save ( ) gc . translate ( 0 , 200 ) gc . scale ( 0 . 35 , - 0 . 35 ) gc . translate ( 70 , - 200 ) tiger : = samples . resource ( " " , " " , ext ) draw ( gc , tiger ) gc . restore ( ) return samples . output ( " " , ext ) , nil } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { draw ( gc , 297 , 210 ) return samples . output ( " " , ext ) , nil } 
func bubble ( gc draw2d . graphiccontext , x , y , width , height float64 ) { sx , sy : = width / 100 , height / 100 gc . moveto ( x + sx * 50 , y ) gc . quadcurveto ( x , y , x , y + sy * 37 . 5 ) gc . quadcurveto ( x , y + sy * 75 , x + sx * 25 , y + sy * 75 ) gc . quadcurveto ( x + sx * 25 , y + sy * 95 , x + sx * 5 , y + sy * 100 ) gc . quadcurveto ( x + sx * 35 , y + sy * 95 , x + sx * 40 , y + sy * 75 ) gc . quadcurveto ( x + sx * 100 , y + sy * 75 , x + sx * 100 , y + sy * 37 . 5 ) gc . quadcurveto ( x + sx * 100 , y , x + sx * 50 , y ) gc . stroke ( ) } 
func dash ( gc draw2d . graphiccontext , x , y , width , height float64 ) { sx , sy : = width / 162 , height / 205 gc . setstrokecolor ( image . black ) gc . setlinedash ( [ ] float64 { height / 10 , height / 50 , height / 50 , height / 50 } , - 50 . 0 ) gc . setlinecap ( draw2d . buttcap ) gc . setlinejoin ( draw2d . roundjoin ) gc . setlinewidth ( height / 50 ) gc . moveto ( x + sx * 60 . 0 , y ) gc . lineto ( x + sx * 60 . 0 , y ) gc . lineto ( x + sx * 162 , y + sy * 205 ) rlineto ( gc , sx * - 102 . 4 , 0 ) gc . cubiccurveto ( x + sx * - 17 , y + sy * 205 , x + sx * - 17 , y + sy * 103 , x + sx * 60 . 0 , y + sy * 103 . 0 ) gc . stroke ( ) gc . setlinedash ( nil , 0 . 0 ) } 
func arc ( gc draw2d . graphiccontext , xc , yc , width , height float64 ) { xc += width / 2 yc += height / 2 radiusx , radiusy : = width / 2 , height / 2 startangle : = 45 * ( math . pi / 180 . 0 ) / * angles are specified * / angle : = 135 * ( math . pi / 180 . 0 ) / * clockwise in radians * / gc . setlinewidth ( width / 10 ) gc . setlinecap ( draw2d . buttcap ) gc . setstrokecolor ( image . black ) gc . moveto ( xc + math . cos ( startangle ) * radiusx , yc + math . sin ( startangle ) * radiusy ) gc . arcto ( xc , yc , radiusx , radiusy , startangle , angle ) gc . stroke ( ) gc . setstrokecolor ( color . nrgba { 255 , 0x33 , 0x33 , 0x80 } ) gc . setfillcolor ( color . nrgba { 255 , 0x33 , 0x33 , 0x80 } ) gc . setlinewidth ( width / 20 ) gc . moveto ( xc + math . cos ( startangle ) * radiusx , yc + math . sin ( startangle ) * radiusy ) gc . lineto ( xc , yc ) gc . lineto ( xc - radiusx , yc ) gc . stroke ( ) gc . moveto ( xc , yc ) gc . arcto ( xc , yc , width / 10 . 0 , height / 10 . 0 , 0 , 2 * math . pi ) gc . fill ( ) } 
func cubiccurve ( gc draw2d . graphiccontext , x , y , width , height float64 ) { sx , sy : = width / 162 , height / 205 x0 , y0 : = x , y + sy * 100 . 0 x1 , y1 : = x + sx * 75 , y + sy * 205 x2 , y2 : = x + sx * 125 , y x3 , y3 : = x + sx * 205 , y + sy * 100 gc . setstrokecolor ( image . black ) gc . setfillcolor ( color . nrgba { 0xaa , 0xaa , 0xaa , 0xff } ) gc . setlinewidth ( width / 10 ) gc . moveto ( x0 , y0 ) gc . cubiccurveto ( x1 , y1 , x2 , y2 , x3 , y3 ) gc . stroke ( ) gc . setstrokecolor ( color . nrgba { 0xff , 0x33 , 0x33 , 0x88 } ) gc . setlinewidth ( width / 20 ) gc . moveto ( x0 , y0 ) gc . lineto ( x1 , y1 ) gc . lineto ( x2 , y2 ) gc . lineto ( x3 , y3 ) gc . stroke ( ) } 
func fillstroke ( gc draw2d . graphiccontext , x , y , width , height float64 ) { sx , sy : = width / 210 , height / 215 gc . moveto ( x + sx * 113 . 0 , y ) gc . lineto ( x + sx * 215 . 0 , y + sy * 215 ) rlineto ( gc , sx * - 100 , 0 ) gc . cubiccurveto ( x + sx * 35 , y + sy * 215 , x + sx * 35 , y + sy * 113 , x + sx * 113 . 0 , y + sy * 113 ) gc . close ( ) gc . moveto ( x + sx * 50 . 0 , y ) rlineto ( gc , sx * 51 . 2 , sy * 51 . 2 ) rlineto ( gc , sx * - 51 . 2 , sy * 51 . 2 ) rlineto ( gc , sx * - 51 . 2 , sy * - 51 . 2 ) gc . close ( ) gc . setlinewidth ( width / 20 . 0 ) gc . setfillcolor ( color . nrgba { 0 , 0 , 0xff , 0xff } ) gc . setstrokecolor ( image . black ) gc . fillstroke ( ) } 
func pathtransform ( gc draw2d . graphiccontext , x , y , width , height float64 ) { gc . save ( ) gc . setlinewidth ( width / 10 ) gc . translate ( x + width / 2 , y + height / 2 ) gc . scale ( 1 , 4 ) gc . arcto ( 0 , 0 , width / 8 , height / 8 , 0 , math . pi * 2 ) gc . close ( ) gc . stroke ( ) gc . restore ( ) } 
func star ( gc draw2d . graphiccontext , x , y , width , height float64 ) { gc . save ( ) gc . translate ( x + width / 2 , y + height / 2 ) gc . setlinewidth ( width / 40 ) for i : = 0 . 0 ; i < 360 ; i = i + 10 { gc . save ( ) gc . rotate ( i * ( math . pi / 180 . 0 ) ) gc . moveto ( 0 , 0 ) gc . lineto ( width / 2 , 0 ) gc . stroke ( ) gc . restore ( ) } gc . restore ( ) } 
func draw ( gc draw2d . graphiccontext , width , height float64 ) { mx , my : = width * 0 . 025 , height * 0 . 025 dx , dy : = ( width - 2 * mx ) / 4 , ( height - 2 * my ) / 3 w , h : = dx - 2 * mx , dy - 2 * my x0 , y : = 2 * mx , 2 * my x : = x0 bubble ( gc , x , y , w , h ) x += dx curverectangle ( gc , x , y , w , h , color . nrgba { 0x80 , 0 , 0 , 0x80 } , color . nrgba { 0x80 , 0x80 , 0xff , 0xff } ) x += dx dash ( gc , x , y , w , h ) x += dx arc ( gc , x , y , w , h ) x = x0 y += dy arcnegative ( gc , x , y , w , h ) x += dx cubiccurve ( gc , x , y , w , h ) x += dx fillstring ( gc , x , y , w , h ) x += dx fillstroke ( gc , x , y , w , h ) x = x0 y += dy fillstyle ( gc , x , y , w , h ) x += dx pathtransform ( gc , x , y , w , h ) x += dx star ( gc , x , y , w , h ) x += dx gopher2 . draw ( gc , x , y , w , h / 2 ) } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { const offset = 75 . 0 x : = 35 . 0 caps : = [ ] draw2d . linecap { draw2d . buttcap , draw2d . squarecap , draw2d . roundcap } joins : = [ ] draw2d . linejoin { draw2d . beveljoin , draw2d . miterjoin , draw2d . roundjoin } for i : = range caps { draw ( gc , caps [ i ] , joins [ i ] , x , 50 , x , 160 , offset ) x += offset } return samples . output ( " " , ext ) , nil } 
func draw ( gc draw2d . graphiccontext , cap draw2d . linecap , join draw2d . linejoin , x0 , y0 , x1 , y1 , offset float64 ) { gc . setlinecap ( cap ) gc . setlinejoin ( join ) gc . setstrokecolor ( color . nrgba { 0x33 , 0x33 , 0x33 , 0xff } ) gc . setlinewidth ( 30 . 0 ) gc . moveto ( x0 , y0 ) gc . lineto ( ( x0 + x1 ) / 2 + offset , ( y0 + y1 ) / 2 ) gc . lineto ( x1 , y1 ) gc . stroke ( ) gc . setstrokecolor ( color . nrgba { 0xff , 0x33 , 0x33 , 0xff } ) gc . setlinewidth ( 2 . 56 ) gc . moveto ( x0 , y0 ) gc . lineto ( ( x0 + x1 ) / 2 + offset , ( y0 + y1 ) / 2 ) gc . lineto ( x1 , y1 ) gc . stroke ( ) } 
func drawcontour ( path draw2d . pathbuilder , ps [ ] truetype . point , dx , dy float64 ) { if len ( ps ) == 0 { return } startx , starty : = pointtof64point ( ps [ 0 ] ) path . moveto ( startx + dx , starty + dy ) q0x , q0y , on0 : = startx , starty , true for , p : = range ps [ 1 : ] { qx , qy : = pointtof64point ( p ) on : = p . flags & 0x01 ! = 0 if on { if on0 { path . lineto ( qx + dx , qy + dy ) } else { path . quadcurveto ( q0x + dx , q0y + dy , qx + dx , qy + dy ) } } else { if on0 { } else { midx : = ( q0x + qx ) / 2 midy : = ( q0y + qy ) / 2 path . quadcurveto ( q0x + dx , q0y + dy , midx + dx , midy + dy ) } } q0x , q0y , on0 = qx , qy , on } if on0 { path . lineto ( startx + dx , starty + dy ) } else { path . quadcurveto ( q0x + dx , q0y + dy , startx + dx , starty + dy ) } } 
func newgraphiccontext ( img draw . image ) * graphiccontext { var painter painter switch selectimage : = img . ( type ) { case * image . rgba : painter = raster . newrgbapainter ( selectimage ) default : panic ( " " ) } return newgraphiccontextwithpainter ( img , painter ) } 
func newgraphiccontextwithpainter ( img draw . image , painter painter ) * graphiccontext { width , height : = img . bounds ( ) . dx ( ) , img . bounds ( ) . dy ( ) dpi : = 92 gc : = & graphiccontext { draw2dbase . newstackgraphiccontext ( ) , img , painter , raster . newrasterizer ( width , height ) , raster . newrasterizer ( width , height ) , draw2d . getglobalfontcache ( ) , draw2dbase . newglyphcache ( ) , & truetype . glyphbuf { } , dpi , } return gc } 
func ( gc * graphiccontext ) clear ( ) { width , height : = gc . img . bounds ( ) . dx ( ) , gc . img . bounds ( ) . dy ( ) gc . clearrect ( 0 , 0 , width , height ) } 
func ( gc * graphiccontext ) clearrect ( x1 , y1 , x2 , y2 int ) { imagecolor : = image . newuniform ( gc . current . fillcolor ) draw . draw ( gc . img , image . rect ( x1 , y1 , x2 , y2 ) , imagecolor , image . zp , draw . over ) } 
func drawimage ( src image . image , dest draw . image , tr draw2d . matrix , op draw . op , filter imagefilter ) { var transformer draw . transformer switch filter { case linearfilter : transformer = draw . nearestneighbor case bilinearfilter : transformer = draw . bilinear case bicubicfilter : transformer = draw . catmullrom } transformer . transform ( dest , f64 . aff3 { tr [ 0 ] , tr [ 1 ] , tr [ 4 ] , tr [ 2 ] , tr [ 3 ] , tr [ 5 ] } , src , src . bounds ( ) , op , nil ) } 
func ( gc * graphiccontext ) drawimage ( img image . image ) { drawimage ( img , gc . img , gc . current . tr , draw . over , bilinearfilter ) } 
func ( gc * graphiccontext ) stroke ( paths ... * draw2d . path ) { paths = append ( paths , gc . current . path ) gc . strokerasterizer . usenonzerowinding = true stroker : = draw2dbase . newlinestroker ( gc . current . cap , gc . current . join , draw2dbase . transformer { tr : gc . current . tr , flattener : ftlinebuilder { adder : gc . strokerasterizer } } ) stroker . halflinewidth = gc . current . linewidth / 2 var liner draw2dbase . flattener if gc . current . dash ! = nil && len ( gc . current . dash ) > 0 { liner = draw2dbase . newdashconverter ( gc . current . dash , gc . current . dashoffset , stroker ) } else { liner = stroker } for , p : = range paths { draw2dbase . flatten ( p , liner , gc . current . tr . getscale ( ) ) } gc . paint ( gc . strokerasterizer , gc . current . strokecolor ) } 
func ( gc * graphiccontext ) fill ( paths ... * draw2d . path ) { paths = append ( paths , gc . current . path ) gc . fillrasterizer . usenonzerowinding = gc . current . fillrule == draw2d . fillrulewinding / * * * * first method * * * * / flattener : = draw2dbase . transformer { tr : gc . current . tr , flattener : ftlinebuilder { adder : gc . fillrasterizer } } for , p : = range paths { draw2dbase . flatten ( p , flattener , gc . current . tr . getscale ( ) ) } gc . paint ( gc . fillrasterizer , gc . current . fillcolor ) } 
func ( gc * graphiccontext ) fillstroke ( paths ... * draw2d . path ) { paths = append ( paths , gc . current . path ) gc . fillrasterizer . usenonzerowinding = gc . current . fillrule == draw2d . fillrulewinding gc . strokerasterizer . usenonzerowinding = true flattener : = draw2dbase . transformer { tr : gc . current . tr , flattener : ftlinebuilder { adder : gc . fillrasterizer } } stroker : = draw2dbase . newlinestroker ( gc . current . cap , gc . current . join , draw2dbase . transformer { tr : gc . current . tr , flattener : ftlinebuilder { adder : gc . strokerasterizer } } ) stroker . halflinewidth = gc . current . linewidth / 2 var liner draw2dbase . flattener if gc . current . dash ! = nil && len ( gc . current . dash ) > 0 { liner = draw2dbase . newdashconverter ( gc . current . dash , gc . current . dashoffset , stroker ) } else { liner = stroker } demux : = draw2dbase . demuxflattener { flatteners : [ ] draw2dbase . flattener { flattener , liner } } for , p : = range paths { draw2dbase . flatten ( p , demux , gc . current . tr . getscale ( ) ) } gc . paint ( gc . fillrasterizer , gc . current . fillcolor ) gc . paint ( gc . strokerasterizer , gc . current . strokecolor ) } 
func main ( gc draw2d . graphiccontext , ext string ) ( string , error ) { const margin = 30 const linewidth = 3 gopher : = samples . resource ( " " , " " , ext ) err : = draw ( gc , gopher , 297 , 210 , margin , linewidth ) return samples . output ( " " , ext ) , err } 
func draw ( gc draw2d . graphiccontext , png string , dw , dh , margin , linewidth float64 ) error { draw2dkit . roundedrectangle ( gc , linewidth , linewidth , dw - linewidth , dh - linewidth , 100 , 100 ) gc . setlinewidth ( linewidth ) gc . fillstroke ( ) source , err : = draw2dimg . loadfrompngfile ( png ) if err ! = nil { return err } sw , sh : = float64 ( source . bounds ( ) . dx ( ) ) , float64 ( source . bounds ( ) . dy ( ) ) scale : = math . min ( ( dw - margin * 2 ) / sw , ( dh - margin * 2 ) / sh ) gc . save ( ) gc . translate ( ( dw - sw * scale ) / 2 , ( dh - sh * scale ) / 2 ) gc . scale ( scale , scale ) gc . rotate ( 0 . 2 ) gc . drawimage ( source ) gc . restore ( ) return nil } 
func checksumstring32s ( s string , seed uint32 ) uint32 { if len ( s ) == 0 { return checksum32s ( nil , seed ) } ss : = ( * reflect . stringheader ) ( unsafe . pointer ( & s ) ) return checksum32s ( ( * [ maxint32 ] byte ) ( unsafe . pointer ( ss . data ) ) [ : len ( s ) : len ( s ) ] , seed ) } 
func checksumstring64s ( s string , seed uint64 ) uint64 { if len ( s ) == 0 { return checksum64s ( nil , seed ) } ss : = ( * reflect . stringheader ) ( unsafe . pointer ( & s ) ) return checksum64s ( ( * [ maxint32 ] byte ) ( unsafe . pointer ( ss . data ) ) [ : len ( s ) : len ( s ) ] , seed ) } 
func news32 ( seed uint32 ) ( xx * xxhash32 ) { xx = & xxhash32 { seed : seed , } xx . reset ( ) return } 
func ( xx * xxhash32 ) sum ( in [ ] byte ) [ ] byte { s : = xx . sum32 ( ) return append ( in , byte ( s > > 24 ) , byte ( s > > 16 ) , byte ( s > > 8 ) , byte ( s ) ) } 
func news64 ( seed uint64 ) ( xx * xxhash64 ) { xx = & xxhash64 { seed : seed , } xx . reset ( ) return } 
func ( xx * xxhash64 ) sum ( in [ ] byte ) [ ] byte { s : = xx . sum64 ( ) return append ( in , byte ( s > > 56 ) , byte ( s > > 48 ) , byte ( s > > 40 ) , byte ( s > > 32 ) , byte ( s > > 24 ) , byte ( s > > 16 ) , byte ( s > > 8 ) , byte ( s ) ) } 
func round64 ( h , v uint64 ) uint64 { h += v * prime64x2 h = rotl64 31 ( h ) h * = prime64x1 return h } 
func checksum64s ( in [ ] byte , seed uint64 ) uint64 { if len ( in ) == 0 && seed == 0 { return 0xef46db3751d8e999 } if len ( in ) > 31 { return checksum64 ( in , seed ) } return checksum64short ( in , seed ) } 
func getexecutablepath ( ) ( string , error ) { buf : = make ( [ ] uint16 , syscall . max path + 1 ) res , , err : = getmodulefilename . call ( 0 , uintptr ( unsafe . pointer ( & buf [ 0 ] ) ) , uintptr ( len ( buf ) ) ) if res == 0 | | res >= syscall . max path | | buf [ 0 ] == 0 | | buf [ res - 1 ] == 0 { return " " , fmt . errorf ( " " , res , err ) } return string ( utf16 . decode ( buf [ : res ] ) ) , nil } 
func getexecutablepath ( ) ( string , error ) { exepath , err : = readlink ( " " ) if err ! = nil { err = fmt . errorf ( " " , err ) } return filepath . clean ( exepath ) , err } 
func getexecutablepath ( ) ( string , error ) { path max : = 1024 exepath : = make ( [ ] byte , path max ) exelen : = c . size t ( len ( exepath ) ) var mib [ 4 ] c . int mib [ 0 ] = 1 mib [ 1 ] = 14 mib [ 2 ] = 12 mib [ 3 ] = - 1 status , err : = c . sysctl ( ( * c . int ) ( unsafe . pointer ( & mib [ 0 ] ) ) , 4 , unsafe . pointer ( & exepath [ 0 ] ) , & exelen , nil , 0 ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } if status ! = 0 { return " " , fmt . errorf ( " " , status ) } exepathstringlen : = bytes . index ( exepath , [ ] byte { 0 } ) exepathstring : = string ( exepath [ : exepathstringlen ] ) return filepath . clean ( exepathstring ) , nil } 
func readlink ( name string ) ( string , error ) { for len : = 128 ; ; len * = 2 { b : = make ( [ ] byte , len ) n , e : = syscall . readlink ( name , b ) if e ! = nil { return " " , & os . patherror { " " , name , e } } if n < len { if z : = bytes . indexbyte ( b [ : n ] , 0 ) ; z >= 0 { n = z } return string ( b [ : n ] ) , nil } } } 
func getexecutablepath ( ) ( string , error ) { path max : = 1024 exepath : = make ( [ ] byte , path max ) exelen : = c . uint32 t ( len ( exepath ) ) status , err : = c . nsgetexecutablepath ( ( * c . char ) ( unsafe . pointer ( & exepath [ 0 ] ) ) , & exelen ) if err ! = nil { return " " , fmt . errorf ( " " , err ) } if status ! = 0 { return " " , fmt . errorf ( " " , status ) } exepathstringlen : = bytes . index ( exepath , [ ] byte { 0 } ) exepathstring : = string ( exepath [ : exepathstringlen ] ) return filepath . clean ( exepathstring ) , nil } 
func stage ( ) daemonstage { if currstage == stageunknown { s , , : = getstage ( ) currstage = daemonstage ( s ) } return currstage } 
func get ( ) * glg { once . do ( func ( ) { fastime . setformat ( timeformat ) glg = new ( ) } ) return glg } 
func ( g * glg ) setmode ( mode mode ) * glg { g . logger . range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . mode = mode l . updatemode ( ) g . logger . store ( key . ( level ) , l ) return true } ) return g } 
func ( g * glg ) setlevelmode ( level level , mode mode ) * glg { lev , ok : = g . logger . load ( level ) if ok { l : = lev . ( * logger ) l . mode = mode l . updatemode ( ) g . logger . store ( level , l ) } return g } 
func ( g * glg ) setprefix ( pref string ) * glg { v , ok : = g . logger . load ( print ) if ok { value : = v . ( * logger ) value . tag = pref g . logger . store ( print , value ) } return g } 
func ( g * glg ) getcurrentmode ( level level ) mode { l , ok : = g . logger . load ( level ) if ok { return l . ( * logger ) . mode } return none } 
func ( g * glg ) initwriter ( ) * glg { g . logger . range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . writer = nil l . updatemode ( ) g . logger . store ( key . ( level ) , l ) return true } ) return g } 
func ( g * glg ) setwriter ( writer io . writer ) * glg { if writer == nil { return g } g . logger . range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . writer = writer l . updatemode ( ) g . logger . store ( key . ( level ) , l ) return true } ) return g } 
func ( g * glg ) setlevelcolor ( level level , color func ( string ) string ) * glg { lev , ok : = g . logger . load ( level ) if ok { l : = lev . ( * logger ) l . color = color g . logger . store ( level , l ) } return g } 
func ( g * glg ) setlevelwriter ( level level , writer io . writer ) * glg { if writer == nil { return g } lev , ok : = g . logger . load ( level ) if ok { l : = lev . ( * logger ) l . writer = writer l . updatemode ( ) g . logger . store ( level , l ) } return g } 
func ( g * glg ) addstdlevel ( tag string , mode mode , iscolor bool ) * glg { atomic . adduint32 ( g . levelcounter , 1 ) lev : = level ( atomic . loaduint32 ( g . levelcounter ) ) g . levelmap . store ( tag , lev ) l : = & logger { writer : nil , std : os . stdout , color : colorless , iscolor : iscolor , mode : mode , tag : tag , } l . updatemode ( ) g . logger . store ( lev , l ) return g } 
func ( g * glg ) enablecolor ( ) * glg { g . logger . range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . iscolor = true l . updatemode ( ) g . logger . store ( key . ( level ) , l ) return true } ) return g } 
func ( g * glg ) enablelevelcolor ( lv level ) * glg { ins , ok : = g . logger . load ( lv ) if ok { l : = ins . ( * logger ) l . iscolor = true l . updatemode ( ) g . logger . store ( lv , l ) } return g } 
func ( g * glg ) disablelevelcolor ( lv level ) * glg { ins , ok : = g . logger . load ( lv ) if ok { l : = ins . ( * logger ) l . iscolor = false l . updatemode ( ) g . logger . store ( lv , l ) } return g } 
func ( g * glg ) rawstring ( data [ ] byte ) string { str : = * ( * string ) ( unsafe . pointer ( & data ) ) return str [ strings . index ( str , sep ) + sepl : len ( str ) - rcl ] } 
func ( g * glg ) tagstringtolevel ( tag string ) level { l , ok : = g . levelmap . load ( tag ) if ! ok { return 255 } return l . ( level ) } 
func filewriter ( path string , perm os . filemode ) * os . file { if path == " " { return nil } var err error var file * os . file if , err = os . stat ( path ) ; err ! = nil { if , err = os . stat ( filepath . dir ( path ) ) ; err ! = nil { err = os . mkdirall ( filepath . dir ( path ) , perm ) if err ! = nil { return nil } } file , err = os . create ( path ) if err ! = nil { return nil } err = file . close ( ) if err ! = nil { return nil } } file , err = os . openfile ( path , os . o append | os . o create | os . o wronly , perm ) if err ! = nil { return nil } return file } 
func ( g * glg ) log ( val ... interface { } ) error { return g . out ( log , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) logf ( format string , val ... interface { } ) error { return g . out ( log , format , val ... ) } 
func ( g * glg ) logfunc ( f func ( ) string ) error { if g . ismodeenable ( log ) { return g . out ( log , " " , f ( ) ) } return nil } 
func log ( val ... interface { } ) error { return glg . out ( log , blankformat ( len ( val ) ) , val ... ) } 
func logf ( format string , val ... interface { } ) error { return glg . out ( log , format , val ... ) } 
func logfunc ( f func ( ) string ) error { if ismodeenable ( log ) { return glg . out ( log , " " , f ( ) ) } return nil } 
func ( g * glg ) info ( val ... interface { } ) error { return g . out ( info , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) infof ( format string , val ... interface { } ) error { return g . out ( info , format , val ... ) } 
func ( g * glg ) infofunc ( f func ( ) string ) error { if g . ismodeenable ( info ) { return g . out ( info , " " , f ( ) ) } return nil } 
func info ( val ... interface { } ) error { return glg . out ( info , blankformat ( len ( val ) ) , val ... ) } 
func infof ( format string , val ... interface { } ) error { return glg . out ( info , format , val ... ) } 
func infofunc ( f func ( ) string ) error { if ismodeenable ( info ) { return glg . out ( info , " " , f ( ) ) } return nil } 
func ( g * glg ) success ( val ... interface { } ) error { return g . out ( ok , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) successf ( format string , val ... interface { } ) error { return g . out ( ok , format , val ... ) } 
func ( g * glg ) successfunc ( f func ( ) string ) error { if g . ismodeenable ( ok ) { return g . out ( ok , " " , f ( ) ) } return nil } 
func success ( val ... interface { } ) error { return glg . out ( ok , blankformat ( len ( val ) ) , val ... ) } 
func successf ( format string , val ... interface { } ) error { return glg . out ( ok , format , val ... ) } 
func successfunc ( f func ( ) string ) error { if ismodeenable ( ok ) { return glg . out ( ok , " " , f ( ) ) } return nil } 
func ( g * glg ) debug ( val ... interface { } ) error { return g . out ( debg , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) debugf ( format string , val ... interface { } ) error { return g . out ( debg , format , val ... ) } 
func ( g * glg ) debugfunc ( f func ( ) string ) error { if g . ismodeenable ( debg ) { return g . out ( debg , " " , f ( ) ) } return nil } 
func debug ( val ... interface { } ) error { return glg . out ( debg , blankformat ( len ( val ) ) , val ... ) } 
func debugf ( format string , val ... interface { } ) error { return glg . out ( debg , format , val ... ) } 
func debugfunc ( f func ( ) string ) error { if ismodeenable ( debg ) { return glg . out ( debg , " " , f ( ) ) } return nil } 
func ( g * glg ) warn ( val ... interface { } ) error { return g . out ( warn , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) warnf ( format string , val ... interface { } ) error { return g . out ( warn , format , val ... ) } 
func ( g * glg ) warnfunc ( f func ( ) string ) error { if g . ismodeenable ( warn ) { return g . out ( warn , " " , f ( ) ) } return nil } 
func warn ( val ... interface { } ) error { return glg . out ( warn , blankformat ( len ( val ) ) , val ... ) } 
func warnf ( format string , val ... interface { } ) error { return glg . out ( warn , format , val ... ) } 
func warnfunc ( f func ( ) string ) error { if ismodeenable ( warn ) { return glg . out ( warn , " " , f ( ) ) } return nil } 
func ( g * glg ) customlog ( level string , val ... interface { } ) error { return g . out ( g . tagstringtolevel ( level ) , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) customlogf ( level string , format string , val ... interface { } ) error { return g . out ( g . tagstringtolevel ( level ) , format , val ... ) } 
func ( g * glg ) customlogfunc ( level string , f func ( ) string ) error { lv : = g . tagstringtolevel ( level ) if g . ismodeenable ( lv ) { return g . out ( lv , " " , f ( ) ) } return nil } 
func customlog ( level string , val ... interface { } ) error { return glg . out ( glg . tagstringtolevel ( level ) , blankformat ( len ( val ) ) , val ... ) } 
func customlogf ( level string , format string , val ... interface { } ) error { return glg . out ( glg . tagstringtolevel ( level ) , format , val ... ) } 
func customlogfunc ( level string , f func ( ) string ) error { lv : = tagstringtolevel ( level ) if ismodeenable ( lv ) { return glg . out ( lv , " " , f ( ) ) } return nil } 
func ( g * glg ) print ( val ... interface { } ) error { return g . out ( print , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) printf ( format string , val ... interface { } ) error { return g . out ( print , format , val ... ) } 
func ( g * glg ) printfunc ( f func ( ) string ) error { if g . ismodeenable ( print ) { return g . out ( print , " " , f ( ) ) } return nil } 
func print ( val ... interface { } ) error { return glg . out ( print , blankformat ( len ( val ) ) , val ... ) } 
func println ( val ... interface { } ) error { return glg . out ( print , blankformat ( len ( val ) ) , val ... ) } 
func printf ( format string , val ... interface { } ) error { return glg . out ( print , format , val ... ) } 
func printfunc ( f func ( ) string ) error { if ismodeenable ( print ) { return glg . out ( print , " " , f ( ) ) } return nil } 
func ( g * glg ) error ( val ... interface { } ) error { return g . out ( err , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) errorf ( format string , val ... interface { } ) error { return g . out ( err , format , val ... ) } 
func ( g * glg ) errorfunc ( f func ( ) string ) error { if g . ismodeenable ( err ) { return g . out ( err , " " , f ( ) ) } return nil } 
func error ( val ... interface { } ) error { return glg . out ( err , blankformat ( len ( val ) ) , val ... ) } 
func errorf ( format string , val ... interface { } ) error { return glg . out ( err , format , val ... ) } 
func errorfunc ( f func ( ) string ) error { if ismodeenable ( err ) { return glg . out ( err , " " , f ( ) ) } return nil } 
func ( g * glg ) fail ( val ... interface { } ) error { return g . out ( fail , blankformat ( len ( val ) ) , val ... ) } 
func ( g * glg ) failf ( format string , val ... interface { } ) error { return g . out ( fail , format , val ... ) } 
func ( g * glg ) failfunc ( f func ( ) string ) error { if g . ismodeenable ( fail ) { return g . out ( fail , " " , f ( ) ) } return nil } 
func fail ( val ... interface { } ) error { return glg . out ( fail , blankformat ( len ( val ) ) , val ... ) } 
func failf ( format string , val ... interface { } ) error { return glg . out ( fail , format , val ... ) } 
func failfunc ( f func ( ) string ) error { if ismodeenable ( fail ) { return glg . out ( fail , " " , f ( ) ) } return nil } 
func ( g * glg ) fatal ( val ... interface { } ) { err : = g . out ( fatal , blankformat ( len ( val ) ) , val ... ) if err ! = nil { err = g . error ( err . error ( ) ) if err ! = nil { panic ( err ) } } exit ( 1 ) } 
func ( g * glg ) fatalf ( format string , val ... interface { } ) { err : = g . out ( fatal , format , val ... ) if err ! = nil { err = g . error ( err . error ( ) ) if err ! = nil { panic ( err ) } } exit ( 1 ) } 
func ( g * glg ) ismodeenable ( l level ) bool { return g . getcurrentmode ( l ) ! = none } 
func capturemetrics ( hnd http . handler , w http . responsewriter , r * http . request ) metrics { return capturemetricsfn ( w , func ( ww http . responsewriter ) { hnd . servehttp ( ww , r ) } ) } 
func ( da * cedar ) get ( key [ ] byte , from , pos int ) * int { for ; pos < len ( key ) ; pos ++ { if value : = da . array [ from ] . value ; value >= 0 && value ! = valuelimit { to : = da . follow ( from , 0 ) da . array [ to ] . value = value } from = da . follow ( from , key [ pos ] ) } to : = from if da . array [ from ] . value < 0 { to = da . follow ( from , 0 ) } return & da . array [ to ] . value } 
func ( da * cedar ) pushsibling ( from , base int , label byte , haschild bool ) { c : = & da . ninfos [ from ] . child keeporder : = * c == 0 if da . ordered { keeporder = label > * c } if haschild && keeporder { c = & da . ninfos [ base ^ int ( * c ) ] . sibling for da . ordered && * c ! = 0 && * c < label { c = & da . ninfos [ base ^ int ( * c ) ] . sibling } } da . ninfos [ base ^ int ( label ) ] . sibling = * c * c = label } 
func ( da * cedar ) save ( out io . writer , datatype string ) error { switch datatype { case " " , " " : dataeecoder : = gob . newencoder ( out ) return dataeecoder . encode ( da . cedar ) case " " , " " : dataeecoder : = json . newencoder ( out ) return dataeecoder . encode ( da . cedar ) } return errinvaliddatatype } 
func ( da * cedar ) savetofile ( filename string , datatype string ) error { file , err : = os . openfile ( filename , os . o create | os . o wronly , 0666 ) if err ! = nil { return err } defer file . close ( ) out : = bufio . newwriter ( file ) defer out . flush ( ) da . save ( out , datatype ) return nil } 
func ( da * cedar ) load ( in io . reader , datatype string ) error { switch datatype { case " " , " " : datadecoder : = gob . newdecoder ( in ) return datadecoder . decode ( da . cedar ) case " " , " " : datadecoder : = json . newdecoder ( in ) return datadecoder . decode ( da . cedar ) } return errinvaliddatatype } 
func ( da * cedar ) loadfromfile ( filename string , datatype string ) error { file , err : = os . openfile ( filename , os . o rdonly , 0600 ) defer file . close ( ) if err ! = nil { return err } in : = bufio . newreader ( file ) return da . load ( in , datatype ) } 
func ( da * cedar ) status ( ) ( keys , nodes , size , capacity int ) { for i : = 0 ; i < da . size ; i ++ { n : = da . array [ i ] if n . check >= 0 { nodes ++ if n . value >= 0 { keys ++ } } } return keys , nodes , da . size , da . capacity } 
func ( da * cedar ) jump ( path [ ] byte , from int ) ( to int , err error ) { for , b : = range path { if da . array [ from ] . value >= 0 { return from , errnopath } to = da . array [ from ] . base ( ) ^ int ( b ) if da . array [ to ] . check ! = from { return from , errnopath } from = to } return to , nil } 
func ( da * cedar ) key ( id int ) ( key [ ] byte , err error ) { for id > 0 { from : = da . array [ id ] . check if from < 0 { return nil , errnopath } if char : = byte ( da . array [ from ] . base ( ) ^ id ) ; char ! = 0 { key = append ( key , char ) } id = from } if id ! = 0 | | len ( key ) == 0 { return nil , errinvalidkey } for i : = 0 ; i < len ( key ) / 2 ; i ++ { key [ i ] , key [ len ( key ) - i - 1 ] = key [ len ( key ) - i - 1 ] , key [ i ] } return key , nil } 
func ( da * cedar ) value ( id int ) ( value int , err error ) { value = da . array [ id ] . value if value >= 0 { return value , nil } to : = da . array [ id ] . base ( ) if da . array [ to ] . check == id && da . array [ to ] . value >= 0 { return da . array [ to ] . value , nil } return 0 , errnovalue } 
func ( da * cedar ) insert ( key [ ] byte , value int ) error { if value < 0 | | value >= valuelimit { return errinvalidvalue } p : = da . get ( key , 0 , 0 ) * p = value return nil } 
func ( da * cedar ) update ( key [ ] byte , value int ) error { p : = da . get ( key , 0 , 0 ) if * p == valuelimit { * p = value return nil } if * p + value < 0 | | * p + value >= valuelimit { return errinvalidvalue } * p += value return nil } 
func ( da * cedar ) delete ( key [ ] byte ) error { to , err : = da . jump ( key , 0 ) if err ! = nil { return errnopath } if da . array [ to ] . value < 0 { base : = da . array [ to ] . base ( ) if da . array [ base ] . check == to { to = base } } for to > 0 { from : = da . array [ to ] . check base : = da . array [ from ] . base ( ) label : = byte ( to ^ base ) if da . ninfos [ to ] . sibling ! = 0 | | da . ninfos [ from ] . child ! = label { da . popsibling ( from , base , label ) da . pushenode ( to ) break } da . pushenode ( to ) to = from } return nil } 
func ( da * cedar ) get ( key [ ] byte ) ( value int , err error ) { to , err : = da . jump ( key , 0 ) if err ! = nil { return 0 , err } return da . value ( to ) } 
func ( da * cedar ) prefixmatch ( key [ ] byte , num int ) ( ids [ ] int ) { for from , i : = 0 , 0 ; i < len ( key ) ; i ++ { to , err : = da . jump ( key [ i : i + 1 ] , from ) if err ! = nil { break } if , err : = da . value ( to ) ; err == nil { ids = append ( ids , to ) num -- if num == 0 { return } } from = to } return } 
func ( da * cedar ) prefixpredict ( key [ ] byte , num int ) ( ids [ ] int ) { root , err : = da . jump ( key , 0 ) if err ! = nil { return } for from , err : = da . begin ( root ) ; err == nil ; from , err = da . next ( from , root ) { ids = append ( ids , from ) num -- if num == 0 { return } } return } 
func ( v * version ) set ( version string ) error { metadata : = splitoff ( & version , " " ) prerelease : = prerelease ( splitoff ( & version , " " ) ) dotparts : = strings . splitn ( version , " " , 3 ) if len ( dotparts ) ! = 3 { return fmt . errorf ( " " , version ) } if err : = validateidentifier ( string ( prerelease ) ) ; err ! = nil { return fmt . errorf ( " " , err ) } if err : = validateidentifier ( metadata ) ; err ! = nil { return fmt . errorf ( " " , err ) } parsed : = make ( [ ] int64 , 3 , 3 ) for i , v : = range dotparts [ : 3 ] { val , err : = strconv . parseint ( v , 10 , 64 ) parsed [ i ] = val if err ! = nil { return err } } v . metadata = metadata v . prerelease = prerelease v . major = parsed [ 0 ] v . minor = parsed [ 1 ] v . patch = parsed [ 2 ] return nil } 
func ( v version ) compare ( versionb version ) int { if cmp : = recursivecompare ( v . slice ( ) , versionb . slice ( ) ) ; cmp ! = 0 { return cmp } return prereleasecompare ( v , versionb ) } 
func ( v version ) slice ( ) [ ] int64 { return [ ] int64 { v . major , v . minor , v . patch } } 
func ( v * version ) bumpmajor ( ) { v . major += 1 v . minor = 0 v . patch = 0 v . prerelease = prerelease ( " " ) v . metadata = " " } 
func ( v * version ) bumpminor ( ) { v . minor += 1 v . patch = 0 v . prerelease = prerelease ( " " ) v . metadata = " " } 
func ( v * version ) bumppatch ( ) { v . patch += 1 v . prerelease = prerelease ( " " ) v . metadata = " " } 
func validateidentifier ( id string ) error { if id ! = " " && ! reidentifier . matchstring ( id ) { return fmt . errorf ( " " , id ) } return nil } 
func newstream ( bufsize int , replay bool ) * stream { return & stream { autoreplay : replay , subscribers : make ( [ ] * subscriber , 0 ) , register : make ( chan * subscriber ) , deregister : make ( chan * subscriber ) , event : make ( chan * event , bufsize ) , quit : make ( chan bool ) , eventlog : make ( eventlog , 0 ) , } } 
func ( str * stream ) addsubscriber ( eventid string ) * subscriber { sub : = & subscriber { eventid : eventid , quit : str . deregister , connection : make ( chan * event , 64 ) , } str . register < - sub return sub } 
func new ( ) * server { return & server { buffersize : defaultbuffersize , autostream : false , autoreplay : true , streams : make ( map [ string ] * stream ) , } } 
func ( s * server ) close ( ) { s . mu . lock ( ) defer s . mu . unlock ( ) for id : = range s . streams { s . streams [ id ] . quit < - true delete ( s . streams , id ) } } 
func ( s * server ) createstream ( id string ) * stream { s . mu . lock ( ) defer s . mu . unlock ( ) if s . streams [ id ] ! = nil { return s . streams [ id ] } str : = newstream ( s . buffersize , s . autoreplay ) str . run ( ) s . streams [ id ] = str return str } 
func ( s * server ) removestream ( id string ) { s . mu . lock ( ) defer s . mu . unlock ( ) if s . streams [ id ] ! = nil { s . streams [ id ] . close ( ) delete ( s . streams , id ) } } 
func ( s * server ) streamexists ( id string ) bool { s . mu . lock ( ) defer s . mu . unlock ( ) return s . streams [ id ] ! = nil } 
func ( s * server ) publish ( id string , event * event ) { s . mu . lock ( ) defer s . mu . unlock ( ) if s . streams [ id ] ! = nil { s . streams [ id ] . event < - s . process ( event ) } } 
func newclient ( url string ) * client { return & client { url : url , connection : & http . client { } , headers : make ( map [ string ] string ) , subscribed : make ( map [ chan * event ] chan bool ) , } } 
func ( c * client ) subscribe ( stream string , handler func ( msg * event ) ) error { operation : = func ( ) error { resp , err : = c . request ( stream ) if err ! = nil { return err } defer resp . body . close ( ) reader : = neweventstreamreader ( resp . body ) for { event , err : = reader . readevent ( ) if err ! = nil { if err == io . eof { return nil } if c . disconnectcb ! = nil { c . disconnectcb ( c ) } return err } if msg , err : = c . processevent ( event ) ; err == nil { if len ( msg . id ) > 0 { c . eventid = string ( msg . id ) } else { msg . id = [ ] byte ( c . eventid ) } handler ( msg ) } } } return backoff . retry ( operation , backoff . newexponentialbackoff ( ) ) } 
func ( c * client ) subscriberaw ( handler func ( msg * event ) ) error { return c . subscribe ( " " , handler ) } 
func ( c * client ) unsubscribe ( ch chan * event ) { c . mu . lock ( ) defer c . mu . unlock ( ) if c . subscribed [ ch ] ! = nil { c . subscribed [ ch ] < - true } } 
func neweventstreamreader ( eventstream io . reader ) * eventstreamreader { scanner : = bufio . newscanner ( eventstream ) split : = func ( data [ ] byte , ateof bool ) ( int , [ ] byte , error ) { if ateof && len ( data ) == 0 { return 0 , nil , nil } if i : = bytes . index ( data , [ ] byte ( " \n \n " ) ) ; i >= 0 { return i + 1 , data [ 0 : i ] , nil } if i : = bytes . index ( data , [ ] byte ( " " ) ) ; i >= 0 { return i + 1 , data [ 0 : i ] , nil } if i : = bytes . index ( data , [ ] byte ( " \n \n " ) ) ; i >= 0 { return i + 1 , data [ 0 : i ] , nil } if ateof { return len ( data ) , data , nil } return 0 , nil , nil } scanner . split ( split ) return & eventstreamreader { scanner : scanner , } } 
func ( e * eventstreamreader ) readevent ( ) ( [ ] byte , error ) { if e . scanner . scan ( ) { event : = e . scanner . bytes ( ) return event , nil } if err : = e . scanner . err ( ) ; err ! = nil { return nil , err } return nil , io . eof } 
func ( e * eventlog ) add ( ev * event ) { ev . id = [ ] byte ( e . currentindex ( ) ) ev . timestamp = time . now ( ) ( * e ) = append ( ( * e ) , ev ) } 
func ( e * eventlog ) replay ( s * subscriber ) { for i : = 0 ; i < len ( ( * e ) ) ; i ++ { if string ( ( * e ) [ i ] . id ) >= s . eventid { s . connection < - ( * e ) [ i ] } } } 
func readconfig ( ) ( * userconfig , error ) { b , err : = ioutil . readfile ( filepath . join ( configdir , accountfile ) ) if err ! = nil { return nil , err } uc : = & userconfig { } if err : = json . unmarshal ( b , uc ) ; err ! = nil { return nil , err } if key , err : = readkey ( filepath . join ( configdir , accountkey ) ) ; err == nil { uc . key = key } return uc , nil } 
func writeconfig ( uc * userconfig ) error { b , err : = json . marshalindent ( uc , " " , " " ) if err ! = nil { return err } if err : = os . mkdirall ( configdir , 0700 ) ; err ! = nil { return err } return ioutil . writefile ( filepath . join ( configdir , accountfile ) , b , 0600 ) } 
func readkey ( path string ) ( crypto . signer , error ) { b , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } d , : = pem . decode ( b ) if d == nil { return nil , fmt . errorf ( " " , path ) } switch d . type { case rsaprivatekey : return x509 . parsepkcs1privatekey ( d . bytes ) case ecprivatekey : return x509 . parseecprivatekey ( d . bytes ) default : return nil , fmt . errorf ( " " , d . type ) } } 
func writekey ( path string , k * ecdsa . privatekey ) error { f , err : = os . openfile ( path , os . o wronly | os . o create | os . o trunc , 0600 ) if err ! = nil { return err } bytes , err : = x509 . marshalecprivatekey ( k ) if err ! = nil { return err } b : = & pem . block { type : ecprivatekey , bytes : bytes } if err : = pem . encode ( f , b ) ; err ! = nil { f . close ( ) return err } return f . close ( ) } 
func anykey ( filename string , gen bool ) ( crypto . signer , error ) { k , err : = readkey ( filename ) if err == nil { return k , nil } if ! os . isnotexist ( err ) | | ! gen { return nil , err } eckey , err : = ecdsa . generatekey ( elliptic . p256 ( ) , rand . reader ) if err ! = nil { return nil , err } return eckey , writekey ( filename , eckey ) } 
func samedir ( existing , filename string ) string { return filepath . join ( filepath . dir ( existing ) , filename ) } 
func printaccount ( w io . writer , a * acme . account , kp string ) { tw : = tabwriter . newwriter ( w , 0 , 8 , 0 , ' \ t ' , 0 ) fmt . fprintln ( tw , " \ t " , a . uri ) fmt . fprintln ( tw , " \ t " , kp ) fmt . fprintln ( tw , " \ t " , strings . join ( a . contact , " " ) ) fmt . fprintln ( tw , " \ t " , a . currentterms ) agreed : = a . agreedterms if a . agreedterms == " " { agreed = " " } else if a . agreedterms == a . currentterms { agreed = " " } fmt . fprintln ( tw , " \ t " , agreed ) tw . flush ( ) } 
func tmpl ( w io . writer , text string , data interface { } ) { t : = template . new ( " " ) t . funcs ( template . funcmap { " " : strings . trimspace , " " : capitalize , } ) template . must ( t . parse ( text ) ) ew : = & errwriter { w : w } err : = t . execute ( ew , data ) if ew . err ! = nil { if strings . contains ( ew . err . error ( ) , " " ) { os . exit ( 1 ) } fatalf ( " " , ew . err ) } if err ! = nil { panic ( err ) } } 
func printusage ( w io . writer ) { bw : = bufio . newwriter ( w ) tmpl ( bw , usagetemplate , commands ) bw . flush ( ) } 
func ( c * command ) name ( ) string { name : = c . usageline i : = strings . indexrune ( name , ' ' ) if i >= 0 { name = name [ : i ] } return name } 
func ( p * clearparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandclear , p , nil ) } 
func ( p * disableparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddisable , nil , nil ) } 
func ( p * getdomstorageitemsparams ) do ( ctx context . context ) ( entries [ ] item , err error ) { var res getdomstorageitemsreturns err = cdp . execute ( ctx , commandgetdomstorageitems , p , & res ) if err ! = nil { return nil , err } return res . entries , nil } 
func ( p * removedomstorageitemparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremovedomstorageitem , p , nil ) } 
func ( p * setdomstorageitemparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdomstorageitem , p , nil ) } 
func ( v traceconfig ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * traceconfig ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing ( & r , v ) return r . error ( ) } 
func ( v startparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v requestmemorydumpreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestmemorydumpreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing2 ( & r , v ) return r . error ( ) } 
func ( v requestmemorydumpparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestmemorydumpparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing3 ( & r , v ) return r . error ( ) } 
func ( v recordclocksyncmarkerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * recordclocksyncmarkerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing4 ( & r , v ) return r . error ( ) } 
func ( v memorydumpconfig ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * memorydumpconfig ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing5 ( & r , v ) return r . error ( ) } 
func ( v getcategoriesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcategoriesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing6 ( & r , v ) return r . error ( ) } 
func ( v getcategoriesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcategoriesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing7 ( & r , v ) return r . error ( ) } 
func ( v eventtracingcomplete ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventtracingcomplete ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing8 ( & r , v ) return r . error ( ) } 
func ( v eventdatacollected ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdatacollected ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing9 ( & r , v ) return r . error ( ) } 
func ( v eventbufferusage ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventbufferusage ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing10 ( & r , v ) return r . error ( ) } 
func ( v endparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototracing11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * endparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototracing11 ( & r , v ) return r . error ( ) } 
func ( p * deliverpushmessageparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddeliverpushmessage , p , nil ) } 
func ( p * dispatchsynceventparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddispatchsyncevent , p , nil ) } 
func ( p * inspectworkerparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandinspectworker , p , nil ) } 
func ( p * setforceupdateonpageloadparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetforceupdateonpageload , p , nil ) } 
func ( p * skipwaitingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandskipwaiting , p , nil ) } 
func ( p * startworkerparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstartworker , p , nil ) } 
func ( p * stopallworkersparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopallworkers , nil , nil ) } 
func ( p * stopworkerparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopworker , p , nil ) } 
func ( p * unregisterparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandunregister , p , nil ) } 
func ( p * updateregistrationparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandupdateregistration , p , nil ) } 
func ( p * bindparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandbind , p , nil ) } 
func ( p * unbindparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandunbind , p , nil ) } 
func ( v getencodedresponsereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaudits ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getencodedresponsereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaudits ( & r , v ) return r . error ( ) } 
func ( v getencodedresponseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaudits1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getencodedresponseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaudits1 ( & r , v ) return r . error ( ) } 
func ( e * exceptiondetails ) error ( ) string { return fmt . sprintf ( " " , e . text , e . linenumber , e . columnnumber ) } 
func ( t * timestamp ) unmarshaleasyjson ( in * jlexer . lexer ) { * t = timestamp ( time . unix ( 0 , int64 ( in . float64 ( ) * float64 ( time . millisecond ) ) ) ) } 
func ( t * timestamp ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t type ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * type ) unmarshaleasyjson ( in * jlexer . lexer ) { switch type ( in . string ( ) ) { case typeobject : * t = typeobject case typefunction : * t = typefunction case typeundefined : * t = typeundefined case typestring : * t = typestring case typenumber : * t = typenumber case typeboolean : * t = typeboolean case typesymbol : * t = typesymbol case typebigint : * t = typebigint case typeaccessor : * t = typeaccessor default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * type ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t subtype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * subtype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch subtype ( in . string ( ) ) { case subtypearray : * t = subtypearray case subtypenull : * t = subtypenull case subtypenode : * t = subtypenode case subtyperegexp : * t = subtyperegexp case subtypedate : * t = subtypedate case subtypemap : * t = subtypemap case subtypeset : * t = subtypeset case subtypeweakmap : * t = subtypeweakmap case subtypeweakset : * t = subtypeweakset case subtypeiterator : * t = subtypeiterator case subtypegenerator : * t = subtypegenerator case subtypeerror : * t = subtypeerror case subtypeproxy : * t = subtypeproxy case subtypepromise : * t = subtypepromise case subtypetypedarray : * t = subtypetypedarray case subtypearraybuffer : * t = subtypearraybuffer case subtypedataview : * t = subtypedataview default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * subtype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t apitype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * apitype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch apitype ( in . string ( ) ) { case apitypelog : * t = apitypelog case apitypedebug : * t = apitypedebug case apitypeinfo : * t = apitypeinfo case apitypeerror : * t = apitypeerror case apitypewarning : * t = apitypewarning case apitypedir : * t = apitypedir case apitypedirxml : * t = apitypedirxml case apitypetable : * t = apitypetable case apitypetrace : * t = apitypetrace case apitypeclear : * t = apitypeclear case apitypestartgroup : * t = apitypestartgroup case apitypestartgroupcollapsed : * t = apitypestartgroupcollapsed case apitypeendgroup : * t = apitypeendgroup case apitypeassert : * t = apitypeassert case apitypeprofile : * t = apitypeprofile case apitypeprofileend : * t = apitypeprofileend case apitypecount : * t = apitypecount case apitypetimeend : * t = apitypetimeend default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * apitype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v requestdatabasereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestdatabasereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb ( & r , v ) return r . error ( ) } 
func ( v requestdatabaseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestdatabaseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb1 ( & r , v ) return r . error ( ) } 
func ( v requestdatabasenamesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestdatabasenamesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb2 ( & r , v ) return r . error ( ) } 
func ( v requestdatabasenamesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestdatabasenamesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb3 ( & r , v ) return r . error ( ) } 
func ( v requestdatareturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestdatareturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb4 ( & r , v ) return r . error ( ) } 
func ( v requestdataparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestdataparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb5 ( & r , v ) return r . error ( ) } 
func ( v objectstoreindex ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * objectstoreindex ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb6 ( & r , v ) return r . error ( ) } 
func ( v objectstore ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * objectstore ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb7 ( & r , v ) return r . error ( ) } 
func ( v keyrange ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * keyrange ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb8 ( & r , v ) return r . error ( ) } 
func ( v keypath ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * keypath ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb9 ( & r , v ) return r . error ( ) } 
func ( v key ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * key ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb10 ( & r , v ) return r . error ( ) } 
func ( v getmetadatareturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmetadatareturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb11 ( & r , v ) return r . error ( ) } 
func ( v getmetadataparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmetadataparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb12 ( & r , v ) return r . error ( ) } 
func ( v deleteobjectstoreentriesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * deleteobjectstoreentriesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb15 ( & r , v ) return r . error ( ) } 
func ( v deletedatabaseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * deletedatabaseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb16 ( & r , v ) return r . error ( ) } 
func ( v databasewithobjectstores ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * databasewithobjectstores ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb17 ( & r , v ) return r . error ( ) } 
func ( v * dataentry ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb18 ( & r , v ) return r . error ( ) } 
func ( v clearobjectstoreparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoindexeddb19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * clearobjectstoreparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoindexeddb19 ( & r , v ) return r . error ( ) } 
func ( v violationsetting ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolog ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * violationsetting ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolog ( & r , v ) return r . error ( ) } 
func ( v stopviolationsreportparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolog1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopviolationsreportparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolog1 ( & r , v ) return r . error ( ) } 
func ( v startviolationsreportparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolog2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * startviolationsreportparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolog2 ( & r , v ) return r . error ( ) } 
func ( v evententryadded ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolog3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * evententryadded ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolog3 ( & r , v ) return r . error ( ) } 
func ( v entry ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolog4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * entry ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolog4 ( & r , v ) return r . error ( ) } 
func ( v stickypositionconstraint ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stickypositionconstraint ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree ( & r , v ) return r . error ( ) } 
func ( v snapshotcommandlogreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * snapshotcommandlogreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree1 ( & r , v ) return r . error ( ) } 
func ( v snapshotcommandlogparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * snapshotcommandlogparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree2 ( & r , v ) return r . error ( ) } 
func ( v scrollrect ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * scrollrect ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree3 ( & r , v ) return r . error ( ) } 
func ( v replaysnapshotreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * replaysnapshotreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree4 ( & r , v ) return r . error ( ) } 
func ( v replaysnapshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * replaysnapshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree5 ( & r , v ) return r . error ( ) } 
func ( v releasesnapshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * releasesnapshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree6 ( & r , v ) return r . error ( ) } 
func ( v profilesnapshotreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * profilesnapshotreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree7 ( & r , v ) return r . error ( ) } 
func ( v profilesnapshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * profilesnapshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree8 ( & r , v ) return r . error ( ) } 
func ( v picturetile ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * picturetile ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree9 ( & r , v ) return r . error ( ) } 
func ( v makesnapshotreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * makesnapshotreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree10 ( & r , v ) return r . error ( ) } 
func ( v makesnapshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * makesnapshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree11 ( & r , v ) return r . error ( ) } 
func ( v loadsnapshotreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * loadsnapshotreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree12 ( & r , v ) return r . error ( ) } 
func ( v loadsnapshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * loadsnapshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree13 ( & r , v ) return r . error ( ) } 
func ( v layer ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * layer ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree14 ( & r , v ) return r . error ( ) } 
func ( v eventlayertreedidchange ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventlayertreedidchange ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree15 ( & r , v ) return r . error ( ) } 
func ( v eventlayerpainted ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventlayerpainted ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree16 ( & r , v ) return r . error ( ) } 
func ( v enableparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v compositingreasonsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * compositingreasonsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree19 ( & r , v ) return r . error ( ) } 
func ( v compositingreasonsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotolayertree20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * compositingreasonsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotolayertree20 ( & r , v ) return r . error ( ) } 
func ( t stylesheetorigin ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * stylesheetorigin ) unmarshaleasyjson ( in * jlexer . lexer ) { switch stylesheetorigin ( in . string ( ) ) { case stylesheetorigininjected : * t = stylesheetorigininjected case stylesheetoriginuseragent : * t = stylesheetoriginuseragent case stylesheetorigininspector : * t = stylesheetorigininspector case stylesheetoriginregular : * t = stylesheetoriginregular default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * stylesheetorigin ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t mediasource ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * mediasource ) unmarshaleasyjson ( in * jlexer . lexer ) { switch mediasource ( in . string ( ) ) { case mediasourcemediarule : * t = mediasourcemediarule case mediasourceimportrule : * t = mediasourceimportrule case mediasourcelinkedsheet : * t = mediasourcelinkedsheet case mediasourceinlinesheet : * t = mediasourceinlinesheet default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * mediasource ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v takeheapsnapshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takeheapsnapshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler ( & r , v ) return r . error ( ) } 
func ( v stoptrackingheapobjectsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stoptrackingheapobjectsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler1 ( & r , v ) return r . error ( ) } 
func ( v stopsamplingreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopsamplingreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler2 ( & r , v ) return r . error ( ) } 
func ( v * stopsamplingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler3 ( & r , v ) return r . error ( ) } 
func ( v starttrackingheapobjectsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * starttrackingheapobjectsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler4 ( & r , v ) return r . error ( ) } 
func ( v samplingheapprofilesample ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * samplingheapprofilesample ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler6 ( & r , v ) return r . error ( ) } 
func ( v samplingheapprofilenode ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * samplingheapprofilenode ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler7 ( & r , v ) return r . error ( ) } 
func ( v samplingheapprofile ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * samplingheapprofile ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler8 ( & r , v ) return r . error ( ) } 
func ( v getsamplingprofilereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getsamplingprofilereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler9 ( & r , v ) return r . error ( ) } 
func ( v getsamplingprofileparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getsamplingprofileparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler10 ( & r , v ) return r . error ( ) } 
func ( v getobjectbyheapobjectidreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getobjectbyheapobjectidreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler11 ( & r , v ) return r . error ( ) } 
func ( v getobjectbyheapobjectidparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getobjectbyheapobjectidparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler12 ( & r , v ) return r . error ( ) } 
func ( v getheapobjectidreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getheapobjectidreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler13 ( & r , v ) return r . error ( ) } 
func ( v getheapobjectidparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getheapobjectidparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler14 ( & r , v ) return r . error ( ) } 
func ( v eventresetprofiles ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventresetprofiles ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler15 ( & r , v ) return r . error ( ) } 
func ( v eventreportheapsnapshotprogress ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventreportheapsnapshotprogress ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler16 ( & r , v ) return r . error ( ) } 
func ( v eventlastseenobjectid ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventlastseenobjectid ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler17 ( & r , v ) return r . error ( ) } 
func ( v eventheapstatsupdate ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventheapstatsupdate ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler18 ( & r , v ) return r . error ( ) } 
func ( v eventaddheapsnapshotchunk ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventaddheapsnapshotchunk ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler19 ( & r , v ) return r . error ( ) } 
func ( v collectgarbageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * collectgarbageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler22 ( & r , v ) return r . error ( ) } 
func ( v addinspectedheapobjectparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheapprofiler23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * addinspectedheapobjectparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheapprofiler23 ( & r , v ) return r . error ( ) } 
func ( p * getcurrenttimeparams ) do ( ctx context . context ) ( currenttime float64 , err error ) { var res getcurrenttimereturns err = cdp . execute ( ctx , commandgetcurrenttime , p , & res ) if err ! = nil { return 0 , err } return res . currenttime , nil } 
func ( p * getplaybackrateparams ) do ( ctx context . context ) ( playbackrate float64 , err error ) { var res getplaybackratereturns err = cdp . execute ( ctx , commandgetplaybackrate , nil , & res ) if err ! = nil { return 0 , err } return res . playbackrate , nil } 
func ( p * releaseanimationsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandreleaseanimations , p , nil ) } 
func ( p * resolveanimationparams ) do ( ctx context . context ) ( remoteobject * runtime . remoteobject , err error ) { var res resolveanimationreturns err = cdp . execute ( ctx , commandresolveanimation , p , & res ) if err ! = nil { return nil , err } return res . remoteobject , nil } 
func ( p * seekanimationsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandseekanimations , p , nil ) } 
func ( p * setpausedparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetpaused , p , nil ) } 
func ( p * setplaybackrateparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetplaybackrate , p , nil ) } 
func ( p * settimingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsettiming , p , nil ) } 
func ( v empty ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdproto ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * empty ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdproto ( & r , v ) return r . error ( ) } 
func ( v message ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdproto1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * message ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdproto1 ( & r , v ) return r . error ( ) } 
func ( v error ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdproto2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * error ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdproto2 ( & r , v ) return r . error ( ) } 
func ( p * getdomcountersparams ) do ( ctx context . context ) ( documents int64 , nodes int64 , jseventlisteners int64 , err error ) { var res getdomcountersreturns err = cdp . execute ( ctx , commandgetdomcounters , nil , & res ) if err ! = nil { return 0 , 0 , 0 , err } return res . documents , res . nodes , res . jseventlisteners , nil } 
func ( p * prepareforleakdetectionparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandprepareforleakdetection , nil , nil ) } 
func ( p * forciblypurgejavascriptmemoryparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandforciblypurgejavascriptmemory , nil , nil ) } 
func ( p * setpressurenotificationssuppressedparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetpressurenotificationssuppressed , p , nil ) } 
func ( p * simulatepressurenotificationparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsimulatepressurenotification , p , nil ) } 
func ( p startsamplingparams ) withsamplinginterval ( samplinginterval int64 ) * startsamplingparams { p . samplinginterval = samplinginterval return & p } 
func ( p startsamplingparams ) withsuppressrandomness ( suppressrandomness bool ) * startsamplingparams { p . suppressrandomness = suppressrandomness return & p } 
func ( p * startsamplingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstartsampling , p , nil ) } 
func ( p * stopsamplingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopsampling , nil , nil ) } 
func ( p * getalltimesamplingprofileparams ) do ( ctx context . context ) ( profile * samplingprofile , err error ) { var res getalltimesamplingprofilereturns err = cdp . execute ( ctx , commandgetalltimesamplingprofile , nil , & res ) if err ! = nil { return nil , err } return res . profile , nil } 
func ( p * getbrowsersamplingprofileparams ) do ( ctx context . context ) ( profile * samplingprofile , err error ) { var res getbrowsersamplingprofilereturns err = cdp . execute ( ctx , commandgetbrowsersamplingprofile , nil , & res ) if err ! = nil { return nil , err } return res . profile , nil } 
func ( p * getsamplingprofileparams ) do ( ctx context . context ) ( profile * samplingprofile , err error ) { var res getsamplingprofilereturns err = cdp . execute ( ctx , commandgetsamplingprofile , nil , & res ) if err ! = nil { return nil , err } return res . profile , nil } 
func ( t source ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * source ) unmarshaleasyjson ( in * jlexer . lexer ) { switch source ( in . string ( ) ) { case sourcexml : * t = sourcexml case sourcejavascript : * t = sourcejavascript case sourcenetwork : * t = sourcenetwork case sourcestorage : * t = sourcestorage case sourceappcache : * t = sourceappcache case sourcerendering : * t = sourcerendering case sourcesecurity : * t = sourcesecurity case sourcedeprecation : * t = sourcedeprecation case sourceworker : * t = sourceworker case sourceviolation : * t = sourceviolation case sourceintervention : * t = sourceintervention case sourcerecommendation : * t = sourcerecommendation case sourceother : * t = sourceother default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * source ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t level ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * level ) unmarshaleasyjson ( in * jlexer . lexer ) { switch level ( in . string ( ) ) { case levelverbose : * t = levelverbose case levelinfo : * t = levelinfo case levelwarning : * t = levelwarning case levelerror : * t = levelerror default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * level ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t violation ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * violation ) unmarshaleasyjson ( in * jlexer . lexer ) { switch violation ( in . string ( ) ) { case violationlongtask : * t = violationlongtask case violationlonglayout : * t = violationlonglayout case violationblockedevent : * t = violationblockedevent case violationblockedparser : * t = violationblockedparser case violationdiscouragedapiuse : * t = violationdiscouragedapiuse case violationhandler : * t = violationhandler case violationrecurringhandler : * t = violationrecurringhandler default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * violation ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t windowstate ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * windowstate ) unmarshaleasyjson ( in * jlexer . lexer ) { switch windowstate ( in . string ( ) ) { case windowstatenormal : * t = windowstatenormal case windowstateminimized : * t = windowstateminimized case windowstatemaximized : * t = windowstatemaximized case windowstatefullscreen : * t = windowstatefullscreen default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * windowstate ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t permissiontype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * permissiontype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch permissiontype ( in . string ( ) ) { case permissiontypeaccessibilityevents : * t = permissiontypeaccessibilityevents case permissiontypeaudiocapture : * t = permissiontypeaudiocapture case permissiontypebackgroundsync : * t = permissiontypebackgroundsync case permissiontypebackgroundfetch : * t = permissiontypebackgroundfetch case permissiontypeclipboardread : * t = permissiontypeclipboardread case permissiontypeclipboardwrite : * t = permissiontypeclipboardwrite case permissiontypedurablestorage : * t = permissiontypedurablestorage case permissiontypeflash : * t = permissiontypeflash case permissiontypegeolocation : * t = permissiontypegeolocation case permissiontypemidi : * t = permissiontypemidi case permissiontypemidisysex : * t = permissiontypemidisysex case permissiontypenotifications : * t = permissiontypenotifications case permissiontypepaymenthandler : * t = permissiontypepaymenthandler case permissiontypeprotectedmediaidentifier : * t = permissiontypeprotectedmediaidentifier case permissiontypesensors : * t = permissiontypesensors case permissiontypevideocapture : * t = permissiontypevideocapture case permissiontypeidledetection : * t = permissiontypeidledetection default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * permissiontype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( p * cleardeviceorientationoverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcleardeviceorientationoverride , nil , nil ) } 
func ( p * setdeviceorientationoverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdeviceorientationoverride , p , nil ) } 
func ( t requeststage ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * requeststage ) unmarshaleasyjson ( in * jlexer . lexer ) { switch requeststage ( in . string ( ) ) { case requeststagerequest : * t = requeststagerequest case requeststageresponse : * t = requeststageresponse default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * requeststage ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t authchallengesource ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * authchallengesource ) unmarshaleasyjson ( in * jlexer . lexer ) { switch authchallengesource ( in . string ( ) ) { case authchallengesourceserver : * t = authchallengesourceserver case authchallengesourceproxy : * t = authchallengesourceproxy default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * authchallengesource ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t authchallengeresponseresponse ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * authchallengeresponseresponse ) unmarshaleasyjson ( in * jlexer . lexer ) { switch authchallengeresponseresponse ( in . string ( ) ) { case authchallengeresponseresponsedefault : * t = authchallengeresponseresponsedefault case authchallengeresponseresponsecancelauth : * t = authchallengeresponseresponsecancelauth case authchallengeresponseresponseprovidecredentials : * t = authchallengeresponseresponseprovidecredentials default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * authchallengeresponseresponse ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t mixedcontenttype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * mixedcontenttype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch mixedcontenttype ( in . string ( ) ) { case mixedcontenttypeblockable : * t = mixedcontenttypeblockable case mixedcontenttypeoptionallyblockable : * t = mixedcontenttypeoptionallyblockable case mixedcontenttypenone : * t = mixedcontenttypenone default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * mixedcontenttype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t state ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * state ) unmarshaleasyjson ( in * jlexer . lexer ) { switch state ( in . string ( ) ) { case stateunknown : * t = stateunknown case stateneutral : * t = stateneutral case stateinsecure : * t = stateinsecure case statesecure : * t = statesecure case stateinfo : * t = stateinfo default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * state ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t certificateerroraction ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * certificateerroraction ) unmarshaleasyjson ( in * jlexer . lexer ) { switch certificateerroraction ( in . string ( ) ) { case certificateerroractioncontinue : * t = certificateerroractioncontinue case certificateerroractioncancel : * t = certificateerroractioncancel default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * certificateerroraction ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t * type ) unmarshaleasyjson ( in * jlexer . lexer ) { switch type ( in . string ( ) ) { case typeappcache : * t = typeappcache case typecookies : * t = typecookies case typefilesystems : * t = typefilesystems case typeindexeddb : * t = typeindexeddb case typelocalstorage : * t = typelocalstorage case typeshadercache : * t = typeshadercache case typewebsql : * t = typewebsql case typeserviceworkers : * t = typeserviceworkers case typecachestorage : * t = typecachestorage case typeall : * t = typeall case typeother : * t = typeother default : in . adderror ( errors . new ( " " ) ) } } 
func ( p * getrealtimedataparams ) do ( ctx context . context ) ( realtimedata * contextrealtimedata , err error ) { var res getrealtimedatareturns err = cdp . execute ( ctx , commandgetrealtimedata , p , & res ) if err ! = nil { return nil , err } return res . realtimedata , nil } 
func ( t screenshotparamsformat ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * screenshotparamsformat ) unmarshaleasyjson ( in * jlexer . lexer ) { switch screenshotparamsformat ( in . string ( ) ) { case screenshotparamsformatjpeg : * t = screenshotparamsformatjpeg case screenshotparamsformatpng : * t = screenshotparamsformatpng default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * screenshotparamsformat ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( p * startviolationsreportparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstartviolationsreport , p , nil ) } 
func ( p * stopviolationsreportparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopviolationsreport , nil , nil ) } 
func ( v takeresponsebodyasstreamreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takeresponsebodyasstreamreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch ( & r , v ) return r . error ( ) } 
func ( v takeresponsebodyasstreamparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takeresponsebodyasstreamparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch1 ( & r , v ) return r . error ( ) } 
func ( v requestpattern ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestpattern ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch2 ( & r , v ) return r . error ( ) } 
func ( v headerentry ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * headerentry ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch3 ( & r , v ) return r . error ( ) } 
func ( v getresponsebodyreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getresponsebodyreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch4 ( & r , v ) return r . error ( ) } 
func ( v * getresponsebodyparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch5 ( & r , v ) return r . error ( ) } 
func ( v fulfillrequestparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * fulfillrequestparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch6 ( & r , v ) return r . error ( ) } 
func ( v failrequestparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * failrequestparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch7 ( & r , v ) return r . error ( ) } 
func ( v eventrequestpaused ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventrequestpaused ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch8 ( & r , v ) return r . error ( ) } 
func ( v eventauthrequired ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventauthrequired ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch9 ( & r , v ) return r . error ( ) } 
func ( v disableparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v continuewithauthparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * continuewithauthparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch12 ( & r , v ) return r . error ( ) } 
func ( v continuerequestparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * continuerequestparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch13 ( & r , v ) return r . error ( ) } 
func ( v authchallengeresponse ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v authchallenge ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotofetch15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * authchallenge ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotofetch15 ( & r , v ) return r . error ( ) } 
func ( t gesturetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * gesturetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch gesturetype ( in . string ( ) ) { case gesturedefault : * t = gesturedefault case gesturetouch : * t = gesturetouch case gesturemouse : * t = gesturemouse default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * gesturetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t timesinceepoch ) marshaleasyjson ( out * jwriter . writer ) { v : = float64 ( time . time ( t ) . unixnano ( ) / int64 ( time . second ) ) out . buffer . ensurespace ( 20 ) out . buffer . buf = strconv . appendfloat ( out . buffer . buf , v , ' f ' , - 1 , 64 ) } 
func ( t * timesinceepoch ) unmarshaleasyjson ( in * jlexer . lexer ) { * t = timesinceepoch ( time . unix ( 0 , int64 ( in . float64 ( ) * float64 ( time . second ) ) ) ) } 
func ( t * timesinceepoch ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t modifier ) string ( ) string { switch t { case modifiernone : return " " case modifieralt : return " " case modifierctrl : return " " case modifiermeta : return " " case modifiershift : return " " } return fmt . sprintf ( " " , t ) } 
func ( t modifier ) marshaleasyjson ( out * jwriter . writer ) { out . int64 ( int64 ( t ) ) } 
func ( t * modifier ) unmarshaleasyjson ( in * jlexer . lexer ) { switch modifier ( in . int64 ( ) ) { case modifiernone : * t = modifiernone case modifieralt : * t = modifieralt case modifierctrl : * t = modifierctrl case modifiermeta : * t = modifiermeta case modifiershift : * t = modifiershift default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * modifier ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t keytype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * keytype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch keytype ( in . string ( ) ) { case keydown : * t = keydown case keyup : * t = keyup case keyrawdown : * t = keyrawdown case keychar : * t = keychar default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * keytype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t mousetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * mousetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch mousetype ( in . string ( ) ) { case mousepressed : * t = mousepressed case mousereleased : * t = mousereleased case mousemoved : * t = mousemoved case mousewheel : * t = mousewheel default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * mousetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t buttontype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * buttontype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch buttontype ( in . string ( ) ) { case buttonnone : * t = buttonnone case buttonleft : * t = buttonleft case buttonmiddle : * t = buttonmiddle case buttonright : * t = buttonright case buttonback : * t = buttonback case buttonforward : * t = buttonforward default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * buttontype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t dispatchmouseeventpointertype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * dispatchmouseeventpointertype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch dispatchmouseeventpointertype ( in . string ( ) ) { case mouse : * t = mouse case pen : * t = pen default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * dispatchmouseeventpointertype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t touchtype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * touchtype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch touchtype ( in . string ( ) ) { case touchstart : * t = touchstart case touchend : * t = touchend case touchmove : * t = touchmove case touchcancel : * t = touchcancel default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * touchtype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t dombreakpointtype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * dombreakpointtype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch dombreakpointtype ( in . string ( ) ) { case dombreakpointtypesubtreemodified : * t = dombreakpointtypesubtreemodified case dombreakpointtypeattributemodified : * t = dombreakpointtypeattributemodified case dombreakpointtypenoderemoved : * t = dombreakpointtypenoderemoved default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * dombreakpointtype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t scopetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * scopetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch scopetype ( in . string ( ) ) { case scopetypeglobal : * t = scopetypeglobal case scopetypelocal : * t = scopetypelocal case scopetypewith : * t = scopetypewith case scopetypeclosure : * t = scopetypeclosure case scopetypecatch : * t = scopetypecatch case scopetypeblock : * t = scopetypeblock case scopetypescript : * t = scopetypescript case scopetypeeval : * t = scopetypeeval case scopetypemodule : * t = scopetypemodule default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * scopetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t breaklocationtype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * breaklocationtype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch breaklocationtype ( in . string ( ) ) { case breaklocationtypedebuggerstatement : * t = breaklocationtypedebuggerstatement case breaklocationtypecall : * t = breaklocationtypecall case breaklocationtypereturn : * t = breaklocationtypereturn default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * breaklocationtype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t pausedreason ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * pausedreason ) unmarshaleasyjson ( in * jlexer . lexer ) { switch pausedreason ( in . string ( ) ) { case pausedreasonxhr : * t = pausedreasonxhr case pausedreasondom : * t = pausedreasondom case pausedreasoneventlistener : * t = pausedreasoneventlistener case pausedreasonexception : * t = pausedreasonexception case pausedreasonassert : * t = pausedreasonassert case pausedreasondebugcommand : * t = pausedreasondebugcommand case pausedreasonpromiserejection : * t = pausedreasonpromiserejection case pausedreasonoom : * t = pausedreasonoom case pausedreasonother : * t = pausedreasonother case pausedreasonambiguous : * t = pausedreasonambiguous default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * pausedreason ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t continuetolocationtargetcallframes ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * continuetolocationtargetcallframes ) unmarshaleasyjson ( in * jlexer . lexer ) { switch continuetolocationtargetcallframes ( in . string ( ) ) { case continuetolocationtargetcallframesany : * t = continuetolocationtargetcallframesany case continuetolocationtargetcallframescurrent : * t = continuetolocationtargetcallframescurrent default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * continuetolocationtargetcallframes ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t exceptionsstate ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * exceptionsstate ) unmarshaleasyjson ( in * jlexer . lexer ) { switch exceptionsstate ( in . string ( ) ) { case exceptionsstatenone : * t = exceptionsstatenone case exceptionsstateuncaught : * t = exceptionsstateuncaught case exceptionsstateall : * t = exceptionsstateall default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * exceptionsstate ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( p getpartialaxtreeparams ) withnodeid ( nodeid cdp . nodeid ) * getpartialaxtreeparams { p . nodeid = nodeid return & p } 
func ( p getpartialaxtreeparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * getpartialaxtreeparams { p . backendnodeid = backendnodeid return & p } 
func ( p getpartialaxtreeparams ) withobjectid ( objectid runtime . remoteobjectid ) * getpartialaxtreeparams { p . objectid = objectid return & p } 
func ( p getpartialaxtreeparams ) withfetchrelatives ( fetchrelatives bool ) * getpartialaxtreeparams { p . fetchrelatives = fetchrelatives return & p } 
func ( p * getpartialaxtreeparams ) do ( ctx context . context ) ( nodes [ ] * node , err error ) { var res getpartialaxtreereturns err = cdp . execute ( ctx , commandgetpartialaxtree , p , & res ) if err ! = nil { return nil , err } return res . nodes , nil } 
func ( p * getfullaxtreeparams ) do ( ctx context . context ) ( nodes [ ] * node , err error ) { var res getfullaxtreereturns err = cdp . execute ( ctx , commandgetfullaxtree , nil , & res ) if err ! = nil { return nil , err } return res . nodes , nil } 
func ( v touchpoint ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * touchpoint ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput ( & r , v ) return r . error ( ) } 
func ( v synthesizetapgestureparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * synthesizetapgestureparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput1 ( & r , v ) return r . error ( ) } 
func ( v synthesizescrollgestureparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * synthesizescrollgestureparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput2 ( & r , v ) return r . error ( ) } 
func ( v synthesizepinchgestureparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * synthesizepinchgestureparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput3 ( & r , v ) return r . error ( ) } 
func ( v setignoreinputeventsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setignoreinputeventsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput4 ( & r , v ) return r . error ( ) } 
func ( v inserttextparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * inserttextparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput5 ( & r , v ) return r . error ( ) } 
func ( v emulatetouchfrommouseeventparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * emulatetouchfrommouseeventparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput6 ( & r , v ) return r . error ( ) } 
func ( v dispatchtoucheventparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * dispatchtoucheventparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput7 ( & r , v ) return r . error ( ) } 
func ( v dispatchmouseeventparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * dispatchmouseeventparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput8 ( & r , v ) return r . error ( ) } 
func ( v dispatchkeyeventparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinput9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * dispatchkeyeventparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinput9 ( & r , v ) return r . error ( ) } 
func ( p * settimedomainparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsettimedomain , p , nil ) } 
func ( p * getmetricsparams ) do ( ctx context . context ) ( metrics [ ] * metric , err error ) { var res getmetricsreturns err = cdp . execute ( ctx , commandgetmetrics , nil , & res ) if err ! = nil { return nil , err } return res . metrics , nil } 
func ( p * compositingreasonsparams ) do ( ctx context . context ) ( compositingreasons [ ] string , err error ) { var res compositingreasonsreturns err = cdp . execute ( ctx , commandcompositingreasons , p , & res ) if err ! = nil { return nil , err } return res . compositingreasons , nil } 
func ( p * loadsnapshotparams ) do ( ctx context . context ) ( snapshotid snapshotid , err error ) { var res loadsnapshotreturns err = cdp . execute ( ctx , commandloadsnapshot , p , & res ) if err ! = nil { return " " , err } return res . snapshotid , nil } 
func ( p * makesnapshotparams ) do ( ctx context . context ) ( snapshotid snapshotid , err error ) { var res makesnapshotreturns err = cdp . execute ( ctx , commandmakesnapshot , p , & res ) if err ! = nil { return " " , err } return res . snapshotid , nil } 
func ( p profilesnapshotparams ) withminrepeatcount ( minrepeatcount int64 ) * profilesnapshotparams { p . minrepeatcount = minrepeatcount return & p } 
func ( p profilesnapshotparams ) withminduration ( minduration float64 ) * profilesnapshotparams { p . minduration = minduration return & p } 
func ( p profilesnapshotparams ) withcliprect ( cliprect * dom . rect ) * profilesnapshotparams { p . cliprect = cliprect return & p } 
func ( p * profilesnapshotparams ) do ( ctx context . context ) ( timings [ ] paintprofile , err error ) { var res profilesnapshotreturns err = cdp . execute ( ctx , commandprofilesnapshot , p , & res ) if err ! = nil { return nil , err } return res . timings , nil } 
func ( p * releasesnapshotparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandreleasesnapshot , p , nil ) } 
func ( p replaysnapshotparams ) withfromstep ( fromstep int64 ) * replaysnapshotparams { p . fromstep = fromstep return & p } 
func ( p replaysnapshotparams ) withtostep ( tostep int64 ) * replaysnapshotparams { p . tostep = tostep return & p } 
func ( p replaysnapshotparams ) withscale ( scale float64 ) * replaysnapshotparams { p . scale = scale return & p } 
func ( p * replaysnapshotparams ) do ( ctx context . context ) ( dataurl string , err error ) { var res replaysnapshotreturns err = cdp . execute ( ctx , commandreplaysnapshot , p , & res ) if err ! = nil { return " " , err } return res . dataurl , nil } 
func ( p * snapshotcommandlogparams ) do ( ctx context . context ) ( commandlog [ ] easyjson . rawmessage , err error ) { var res snapshotcommandlogreturns err = cdp . execute ( ctx , commandsnapshotcommandlog , p , & res ) if err ! = nil { return nil , err } return res . commandlog , nil } 
func ( v websocketresponse ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * websocketresponse ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork ( & r , v ) return r . error ( ) } 
func ( v websocketrequest ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * websocketrequest ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork1 ( & r , v ) return r . error ( ) } 
func ( v websocketframe ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * websocketframe ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork2 ( & r , v ) return r . error ( ) } 
func ( v takeresponsebodyforinterceptionasstreamreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takeresponsebodyforinterceptionasstreamreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork3 ( & r , v ) return r . error ( ) } 
func ( v takeresponsebodyforinterceptionasstreamparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takeresponsebodyforinterceptionasstreamparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork4 ( & r , v ) return r . error ( ) } 
func ( v signedexchangesignature ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * signedexchangesignature ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork5 ( & r , v ) return r . error ( ) } 
func ( v signedexchangeinfo ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * signedexchangeinfo ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork6 ( & r , v ) return r . error ( ) } 
func ( v signedexchangeheader ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * signedexchangeheader ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork7 ( & r , v ) return r . error ( ) } 
func ( v signedexchangeerror ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * signedexchangeerror ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork8 ( & r , v ) return r . error ( ) } 
func ( v signedcertificatetimestamp ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * signedcertificatetimestamp ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork9 ( & r , v ) return r . error ( ) } 
func ( v setrequestinterceptionparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setrequestinterceptionparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork10 ( & r , v ) return r . error ( ) } 
func ( v setextrahttpheadersparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setextrahttpheadersparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork11 ( & r , v ) return r . error ( ) } 
func ( v setdatasizelimitsfortestparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdatasizelimitsfortestparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork12 ( & r , v ) return r . error ( ) } 
func ( v setcookiesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setcookiesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork13 ( & r , v ) return r . error ( ) } 
func ( v setcookiereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setcookiereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork14 ( & r , v ) return r . error ( ) } 
func ( v setcookieparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setcookieparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork15 ( & r , v ) return r . error ( ) } 
func ( v setcachedisabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setcachedisabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork16 ( & r , v ) return r . error ( ) } 
func ( v setbypassserviceworkerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbypassserviceworkerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork17 ( & r , v ) return r . error ( ) } 
func ( v setblockedurlsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setblockedurlsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork18 ( & r , v ) return r . error ( ) } 
func ( v securitydetails ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * securitydetails ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork19 ( & r , v ) return r . error ( ) } 
func ( v searchinresponsebodyreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * searchinresponsebodyreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork20 ( & r , v ) return r . error ( ) } 
func ( v searchinresponsebodyparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * searchinresponsebodyparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork21 ( & r , v ) return r . error ( ) } 
func ( v response ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v resourcetiming ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resourcetiming ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork23 ( & r , v ) return r . error ( ) } 
func ( v request ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork25 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * request ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork25 ( & r , v ) return r . error ( ) } 
func ( v replayxhrparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * replayxhrparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork26 ( & r , v ) return r . error ( ) } 
func ( v initiator ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork27 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * initiator ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork27 ( & r , v ) return r . error ( ) } 
func ( v getresponsebodyparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork29 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v getresponsebodyforinterceptionreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork30 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getresponsebodyforinterceptionreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork30 ( & r , v ) return r . error ( ) } 
func ( v getresponsebodyforinterceptionparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork31 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getresponsebodyforinterceptionparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork31 ( & r , v ) return r . error ( ) } 
func ( v getrequestpostdatareturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork32 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getrequestpostdatareturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork32 ( & r , v ) return r . error ( ) } 
func ( v getrequestpostdataparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork33 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getrequestpostdataparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork33 ( & r , v ) return r . error ( ) } 
func ( v getcookiesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork34 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcookiesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork34 ( & r , v ) return r . error ( ) } 
func ( v getcookiesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork35 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcookiesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork35 ( & r , v ) return r . error ( ) } 
func ( v getcertificatereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork36 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcertificatereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork36 ( & r , v ) return r . error ( ) } 
func ( v getcertificateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork37 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcertificateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork37 ( & r , v ) return r . error ( ) } 
func ( v getallcookiesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork38 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getallcookiesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork38 ( & r , v ) return r . error ( ) } 
func ( v getallcookiesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork39 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getallcookiesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork39 ( & r , v ) return r . error ( ) } 
func ( v eventwebsocketwillsendhandshakerequest ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork40 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwebsocketwillsendhandshakerequest ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork40 ( & r , v ) return r . error ( ) } 
func ( v eventwebsockethandshakeresponsereceived ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork41 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwebsockethandshakeresponsereceived ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork41 ( & r , v ) return r . error ( ) } 
func ( v eventwebsocketframesent ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork42 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwebsocketframesent ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork42 ( & r , v ) return r . error ( ) } 
func ( v eventwebsocketframereceived ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork43 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwebsocketframereceived ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork43 ( & r , v ) return r . error ( ) } 
func ( v eventwebsocketframeerror ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork44 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwebsocketframeerror ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork44 ( & r , v ) return r . error ( ) } 
func ( v eventwebsocketcreated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork45 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwebsocketcreated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork45 ( & r , v ) return r . error ( ) } 
func ( v eventwebsocketclosed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork46 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwebsocketclosed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork46 ( & r , v ) return r . error ( ) } 
func ( v eventsignedexchangereceived ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork47 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventsignedexchangereceived ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork47 ( & r , v ) return r . error ( ) } 
func ( v eventresponsereceived ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork48 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventresponsereceived ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork48 ( & r , v ) return r . error ( ) } 
func ( v eventresourcechangedpriority ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork49 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventresourcechangedpriority ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork49 ( & r , v ) return r . error ( ) } 
func ( v eventrequestwillbesent ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork50 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventrequestwillbesent ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork50 ( & r , v ) return r . error ( ) } 
func ( v eventrequestservedfromcache ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork51 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventrequestservedfromcache ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork51 ( & r , v ) return r . error ( ) } 
func ( v eventrequestintercepted ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork52 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventrequestintercepted ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork52 ( & r , v ) return r . error ( ) } 
func ( v eventloadingfinished ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork53 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventloadingfinished ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork53 ( & r , v ) return r . error ( ) } 
func ( v eventloadingfailed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork54 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventloadingfailed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork54 ( & r , v ) return r . error ( ) } 
func ( v eventeventsourcemessagereceived ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork55 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventeventsourcemessagereceived ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork55 ( & r , v ) return r . error ( ) } 
func ( v eventdatareceived ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork56 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdatareceived ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork56 ( & r , v ) return r . error ( ) } 
func ( v emulatenetworkconditionsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork58 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * emulatenetworkconditionsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork58 ( & r , v ) return r . error ( ) } 
func ( v deletecookiesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork60 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * deletecookiesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork60 ( & r , v ) return r . error ( ) } 
func ( v cookieparam ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork61 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cookieparam ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork61 ( & r , v ) return r . error ( ) } 
func ( v continueinterceptedrequestparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork63 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * continueinterceptedrequestparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork63 ( & r , v ) return r . error ( ) } 
func ( v clearbrowsercookiesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork64 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * clearbrowsercookiesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork64 ( & r , v ) return r . error ( ) } 
func ( v clearbrowsercacheparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork65 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * clearbrowsercacheparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork65 ( & r , v ) return r . error ( ) } 
func ( v cachedresource ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotonetwork66 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cachedresource ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork66 ( & r , v ) return r . error ( ) } 
func ( v * authchallengeresponse ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotonetwork67 ( & r , v ) return r . error ( ) } 
func ( v textboxsnapshot ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * textboxsnapshot ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot ( & r , v ) return r . error ( ) } 
func ( v rarestringdata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * rarestringdata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot1 ( & r , v ) return r . error ( ) } 
func ( v rareintegerdata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * rareintegerdata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot2 ( & r , v ) return r . error ( ) } 
func ( v rarebooleandata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * rarebooleandata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot3 ( & r , v ) return r . error ( ) } 
func ( v nodetreesnapshot ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * nodetreesnapshot ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot4 ( & r , v ) return r . error ( ) } 
func ( v namevalue ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * namevalue ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot5 ( & r , v ) return r . error ( ) } 
func ( v layouttreesnapshot ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * layouttreesnapshot ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot6 ( & r , v ) return r . error ( ) } 
func ( v layouttreenode ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * layouttreenode ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot7 ( & r , v ) return r . error ( ) } 
func ( v inlinetextbox ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * inlinetextbox ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot8 ( & r , v ) return r . error ( ) } 
func ( v documentsnapshot ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * documentsnapshot ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot10 ( & r , v ) return r . error ( ) } 
func ( v domnode ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * domnode ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot12 ( & r , v ) return r . error ( ) } 
func ( v computedstyle ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomsnapshot13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * computedstyle ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot13 ( & r , v ) return r . error ( ) } 
func ( v * capturesnapshotreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomsnapshot14 ( & r , v ) return r . error ( ) } 
func ( v stopsamplingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v startsamplingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * startsamplingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory1 ( & r , v ) return r . error ( ) } 
func ( v simulatepressurenotificationparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * simulatepressurenotificationparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory2 ( & r , v ) return r . error ( ) } 
func ( v setpressurenotificationssuppressedparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setpressurenotificationssuppressedparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory3 ( & r , v ) return r . error ( ) } 
func ( v samplingprofilenode ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * samplingprofilenode ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory4 ( & r , v ) return r . error ( ) } 
func ( v samplingprofile ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * samplingprofile ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory5 ( & r , v ) return r . error ( ) } 
func ( v prepareforleakdetectionparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * prepareforleakdetectionparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory6 ( & r , v ) return r . error ( ) } 
func ( v module ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * module ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory7 ( & r , v ) return r . error ( ) } 
func ( v getdomcountersreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdomcountersreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory10 ( & r , v ) return r . error ( ) } 
func ( v getdomcountersparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdomcountersparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory11 ( & r , v ) return r . error ( ) } 
func ( v getbrowsersamplingprofilereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbrowsersamplingprofilereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory12 ( & r , v ) return r . error ( ) } 
func ( v getbrowsersamplingprofileparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbrowsersamplingprofileparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory13 ( & r , v ) return r . error ( ) } 
func ( v getalltimesamplingprofilereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getalltimesamplingprofilereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory14 ( & r , v ) return r . error ( ) } 
func ( v getalltimesamplingprofileparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getalltimesamplingprofileparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory15 ( & r , v ) return r . error ( ) } 
func ( v forciblypurgejavascriptmemoryparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotomemory16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * forciblypurgejavascriptmemoryparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotomemory16 ( & r , v ) return r . error ( ) } 
func ( v takecoveragedeltareturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takecoveragedeltareturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss1 ( & r , v ) return r . error ( ) } 
func ( v takecoveragedeltaparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takecoveragedeltaparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss2 ( & r , v ) return r . error ( ) } 
func ( v stylesheetheader ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stylesheetheader ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss3 ( & r , v ) return r . error ( ) } 
func ( v styledeclarationedit ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * styledeclarationedit ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss4 ( & r , v ) return r . error ( ) } 
func ( v style ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * style ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss5 ( & r , v ) return r . error ( ) } 
func ( v stopruleusagetrackingreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopruleusagetrackingreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss6 ( & r , v ) return r . error ( ) } 
func ( v stopruleusagetrackingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopruleusagetrackingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss7 ( & r , v ) return r . error ( ) } 
func ( v startruleusagetrackingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * startruleusagetrackingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss8 ( & r , v ) return r . error ( ) } 
func ( v sourcerange ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * sourcerange ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss9 ( & r , v ) return r . error ( ) } 
func ( v shorthandentry ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * shorthandentry ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss10 ( & r , v ) return r . error ( ) } 
func ( v setstyletextsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setstyletextsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss11 ( & r , v ) return r . error ( ) } 
func ( v setstyletextsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setstyletextsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss12 ( & r , v ) return r . error ( ) } 
func ( v setstylesheettextreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setstylesheettextreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss13 ( & r , v ) return r . error ( ) } 
func ( v setstylesheettextparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setstylesheettextparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss14 ( & r , v ) return r . error ( ) } 
func ( v setruleselectorreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setruleselectorreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss15 ( & r , v ) return r . error ( ) } 
func ( v setruleselectorparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setruleselectorparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss16 ( & r , v ) return r . error ( ) } 
func ( v setmediatextreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setmediatextreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss17 ( & r , v ) return r . error ( ) } 
func ( v setmediatextparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setmediatextparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss18 ( & r , v ) return r . error ( ) } 
func ( v setkeyframekeyreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setkeyframekeyreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss19 ( & r , v ) return r . error ( ) } 
func ( v setkeyframekeyparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setkeyframekeyparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss20 ( & r , v ) return r . error ( ) } 
func ( v seteffectivepropertyvaluefornodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * seteffectivepropertyvaluefornodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss21 ( & r , v ) return r . error ( ) } 
func ( v selectorlist ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * selectorlist ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss22 ( & r , v ) return r . error ( ) } 
func ( v ruleusage ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * ruleusage ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss23 ( & r , v ) return r . error ( ) } 
func ( v rulematch ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss24 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * rulematch ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss24 ( & r , v ) return r . error ( ) } 
func ( v rule ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss25 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * rule ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss25 ( & r , v ) return r . error ( ) } 
func ( v pseudoelementmatches ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pseudoelementmatches ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss26 ( & r , v ) return r . error ( ) } 
func ( v property ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss27 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * property ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss27 ( & r , v ) return r . error ( ) } 
func ( v platformfontusage ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss28 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * platformfontusage ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss28 ( & r , v ) return r . error ( ) } 
func ( v mediaqueryexpression ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss29 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * mediaqueryexpression ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss29 ( & r , v ) return r . error ( ) } 
func ( v mediaquery ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss30 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * mediaquery ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss30 ( & r , v ) return r . error ( ) } 
func ( v media ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss31 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * media ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss31 ( & r , v ) return r . error ( ) } 
func ( v keyframesrule ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss32 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v keyframerule ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss33 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * keyframerule ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss33 ( & r , v ) return r . error ( ) } 
func ( v inheritedstyleentry ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss34 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * inheritedstyleentry ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss34 ( & r , v ) return r . error ( ) } 
func ( v getstylesheettextreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss35 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getstylesheettextreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss35 ( & r , v ) return r . error ( ) } 
func ( v getstylesheettextparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss36 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getstylesheettextparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss36 ( & r , v ) return r . error ( ) } 
func ( v getplatformfontsfornodereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss37 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getplatformfontsfornodereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss37 ( & r , v ) return r . error ( ) } 
func ( v getplatformfontsfornodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss38 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getplatformfontsfornodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss38 ( & r , v ) return r . error ( ) } 
func ( v getmediaqueriesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss39 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmediaqueriesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss39 ( & r , v ) return r . error ( ) } 
func ( v getmediaqueriesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss40 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmediaqueriesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss40 ( & r , v ) return r . error ( ) } 
func ( v getmatchedstylesfornodereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss41 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmatchedstylesfornodereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss41 ( & r , v ) return r . error ( ) } 
func ( v getmatchedstylesfornodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss42 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmatchedstylesfornodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss42 ( & r , v ) return r . error ( ) } 
func ( v getinlinestylesfornodereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss43 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getinlinestylesfornodereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss43 ( & r , v ) return r . error ( ) } 
func ( v getinlinestylesfornodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss44 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getinlinestylesfornodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss44 ( & r , v ) return r . error ( ) } 
func ( v getcomputedstylefornodereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss45 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcomputedstylefornodereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss45 ( & r , v ) return r . error ( ) } 
func ( v getcomputedstylefornodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss46 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcomputedstylefornodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss46 ( & r , v ) return r . error ( ) } 
func ( v getbackgroundcolorsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss47 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbackgroundcolorsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss47 ( & r , v ) return r . error ( ) } 
func ( v getbackgroundcolorsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss48 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbackgroundcolorsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss48 ( & r , v ) return r . error ( ) } 
func ( v forcepseudostateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss49 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * forcepseudostateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss49 ( & r , v ) return r . error ( ) } 
func ( v fontface ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss50 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * fontface ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss50 ( & r , v ) return r . error ( ) } 
func ( v eventstylesheetremoved ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss51 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventstylesheetremoved ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss51 ( & r , v ) return r . error ( ) } 
func ( v eventstylesheetchanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss52 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventstylesheetchanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss52 ( & r , v ) return r . error ( ) } 
func ( v eventstylesheetadded ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss53 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventstylesheetadded ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss53 ( & r , v ) return r . error ( ) } 
func ( v eventmediaqueryresultchanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss54 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventmediaqueryresultchanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss54 ( & r , v ) return r . error ( ) } 
func ( v eventfontsupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss55 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventfontsupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss55 ( & r , v ) return r . error ( ) } 
func ( v * disableparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss57 ( & r , v ) return r . error ( ) } 
func ( v createstylesheetreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss58 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createstylesheetreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss58 ( & r , v ) return r . error ( ) } 
func ( v createstylesheetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss59 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createstylesheetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss59 ( & r , v ) return r . error ( ) } 
func ( v computedproperty ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss60 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * computedproperty ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss60 ( & r , v ) return r . error ( ) } 
func ( v collectclassnamesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss61 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * collectclassnamesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss61 ( & r , v ) return r . error ( ) } 
func ( v collectclassnamesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss62 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * collectclassnamesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss62 ( & r , v ) return r . error ( ) } 
func ( v addrulereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss63 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * addrulereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss63 ( & r , v ) return r . error ( ) } 
func ( v addruleparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocss64 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * addruleparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocss64 ( & r , v ) return r . error ( ) } 
func ( v stepoverparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stepoverparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger ( & r , v ) return r . error ( ) } 
func ( v stepoutparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stepoutparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger1 ( & r , v ) return r . error ( ) } 
func ( v stepintoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stepintoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger2 ( & r , v ) return r . error ( ) } 
func ( v setvariablevalueparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setvariablevalueparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger3 ( & r , v ) return r . error ( ) } 
func ( v setskipallpausesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setskipallpausesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger4 ( & r , v ) return r . error ( ) } 
func ( v setscriptsourcereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setscriptsourcereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger5 ( & r , v ) return r . error ( ) } 
func ( v setscriptsourceparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setscriptsourceparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger6 ( & r , v ) return r . error ( ) } 
func ( v setreturnvalueparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setreturnvalueparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger7 ( & r , v ) return r . error ( ) } 
func ( v setpauseonexceptionsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setpauseonexceptionsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger8 ( & r , v ) return r . error ( ) } 
func ( v setbreakpointsactiveparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbreakpointsactiveparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger9 ( & r , v ) return r . error ( ) } 
func ( v setbreakpointreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbreakpointreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger10 ( & r , v ) return r . error ( ) } 
func ( v setbreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger11 ( & r , v ) return r . error ( ) } 
func ( v setbreakpointonfunctioncallreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbreakpointonfunctioncallreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger12 ( & r , v ) return r . error ( ) } 
func ( v setbreakpointonfunctioncallparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbreakpointonfunctioncallparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger13 ( & r , v ) return r . error ( ) } 
func ( v setbreakpointbyurlreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbreakpointbyurlreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger14 ( & r , v ) return r . error ( ) } 
func ( v setbreakpointbyurlparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbreakpointbyurlparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger15 ( & r , v ) return r . error ( ) } 
func ( v setblackboxedrangesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setblackboxedrangesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger16 ( & r , v ) return r . error ( ) } 
func ( v setblackboxpatternsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setblackboxpatternsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger17 ( & r , v ) return r . error ( ) } 
func ( v setasynccallstackdepthparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setasynccallstackdepthparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger18 ( & r , v ) return r . error ( ) } 
func ( v searchmatch ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * searchmatch ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger19 ( & r , v ) return r . error ( ) } 
func ( v searchincontentreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * searchincontentreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger20 ( & r , v ) return r . error ( ) } 
func ( v searchincontentparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * searchincontentparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger21 ( & r , v ) return r . error ( ) } 
func ( v scriptposition ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * scriptposition ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger22 ( & r , v ) return r . error ( ) } 
func ( v scope ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * scope ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger23 ( & r , v ) return r . error ( ) } 
func ( v resumeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger24 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resumeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger24 ( & r , v ) return r . error ( ) } 
func ( v restartframereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger25 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * restartframereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger25 ( & r , v ) return r . error ( ) } 
func ( v restartframeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * restartframeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger26 ( & r , v ) return r . error ( ) } 
func ( v removebreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger27 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removebreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger27 ( & r , v ) return r . error ( ) } 
func ( v pauseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger28 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pauseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger28 ( & r , v ) return r . error ( ) } 
func ( v pauseonasynccallparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger29 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pauseonasynccallparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger29 ( & r , v ) return r . error ( ) } 
func ( v location ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger30 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * location ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger30 ( & r , v ) return r . error ( ) } 
func ( v getstacktracereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger31 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getstacktracereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger31 ( & r , v ) return r . error ( ) } 
func ( v getstacktraceparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger32 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getstacktraceparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger32 ( & r , v ) return r . error ( ) } 
func ( v getscriptsourcereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger33 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getscriptsourcereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger33 ( & r , v ) return r . error ( ) } 
func ( v getscriptsourceparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger34 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getscriptsourceparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger34 ( & r , v ) return r . error ( ) } 
func ( v getpossiblebreakpointsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger35 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getpossiblebreakpointsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger35 ( & r , v ) return r . error ( ) } 
func ( v getpossiblebreakpointsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger36 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getpossiblebreakpointsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger36 ( & r , v ) return r . error ( ) } 
func ( v eventscriptparsed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger37 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventscriptparsed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger37 ( & r , v ) return r . error ( ) } 
func ( v eventscriptfailedtoparse ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger38 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventscriptfailedtoparse ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger38 ( & r , v ) return r . error ( ) } 
func ( v eventresumed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger39 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventresumed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger39 ( & r , v ) return r . error ( ) } 
func ( v eventpaused ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger40 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventpaused ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger40 ( & r , v ) return r . error ( ) } 
func ( v eventbreakpointresolved ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger41 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventbreakpointresolved ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger41 ( & r , v ) return r . error ( ) } 
func ( v evaluateoncallframereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger42 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * evaluateoncallframereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger42 ( & r , v ) return r . error ( ) } 
func ( v evaluateoncallframeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger43 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * evaluateoncallframeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger43 ( & r , v ) return r . error ( ) } 
func ( v enablereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger44 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * enablereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger44 ( & r , v ) return r . error ( ) } 
func ( v continuetolocationparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger47 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * continuetolocationparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger47 ( & r , v ) return r . error ( ) } 
func ( v * callframe ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger48 ( & r , v ) return r . error ( ) } 
func ( v breaklocation ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodebugger49 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * breaklocation ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodebugger49 ( & r , v ) return r . error ( ) } 
func ( t pressurelevel ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * pressurelevel ) unmarshaleasyjson ( in * jlexer . lexer ) { switch pressurelevel ( in . string ( ) ) { case pressurelevelmoderate : * t = pressurelevelmoderate case pressurelevelcritical : * t = pressurelevelcritical default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * pressurelevel ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v timings ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * timings ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar ( & r , v ) return r . error ( ) } 
func ( v * response ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar1 ( & r , v ) return r . error ( ) } 
func ( v postdata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * postdata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar3 ( & r , v ) return r . error ( ) } 
func ( v param ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * param ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar4 ( & r , v ) return r . error ( ) } 
func ( v pagetimings ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pagetimings ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar5 ( & r , v ) return r . error ( ) } 
func ( v page ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * page ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar6 ( & r , v ) return r . error ( ) } 
func ( v namevaluepair ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * namevaluepair ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar7 ( & r , v ) return r . error ( ) } 
func ( v log ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * log ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar8 ( & r , v ) return r . error ( ) } 
func ( v har ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * har ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar9 ( & r , v ) return r . error ( ) } 
func ( v creator ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * creator ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar11 ( & r , v ) return r . error ( ) } 
func ( v cookie ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cookie ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar12 ( & r , v ) return r . error ( ) } 
func ( v content ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * content ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar13 ( & r , v ) return r . error ( ) } 
func ( v cachedata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cachedata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotohar14 ( & r , v ) return r . error ( ) } 
func ( v cache ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotohar15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v setvirtualtimepolicyreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setvirtualtimepolicyreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation ( & r , v ) return r . error ( ) } 
func ( v setvirtualtimepolicyparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setvirtualtimepolicyparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation1 ( & r , v ) return r . error ( ) } 
func ( v setuseragentoverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setuseragentoverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation2 ( & r , v ) return r . error ( ) } 
func ( v settouchemulationenabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * settouchemulationenabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation3 ( & r , v ) return r . error ( ) } 
func ( v setscrollbarshiddenparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setscrollbarshiddenparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation4 ( & r , v ) return r . error ( ) } 
func ( v setscriptexecutiondisabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setscriptexecutiondisabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation5 ( & r , v ) return r . error ( ) } 
func ( v setpagescalefactorparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setpagescalefactorparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation6 ( & r , v ) return r . error ( ) } 
func ( v setgeolocationoverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setgeolocationoverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation7 ( & r , v ) return r . error ( ) } 
func ( v setfocusemulationenabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setfocusemulationenabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation8 ( & r , v ) return r . error ( ) } 
func ( v setemulatedmediaparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setemulatedmediaparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation9 ( & r , v ) return r . error ( ) } 
func ( v setemittoucheventsformouseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setemittoucheventsformouseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation10 ( & r , v ) return r . error ( ) } 
func ( v setdocumentcookiedisabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdocumentcookiedisabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation11 ( & r , v ) return r . error ( ) } 
func ( v setdevicemetricsoverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdevicemetricsoverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation12 ( & r , v ) return r . error ( ) } 
func ( v setdefaultbackgroundcoloroverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdefaultbackgroundcoloroverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation13 ( & r , v ) return r . error ( ) } 
func ( v setcputhrottlingrateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setcputhrottlingrateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation14 ( & r , v ) return r . error ( ) } 
func ( v screenorientation ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * screenorientation ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation15 ( & r , v ) return r . error ( ) } 
func ( v resetpagescalefactorparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resetpagescalefactorparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation16 ( & r , v ) return r . error ( ) } 
func ( v eventvirtualtimebudgetexpired ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventvirtualtimebudgetexpired ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation17 ( & r , v ) return r . error ( ) } 
func ( v cleargeolocationoverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cleargeolocationoverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation18 ( & r , v ) return r . error ( ) } 
func ( v cleardevicemetricsoverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cleardevicemetricsoverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation19 ( & r , v ) return r . error ( ) } 
func ( v canemulatereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * canemulatereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation20 ( & r , v ) return r . error ( ) } 
func ( v canemulateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoemulation21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * canemulateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoemulation21 ( & r , v ) return r . error ( ) } 
func ( t * keytype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch keytype ( in . string ( ) ) { case keytypenumber : * t = keytypenumber case keytypestring : * t = keytypestring case keytypedate : * t = keytypedate case keytypearray : * t = keytypearray default : in . adderror ( errors . new ( " " ) ) } } 
func ( t keypathtype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * keypathtype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch keypathtype ( in . string ( ) ) { case keypathtypenull : * t = keypathtypenull case keypathtypestring : * t = keypathtypestring case keypathtypearray : * t = keypathtypearray default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * keypathtype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t streamformat ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * streamformat ) unmarshaleasyjson ( in * jlexer . lexer ) { switch streamformat ( in . string ( ) ) { case streamformatjson : * t = streamformatjson case streamformatproto : * t = streamformatproto default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * streamformat ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t streamcompression ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * streamcompression ) unmarshaleasyjson ( in * jlexer . lexer ) { switch streamcompression ( in . string ( ) ) { case streamcompressionnone : * t = streamcompressionnone case streamcompressiongzip : * t = streamcompressiongzip default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * streamcompression ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t recordmode ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * recordmode ) unmarshaleasyjson ( in * jlexer . lexer ) { switch recordmode ( in . string ( ) ) { case recordmoderecorduntilfull : * t = recordmoderecorduntilfull case recordmoderecordcontinuously : * t = recordmoderecordcontinuously case recordmoderecordasmuchaspossible : * t = recordmoderecordasmuchaspossible case recordmodeechotoconsole : * t = recordmodeechotoconsole default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * recordmode ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t transfermode ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * transfermode ) unmarshaleasyjson ( in * jlexer . lexer ) { switch transfermode ( in . string ( ) ) { case transfermodereportevents : * t = transfermodereportevents case transfermodereturnasstream : * t = transfermodereturnasstream default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * transfermode ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( p * clearobjectstoreparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandclearobjectstore , p , nil ) } 
func ( p * deletedatabaseparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddeletedatabase , p , nil ) } 
func ( p * deleteobjectstoreentriesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddeleteobjectstoreentries , p , nil ) } 
func ( p requestdataparams ) withkeyrange ( keyrange * keyrange ) * requestdataparams { p . keyrange = keyrange return & p } 
func ( p * requestdataparams ) do ( ctx context . context ) ( objectstoredataentries [ ] * dataentry , hasmore bool , err error ) { var res requestdatareturns err = cdp . execute ( ctx , commandrequestdata , p , & res ) if err ! = nil { return nil , false , err } return res . objectstoredataentries , res . hasmore , nil } 
func ( p * getmetadataparams ) do ( ctx context . context ) ( entriescount float64 , keygeneratorvalue float64 , err error ) { var res getmetadatareturns err = cdp . execute ( ctx , commandgetmetadata , p , & res ) if err ! = nil { return 0 , 0 , err } return res . entriescount , res . keygeneratorvalue , nil } 
func ( p * requestdatabaseparams ) do ( ctx context . context ) ( databasewithobjectstores * databasewithobjectstores , err error ) { var res requestdatabasereturns err = cdp . execute ( ctx , commandrequestdatabase , p , & res ) if err ! = nil { return nil , err } return res . databasewithobjectstores , nil } 
func ( p * requestdatabasenamesparams ) do ( ctx context . context ) ( databasenames [ ] string , err error ) { var res requestdatabasenamesreturns err = cdp . execute ( ctx , commandrequestdatabasenames , p , & res ) if err ! = nil { return nil , err } return res . databasenames , nil } 
func ( v eventtargetreloadedaftercrash ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinspector ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventtargetreloadedaftercrash ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinspector ( & r , v ) return r . error ( ) } 
func ( v eventdetached ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoinspector2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdetached ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinspector2 ( & r , v ) return r . error ( ) } 
func ( v * enableparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoinspector3 ( & r , v ) return r . error ( ) } 
func ( v getrealtimedatareturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotowebaudio ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getrealtimedatareturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotowebaudio ( & r , v ) return r . error ( ) } 
func ( v getrealtimedataparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotowebaudio1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getrealtimedataparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotowebaudio1 ( & r , v ) return r . error ( ) } 
func ( v eventcontextdestroyed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotowebaudio2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventcontextdestroyed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotowebaudio2 ( & r , v ) return r . error ( ) } 
func ( v eventcontextcreated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotowebaudio3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventcontextcreated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotowebaudio3 ( & r , v ) return r . error ( ) } 
func ( v eventcontextchanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotowebaudio4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventcontextchanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotowebaudio4 ( & r , v ) return r . error ( ) } 
func ( v contextrealtimedata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotowebaudio7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * contextrealtimedata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotowebaudio7 ( & r , v ) return r . error ( ) } 
func ( v baseaudiocontext ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotowebaudio8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * baseaudiocontext ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotowebaudio8 ( & r , v ) return r . error ( ) } 
func ( v setremotelocationsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setremotelocationsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget ( & r , v ) return r . error ( ) } 
func ( v setdiscovertargetsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdiscovertargetsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget1 ( & r , v ) return r . error ( ) } 
func ( v setautoattachparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setautoattachparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget2 ( & r , v ) return r . error ( ) } 
func ( v sendmessagetotargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * sendmessagetotargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget3 ( & r , v ) return r . error ( ) } 
func ( v remotelocation ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * remotelocation ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget4 ( & r , v ) return r . error ( ) } 
func ( v info ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * info ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget5 ( & r , v ) return r . error ( ) } 
func ( v gettargetsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gettargetsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget6 ( & r , v ) return r . error ( ) } 
func ( v gettargetsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gettargetsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget7 ( & r , v ) return r . error ( ) } 
func ( v gettargetinforeturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gettargetinforeturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget8 ( & r , v ) return r . error ( ) } 
func ( v gettargetinfoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gettargetinfoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget9 ( & r , v ) return r . error ( ) } 
func ( v getbrowsercontextsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbrowsercontextsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget10 ( & r , v ) return r . error ( ) } 
func ( v getbrowsercontextsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbrowsercontextsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget11 ( & r , v ) return r . error ( ) } 
func ( v exposedevtoolsprotocolparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * exposedevtoolsprotocolparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget12 ( & r , v ) return r . error ( ) } 
func ( v eventtargetinfochanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventtargetinfochanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget13 ( & r , v ) return r . error ( ) } 
func ( v eventtargetdestroyed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventtargetdestroyed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget14 ( & r , v ) return r . error ( ) } 
func ( v eventtargetcreated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventtargetcreated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget15 ( & r , v ) return r . error ( ) } 
func ( v eventtargetcrashed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventtargetcrashed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget16 ( & r , v ) return r . error ( ) } 
func ( v eventreceivedmessagefromtarget ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventreceivedmessagefromtarget ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget17 ( & r , v ) return r . error ( ) } 
func ( v eventdetachedfromtarget ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdetachedfromtarget ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget18 ( & r , v ) return r . error ( ) } 
func ( v eventattachedtotarget ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventattachedtotarget ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget19 ( & r , v ) return r . error ( ) } 
func ( v disposebrowsercontextparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * disposebrowsercontextparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget20 ( & r , v ) return r . error ( ) } 
func ( v detachfromtargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * detachfromtargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget21 ( & r , v ) return r . error ( ) } 
func ( v createtargetreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createtargetreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget22 ( & r , v ) return r . error ( ) } 
func ( v createtargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createtargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget23 ( & r , v ) return r . error ( ) } 
func ( v createbrowsercontextreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget24 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createbrowsercontextreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget24 ( & r , v ) return r . error ( ) } 
func ( v createbrowsercontextparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget25 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createbrowsercontextparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget25 ( & r , v ) return r . error ( ) } 
func ( v closetargetreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * closetargetreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget26 ( & r , v ) return r . error ( ) } 
func ( v closetargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget27 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * closetargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget27 ( & r , v ) return r . error ( ) } 
func ( v attachtotargetreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget28 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * attachtotargetreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget28 ( & r , v ) return r . error ( ) } 
func ( v attachtotargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget29 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * attachtotargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget29 ( & r , v ) return r . error ( ) } 
func ( v attachtobrowsertargetreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget30 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * attachtobrowsertargetreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget30 ( & r , v ) return r . error ( ) } 
func ( v attachtobrowsertargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget31 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * attachtobrowsertargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget31 ( & r , v ) return r . error ( ) } 
func ( v activatetargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototarget32 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * activatetargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototarget32 ( & r , v ) return r . error ( ) } 
func ( v waitfordebuggerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * waitfordebuggerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage ( & r , v ) return r . error ( ) } 
func ( v visualviewport ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * visualviewport ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage1 ( & r , v ) return r . error ( ) } 
func ( v viewport ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * viewport ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage2 ( & r , v ) return r . error ( ) } 
func ( v stopscreencastparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopscreencastparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage3 ( & r , v ) return r . error ( ) } 
func ( v stoploadingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stoploadingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage4 ( & r , v ) return r . error ( ) } 
func ( v startscreencastparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * startscreencastparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage5 ( & r , v ) return r . error ( ) } 
func ( v setweblifecyclestateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setweblifecyclestateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage6 ( & r , v ) return r . error ( ) } 
func ( v setproducecompilationcacheparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setproducecompilationcacheparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage7 ( & r , v ) return r . error ( ) } 
func ( v setlifecycleeventsenabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setlifecycleeventsenabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage8 ( & r , v ) return r . error ( ) } 
func ( v setfontsizesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setfontsizesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage9 ( & r , v ) return r . error ( ) } 
func ( v setfontfamiliesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setfontfamiliesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage10 ( & r , v ) return r . error ( ) } 
func ( v setdownloadbehaviorparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdownloadbehaviorparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage11 ( & r , v ) return r . error ( ) } 
func ( v setdocumentcontentparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdocumentcontentparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage12 ( & r , v ) return r . error ( ) } 
func ( v setbypasscspparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setbypasscspparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage13 ( & r , v ) return r . error ( ) } 
func ( v setadblockingenabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setadblockingenabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage14 ( & r , v ) return r . error ( ) } 
func ( v searchinresourcereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * searchinresourcereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage15 ( & r , v ) return r . error ( ) } 
func ( v searchinresourceparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * searchinresourceparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage16 ( & r , v ) return r . error ( ) } 
func ( v screencastframemetadata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * screencastframemetadata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage17 ( & r , v ) return r . error ( ) } 
func ( v screencastframeackparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * screencastframeackparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage18 ( & r , v ) return r . error ( ) } 
func ( v resetnavigationhistoryparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resetnavigationhistoryparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage19 ( & r , v ) return r . error ( ) } 
func ( v removescripttoevaluateonnewdocumentparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removescripttoevaluateonnewdocumentparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage20 ( & r , v ) return r . error ( ) } 
func ( v reloadparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * reloadparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage21 ( & r , v ) return r . error ( ) } 
func ( v printtopdfreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * printtopdfreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage22 ( & r , v ) return r . error ( ) } 
func ( v printtopdfparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * printtopdfparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage23 ( & r , v ) return r . error ( ) } 
func ( v navigationentry ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage24 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * navigationentry ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage24 ( & r , v ) return r . error ( ) } 
func ( v navigatetohistoryentryparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage25 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * navigatetohistoryentryparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage25 ( & r , v ) return r . error ( ) } 
func ( v navigatereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * navigatereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage26 ( & r , v ) return r . error ( ) } 
func ( v navigateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage27 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * navigateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage27 ( & r , v ) return r . error ( ) } 
func ( v layoutviewport ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage28 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * layoutviewport ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage28 ( & r , v ) return r . error ( ) } 
func ( v handlejavascriptdialogparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage29 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * handlejavascriptdialogparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage29 ( & r , v ) return r . error ( ) } 
func ( v getresourcetreereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage30 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getresourcetreereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage30 ( & r , v ) return r . error ( ) } 
func ( v getresourcetreeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage31 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getresourcetreeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage31 ( & r , v ) return r . error ( ) } 
func ( v getresourcecontentreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage32 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getresourcecontentreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage32 ( & r , v ) return r . error ( ) } 
func ( v getresourcecontentparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage33 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getresourcecontentparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage33 ( & r , v ) return r . error ( ) } 
func ( v getnavigationhistoryreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage34 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getnavigationhistoryreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage34 ( & r , v ) return r . error ( ) } 
func ( v getnavigationhistoryparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage35 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getnavigationhistoryparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage35 ( & r , v ) return r . error ( ) } 
func ( v getlayoutmetricsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage36 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getlayoutmetricsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage36 ( & r , v ) return r . error ( ) } 
func ( v getlayoutmetricsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage37 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getlayoutmetricsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage37 ( & r , v ) return r . error ( ) } 
func ( v getinstallabilityerrorsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage38 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getinstallabilityerrorsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage38 ( & r , v ) return r . error ( ) } 
func ( v getinstallabilityerrorsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage39 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getinstallabilityerrorsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage39 ( & r , v ) return r . error ( ) } 
func ( v getframetreereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage40 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getframetreereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage40 ( & r , v ) return r . error ( ) } 
func ( v getframetreeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage41 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getframetreeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage41 ( & r , v ) return r . error ( ) } 
func ( v getappmanifestreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage42 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getappmanifestreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage42 ( & r , v ) return r . error ( ) } 
func ( v getappmanifestparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage43 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getappmanifestparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage43 ( & r , v ) return r . error ( ) } 
func ( v generatetestreportparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage44 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * generatetestreportparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage44 ( & r , v ) return r . error ( ) } 
func ( v frametree ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage45 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * frametree ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage45 ( & r , v ) return r . error ( ) } 
func ( v frameresourcetree ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage46 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * frameresourcetree ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage46 ( & r , v ) return r . error ( ) } 
func ( v frameresource ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage47 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * frameresource ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage47 ( & r , v ) return r . error ( ) } 
func ( v fontsizes ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage48 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * fontsizes ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage48 ( & r , v ) return r . error ( ) } 
func ( v fontfamilies ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage49 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * fontfamilies ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage49 ( & r , v ) return r . error ( ) } 
func ( v eventwindowopen ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage50 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventwindowopen ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage50 ( & r , v ) return r . error ( ) } 
func ( v eventscreencastvisibilitychanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage51 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventscreencastvisibilitychanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage51 ( & r , v ) return r . error ( ) } 
func ( v eventscreencastframe ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage52 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventscreencastframe ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage52 ( & r , v ) return r . error ( ) } 
func ( v eventnavigatedwithindocument ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage53 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventnavigatedwithindocument ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage53 ( & r , v ) return r . error ( ) } 
func ( v eventloadeventfired ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage54 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventloadeventfired ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage54 ( & r , v ) return r . error ( ) } 
func ( v eventlifecycleevent ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage55 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventlifecycleevent ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage55 ( & r , v ) return r . error ( ) } 
func ( v eventjavascriptdialogopening ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage56 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventjavascriptdialogopening ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage56 ( & r , v ) return r . error ( ) } 
func ( v eventjavascriptdialogclosed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage57 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventjavascriptdialogclosed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage57 ( & r , v ) return r . error ( ) } 
func ( v eventinterstitialshown ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage58 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventinterstitialshown ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage58 ( & r , v ) return r . error ( ) } 
func ( v eventinterstitialhidden ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage59 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventinterstitialhidden ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage59 ( & r , v ) return r . error ( ) } 
func ( v eventframestoppedloading ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage60 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventframestoppedloading ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage60 ( & r , v ) return r . error ( ) } 
func ( v eventframestartedloading ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage61 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventframestartedloading ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage61 ( & r , v ) return r . error ( ) } 
func ( v eventframeresized ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage62 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventframeresized ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage62 ( & r , v ) return r . error ( ) } 
func ( v eventframerequestednavigation ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage63 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventframerequestednavigation ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage63 ( & r , v ) return r . error ( ) } 
func ( v eventframenavigated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage64 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventframenavigated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage64 ( & r , v ) return r . error ( ) } 
func ( v eventframedetached ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage65 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventframedetached ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage65 ( & r , v ) return r . error ( ) } 
func ( v eventframeattached ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage66 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventframeattached ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage66 ( & r , v ) return r . error ( ) } 
func ( v eventdownloadwillbegin ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage67 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdownloadwillbegin ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage67 ( & r , v ) return r . error ( ) } 
func ( v eventdomcontenteventfired ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage68 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdomcontenteventfired ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage68 ( & r , v ) return r . error ( ) } 
func ( v eventcompilationcacheproduced ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage69 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventcompilationcacheproduced ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage69 ( & r , v ) return r . error ( ) } 
func ( v createisolatedworldreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage72 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createisolatedworldreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage72 ( & r , v ) return r . error ( ) } 
func ( v createisolatedworldparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage73 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * createisolatedworldparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage73 ( & r , v ) return r . error ( ) } 
func ( v closeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage75 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v clearcompilationcacheparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage76 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * clearcompilationcacheparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage76 ( & r , v ) return r . error ( ) } 
func ( v capturesnapshotreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage77 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v capturesnapshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage78 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * capturesnapshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage78 ( & r , v ) return r . error ( ) } 
func ( v capturescreenshotreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage79 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * capturescreenshotreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage79 ( & r , v ) return r . error ( ) } 
func ( v capturescreenshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage80 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * capturescreenshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage80 ( & r , v ) return r . error ( ) } 
func ( v bringtofrontparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage81 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * bringtofrontparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage81 ( & r , v ) return r . error ( ) } 
func ( v appmanifesterror ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage82 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * appmanifesterror ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage82 ( & r , v ) return r . error ( ) } 
func ( v addscripttoevaluateonnewdocumentreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage83 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * addscripttoevaluateonnewdocumentreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage83 ( & r , v ) return r . error ( ) } 
func ( v addscripttoevaluateonnewdocumentparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage84 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * addscripttoevaluateonnewdocumentparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage84 ( & r , v ) return r . error ( ) } 
func ( v addcompilationcacheparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotopage85 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * addcompilationcacheparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotopage85 ( & r , v ) return r . error ( ) } 
func ( p * capturesnapshotparams ) do ( ctx context . context ) ( documents [ ] * documentsnapshot , strings [ ] string , err error ) { var res capturesnapshotreturns err = cdp . execute ( ctx , commandcapturesnapshot , p , & res ) if err ! = nil { return nil , nil , err } return res . documents , res . strings , nil } 
func ( p * getbesteffortcoverageparams ) do ( ctx context . context ) ( result [ ] * scriptcoverage , err error ) { var res getbesteffortcoveragereturns err = cdp . execute ( ctx , commandgetbesteffortcoverage , nil , & res ) if err ! = nil { return nil , err } return res . result , nil } 
func ( p * setsamplingintervalparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetsamplinginterval , p , nil ) } 
func ( p * startparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstart , nil , nil ) } 
func ( p startprecisecoverageparams ) withcallcount ( callcount bool ) * startprecisecoverageparams { p . callcount = callcount return & p } 
func ( p startprecisecoverageparams ) withdetailed ( detailed bool ) * startprecisecoverageparams { p . detailed = detailed return & p } 
func ( p * startprecisecoverageparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstartprecisecoverage , p , nil ) } 
func ( p * starttypeprofileparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstarttypeprofile , nil , nil ) } 
func ( p * stopparams ) do ( ctx context . context ) ( profile * profile , err error ) { var res stopreturns err = cdp . execute ( ctx , commandstop , nil , & res ) if err ! = nil { return nil , err } return res . profile , nil } 
func ( p * stopprecisecoverageparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopprecisecoverage , nil , nil ) } 
func ( p * stoptypeprofileparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstoptypeprofile , nil , nil ) } 
func ( p * takeprecisecoverageparams ) do ( ctx context . context ) ( result [ ] * scriptcoverage , err error ) { var res takeprecisecoveragereturns err = cdp . execute ( ctx , commandtakeprecisecoverage , nil , & res ) if err ! = nil { return nil , err } return res . result , nil } 
func ( p * taketypeprofileparams ) do ( ctx context . context ) ( result [ ] * scripttypeprofile , err error ) { var res taketypeprofilereturns err = cdp . execute ( ctx , commandtaketypeprofile , nil , & res ) if err ! = nil { return nil , err } return res . result , nil } 
func ( p * getapplicationcacheforframeparams ) do ( ctx context . context ) ( applicationcache * applicationcache , err error ) { var res getapplicationcacheforframereturns err = cdp . execute ( ctx , commandgetapplicationcacheforframe , p , & res ) if err ! = nil { return nil , err } return res . applicationcache , nil } 
func ( p * getframeswithmanifestsparams ) do ( ctx context . context ) ( frameids [ ] * framewithmanifest , err error ) { var res getframeswithmanifestsreturns err = cdp . execute ( ctx , commandgetframeswithmanifests , nil , & res ) if err ! = nil { return nil , err } return res . frameids , nil } 
func ( p * getmanifestforframeparams ) do ( ctx context . context ) ( manifesturl string , err error ) { var res getmanifestforframereturns err = cdp . execute ( ctx , commandgetmanifestforframe , p , & res ) if err ! = nil { return " " , err } return res . manifesturl , nil } 
func ( p * setignorecertificateerrorsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetignorecertificateerrors , p , nil ) } 
func ( t resourcetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * resourcetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch resourcetype ( in . string ( ) ) { case resourcetypedocument : * t = resourcetypedocument case resourcetypestylesheet : * t = resourcetypestylesheet case resourcetypeimage : * t = resourcetypeimage case resourcetypemedia : * t = resourcetypemedia case resourcetypefont : * t = resourcetypefont case resourcetypescript : * t = resourcetypescript case resourcetypetexttrack : * t = resourcetypetexttrack case resourcetypexhr : * t = resourcetypexhr case resourcetypefetch : * t = resourcetypefetch case resourcetypeeventsource : * t = resourcetypeeventsource case resourcetypewebsocket : * t = resourcetypewebsocket case resourcetypemanifest : * t = resourcetypemanifest case resourcetypesignedexchange : * t = resourcetypesignedexchange case resourcetypeping : * t = resourcetypeping case resourcetypecspviolationreport : * t = resourcetypecspviolationreport case resourcetypeother : * t = resourcetypeother default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * resourcetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t errorreason ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * errorreason ) unmarshaleasyjson ( in * jlexer . lexer ) { switch errorreason ( in . string ( ) ) { case errorreasonfailed : * t = errorreasonfailed case errorreasonaborted : * t = errorreasonaborted case errorreasontimedout : * t = errorreasontimedout case errorreasonaccessdenied : * t = errorreasonaccessdenied case errorreasonconnectionclosed : * t = errorreasonconnectionclosed case errorreasonconnectionreset : * t = errorreasonconnectionreset case errorreasonconnectionrefused : * t = errorreasonconnectionrefused case errorreasonconnectionaborted : * t = errorreasonconnectionaborted case errorreasonconnectionfailed : * t = errorreasonconnectionfailed case errorreasonnamenotresolved : * t = errorreasonnamenotresolved case errorreasoninternetdisconnected : * t = errorreasoninternetdisconnected case errorreasonaddressunreachable : * t = errorreasonaddressunreachable case errorreasonblockedbyclient : * t = errorreasonblockedbyclient case errorreasonblockedbyresponse : * t = errorreasonblockedbyresponse default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * errorreason ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t connectiontype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * connectiontype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch connectiontype ( in . string ( ) ) { case connectiontypenone : * t = connectiontypenone case connectiontypecellular2g : * t = connectiontypecellular2g case connectiontypecellular3g : * t = connectiontypecellular3g case connectiontypecellular4g : * t = connectiontypecellular4g case connectiontypebluetooth : * t = connectiontypebluetooth case connectiontypeethernet : * t = connectiontypeethernet case connectiontypewifi : * t = connectiontypewifi case connectiontypewimax : * t = connectiontypewimax case connectiontypeother : * t = connectiontypeother default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * connectiontype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t cookiesamesite ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * cookiesamesite ) unmarshaleasyjson ( in * jlexer . lexer ) { switch cookiesamesite ( in . string ( ) ) { case cookiesamesitestrict : * t = cookiesamesitestrict case cookiesamesitelax : * t = cookiesamesitelax case cookiesamesiteextended : * t = cookiesamesiteextended case cookiesamesitenone : * t = cookiesamesitenone default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * cookiesamesite ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t resourcepriority ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * resourcepriority ) unmarshaleasyjson ( in * jlexer . lexer ) { switch resourcepriority ( in . string ( ) ) { case resourcepriorityverylow : * t = resourcepriorityverylow case resourceprioritylow : * t = resourceprioritylow case resourceprioritymedium : * t = resourceprioritymedium case resourcepriorityhigh : * t = resourcepriorityhigh case resourcepriorityveryhigh : * t = resourcepriorityveryhigh default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * resourcepriority ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t certificatetransparencycompliance ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * certificatetransparencycompliance ) unmarshaleasyjson ( in * jlexer . lexer ) { switch certificatetransparencycompliance ( in . string ( ) ) { case certificatetransparencycomplianceunknown : * t = certificatetransparencycomplianceunknown case certificatetransparencycompliancenotcompliant : * t = certificatetransparencycompliancenotcompliant case certificatetransparencycompliancecompliant : * t = certificatetransparencycompliancecompliant default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * certificatetransparencycompliance ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t blockedreason ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * blockedreason ) unmarshaleasyjson ( in * jlexer . lexer ) { switch blockedreason ( in . string ( ) ) { case blockedreasonother : * t = blockedreasonother case blockedreasoncsp : * t = blockedreasoncsp case blockedreasonmixedcontent : * t = blockedreasonmixedcontent case blockedreasonorigin : * t = blockedreasonorigin case blockedreasoninspector : * t = blockedreasoninspector case blockedreasonsubresourcefilter : * t = blockedreasonsubresourcefilter case blockedreasoncontenttype : * t = blockedreasoncontenttype case blockedreasoncollapsedbyclient : * t = blockedreasoncollapsedbyclient default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * blockedreason ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t interceptionstage ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * interceptionstage ) unmarshaleasyjson ( in * jlexer . lexer ) { switch interceptionstage ( in . string ( ) ) { case interceptionstagerequest : * t = interceptionstagerequest case interceptionstageheadersreceived : * t = interceptionstageheadersreceived default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * interceptionstage ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t signedexchangeerrorfield ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * signedexchangeerrorfield ) unmarshaleasyjson ( in * jlexer . lexer ) { switch signedexchangeerrorfield ( in . string ( ) ) { case signedexchangeerrorfieldsignaturesig : * t = signedexchangeerrorfieldsignaturesig case signedexchangeerrorfieldsignatureintegrity : * t = signedexchangeerrorfieldsignatureintegrity case signedexchangeerrorfieldsignaturecerturl : * t = signedexchangeerrorfieldsignaturecerturl case signedexchangeerrorfieldsignaturecertsha256 : * t = signedexchangeerrorfieldsignaturecertsha256 case signedexchangeerrorfieldsignaturevalidityurl : * t = signedexchangeerrorfieldsignaturevalidityurl case signedexchangeerrorfieldsignaturetimestamps : * t = signedexchangeerrorfieldsignaturetimestamps default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * signedexchangeerrorfield ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t referrerpolicy ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * referrerpolicy ) unmarshaleasyjson ( in * jlexer . lexer ) { switch referrerpolicy ( in . string ( ) ) { case referrerpolicyunsafeurl : * t = referrerpolicyunsafeurl case referrerpolicynoreferrerwhendowngrade : * t = referrerpolicynoreferrerwhendowngrade case referrerpolicynoreferrer : * t = referrerpolicynoreferrer case referrerpolicyorigin : * t = referrerpolicyorigin case referrerpolicyoriginwhencrossorigin : * t = referrerpolicyoriginwhencrossorigin case referrerpolicysameorigin : * t = referrerpolicysameorigin case referrerpolicystrictorigin : * t = referrerpolicystrictorigin case referrerpolicystrictoriginwhencrossorigin : * t = referrerpolicystrictoriginwhencrossorigin default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * referrerpolicy ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t initiatortype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * initiatortype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch initiatortype ( in . string ( ) ) { case initiatortypeparser : * t = initiatortypeparser case initiatortypescript : * t = initiatortypescript case initiatortypepreload : * t = initiatortypepreload case initiatortypesignedexchange : * t = initiatortypesignedexchange case initiatortypeother : * t = initiatortypeother default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * initiatortype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v resource ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resource ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache ( & r , v ) return r . error ( ) } 
func ( v getmanifestforframereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmanifestforframereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache1 ( & r , v ) return r . error ( ) } 
func ( v getmanifestforframeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmanifestforframeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache2 ( & r , v ) return r . error ( ) } 
func ( v getframeswithmanifestsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getframeswithmanifestsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache3 ( & r , v ) return r . error ( ) } 
func ( v getframeswithmanifestsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getframeswithmanifestsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache4 ( & r , v ) return r . error ( ) } 
func ( v getapplicationcacheforframereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getapplicationcacheforframereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache5 ( & r , v ) return r . error ( ) } 
func ( v getapplicationcacheforframeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getapplicationcacheforframeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache6 ( & r , v ) return r . error ( ) } 
func ( v framewithmanifest ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * framewithmanifest ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache7 ( & r , v ) return r . error ( ) } 
func ( v eventnetworkstateupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventnetworkstateupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache8 ( & r , v ) return r . error ( ) } 
func ( v eventapplicationcachestatusupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventapplicationcachestatusupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache9 ( & r , v ) return r . error ( ) } 
func ( v applicationcache ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoapplicationcache11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * applicationcache ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoapplicationcache11 ( & r , v ) return r . error ( ) } 
func ( t valuetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * valuetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch valuetype ( in . string ( ) ) { case valuetypeboolean : * t = valuetypeboolean case valuetypetristate : * t = valuetypetristate case valuetypebooleanorundefined : * t = valuetypebooleanorundefined case valuetypeidref : * t = valuetypeidref case valuetypeidreflist : * t = valuetypeidreflist case valuetypeinteger : * t = valuetypeinteger case valuetypenode : * t = valuetypenode case valuetypenodelist : * t = valuetypenodelist case valuetypenumber : * t = valuetypenumber case valuetypestring : * t = valuetypestring case valuetypecomputedstring : * t = valuetypecomputedstring case valuetypetoken : * t = valuetypetoken case valuetypetokenlist : * t = valuetypetokenlist case valuetypedomrelation : * t = valuetypedomrelation case valuetyperole : * t = valuetyperole case valuetypeinternalrole : * t = valuetypeinternalrole case valuetypevalueundefined : * t = valuetypevalueundefined default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * valuetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t valuesourcetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * valuesourcetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch valuesourcetype ( in . string ( ) ) { case valuesourcetypeattribute : * t = valuesourcetypeattribute case valuesourcetypeimplicit : * t = valuesourcetypeimplicit case valuesourcetypestyle : * t = valuesourcetypestyle case valuesourcetypecontents : * t = valuesourcetypecontents case valuesourcetypeplaceholder : * t = valuesourcetypeplaceholder case valuesourcetyperelatedelement : * t = valuesourcetyperelatedelement default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * valuesourcetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t valuenativesourcetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * valuenativesourcetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch valuenativesourcetype ( in . string ( ) ) { case valuenativesourcetypefigcaption : * t = valuenativesourcetypefigcaption case valuenativesourcetypelabel : * t = valuenativesourcetypelabel case valuenativesourcetypelabelfor : * t = valuenativesourcetypelabelfor case valuenativesourcetypelabelwrapped : * t = valuenativesourcetypelabelwrapped case valuenativesourcetypelegend : * t = valuenativesourcetypelegend case valuenativesourcetypetablecaption : * t = valuenativesourcetypetablecaption case valuenativesourcetypetitle : * t = valuenativesourcetypetitle case valuenativesourcetypeother : * t = valuenativesourcetypeother default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * valuenativesourcetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t propertyname ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * propertyname ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v undoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * undoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom ( & r , v ) return r . error ( ) } 
func ( v shapeoutsideinfo ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * shapeoutsideinfo ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom1 ( & r , v ) return r . error ( ) } 
func ( v setouterhtmlparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setouterhtmlparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom2 ( & r , v ) return r . error ( ) } 
func ( v setnodevalueparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setnodevalueparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom3 ( & r , v ) return r . error ( ) } 
func ( v setnodenamereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setnodenamereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom4 ( & r , v ) return r . error ( ) } 
func ( v setnodenameparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setnodenameparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom5 ( & r , v ) return r . error ( ) } 
func ( v setinspectednodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setinspectednodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom6 ( & r , v ) return r . error ( ) } 
func ( v setfileinputfilesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setfileinputfilesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom7 ( & r , v ) return r . error ( ) } 
func ( v setattributesastextparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setattributesastextparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom8 ( & r , v ) return r . error ( ) } 
func ( v setattributevalueparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setattributevalueparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom9 ( & r , v ) return r . error ( ) } 
func ( v resolvenodereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resolvenodereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom10 ( & r , v ) return r . error ( ) } 
func ( v resolvenodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resolvenodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom11 ( & r , v ) return r . error ( ) } 
func ( v requestnodereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestnodereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom12 ( & r , v ) return r . error ( ) } 
func ( v requestnodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestnodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom13 ( & r , v ) return r . error ( ) } 
func ( v requestchildnodesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestchildnodesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom14 ( & r , v ) return r . error ( ) } 
func ( v removenodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removenodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom15 ( & r , v ) return r . error ( ) } 
func ( v removeattributeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removeattributeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom16 ( & r , v ) return r . error ( ) } 
func ( v redoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * redoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom17 ( & r , v ) return r . error ( ) } 
func ( v rect ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * rect ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom18 ( & r , v ) return r . error ( ) } 
func ( v queryselectorreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * queryselectorreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom19 ( & r , v ) return r . error ( ) } 
func ( v queryselectorparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * queryselectorparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom20 ( & r , v ) return r . error ( ) } 
func ( v queryselectorallreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * queryselectorallreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom21 ( & r , v ) return r . error ( ) } 
func ( v queryselectorallparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * queryselectorallparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom22 ( & r , v ) return r . error ( ) } 
func ( v pushnodesbybackendidstofrontendreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pushnodesbybackendidstofrontendreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom23 ( & r , v ) return r . error ( ) } 
func ( v pushnodesbybackendidstofrontendparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom24 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pushnodesbybackendidstofrontendparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom24 ( & r , v ) return r . error ( ) } 
func ( v pushnodebypathtofrontendreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom25 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pushnodebypathtofrontendreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom25 ( & r , v ) return r . error ( ) } 
func ( v pushnodebypathtofrontendparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * pushnodebypathtofrontendparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom26 ( & r , v ) return r . error ( ) } 
func ( v performsearchreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom27 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * performsearchreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom27 ( & r , v ) return r . error ( ) } 
func ( v performsearchparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom28 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * performsearchparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom28 ( & r , v ) return r . error ( ) } 
func ( v movetoreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom29 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * movetoreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom29 ( & r , v ) return r . error ( ) } 
func ( v movetoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom30 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * movetoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom30 ( & r , v ) return r . error ( ) } 
func ( v markundoablestateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom31 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * markundoablestateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom31 ( & r , v ) return r . error ( ) } 
func ( v getsearchresultsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom32 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getsearchresultsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom32 ( & r , v ) return r . error ( ) } 
func ( v getsearchresultsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom33 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getsearchresultsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom33 ( & r , v ) return r . error ( ) } 
func ( v getrelayoutboundaryreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom34 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getrelayoutboundaryreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom34 ( & r , v ) return r . error ( ) } 
func ( v getrelayoutboundaryparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom35 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getrelayoutboundaryparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom35 ( & r , v ) return r . error ( ) } 
func ( v getouterhtmlreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom36 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getouterhtmlreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom36 ( & r , v ) return r . error ( ) } 
func ( v getouterhtmlparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom37 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getouterhtmlparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom37 ( & r , v ) return r . error ( ) } 
func ( v getnodeforlocationreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom38 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getnodeforlocationreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom38 ( & r , v ) return r . error ( ) } 
func ( v getnodeforlocationparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom39 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getnodeforlocationparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom39 ( & r , v ) return r . error ( ) } 
func ( v getframeownerreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom40 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getframeownerreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom40 ( & r , v ) return r . error ( ) } 
func ( v getframeownerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom41 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getframeownerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom41 ( & r , v ) return r . error ( ) } 
func ( v getflatteneddocumentreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom42 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getflatteneddocumentreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom42 ( & r , v ) return r . error ( ) } 
func ( v getflatteneddocumentparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom43 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getflatteneddocumentparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom43 ( & r , v ) return r . error ( ) } 
func ( v getfileinforeturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom44 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getfileinforeturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom44 ( & r , v ) return r . error ( ) } 
func ( v getfileinfoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom45 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getfileinfoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom45 ( & r , v ) return r . error ( ) } 
func ( v getdocumentreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom46 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdocumentreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom46 ( & r , v ) return r . error ( ) } 
func ( v getdocumentparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom47 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdocumentparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom47 ( & r , v ) return r . error ( ) } 
func ( v getcontentquadsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom48 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcontentquadsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom48 ( & r , v ) return r . error ( ) } 
func ( v getcontentquadsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom49 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcontentquadsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom49 ( & r , v ) return r . error ( ) } 
func ( v getboxmodelreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom50 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getboxmodelreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom50 ( & r , v ) return r . error ( ) } 
func ( v getboxmodelparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom51 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getboxmodelparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom51 ( & r , v ) return r . error ( ) } 
func ( v getattributesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom52 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getattributesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom52 ( & r , v ) return r . error ( ) } 
func ( v getattributesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom53 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getattributesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom53 ( & r , v ) return r . error ( ) } 
func ( v focusparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom54 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * focusparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom54 ( & r , v ) return r . error ( ) } 
func ( v eventshadowrootpushed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom55 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventshadowrootpushed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom55 ( & r , v ) return r . error ( ) } 
func ( v eventshadowrootpopped ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom56 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventshadowrootpopped ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom56 ( & r , v ) return r . error ( ) } 
func ( v eventsetchildnodes ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom57 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventsetchildnodes ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom57 ( & r , v ) return r . error ( ) } 
func ( v eventpseudoelementremoved ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom58 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventpseudoelementremoved ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom58 ( & r , v ) return r . error ( ) } 
func ( v eventpseudoelementadded ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom59 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventpseudoelementadded ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom59 ( & r , v ) return r . error ( ) } 
func ( v eventinlinestyleinvalidated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom60 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventinlinestyleinvalidated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom60 ( & r , v ) return r . error ( ) } 
func ( v eventdocumentupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom61 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdocumentupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom61 ( & r , v ) return r . error ( ) } 
func ( v eventdistributednodesupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom62 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdistributednodesupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom62 ( & r , v ) return r . error ( ) } 
func ( v eventchildnoderemoved ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom63 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventchildnoderemoved ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom63 ( & r , v ) return r . error ( ) } 
func ( v eventchildnodeinserted ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom64 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventchildnodeinserted ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom64 ( & r , v ) return r . error ( ) } 
func ( v eventchildnodecountupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom65 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventchildnodecountupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom65 ( & r , v ) return r . error ( ) } 
func ( v eventcharacterdatamodified ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom66 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventcharacterdatamodified ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom66 ( & r , v ) return r . error ( ) } 
func ( v eventattributeremoved ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom67 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventattributeremoved ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom67 ( & r , v ) return r . error ( ) } 
func ( v eventattributemodified ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom68 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventattributemodified ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom68 ( & r , v ) return r . error ( ) } 
func ( v discardsearchresultsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom70 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * discardsearchresultsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom70 ( & r , v ) return r . error ( ) } 
func ( v describenodereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom72 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * describenodereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom72 ( & r , v ) return r . error ( ) } 
func ( v describenodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom73 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * describenodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom73 ( & r , v ) return r . error ( ) } 
func ( v copytoreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom74 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * copytoreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom74 ( & r , v ) return r . error ( ) } 
func ( v copytoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom75 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * copytoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom75 ( & r , v ) return r . error ( ) } 
func ( v collectclassnamesfromsubtreereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom76 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * collectclassnamesfromsubtreereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom76 ( & r , v ) return r . error ( ) } 
func ( v collectclassnamesfromsubtreeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom77 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * collectclassnamesfromsubtreeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom77 ( & r , v ) return r . error ( ) } 
func ( v boxmodel ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodom78 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * boxmodel ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodom78 ( & r , v ) return r . error ( ) } 
func ( v stopcastingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocast ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopcastingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocast ( & r , v ) return r . error ( ) } 
func ( v starttabmirroringparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocast1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * starttabmirroringparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocast1 ( & r , v ) return r . error ( ) } 
func ( v setsinktouseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocast2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setsinktouseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocast2 ( & r , v ) return r . error ( ) } 
func ( v eventsinksupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocast3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventsinksupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocast3 ( & r , v ) return r . error ( ) } 
func ( v eventissueupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocast4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventissueupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocast4 ( & r , v ) return r . error ( ) } 
func ( p * addinspectedheapobjectparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandaddinspectedheapobject , p , nil ) } 
func ( p * collectgarbageparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcollectgarbage , nil , nil ) } 
func ( p * getheapobjectidparams ) do ( ctx context . context ) ( heapsnapshotobjectid heapsnapshotobjectid , err error ) { var res getheapobjectidreturns err = cdp . execute ( ctx , commandgetheapobjectid , p , & res ) if err ! = nil { return " " , err } return res . heapsnapshotobjectid , nil } 
func ( p getobjectbyheapobjectidparams ) withobjectgroup ( objectgroup string ) * getobjectbyheapobjectidparams { p . objectgroup = objectgroup return & p } 
func ( p * getobjectbyheapobjectidparams ) do ( ctx context . context ) ( result * runtime . remoteobject , err error ) { var res getobjectbyheapobjectidreturns err = cdp . execute ( ctx , commandgetobjectbyheapobjectid , p , & res ) if err ! = nil { return nil , err } return res . result , nil } 
func ( p startsamplingparams ) withsamplinginterval ( samplinginterval float64 ) * startsamplingparams { p . samplinginterval = samplinginterval return & p } 
func ( p starttrackingheapobjectsparams ) withtrackallocations ( trackallocations bool ) * starttrackingheapobjectsparams { p . trackallocations = trackallocations return & p } 
func ( p * starttrackingheapobjectsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstarttrackingheapobjects , p , nil ) } 
func ( p * stopsamplingparams ) do ( ctx context . context ) ( profile * samplingheapprofile , err error ) { var res stopsamplingreturns err = cdp . execute ( ctx , commandstopsampling , nil , & res ) if err ! = nil { return nil , err } return res . profile , nil } 
func ( p stoptrackingheapobjectsparams ) withreportprogress ( reportprogress bool ) * stoptrackingheapobjectsparams { p . reportprogress = reportprogress return & p } 
func ( p * stoptrackingheapobjectsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstoptrackingheapobjects , p , nil ) } 
func ( p takeheapsnapshotparams ) withreportprogress ( reportprogress bool ) * takeheapsnapshotparams { p . reportprogress = reportprogress return & p } 
func ( p * takeheapsnapshotparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandtakeheapsnapshot , p , nil ) } 
func ( p grantpermissionsparams ) withbrowsercontextid ( browsercontextid target . browsercontextid ) * grantpermissionsparams { p . browsercontextid = browsercontextid return & p } 
func ( p * grantpermissionsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandgrantpermissions , p , nil ) } 
func ( p resetpermissionsparams ) withbrowsercontextid ( browsercontextid target . browsercontextid ) * resetpermissionsparams { p . browsercontextid = browsercontextid return & p } 
func ( p * resetpermissionsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandresetpermissions , p , nil ) } 
func ( p * crashparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcrash , nil , nil ) } 
func ( p * crashgpuprocessparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcrashgpuprocess , nil , nil ) } 
func ( p * getversionparams ) do ( ctx context . context ) ( protocolversion string , product string , revision string , useragent string , jsversion string , err error ) { var res getversionreturns err = cdp . execute ( ctx , commandgetversion , nil , & res ) if err ! = nil { return " " , " " , " " , " " , " " , err } return res . protocolversion , res . product , res . revision , res . useragent , res . jsversion , nil } 
func ( p * getbrowsercommandlineparams ) do ( ctx context . context ) ( arguments [ ] string , err error ) { var res getbrowsercommandlinereturns err = cdp . execute ( ctx , commandgetbrowsercommandline , nil , & res ) if err ! = nil { return nil , err } return res . arguments , nil } 
func ( p gethistogramsparams ) withquery ( query string ) * gethistogramsparams { p . query = query return & p } 
func ( p gethistogramsparams ) withdelta ( delta bool ) * gethistogramsparams { p . delta = delta return & p } 
func ( p * gethistogramsparams ) do ( ctx context . context ) ( histograms [ ] * histogram , err error ) { var res gethistogramsreturns err = cdp . execute ( ctx , commandgethistograms , p , & res ) if err ! = nil { return nil , err } return res . histograms , nil } 
func ( p gethistogramparams ) withdelta ( delta bool ) * gethistogramparams { p . delta = delta return & p } 
func ( p * gethistogramparams ) do ( ctx context . context ) ( histogram * histogram , err error ) { var res gethistogramreturns err = cdp . execute ( ctx , commandgethistogram , p , & res ) if err ! = nil { return nil , err } return res . histogram , nil } 
func ( p * getwindowboundsparams ) do ( ctx context . context ) ( bounds * bounds , err error ) { var res getwindowboundsreturns err = cdp . execute ( ctx , commandgetwindowbounds , p , & res ) if err ! = nil { return nil , err } return res . bounds , nil } 
func ( p getwindowfortargetparams ) withtargetid ( targetid target . id ) * getwindowfortargetparams { p . targetid = targetid return & p } 
func ( p * getwindowfortargetparams ) do ( ctx context . context ) ( windowid windowid , bounds * bounds , err error ) { var res getwindowfortargetreturns err = cdp . execute ( ctx , commandgetwindowfortarget , p , & res ) if err ! = nil { return 0 , nil , err } return res . windowid , res . bounds , nil } 
func ( p * setwindowboundsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetwindowbounds , p , nil ) } 
func ( p setdocktileparams ) withbadgelabel ( badgelabel string ) * setdocktileparams { p . badgelabel = badgelabel return & p } 
func ( p setdocktileparams ) withimage ( image string ) * setdocktileparams { p . image = image return & p } 
func ( p * setdocktileparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdocktile , p , nil ) } 
func ( p * deletecacheparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddeletecache , p , nil ) } 
func ( p * deleteentryparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddeleteentry , p , nil ) } 
func ( p * requestcachenamesparams ) do ( ctx context . context ) ( caches [ ] * cache , err error ) { var res requestcachenamesreturns err = cdp . execute ( ctx , commandrequestcachenames , p , & res ) if err ! = nil { return nil , err } return res . caches , nil } 
func ( p * requestcachedresponseparams ) do ( ctx context . context ) ( response * cachedresponse , err error ) { var res requestcachedresponsereturns err = cdp . execute ( ctx , commandrequestcachedresponse , p , & res ) if err ! = nil { return nil , err } return res . response , nil } 
func ( p requestentriesparams ) withpathfilter ( pathfilter string ) * requestentriesparams { p . pathfilter = pathfilter return & p } 
func ( p * requestentriesparams ) do ( ctx context . context ) ( cachedataentries [ ] * dataentry , returncount float64 , err error ) { var res requestentriesreturns err = cdp . execute ( ctx , commandrequestentries , p , & res ) if err ! = nil { return nil , 0 , err } return res . cachedataentries , res . returncount , nil } 
func ( p * collectclassnamesfromsubtreeparams ) do ( ctx context . context ) ( classnames [ ] string , err error ) { var res collectclassnamesfromsubtreereturns err = cdp . execute ( ctx , commandcollectclassnamesfromsubtree , p , & res ) if err ! = nil { return nil , err } return res . classnames , nil } 
func ( p copytoparams ) withinsertbeforenodeid ( insertbeforenodeid cdp . nodeid ) * copytoparams { p . insertbeforenodeid = insertbeforenodeid return & p } 
func ( p * copytoparams ) do ( ctx context . context ) ( nodeid cdp . nodeid , err error ) { var res copytoreturns err = cdp . execute ( ctx , commandcopyto , p , & res ) if err ! = nil { return 0 , err } return res . nodeid , nil } 
func ( p describenodeparams ) withnodeid ( nodeid cdp . nodeid ) * describenodeparams { p . nodeid = nodeid return & p } 
func ( p describenodeparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * describenodeparams { p . backendnodeid = backendnodeid return & p } 
func ( p describenodeparams ) withobjectid ( objectid runtime . remoteobjectid ) * describenodeparams { p . objectid = objectid return & p } 
func ( p describenodeparams ) withdepth ( depth int64 ) * describenodeparams { p . depth = depth return & p } 
func ( p describenodeparams ) withpierce ( pierce bool ) * describenodeparams { p . pierce = pierce return & p } 
func ( p * describenodeparams ) do ( ctx context . context ) ( node * cdp . node , err error ) { var res describenodereturns err = cdp . execute ( ctx , commanddescribenode , p , & res ) if err ! = nil { return nil , err } return res . node , nil } 
func ( p * discardsearchresultsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddiscardsearchresults , p , nil ) } 
func ( p focusparams ) withnodeid ( nodeid cdp . nodeid ) * focusparams { p . nodeid = nodeid return & p } 
func ( p focusparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * focusparams { p . backendnodeid = backendnodeid return & p } 
func ( p focusparams ) withobjectid ( objectid runtime . remoteobjectid ) * focusparams { p . objectid = objectid return & p } 
func ( p * focusparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandfocus , p , nil ) } 
func ( p * getattributesparams ) do ( ctx context . context ) ( attributes [ ] string , err error ) { var res getattributesreturns err = cdp . execute ( ctx , commandgetattributes , p , & res ) if err ! = nil { return nil , err } return res . attributes , nil } 
func ( p getboxmodelparams ) withnodeid ( nodeid cdp . nodeid ) * getboxmodelparams { p . nodeid = nodeid return & p } 
func ( p getboxmodelparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * getboxmodelparams { p . backendnodeid = backendnodeid return & p } 
func ( p getboxmodelparams ) withobjectid ( objectid runtime . remoteobjectid ) * getboxmodelparams { p . objectid = objectid return & p } 
func ( p * getboxmodelparams ) do ( ctx context . context ) ( model * boxmodel , err error ) { var res getboxmodelreturns err = cdp . execute ( ctx , commandgetboxmodel , p , & res ) if err ! = nil { return nil , err } return res . model , nil } 
func ( p getcontentquadsparams ) withnodeid ( nodeid cdp . nodeid ) * getcontentquadsparams { p . nodeid = nodeid return & p } 
func ( p getcontentquadsparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * getcontentquadsparams { p . backendnodeid = backendnodeid return & p } 
func ( p getcontentquadsparams ) withobjectid ( objectid runtime . remoteobjectid ) * getcontentquadsparams { p . objectid = objectid return & p } 
func ( p * getcontentquadsparams ) do ( ctx context . context ) ( quads [ ] quad , err error ) { var res getcontentquadsreturns err = cdp . execute ( ctx , commandgetcontentquads , p , & res ) if err ! = nil { return nil , err } return res . quads , nil } 
func ( p getdocumentparams ) withdepth ( depth int64 ) * getdocumentparams { p . depth = depth return & p } 
func ( p getdocumentparams ) withpierce ( pierce bool ) * getdocumentparams { p . pierce = pierce return & p } 
func ( p * getdocumentparams ) do ( ctx context . context ) ( root * cdp . node , err error ) { var res getdocumentreturns err = cdp . execute ( ctx , commandgetdocument , p , & res ) if err ! = nil { return nil , err } return res . root , nil } 
func ( p getflatteneddocumentparams ) withdepth ( depth int64 ) * getflatteneddocumentparams { p . depth = depth return & p } 
func ( p getflatteneddocumentparams ) withpierce ( pierce bool ) * getflatteneddocumentparams { p . pierce = pierce return & p } 
func ( p * getflatteneddocumentparams ) do ( ctx context . context ) ( nodes [ ] * cdp . node , err error ) { var res getflatteneddocumentreturns err = cdp . execute ( ctx , commandgetflatteneddocument , p , & res ) if err ! = nil { return nil , err } return res . nodes , nil } 
func ( p getnodeforlocationparams ) withincludeuseragentshadowdom ( includeuseragentshadowdom bool ) * getnodeforlocationparams { p . includeuseragentshadowdom = includeuseragentshadowdom return & p } 
func ( p * getnodeforlocationparams ) do ( ctx context . context ) ( backendnodeid cdp . backendnodeid , nodeid cdp . nodeid , err error ) { var res getnodeforlocationreturns err = cdp . execute ( ctx , commandgetnodeforlocation , p , & res ) if err ! = nil { return 0 , 0 , err } return res . backendnodeid , res . nodeid , nil } 
func ( p getouterhtmlparams ) withnodeid ( nodeid cdp . nodeid ) * getouterhtmlparams { p . nodeid = nodeid return & p } 
func ( p getouterhtmlparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * getouterhtmlparams { p . backendnodeid = backendnodeid return & p } 
func ( p getouterhtmlparams ) withobjectid ( objectid runtime . remoteobjectid ) * getouterhtmlparams { p . objectid = objectid return & p } 
func ( p * getouterhtmlparams ) do ( ctx context . context ) ( outerhtml string , err error ) { var res getouterhtmlreturns err = cdp . execute ( ctx , commandgetouterhtml , p , & res ) if err ! = nil { return " " , err } return res . outerhtml , nil } 
func ( p * getrelayoutboundaryparams ) do ( ctx context . context ) ( nodeid cdp . nodeid , err error ) { var res getrelayoutboundaryreturns err = cdp . execute ( ctx , commandgetrelayoutboundary , p , & res ) if err ! = nil { return 0 , err } return res . nodeid , nil } 
func ( p * getsearchresultsparams ) do ( ctx context . context ) ( nodeids [ ] cdp . nodeid , err error ) { var res getsearchresultsreturns err = cdp . execute ( ctx , commandgetsearchresults , p , & res ) if err ! = nil { return nil , err } return res . nodeids , nil } 
func ( p * markundoablestateparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandmarkundoablestate , nil , nil ) } 
func ( p movetoparams ) withinsertbeforenodeid ( insertbeforenodeid cdp . nodeid ) * movetoparams { p . insertbeforenodeid = insertbeforenodeid return & p } 
func ( p * movetoparams ) do ( ctx context . context ) ( nodeid cdp . nodeid , err error ) { var res movetoreturns err = cdp . execute ( ctx , commandmoveto , p , & res ) if err ! = nil { return 0 , err } return res . nodeid , nil } 
func ( p performsearchparams ) withincludeuseragentshadowdom ( includeuseragentshadowdom bool ) * performsearchparams { p . includeuseragentshadowdom = includeuseragentshadowdom return & p } 
func ( p * performsearchparams ) do ( ctx context . context ) ( searchid string , resultcount int64 , err error ) { var res performsearchreturns err = cdp . execute ( ctx , commandperformsearch , p , & res ) if err ! = nil { return " " , 0 , err } return res . searchid , res . resultcount , nil } 
func ( p * pushnodebypathtofrontendparams ) do ( ctx context . context ) ( nodeid cdp . nodeid , err error ) { var res pushnodebypathtofrontendreturns err = cdp . execute ( ctx , commandpushnodebypathtofrontend , p , & res ) if err ! = nil { return 0 , err } return res . nodeid , nil } 
func ( p * pushnodesbybackendidstofrontendparams ) do ( ctx context . context ) ( nodeids [ ] cdp . nodeid , err error ) { var res pushnodesbybackendidstofrontendreturns err = cdp . execute ( ctx , commandpushnodesbybackendidstofrontend , p , & res ) if err ! = nil { return nil , err } return res . nodeids , nil } 
func ( p * queryselectorparams ) do ( ctx context . context ) ( nodeid cdp . nodeid , err error ) { var res queryselectorreturns err = cdp . execute ( ctx , commandqueryselector , p , & res ) if err ! = nil { return 0 , err } return res . nodeid , nil } 
func ( p * queryselectorallparams ) do ( ctx context . context ) ( nodeids [ ] cdp . nodeid , err error ) { var res queryselectorallreturns err = cdp . execute ( ctx , commandqueryselectorall , p , & res ) if err ! = nil { return nil , err } return res . nodeids , nil } 
func ( p * redoparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandredo , nil , nil ) } 
func ( p * removeattributeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremoveattribute , p , nil ) } 
func ( p * removenodeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremovenode , p , nil ) } 
func ( p requestchildnodesparams ) withdepth ( depth int64 ) * requestchildnodesparams { p . depth = depth return & p } 
func ( p requestchildnodesparams ) withpierce ( pierce bool ) * requestchildnodesparams { p . pierce = pierce return & p } 
func ( p * requestchildnodesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandrequestchildnodes , p , nil ) } 
func ( p * requestnodeparams ) do ( ctx context . context ) ( nodeid cdp . nodeid , err error ) { var res requestnodereturns err = cdp . execute ( ctx , commandrequestnode , p , & res ) if err ! = nil { return 0 , err } return res . nodeid , nil } 
func ( p resolvenodeparams ) withnodeid ( nodeid cdp . nodeid ) * resolvenodeparams { p . nodeid = nodeid return & p } 
func ( p resolvenodeparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * resolvenodeparams { p . backendnodeid = backendnodeid return & p } 
func ( p resolvenodeparams ) withobjectgroup ( objectgroup string ) * resolvenodeparams { p . objectgroup = objectgroup return & p } 
func ( p resolvenodeparams ) withexecutioncontextid ( executioncontextid runtime . executioncontextid ) * resolvenodeparams { p . executioncontextid = executioncontextid return & p } 
func ( p * resolvenodeparams ) do ( ctx context . context ) ( object * runtime . remoteobject , err error ) { var res resolvenodereturns err = cdp . execute ( ctx , commandresolvenode , p , & res ) if err ! = nil { return nil , err } return res . object , nil } 
func ( p * setattributevalueparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetattributevalue , p , nil ) } 
func ( p setattributesastextparams ) withname ( name string ) * setattributesastextparams { p . name = name return & p } 
func ( p * setattributesastextparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetattributesastext , p , nil ) } 
func ( p setfileinputfilesparams ) withnodeid ( nodeid cdp . nodeid ) * setfileinputfilesparams { p . nodeid = nodeid return & p } 
func ( p setfileinputfilesparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * setfileinputfilesparams { p . backendnodeid = backendnodeid return & p } 
func ( p setfileinputfilesparams ) withobjectid ( objectid runtime . remoteobjectid ) * setfileinputfilesparams { p . objectid = objectid return & p } 
func ( p * setfileinputfilesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetfileinputfiles , p , nil ) } 
func ( p * getfileinfoparams ) do ( ctx context . context ) ( path string , err error ) { var res getfileinforeturns err = cdp . execute ( ctx , commandgetfileinfo , p , & res ) if err ! = nil { return " " , err } return res . path , nil } 
func ( p * setinspectednodeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetinspectednode , p , nil ) } 
func ( p * setnodenameparams ) do ( ctx context . context ) ( nodeid cdp . nodeid , err error ) { var res setnodenamereturns err = cdp . execute ( ctx , commandsetnodename , p , & res ) if err ! = nil { return 0 , err } return res . nodeid , nil } 
func ( p * setnodevalueparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetnodevalue , p , nil ) } 
func ( p * setouterhtmlparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetouterhtml , p , nil ) } 
func ( p * undoparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandundo , nil , nil ) } 
func ( p * getframeownerparams ) do ( ctx context . context ) ( backendnodeid cdp . backendnodeid , nodeid cdp . nodeid , err error ) { var res getframeownerreturns err = cdp . execute ( ctx , commandgetframeowner , p , & res ) if err ! = nil { return 0 , 0 , err } return res . backendnodeid , res . nodeid , nil } 
func ( t contexttype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * contexttype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch contexttype ( in . string ( ) ) { case contexttyperealtime : * t = contexttyperealtime case contexttypeoffline : * t = contexttypeoffline default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * contexttype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t contextstate ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * contextstate ) unmarshaleasyjson ( in * jlexer . lexer ) { switch contextstate ( in . string ( ) ) { case contextstatesuspended : * t = contextstatesuspended case contextstaterunning : * t = contextstaterunning case contextstateclosed : * t = contextstateclosed default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * contextstate ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v settimedomainparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoperformance ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * settimedomainparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoperformance ( & r , v ) return r . error ( ) } 
func ( v metric ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoperformance1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * metric ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoperformance1 ( & r , v ) return r . error ( ) } 
func ( v getmetricsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoperformance2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmetricsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoperformance2 ( & r , v ) return r . error ( ) } 
func ( v getmetricsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoperformance3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getmetricsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoperformance3 ( & r , v ) return r . error ( ) } 
func ( v eventmetrics ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoperformance4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventmetrics ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoperformance4 ( & r , v ) return r . error ( ) } 
func ( t getencodedresponseencoding ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * getencodedresponseencoding ) unmarshaleasyjson ( in * jlexer . lexer ) { switch getencodedresponseencoding ( in . string ( ) ) { case getencodedresponseencodingwebp : * t = getencodedresponseencodingwebp case getencodedresponseencodingjpeg : * t = getencodedresponseencodingjpeg case getencodedresponseencodingpng : * t = getencodedresponseencodingpng default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * getencodedresponseencoding ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t cachedresponsetype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * cachedresponsetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch cachedresponsetype ( in . string ( ) ) { case cachedresponsetypebasic : * t = cachedresponsetypebasic case cachedresponsetypecors : * t = cachedresponsetypecors case cachedresponsetypedefault : * t = cachedresponsetypedefault case cachedresponsetypeerror : * t = cachedresponsetypeerror case cachedresponsetypeopaqueresponse : * t = cachedresponsetypeopaqueresponse case cachedresponsetypeopaqueredirect : * t = cachedresponsetypeopaqueredirect default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * cachedresponsetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( p * addruleparams ) do ( ctx context . context ) ( rule * rule , err error ) { var res addrulereturns err = cdp . execute ( ctx , commandaddrule , p , & res ) if err ! = nil { return nil , err } return res . rule , nil } 
func ( p * collectclassnamesparams ) do ( ctx context . context ) ( classnames [ ] string , err error ) { var res collectclassnamesreturns err = cdp . execute ( ctx , commandcollectclassnames , p , & res ) if err ! = nil { return nil , err } return res . classnames , nil } 
func ( p * createstylesheetparams ) do ( ctx context . context ) ( stylesheetid stylesheetid , err error ) { var res createstylesheetreturns err = cdp . execute ( ctx , commandcreatestylesheet , p , & res ) if err ! = nil { return " " , err } return res . stylesheetid , nil } 
func ( p * forcepseudostateparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandforcepseudostate , p , nil ) } 
func ( p * getbackgroundcolorsparams ) do ( ctx context . context ) ( backgroundcolors [ ] string , computedfontsize string , computedfontweight string , err error ) { var res getbackgroundcolorsreturns err = cdp . execute ( ctx , commandgetbackgroundcolors , p , & res ) if err ! = nil { return nil , " " , " " , err } return res . backgroundcolors , res . computedfontsize , res . computedfontweight , nil } 
func ( p * getcomputedstylefornodeparams ) do ( ctx context . context ) ( computedstyle [ ] * computedproperty , err error ) { var res getcomputedstylefornodereturns err = cdp . execute ( ctx , commandgetcomputedstylefornode , p , & res ) if err ! = nil { return nil , err } return res . computedstyle , nil } 
func ( p * getinlinestylesfornodeparams ) do ( ctx context . context ) ( inlinestyle * style , attributesstyle * style , err error ) { var res getinlinestylesfornodereturns err = cdp . execute ( ctx , commandgetinlinestylesfornode , p , & res ) if err ! = nil { return nil , nil , err } return res . inlinestyle , res . attributesstyle , nil } 
func ( p * getmatchedstylesfornodeparams ) do ( ctx context . context ) ( inlinestyle * style , attributesstyle * style , matchedcssrules [ ] * rulematch , pseudoelements [ ] * pseudoelementmatches , inherited [ ] * inheritedstyleentry , csskeyframesrules [ ] * keyframesrule , err error ) { var res getmatchedstylesfornodereturns err = cdp . execute ( ctx , commandgetmatchedstylesfornode , p , & res ) if err ! = nil { return nil , nil , nil , nil , nil , nil , err } return res . inlinestyle , res . attributesstyle , res . matchedcssrules , res . pseudoelements , res . inherited , res . csskeyframesrules , nil } 
func ( p * getmediaqueriesparams ) do ( ctx context . context ) ( medias [ ] * media , err error ) { var res getmediaqueriesreturns err = cdp . execute ( ctx , commandgetmediaqueries , nil , & res ) if err ! = nil { return nil , err } return res . medias , nil } 
func ( p * getplatformfontsfornodeparams ) do ( ctx context . context ) ( fonts [ ] * platformfontusage , err error ) { var res getplatformfontsfornodereturns err = cdp . execute ( ctx , commandgetplatformfontsfornode , p , & res ) if err ! = nil { return nil , err } return res . fonts , nil } 
func ( p * getstylesheettextparams ) do ( ctx context . context ) ( text string , err error ) { var res getstylesheettextreturns err = cdp . execute ( ctx , commandgetstylesheettext , p , & res ) if err ! = nil { return " " , err } return res . text , nil } 
func ( p * seteffectivepropertyvaluefornodeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandseteffectivepropertyvaluefornode , p , nil ) } 
func ( p * setkeyframekeyparams ) do ( ctx context . context ) ( keytext * value , err error ) { var res setkeyframekeyreturns err = cdp . execute ( ctx , commandsetkeyframekey , p , & res ) if err ! = nil { return nil , err } return res . keytext , nil } 
func ( p * setmediatextparams ) do ( ctx context . context ) ( media * media , err error ) { var res setmediatextreturns err = cdp . execute ( ctx , commandsetmediatext , p , & res ) if err ! = nil { return nil , err } return res . media , nil } 
func ( p * setruleselectorparams ) do ( ctx context . context ) ( selectorlist * selectorlist , err error ) { var res setruleselectorreturns err = cdp . execute ( ctx , commandsetruleselector , p , & res ) if err ! = nil { return nil , err } return res . selectorlist , nil } 
func ( p * setstylesheettextparams ) do ( ctx context . context ) ( sourcemapurl string , err error ) { var res setstylesheettextreturns err = cdp . execute ( ctx , commandsetstylesheettext , p , & res ) if err ! = nil { return " " , err } return res . sourcemapurl , nil } 
func ( p * setstyletextsparams ) do ( ctx context . context ) ( styles [ ] * style , err error ) { var res setstyletextsreturns err = cdp . execute ( ctx , commandsetstyletexts , p , & res ) if err ! = nil { return nil , err } return res . styles , nil } 
func ( p * startruleusagetrackingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstartruleusagetracking , nil , nil ) } 
func ( p * stopruleusagetrackingparams ) do ( ctx context . context ) ( ruleusage [ ] * ruleusage , err error ) { var res stopruleusagetrackingreturns err = cdp . execute ( ctx , commandstopruleusagetracking , nil , & res ) if err ! = nil { return nil , err } return res . ruleusage , nil } 
func ( p * takecoveragedeltaparams ) do ( ctx context . context ) ( coverage [ ] * ruleusage , err error ) { var res takecoveragedeltareturns err = cdp . execute ( ctx , commandtakecoveragedelta , nil , & res ) if err ! = nil { return nil , err } return res . coverage , nil } 
func ( v resolveblobreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoio ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resolveblobreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoio ( & r , v ) return r . error ( ) } 
func ( v resolveblobparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoio1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resolveblobparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoio1 ( & r , v ) return r . error ( ) } 
func ( v readreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoio2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * readreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoio2 ( & r , v ) return r . error ( ) } 
func ( v readparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoio3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * readparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoio3 ( & r , v ) return r . error ( ) } 
func ( p readparams ) withoffset ( offset int64 ) * readparams { p . offset = offset return & p } 
func ( p readparams ) withsize ( size int64 ) * readparams { p . size = size return & p } 
func ( v storageid ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * storageid ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage ( & r , v ) return r . error ( ) } 
func ( v setdomstorageitemparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdomstorageitemparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage1 ( & r , v ) return r . error ( ) } 
func ( v removedomstorageitemparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removedomstorageitemparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage2 ( & r , v ) return r . error ( ) } 
func ( v getdomstorageitemsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdomstorageitemsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage3 ( & r , v ) return r . error ( ) } 
func ( v getdomstorageitemsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdomstorageitemsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage4 ( & r , v ) return r . error ( ) } 
func ( v eventdomstorageitemscleared ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdomstorageitemscleared ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage5 ( & r , v ) return r . error ( ) } 
func ( v eventdomstorageitemupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdomstorageitemupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage6 ( & r , v ) return r . error ( ) } 
func ( v eventdomstorageitemremoved ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdomstorageitemremoved ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage7 ( & r , v ) return r . error ( ) } 
func ( v eventdomstorageitemadded ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventdomstorageitemadded ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage8 ( & r , v ) return r . error ( ) } 
func ( v clearparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomstorage11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * clearparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomstorage11 ( & r , v ) return r . error ( ) } 
func ( t versionrunningstatus ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * versionrunningstatus ) unmarshaleasyjson ( in * jlexer . lexer ) { switch versionrunningstatus ( in . string ( ) ) { case versionrunningstatusstopped : * t = versionrunningstatusstopped case versionrunningstatusstarting : * t = versionrunningstatusstarting case versionrunningstatusrunning : * t = versionrunningstatusrunning case versionrunningstatusstopping : * t = versionrunningstatusstopping default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * versionrunningstatus ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t versionstatus ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * versionstatus ) unmarshaleasyjson ( in * jlexer . lexer ) { switch versionstatus ( in . string ( ) ) { case versionstatusnew : * t = versionstatusnew case versionstatusinstalling : * t = versionstatusinstalling case versionstatusinstalled : * t = versionstatusinstalled case versionstatusactivating : * t = versionstatusactivating case versionstatusactivated : * t = versionstatusactivated case versionstatusredundant : * t = versionstatusredundant default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * versionstatus ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v setwindowboundsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setwindowboundsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser ( & r , v ) return r . error ( ) } 
func ( v setdocktileparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdocktileparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser1 ( & r , v ) return r . error ( ) } 
func ( v resetpermissionsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resetpermissionsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser2 ( & r , v ) return r . error ( ) } 
func ( v histogram ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * histogram ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser3 ( & r , v ) return r . error ( ) } 
func ( v grantpermissionsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * grantpermissionsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser4 ( & r , v ) return r . error ( ) } 
func ( v getwindowfortargetreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getwindowfortargetreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser5 ( & r , v ) return r . error ( ) } 
func ( v getwindowfortargetparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getwindowfortargetparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser6 ( & r , v ) return r . error ( ) } 
func ( v getwindowboundsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getwindowboundsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser7 ( & r , v ) return r . error ( ) } 
func ( v getwindowboundsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getwindowboundsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser8 ( & r , v ) return r . error ( ) } 
func ( v getversionreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getversionreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser9 ( & r , v ) return r . error ( ) } 
func ( v getversionparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getversionparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser10 ( & r , v ) return r . error ( ) } 
func ( v gethistogramsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gethistogramsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser11 ( & r , v ) return r . error ( ) } 
func ( v gethistogramsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gethistogramsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser12 ( & r , v ) return r . error ( ) } 
func ( v gethistogramreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gethistogramreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser13 ( & r , v ) return r . error ( ) } 
func ( v gethistogramparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gethistogramparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser14 ( & r , v ) return r . error ( ) } 
func ( v getbrowsercommandlinereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbrowsercommandlinereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser15 ( & r , v ) return r . error ( ) } 
func ( v getbrowsercommandlineparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbrowsercommandlineparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser16 ( & r , v ) return r . error ( ) } 
func ( v crashparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * crashparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser17 ( & r , v ) return r . error ( ) } 
func ( v crashgpuprocessparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * crashgpuprocessparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser18 ( & r , v ) return r . error ( ) } 
func ( v * closeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser19 ( & r , v ) return r . error ( ) } 
func ( v bucket ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * bucket ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser20 ( & r , v ) return r . error ( ) } 
func ( v bounds ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobrowser21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * bounds ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobrowser21 ( & r , v ) return r . error ( ) } 
func ( v stopobservingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopobservingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice ( & r , v ) return r . error ( ) } 
func ( v startobservingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * startobservingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice1 ( & r , v ) return r . error ( ) } 
func ( v setrecordingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setrecordingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice2 ( & r , v ) return r . error ( ) } 
func ( v eventrecordingstatechanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventrecordingstatechanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice3 ( & r , v ) return r . error ( ) } 
func ( v eventmetadata ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventmetadata ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice4 ( & r , v ) return r . error ( ) } 
func ( v eventbackgroundserviceeventreceived ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventbackgroundserviceeventreceived ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice5 ( & r , v ) return r . error ( ) } 
func ( v event ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * event ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice6 ( & r , v ) return r . error ( ) } 
func ( v cleareventsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotobackgroundservice7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cleareventsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotobackgroundservice7 ( & r , v ) return r . error ( ) } 
func ( v usagefortype ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * usagefortype ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage ( & r , v ) return r . error ( ) } 
func ( v untrackindexeddbfororiginparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * untrackindexeddbfororiginparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage1 ( & r , v ) return r . error ( ) } 
func ( v untrackcachestoragefororiginparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * untrackcachestoragefororiginparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage2 ( & r , v ) return r . error ( ) } 
func ( v trackindexeddbfororiginparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * trackindexeddbfororiginparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage3 ( & r , v ) return r . error ( ) } 
func ( v trackcachestoragefororiginparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * trackcachestoragefororiginparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage4 ( & r , v ) return r . error ( ) } 
func ( v getusageandquotareturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getusageandquotareturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage5 ( & r , v ) return r . error ( ) } 
func ( v getusageandquotaparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getusageandquotaparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage6 ( & r , v ) return r . error ( ) } 
func ( v eventindexeddblistupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventindexeddblistupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage7 ( & r , v ) return r . error ( ) } 
func ( v eventindexeddbcontentupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventindexeddbcontentupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage8 ( & r , v ) return r . error ( ) } 
func ( v eventcachestoragelistupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventcachestoragelistupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage9 ( & r , v ) return r . error ( ) } 
func ( v eventcachestoragecontentupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventcachestoragecontentupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage10 ( & r , v ) return r . error ( ) } 
func ( v cleardatafororiginparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotostorage11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cleardatafororiginparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotostorage11 ( & r , v ) return r . error ( ) } 
func ( p * cleardatafororiginparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcleardatafororigin , p , nil ) } 
func ( p * getusageandquotaparams ) do ( ctx context . context ) ( usage float64 , quota float64 , usagebreakdown [ ] * usagefortype , err error ) { var res getusageandquotareturns err = cdp . execute ( ctx , commandgetusageandquota , p , & res ) if err ! = nil { return 0 , 0 , nil , err } return res . usage , res . quota , res . usagebreakdown , nil } 
func ( p * trackcachestoragefororiginparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandtrackcachestoragefororigin , p , nil ) } 
func ( p * trackindexeddbfororiginparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandtrackindexeddbfororigin , p , nil ) } 
func ( p * untrackcachestoragefororiginparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanduntrackcachestoragefororigin , p , nil ) } 
func ( p * untrackindexeddbfororiginparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanduntrackindexeddbfororigin , p , nil ) } 
func ( p * gethighlightobjectfortestparams ) do ( ctx context . context ) ( highlight easyjson . rawmessage , err error ) { var res gethighlightobjectfortestreturns err = cdp . execute ( ctx , commandgethighlightobjectfortest , p , & res ) if err ! = nil { return nil , err } return res . highlight , nil } 
func ( p * hidehighlightparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandhidehighlight , nil , nil ) } 
func ( p highlightframeparams ) withcontentcolor ( contentcolor * cdp . rgba ) * highlightframeparams { p . contentcolor = contentcolor return & p } 
func ( p highlightframeparams ) withcontentoutlinecolor ( contentoutlinecolor * cdp . rgba ) * highlightframeparams { p . contentoutlinecolor = contentoutlinecolor return & p } 
func ( p * highlightframeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandhighlightframe , p , nil ) } 
func ( p highlightnodeparams ) withnodeid ( nodeid cdp . nodeid ) * highlightnodeparams { p . nodeid = nodeid return & p } 
func ( p highlightnodeparams ) withbackendnodeid ( backendnodeid cdp . backendnodeid ) * highlightnodeparams { p . backendnodeid = backendnodeid return & p } 
func ( p highlightnodeparams ) withobjectid ( objectid runtime . remoteobjectid ) * highlightnodeparams { p . objectid = objectid return & p } 
func ( p highlightnodeparams ) withselector ( selector string ) * highlightnodeparams { p . selector = selector return & p } 
func ( p * highlightnodeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandhighlightnode , p , nil ) } 
func ( p highlightquadparams ) withcolor ( color * cdp . rgba ) * highlightquadparams { p . color = color return & p } 
func ( p highlightquadparams ) withoutlinecolor ( outlinecolor * cdp . rgba ) * highlightquadparams { p . outlinecolor = outlinecolor return & p } 
func ( p * highlightquadparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandhighlightquad , p , nil ) } 
func ( p highlightrectparams ) withcolor ( color * cdp . rgba ) * highlightrectparams { p . color = color return & p } 
func ( p highlightrectparams ) withoutlinecolor ( outlinecolor * cdp . rgba ) * highlightrectparams { p . outlinecolor = outlinecolor return & p } 
func ( p * highlightrectparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandhighlightrect , p , nil ) } 
func ( p setinspectmodeparams ) withhighlightconfig ( highlightconfig * highlightconfig ) * setinspectmodeparams { p . highlightconfig = highlightconfig return & p } 
func ( p * setinspectmodeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetinspectmode , p , nil ) } 
func ( p * setshowadhighlightsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetshowadhighlights , p , nil ) } 
func ( p setpausedindebuggermessageparams ) withmessage ( message string ) * setpausedindebuggermessageparams { p . message = message return & p } 
func ( p * setpausedindebuggermessageparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetpausedindebuggermessage , p , nil ) } 
func ( p * setshowdebugbordersparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetshowdebugborders , p , nil ) } 
func ( p * setshowfpscounterparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetshowfpscounter , p , nil ) } 
func ( p * setshowpaintrectsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetshowpaintrects , p , nil ) } 
func ( p * setshowscrollbottleneckrectsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetshowscrollbottleneckrects , p , nil ) } 
func ( p * setshowhittestbordersparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetshowhittestborders , p , nil ) } 
func ( p * setshowviewportsizeonresizeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetshowviewportsizeonresize , p , nil ) } 
func ( v getdatabasetablenamesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodatabase ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdatabasetablenamesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodatabase ( & r , v ) return r . error ( ) } 
func ( v getdatabasetablenamesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodatabase1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getdatabasetablenamesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodatabase1 ( & r , v ) return r . error ( ) } 
func ( v executesqlreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodatabase2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * executesqlreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodatabase2 ( & r , v ) return r . error ( ) } 
func ( v executesqlparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodatabase3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * executesqlparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodatabase3 ( & r , v ) return r . error ( ) } 
func ( v eventadddatabase ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodatabase4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventadddatabase ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodatabase4 ( & r , v ) return r . error ( ) } 
func ( v database ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodatabase8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * database ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodatabase8 ( & r , v ) return r . error ( ) } 
func ( t scrollrecttype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * scrollrecttype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch scrollrecttype ( in . string ( ) ) { case scrollrecttyperepaintsonscroll : * t = scrollrecttyperepaintsonscroll case scrollrecttypetoucheventhandler : * t = scrollrecttypetoucheventhandler case scrollrecttypewheeleventhandler : * t = scrollrecttypewheeleventhandler default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * scrollrecttype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( p * clearbrowsercacheparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandclearbrowsercache , nil , nil ) } 
func ( p * clearbrowsercookiesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandclearbrowsercookies , nil , nil ) } 
func ( p continueinterceptedrequestparams ) witherrorreason ( errorreason errorreason ) * continueinterceptedrequestparams { p . errorreason = errorreason return & p } 
func ( p continueinterceptedrequestparams ) withurl ( url string ) * continueinterceptedrequestparams { p . url = url return & p } 
func ( p continueinterceptedrequestparams ) withmethod ( method string ) * continueinterceptedrequestparams { p . method = method return & p } 
func ( p continueinterceptedrequestparams ) withpostdata ( postdata string ) * continueinterceptedrequestparams { p . postdata = postdata return & p } 
func ( p continueinterceptedrequestparams ) withheaders ( headers headers ) * continueinterceptedrequestparams { p . headers = headers return & p } 
func ( p continueinterceptedrequestparams ) withauthchallengeresponse ( authchallengeresponse * authchallengeresponse ) * continueinterceptedrequestparams { p . authchallengeresponse = authchallengeresponse return & p } 
func ( p * continueinterceptedrequestparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcontinueinterceptedrequest , p , nil ) } 
func ( p deletecookiesparams ) withurl ( url string ) * deletecookiesparams { p . url = url return & p } 
func ( p deletecookiesparams ) withdomain ( domain string ) * deletecookiesparams { p . domain = domain return & p } 
func ( p deletecookiesparams ) withpath ( path string ) * deletecookiesparams { p . path = path return & p } 
func ( p * deletecookiesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddeletecookies , p , nil ) } 
func ( p emulatenetworkconditionsparams ) withconnectiontype ( connectiontype connectiontype ) * emulatenetworkconditionsparams { p . connectiontype = connectiontype return & p } 
func ( p * emulatenetworkconditionsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandemulatenetworkconditions , p , nil ) } 
func ( p enableparams ) withmaxtotalbuffersize ( maxtotalbuffersize int64 ) * enableparams { p . maxtotalbuffersize = maxtotalbuffersize return & p } 
func ( p enableparams ) withmaxresourcebuffersize ( maxresourcebuffersize int64 ) * enableparams { p . maxresourcebuffersize = maxresourcebuffersize return & p } 
func ( p enableparams ) withmaxpostdatasize ( maxpostdatasize int64 ) * enableparams { p . maxpostdatasize = maxpostdatasize return & p } 
func ( p * enableparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandenable , p , nil ) } 
func ( p * getallcookiesparams ) do ( ctx context . context ) ( cookies [ ] * cookie , err error ) { var res getallcookiesreturns err = cdp . execute ( ctx , commandgetallcookies , nil , & res ) if err ! = nil { return nil , err } return res . cookies , nil } 
func ( p * getcertificateparams ) do ( ctx context . context ) ( tablenames [ ] string , err error ) { var res getcertificatereturns err = cdp . execute ( ctx , commandgetcertificate , p , & res ) if err ! = nil { return nil , err } return res . tablenames , nil } 
func ( p getcookiesparams ) withurls ( urls [ ] string ) * getcookiesparams { p . urls = urls return & p } 
func ( p * getcookiesparams ) do ( ctx context . context ) ( cookies [ ] * cookie , err error ) { var res getcookiesreturns err = cdp . execute ( ctx , commandgetcookies , p , & res ) if err ! = nil { return nil , err } return res . cookies , nil } 
func ( p * getresponsebodyparams ) do ( ctx context . context ) ( body [ ] byte , err error ) { var res getresponsebodyreturns err = cdp . execute ( ctx , commandgetresponsebody , p , & res ) if err ! = nil { return nil , err } var dec [ ] byte if res . base64encoded { dec , err = base64 . stdencoding . decodestring ( res . body ) if err ! = nil { return nil , err } } else { dec = [ ] byte ( res . body ) } return dec , nil } 
func ( p * getrequestpostdataparams ) do ( ctx context . context ) ( postdata string , err error ) { var res getrequestpostdatareturns err = cdp . execute ( ctx , commandgetrequestpostdata , p , & res ) if err ! = nil { return " " , err } return res . postdata , nil } 
func ( p * getresponsebodyforinterceptionparams ) do ( ctx context . context ) ( body [ ] byte , err error ) { var res getresponsebodyforinterceptionreturns err = cdp . execute ( ctx , commandgetresponsebodyforinterception , p , & res ) if err ! = nil { return nil , err } var dec [ ] byte if res . base64encoded { dec , err = base64 . stdencoding . decodestring ( res . body ) if err ! = nil { return nil , err } } else { dec = [ ] byte ( res . body ) } return dec , nil } 
func ( p * takeresponsebodyforinterceptionasstreamparams ) do ( ctx context . context ) ( stream io . streamhandle , err error ) { var res takeresponsebodyforinterceptionasstreamreturns err = cdp . execute ( ctx , commandtakeresponsebodyforinterceptionasstream , p , & res ) if err ! = nil { return " " , err } return res . stream , nil } 
func ( p * replayxhrparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandreplayxhr , p , nil ) } 
func ( p searchinresponsebodyparams ) withcasesensitive ( casesensitive bool ) * searchinresponsebodyparams { p . casesensitive = casesensitive return & p } 
func ( p searchinresponsebodyparams ) withisregex ( isregex bool ) * searchinresponsebodyparams { p . isregex = isregex return & p } 
func ( p * searchinresponsebodyparams ) do ( ctx context . context ) ( result [ ] * debugger . searchmatch , err error ) { var res searchinresponsebodyreturns err = cdp . execute ( ctx , commandsearchinresponsebody , p , & res ) if err ! = nil { return nil , err } return res . result , nil } 
func ( p * setblockedurlsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetblockedurls , p , nil ) } 
func ( p * setbypassserviceworkerparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetbypassserviceworker , p , nil ) } 
func ( p * setcachedisabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetcachedisabled , p , nil ) } 
func ( p setcookieparams ) withurl ( url string ) * setcookieparams { p . url = url return & p } 
func ( p setcookieparams ) withdomain ( domain string ) * setcookieparams { p . domain = domain return & p } 
func ( p setcookieparams ) withpath ( path string ) * setcookieparams { p . path = path return & p } 
func ( p setcookieparams ) withsecure ( secure bool ) * setcookieparams { p . secure = secure return & p } 
func ( p setcookieparams ) withsamesite ( samesite cookiesamesite ) * setcookieparams { p . samesite = samesite return & p } 
func ( p setcookieparams ) withexpires ( expires * cdp . timesinceepoch ) * setcookieparams { p . expires = expires return & p } 
func ( p * setcookieparams ) do ( ctx context . context ) ( success bool , err error ) { var res setcookiereturns err = cdp . execute ( ctx , commandsetcookie , p , & res ) if err ! = nil { return false , err } return res . success , nil } 
func ( p * setcookiesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetcookies , p , nil ) } 
func ( p * setdatasizelimitsfortestparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdatasizelimitsfortest , p , nil ) } 
func ( p * setextrahttpheadersparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetextrahttpheaders , p , nil ) } 
func ( p * setrequestinterceptionparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetrequestinterception , p , nil ) } 
func ( v terminateexecutionparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * terminateexecutionparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime ( & r , v ) return r . error ( ) } 
func ( v stacktraceid ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stacktraceid ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime1 ( & r , v ) return r . error ( ) } 
func ( v stacktrace ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stacktrace ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime2 ( & r , v ) return r . error ( ) } 
func ( v setmaxcallstacksizetocaptureparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setmaxcallstacksizetocaptureparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime3 ( & r , v ) return r . error ( ) } 
func ( v setcustomobjectformatterenabledparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setcustomobjectformatterenabledparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime4 ( & r , v ) return r . error ( ) } 
func ( v runscriptreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * runscriptreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime5 ( & r , v ) return r . error ( ) } 
func ( v runscriptparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * runscriptparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime6 ( & r , v ) return r . error ( ) } 
func ( v runifwaitingfordebuggerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * runifwaitingfordebuggerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime7 ( & r , v ) return r . error ( ) } 
func ( v removebindingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removebindingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime8 ( & r , v ) return r . error ( ) } 
func ( v remoteobject ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * remoteobject ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime9 ( & r , v ) return r . error ( ) } 
func ( v releaseobjectparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * releaseobjectparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime10 ( & r , v ) return r . error ( ) } 
func ( v releaseobjectgroupparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * releaseobjectgroupparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime11 ( & r , v ) return r . error ( ) } 
func ( v queryobjectsreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * queryobjectsreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime12 ( & r , v ) return r . error ( ) } 
func ( v queryobjectsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * queryobjectsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime13 ( & r , v ) return r . error ( ) } 
func ( v propertypreview ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * propertypreview ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime14 ( & r , v ) return r . error ( ) } 
func ( v propertydescriptor ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * propertydescriptor ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime15 ( & r , v ) return r . error ( ) } 
func ( v privatepropertydescriptor ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * privatepropertydescriptor ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime16 ( & r , v ) return r . error ( ) } 
func ( v objectpreview ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * objectpreview ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime17 ( & r , v ) return r . error ( ) } 
func ( v internalpropertydescriptor ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * internalpropertydescriptor ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime18 ( & r , v ) return r . error ( ) } 
func ( v globallexicalscopenamesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * globallexicalscopenamesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime19 ( & r , v ) return r . error ( ) } 
func ( v globallexicalscopenamesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * globallexicalscopenamesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime20 ( & r , v ) return r . error ( ) } 
func ( v getpropertiesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getpropertiesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime21 ( & r , v ) return r . error ( ) } 
func ( v getpropertiesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getpropertiesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime22 ( & r , v ) return r . error ( ) } 
func ( v getisolateidreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getisolateidreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime23 ( & r , v ) return r . error ( ) } 
func ( v getisolateidparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime24 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getisolateidparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime24 ( & r , v ) return r . error ( ) } 
func ( v getheapusagereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime25 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getheapusagereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime25 ( & r , v ) return r . error ( ) } 
func ( v getheapusageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getheapusageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime26 ( & r , v ) return r . error ( ) } 
func ( v executioncontextdescription ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime27 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * executioncontextdescription ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime27 ( & r , v ) return r . error ( ) } 
func ( v exceptiondetails ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime28 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * exceptiondetails ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime28 ( & r , v ) return r . error ( ) } 
func ( v eventinspectrequested ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime29 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventinspectrequested ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime29 ( & r , v ) return r . error ( ) } 
func ( v eventexecutioncontextscleared ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime30 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventexecutioncontextscleared ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime30 ( & r , v ) return r . error ( ) } 
func ( v eventexecutioncontextdestroyed ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime31 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventexecutioncontextdestroyed ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime31 ( & r , v ) return r . error ( ) } 
func ( v eventexecutioncontextcreated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime32 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventexecutioncontextcreated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime32 ( & r , v ) return r . error ( ) } 
func ( v eventexceptionthrown ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime33 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventexceptionthrown ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime33 ( & r , v ) return r . error ( ) } 
func ( v eventexceptionrevoked ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime34 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventexceptionrevoked ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime34 ( & r , v ) return r . error ( ) } 
func ( v eventconsoleapicalled ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime35 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventconsoleapicalled ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime35 ( & r , v ) return r . error ( ) } 
func ( v eventbindingcalled ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime36 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventbindingcalled ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime36 ( & r , v ) return r . error ( ) } 
func ( v evaluatereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime37 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * evaluatereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime37 ( & r , v ) return r . error ( ) } 
func ( v evaluateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime38 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * evaluateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime38 ( & r , v ) return r . error ( ) } 
func ( v entrypreview ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime39 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * entrypreview ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime39 ( & r , v ) return r . error ( ) } 
func ( v discardconsoleentriesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime41 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * discardconsoleentriesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime41 ( & r , v ) return r . error ( ) } 
func ( v custompreview ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime43 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * custompreview ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime43 ( & r , v ) return r . error ( ) } 
func ( v compilescriptreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime44 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * compilescriptreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime44 ( & r , v ) return r . error ( ) } 
func ( v compilescriptparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime45 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * compilescriptparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime45 ( & r , v ) return r . error ( ) } 
func ( v callfunctiononreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime46 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * callfunctiononreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime46 ( & r , v ) return r . error ( ) } 
func ( v callfunctiononparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime47 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * callfunctiononparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime47 ( & r , v ) return r . error ( ) } 
func ( v callframe ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime48 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v callargument ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime49 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * callargument ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime49 ( & r , v ) return r . error ( ) } 
func ( v awaitpromisereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime50 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * awaitpromisereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime50 ( & r , v ) return r . error ( ) } 
func ( v awaitpromiseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime51 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * awaitpromiseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime51 ( & r , v ) return r . error ( ) } 
func ( v addbindingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoruntime52 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * addbindingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoruntime52 ( & r , v ) return r . error ( ) } 
func ( t detachreason ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * detachreason ) unmarshaleasyjson ( in * jlexer . lexer ) { switch detachreason ( in . string ( ) ) { case detachreasontargetclosed : * t = detachreasontargetclosed case detachreasoncanceledbyuser : * t = detachreasoncanceledbyuser case detachreasonreplacedwithdevtools : * t = detachreasonreplacedwithdevtools case detachreasonrenderprocessgone : * t = detachreasonrenderprocessgone default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * detachreason ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( p * canemulateparams ) do ( ctx context . context ) ( result bool , err error ) { var res canemulatereturns err = cdp . execute ( ctx , commandcanemulate , nil , & res ) if err ! = nil { return false , err } return res . result , nil } 
func ( p * cleardevicemetricsoverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcleardevicemetricsoverride , nil , nil ) } 
func ( p * cleargeolocationoverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcleargeolocationoverride , nil , nil ) } 
func ( p * resetpagescalefactorparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandresetpagescalefactor , nil , nil ) } 
func ( p * setfocusemulationenabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetfocusemulationenabled , p , nil ) } 
func ( p * setcputhrottlingrateparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetcputhrottlingrate , p , nil ) } 
func ( p setdefaultbackgroundcoloroverrideparams ) withcolor ( color * cdp . rgba ) * setdefaultbackgroundcoloroverrideparams { p . color = color return & p } 
func ( p * setdefaultbackgroundcoloroverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdefaultbackgroundcoloroverride , p , nil ) } 
func ( p setdevicemetricsoverrideparams ) withscale ( scale float64 ) * setdevicemetricsoverrideparams { p . scale = scale return & p } 
func ( p setdevicemetricsoverrideparams ) withscreenwidth ( screenwidth int64 ) * setdevicemetricsoverrideparams { p . screenwidth = screenwidth return & p } 
func ( p setdevicemetricsoverrideparams ) withscreenheight ( screenheight int64 ) * setdevicemetricsoverrideparams { p . screenheight = screenheight return & p } 
func ( p setdevicemetricsoverrideparams ) withpositionx ( positionx int64 ) * setdevicemetricsoverrideparams { p . positionx = positionx return & p } 
func ( p setdevicemetricsoverrideparams ) withpositiony ( positiony int64 ) * setdevicemetricsoverrideparams { p . positiony = positiony return & p } 
func ( p setdevicemetricsoverrideparams ) withdontsetvisiblesize ( dontsetvisiblesize bool ) * setdevicemetricsoverrideparams { p . dontsetvisiblesize = dontsetvisiblesize return & p } 
func ( p setdevicemetricsoverrideparams ) withscreenorientation ( screenorientation * screenorientation ) * setdevicemetricsoverrideparams { p . screenorientation = screenorientation return & p } 
func ( p setdevicemetricsoverrideparams ) withviewport ( viewport * page . viewport ) * setdevicemetricsoverrideparams { p . viewport = viewport return & p } 
func ( p * setdevicemetricsoverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdevicemetricsoverride , p , nil ) } 
func ( p * setscrollbarshiddenparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetscrollbarshidden , p , nil ) } 
func ( p * setdocumentcookiedisabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdocumentcookiedisabled , p , nil ) } 
func ( p setemittoucheventsformouseparams ) withconfiguration ( configuration setemittoucheventsformouseconfiguration ) * setemittoucheventsformouseparams { p . configuration = configuration return & p } 
func ( p * setemittoucheventsformouseparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetemittoucheventsformouse , p , nil ) } 
func ( p * setemulatedmediaparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetemulatedmedia , p , nil ) } 
func ( p setgeolocationoverrideparams ) withlatitude ( latitude float64 ) * setgeolocationoverrideparams { p . latitude = latitude return & p } 
func ( p setgeolocationoverrideparams ) withlongitude ( longitude float64 ) * setgeolocationoverrideparams { p . longitude = longitude return & p } 
func ( p setgeolocationoverrideparams ) withaccuracy ( accuracy float64 ) * setgeolocationoverrideparams { p . accuracy = accuracy return & p } 
func ( p * setgeolocationoverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetgeolocationoverride , p , nil ) } 
func ( p * setpagescalefactorparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetpagescalefactor , p , nil ) } 
func ( p * setscriptexecutiondisabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetscriptexecutiondisabled , p , nil ) } 
func ( p settouchemulationenabledparams ) withmaxtouchpoints ( maxtouchpoints int64 ) * settouchemulationenabledparams { p . maxtouchpoints = maxtouchpoints return & p } 
func ( p * settouchemulationenabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsettouchemulationenabled , p , nil ) } 
func ( p setvirtualtimepolicyparams ) withbudget ( budget float64 ) * setvirtualtimepolicyparams { p . budget = budget return & p } 
func ( p setvirtualtimepolicyparams ) withmaxvirtualtimetaskstarvationcount ( maxvirtualtimetaskstarvationcount int64 ) * setvirtualtimepolicyparams { p . maxvirtualtimetaskstarvationcount = maxvirtualtimetaskstarvationcount return & p } 
func ( p setvirtualtimepolicyparams ) withwaitfornavigation ( waitfornavigation bool ) * setvirtualtimepolicyparams { p . waitfornavigation = waitfornavigation return & p } 
func ( p setvirtualtimepolicyparams ) withinitialvirtualtime ( initialvirtualtime * cdp . timesinceepoch ) * setvirtualtimepolicyparams { p . initialvirtualtime = initialvirtualtime return & p } 
func ( p * setvirtualtimepolicyparams ) do ( ctx context . context ) ( virtualtimeticksbase float64 , err error ) { var res setvirtualtimepolicyreturns err = cdp . execute ( ctx , commandsetvirtualtimepolicy , p , & res ) if err ! = nil { return 0 , err } return res . virtualtimeticksbase , nil } 
func ( p setuseragentoverrideparams ) withacceptlanguage ( acceptlanguage string ) * setuseragentoverrideparams { p . acceptlanguage = acceptlanguage return & p } 
func ( p setuseragentoverrideparams ) withplatform ( platform string ) * setuseragentoverrideparams { p . platform = platform return & p } 
func ( p * setuseragentoverrideparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetuseragentoverride , p , nil ) } 
func ( p dispatchkeyeventparams ) withmodifiers ( modifiers modifier ) * dispatchkeyeventparams { p . modifiers = modifiers return & p } 
func ( p dispatchkeyeventparams ) withtimestamp ( timestamp * timesinceepoch ) * dispatchkeyeventparams { p . timestamp = timestamp return & p } 
func ( p dispatchkeyeventparams ) withtext ( text string ) * dispatchkeyeventparams { p . text = text return & p } 
func ( p dispatchkeyeventparams ) withunmodifiedtext ( unmodifiedtext string ) * dispatchkeyeventparams { p . unmodifiedtext = unmodifiedtext return & p } 
func ( p dispatchkeyeventparams ) withkeyidentifier ( keyidentifier string ) * dispatchkeyeventparams { p . keyidentifier = keyidentifier return & p } 
func ( p dispatchkeyeventparams ) withcode ( code string ) * dispatchkeyeventparams { p . code = code return & p } 
func ( p dispatchkeyeventparams ) withkey ( key string ) * dispatchkeyeventparams { p . key = key return & p } 
func ( p dispatchkeyeventparams ) withwindowsvirtualkeycode ( windowsvirtualkeycode int64 ) * dispatchkeyeventparams { p . windowsvirtualkeycode = windowsvirtualkeycode return & p } 
func ( p dispatchkeyeventparams ) withnativevirtualkeycode ( nativevirtualkeycode int64 ) * dispatchkeyeventparams { p . nativevirtualkeycode = nativevirtualkeycode return & p } 
func ( p dispatchkeyeventparams ) withautorepeat ( autorepeat bool ) * dispatchkeyeventparams { p . autorepeat = autorepeat return & p } 
func ( p dispatchkeyeventparams ) withiskeypad ( iskeypad bool ) * dispatchkeyeventparams { p . iskeypad = iskeypad return & p } 
func ( p dispatchkeyeventparams ) withissystemkey ( issystemkey bool ) * dispatchkeyeventparams { p . issystemkey = issystemkey return & p } 
func ( p dispatchkeyeventparams ) withlocation ( location int64 ) * dispatchkeyeventparams { p . location = location return & p } 
func ( p * dispatchkeyeventparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddispatchkeyevent , p , nil ) } 
func ( p * inserttextparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandinserttext , p , nil ) } 
func ( p dispatchmouseeventparams ) withmodifiers ( modifiers modifier ) * dispatchmouseeventparams { p . modifiers = modifiers return & p } 
func ( p dispatchmouseeventparams ) withtimestamp ( timestamp * timesinceepoch ) * dispatchmouseeventparams { p . timestamp = timestamp return & p } 
func ( p dispatchmouseeventparams ) withbutton ( button buttontype ) * dispatchmouseeventparams { p . button = button return & p } 
func ( p dispatchmouseeventparams ) withbuttons ( buttons int64 ) * dispatchmouseeventparams { p . buttons = buttons return & p } 
func ( p dispatchmouseeventparams ) withclickcount ( clickcount int64 ) * dispatchmouseeventparams { p . clickcount = clickcount return & p } 
func ( p dispatchmouseeventparams ) withdeltax ( deltax float64 ) * dispatchmouseeventparams { p . deltax = deltax return & p } 
func ( p dispatchmouseeventparams ) withdeltay ( deltay float64 ) * dispatchmouseeventparams { p . deltay = deltay return & p } 
func ( p dispatchmouseeventparams ) withpointertype ( pointertype dispatchmouseeventpointertype ) * dispatchmouseeventparams { p . pointertype = pointertype return & p } 
func ( p * dispatchmouseeventparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddispatchmouseevent , p , nil ) } 
func ( p dispatchtoucheventparams ) withmodifiers ( modifiers modifier ) * dispatchtoucheventparams { p . modifiers = modifiers return & p } 
func ( p dispatchtoucheventparams ) withtimestamp ( timestamp * timesinceepoch ) * dispatchtoucheventparams { p . timestamp = timestamp return & p } 
func ( p * dispatchtoucheventparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddispatchtouchevent , p , nil ) } 
func ( p emulatetouchfrommouseeventparams ) withtimestamp ( timestamp * timesinceepoch ) * emulatetouchfrommouseeventparams { p . timestamp = timestamp return & p } 
func ( p emulatetouchfrommouseeventparams ) withdeltax ( deltax float64 ) * emulatetouchfrommouseeventparams { p . deltax = deltax return & p } 
func ( p emulatetouchfrommouseeventparams ) withdeltay ( deltay float64 ) * emulatetouchfrommouseeventparams { p . deltay = deltay return & p } 
func ( p emulatetouchfrommouseeventparams ) withmodifiers ( modifiers modifier ) * emulatetouchfrommouseeventparams { p . modifiers = modifiers return & p } 
func ( p emulatetouchfrommouseeventparams ) withclickcount ( clickcount int64 ) * emulatetouchfrommouseeventparams { p . clickcount = clickcount return & p } 
func ( p * emulatetouchfrommouseeventparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandemulatetouchfrommouseevent , p , nil ) } 
func ( p * setignoreinputeventsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetignoreinputevents , p , nil ) } 
func ( p synthesizepinchgestureparams ) withrelativespeed ( relativespeed int64 ) * synthesizepinchgestureparams { p . relativespeed = relativespeed return & p } 
func ( p synthesizepinchgestureparams ) withgesturesourcetype ( gesturesourcetype gesturetype ) * synthesizepinchgestureparams { p . gesturesourcetype = gesturesourcetype return & p } 
func ( p * synthesizepinchgestureparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsynthesizepinchgesture , p , nil ) } 
func ( p synthesizescrollgestureparams ) withxdistance ( xdistance float64 ) * synthesizescrollgestureparams { p . xdistance = xdistance return & p } 
func ( p synthesizescrollgestureparams ) withydistance ( ydistance float64 ) * synthesizescrollgestureparams { p . ydistance = ydistance return & p } 
func ( p synthesizescrollgestureparams ) withxoverscroll ( xoverscroll float64 ) * synthesizescrollgestureparams { p . xoverscroll = xoverscroll return & p } 
func ( p synthesizescrollgestureparams ) withyoverscroll ( yoverscroll float64 ) * synthesizescrollgestureparams { p . yoverscroll = yoverscroll return & p } 
func ( p synthesizescrollgestureparams ) withpreventfling ( preventfling bool ) * synthesizescrollgestureparams { p . preventfling = preventfling return & p } 
func ( p synthesizescrollgestureparams ) withspeed ( speed int64 ) * synthesizescrollgestureparams { p . speed = speed return & p } 
func ( p synthesizescrollgestureparams ) withgesturesourcetype ( gesturesourcetype gesturetype ) * synthesizescrollgestureparams { p . gesturesourcetype = gesturesourcetype return & p } 
func ( p synthesizescrollgestureparams ) withrepeatcount ( repeatcount int64 ) * synthesizescrollgestureparams { p . repeatcount = repeatcount return & p } 
func ( p synthesizescrollgestureparams ) withrepeatdelayms ( repeatdelayms int64 ) * synthesizescrollgestureparams { p . repeatdelayms = repeatdelayms return & p } 
func ( p synthesizescrollgestureparams ) withinteractionmarkername ( interactionmarkername string ) * synthesizescrollgestureparams { p . interactionmarkername = interactionmarkername return & p } 
func ( p * synthesizescrollgestureparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsynthesizescrollgesture , p , nil ) } 
func ( p synthesizetapgestureparams ) withduration ( duration int64 ) * synthesizetapgestureparams { p . duration = duration return & p } 
func ( p synthesizetapgestureparams ) withtapcount ( tapcount int64 ) * synthesizetapgestureparams { p . tapcount = tapcount return & p } 
func ( p synthesizetapgestureparams ) withgesturesourcetype ( gesturesourcetype gesturetype ) * synthesizetapgestureparams { p . gesturesourcetype = gesturesourcetype return & p } 
func ( p * synthesizetapgestureparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsynthesizetapgesture , p , nil ) } 
func ( p * getinfoparams ) do ( ctx context . context ) ( gpu * gpuinfo , modelname string , modelversion string , commandline string , err error ) { var res getinforeturns err = cdp . execute ( ctx , commandgetinfo , nil , & res ) if err ! = nil { return nil , " " , " " , " " , err } return res . gpu , res . modelname , res . modelversion , res . commandline , nil } 
func ( p * getprocessinfoparams ) do ( ctx context . context ) ( processinfo [ ] * processinfo , err error ) { var res getprocessinforeturns err = cdp . execute ( ctx , commandgetprocessinfo , nil , & res ) if err ! = nil { return nil , err } return res . processinfo , nil } 
func ( t methodtype ) domain ( ) string { return string ( t [ : strings . indexbyte ( string ( t ) , ' . ' ) ] ) } 
func ( p geteventlistenersparams ) withdepth ( depth int64 ) * geteventlistenersparams { p . depth = depth return & p } 
func ( p geteventlistenersparams ) withpierce ( pierce bool ) * geteventlistenersparams { p . pierce = pierce return & p } 
func ( p * geteventlistenersparams ) do ( ctx context . context ) ( listeners [ ] * eventlistener , err error ) { var res geteventlistenersreturns err = cdp . execute ( ctx , commandgeteventlisteners , p , & res ) if err ! = nil { return nil , err } return res . listeners , nil } 
func ( p * removedombreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremovedombreakpoint , p , nil ) } 
func ( p removeeventlistenerbreakpointparams ) withtargetname ( targetname string ) * removeeventlistenerbreakpointparams { p . targetname = targetname return & p } 
func ( p * removeeventlistenerbreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremoveeventlistenerbreakpoint , p , nil ) } 
func ( p * removeinstrumentationbreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremoveinstrumentationbreakpoint , p , nil ) } 
func ( p * removexhrbreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremovexhrbreakpoint , p , nil ) } 
func ( p * setdombreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdombreakpoint , p , nil ) } 
func ( p seteventlistenerbreakpointparams ) withtargetname ( targetname string ) * seteventlistenerbreakpointparams { p . targetname = targetname return & p } 
func ( p * seteventlistenerbreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandseteventlistenerbreakpoint , p , nil ) } 
func ( p * setinstrumentationbreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetinstrumentationbreakpoint , p , nil ) } 
func ( p * setxhrbreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetxhrbreakpoint , p , nil ) } 
func ( t transitiontype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * transitiontype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch transitiontype ( in . string ( ) ) { case transitiontypelink : * t = transitiontypelink case transitiontypetyped : * t = transitiontypetyped case transitiontypeaddressbar : * t = transitiontypeaddressbar case transitiontypeautobookmark : * t = transitiontypeautobookmark case transitiontypeautosubframe : * t = transitiontypeautosubframe case transitiontypemanualsubframe : * t = transitiontypemanualsubframe case transitiontypegenerated : * t = transitiontypegenerated case transitiontypeautotoplevel : * t = transitiontypeautotoplevel case transitiontypeformsubmit : * t = transitiontypeformsubmit case transitiontypereload : * t = transitiontypereload case transitiontypekeyword : * t = transitiontypekeyword case transitiontypekeywordgenerated : * t = transitiontypekeywordgenerated case transitiontypeother : * t = transitiontypeother default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * transitiontype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t dialogtype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * dialogtype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch dialogtype ( in . string ( ) ) { case dialogtypealert : * t = dialogtypealert case dialogtypeconfirm : * t = dialogtypeconfirm case dialogtypeprompt : * t = dialogtypeprompt case dialogtypebeforeunload : * t = dialogtypebeforeunload default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * dialogtype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t clientnavigationreason ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * clientnavigationreason ) unmarshaleasyjson ( in * jlexer . lexer ) { switch clientnavigationreason ( in . string ( ) ) { case clientnavigationreasonformsubmissionget : * t = clientnavigationreasonformsubmissionget case clientnavigationreasonformsubmissionpost : * t = clientnavigationreasonformsubmissionpost case clientnavigationreasonhttpheaderrefresh : * t = clientnavigationreasonhttpheaderrefresh case clientnavigationreasonscriptinitiated : * t = clientnavigationreasonscriptinitiated case clientnavigationreasonmetatagrefresh : * t = clientnavigationreasonmetatagrefresh case clientnavigationreasonpageblockinterstitial : * t = clientnavigationreasonpageblockinterstitial case clientnavigationreasonreload : * t = clientnavigationreasonreload default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * clientnavigationreason ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t capturescreenshotformat ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * capturescreenshotformat ) unmarshaleasyjson ( in * jlexer . lexer ) { switch capturescreenshotformat ( in . string ( ) ) { case capturescreenshotformatjpeg : * t = capturescreenshotformatjpeg case capturescreenshotformatpng : * t = capturescreenshotformatpng default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * capturescreenshotformat ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t capturesnapshotformat ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * capturesnapshotformat ) unmarshaleasyjson ( in * jlexer . lexer ) { switch capturesnapshotformat ( in . string ( ) ) { case capturesnapshotformatmhtml : * t = capturesnapshotformatmhtml default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * capturesnapshotformat ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t setdownloadbehaviorbehavior ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * setdownloadbehaviorbehavior ) unmarshaleasyjson ( in * jlexer . lexer ) { switch setdownloadbehaviorbehavior ( in . string ( ) ) { case setdownloadbehaviorbehaviordeny : * t = setdownloadbehaviorbehaviordeny case setdownloadbehaviorbehaviorallow : * t = setdownloadbehaviorbehaviorallow case setdownloadbehaviorbehaviordefault : * t = setdownloadbehaviorbehaviordefault default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * setdownloadbehaviorbehavior ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t screencastformat ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * screencastformat ) unmarshaleasyjson ( in * jlexer . lexer ) { switch screencastformat ( in . string ( ) ) { case screencastformatjpeg : * t = screencastformatjpeg case screencastformatpng : * t = screencastformatpng default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * screencastformat ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t setweblifecyclestatestate ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * setweblifecyclestatestate ) unmarshaleasyjson ( in * jlexer . lexer ) { switch setweblifecyclestatestate ( in . string ( ) ) { case setweblifecyclestatestatefrozen : * t = setweblifecyclestatestatefrozen case setweblifecyclestatestateactive : * t = setweblifecyclestatestateactive default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * setweblifecyclestatestate ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v typeprofileentry ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * typeprofileentry ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler ( & r , v ) return r . error ( ) } 
func ( v typeobject ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * typeobject ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler1 ( & r , v ) return r . error ( ) } 
func ( v taketypeprofilereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * taketypeprofilereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler2 ( & r , v ) return r . error ( ) } 
func ( v taketypeprofileparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * taketypeprofileparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler3 ( & r , v ) return r . error ( ) } 
func ( v takeprecisecoveragereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takeprecisecoveragereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler4 ( & r , v ) return r . error ( ) } 
func ( v takeprecisecoverageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * takeprecisecoverageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler5 ( & r , v ) return r . error ( ) } 
func ( v stoptypeprofileparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stoptypeprofileparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler6 ( & r , v ) return r . error ( ) } 
func ( v stopreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler7 ( & r , v ) return r . error ( ) } 
func ( v stopprecisecoverageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopprecisecoverageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler8 ( & r , v ) return r . error ( ) } 
func ( v stopparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler9 ( & r , v ) return r . error ( ) } 
func ( v starttypeprofileparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * starttypeprofileparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler10 ( & r , v ) return r . error ( ) } 
func ( v startprecisecoverageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * startprecisecoverageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler11 ( & r , v ) return r . error ( ) } 
func ( v * startparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler12 ( & r , v ) return r . error ( ) } 
func ( v setsamplingintervalparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setsamplingintervalparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler13 ( & r , v ) return r . error ( ) } 
func ( v scripttypeprofile ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * scripttypeprofile ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler14 ( & r , v ) return r . error ( ) } 
func ( v scriptcoverage ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * scriptcoverage ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler15 ( & r , v ) return r . error ( ) } 
func ( v profilenode ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * profilenode ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler16 ( & r , v ) return r . error ( ) } 
func ( v profile ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * profile ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler17 ( & r , v ) return r . error ( ) } 
func ( v positiontickinfo ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * positiontickinfo ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler18 ( & r , v ) return r . error ( ) } 
func ( v getbesteffortcoveragereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbesteffortcoveragereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler19 ( & r , v ) return r . error ( ) } 
func ( v getbesteffortcoverageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getbesteffortcoverageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler20 ( & r , v ) return r . error ( ) } 
func ( v functioncoverage ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler21 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * functioncoverage ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler21 ( & r , v ) return r . error ( ) } 
func ( v eventconsoleprofilestarted ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler22 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventconsoleprofilestarted ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler22 ( & r , v ) return r . error ( ) } 
func ( v eventconsoleprofilefinished ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler23 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventconsoleprofilefinished ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler23 ( & r , v ) return r . error ( ) } 
func ( v coveragerange ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoprofiler26 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * coveragerange ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoprofiler26 ( & r , v ) return r . error ( ) } 
func withexecutor ( parent context . context , executor executor ) context . context { return context . withvalue ( parent , executorkey , executor ) } 
func execute ( ctx context . context , method string , params easyjson . marshaler , res easyjson . unmarshaler ) error { if executor : = ctx . value ( executorkey ) ; executor ! = nil { return executor . ( executor ) . execute ( ctx , method , params , res ) } return errinvalidcontext } 
func ( t * nodeid ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t * backendnodeid ) unmarshaleasyjson ( in * jlexer . lexer ) { buf : = in . raw ( ) if l : = len ( buf ) ; l > 2 && buf [ 0 ] == ' " ' && buf [ l - 1 ] == ' " ' { buf = buf [ 1 : l - 1 ] } v , err : = strconv . parseint ( string ( buf ) , 10 , 64 ) if err ! = nil { in . adderror ( err ) } * t = backendnodeid ( v ) } 
func ( t * backendnodeid ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t pseudotype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * pseudotype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch pseudotype ( in . string ( ) ) { case pseudotypefirstline : * t = pseudotypefirstline case pseudotypefirstletter : * t = pseudotypefirstletter case pseudotypebefore : * t = pseudotypebefore case pseudotypeafter : * t = pseudotypeafter case pseudotypebackdrop : * t = pseudotypebackdrop case pseudotypeselection : * t = pseudotypeselection case pseudotypefirstlineinherited : * t = pseudotypefirstlineinherited case pseudotypescrollbar : * t = pseudotypescrollbar case pseudotypescrollbarthumb : * t = pseudotypescrollbarthumb case pseudotypescrollbarbutton : * t = pseudotypescrollbarbutton case pseudotypescrollbartrack : * t = pseudotypescrollbartrack case pseudotypescrollbartrackpiece : * t = pseudotypescrollbartrackpiece case pseudotypescrollbarcorner : * t = pseudotypescrollbarcorner case pseudotyperesizer : * t = pseudotyperesizer case pseudotypeinputlistbutton : * t = pseudotypeinputlistbutton default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * pseudotype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t shadowroottype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * shadowroottype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch shadowroottype ( in . string ( ) ) { case shadowroottypeuseragent : * t = shadowroottypeuseragent case shadowroottypeopen : * t = shadowroottypeopen case shadowroottypeclosed : * t = shadowroottypeclosed default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * shadowroottype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( n * node ) attributevalue ( name string ) string { n . rlock ( ) defer n . runlock ( ) for i : = 0 ; i < len ( n . attributes ) ; i += 2 { if n . attributes [ i ] == name { return n . attributes [ i + 1 ] } } return " " } 
func ( n * node ) xpath ( stopatdocument , stopatid bool ) string { n . rlock ( ) defer n . runlock ( ) p : = " " pos : = " " id : = n . attributevalue ( " " ) switch { case n . parent == nil : return n . localname case stopatdocument && n . nodetype == nodetypedocument : return " " case stopatid && id ! = " " : p = " " pos = ' [ @id= ' ' + id + ' ' ] ' case n . parent ! = nil : var i int var found bool n . parent . rlock ( ) for j : = 0 ; j < len ( n . parent . children ) ; j ++ { if n . parent . children [ j ] . localname == n . localname { i ++ } if n . parent . children [ j ] . nodeid == n . nodeid { found = true break } } n . parent . runlock ( ) if found { pos = " " + strconv . itoa ( i ) + " " } p = n . parent . xpath ( stopatdocument , stopatid ) } return p + " " + n . localname + pos } 
func ( ns nodestate ) string ( ) string { var s [ ] string for k , v : = range nodestatenames { if ns & k ! = 0 { s = append ( s , v ) } } return " " + strings . join ( s , " " ) + " " } 
func ( t nodetype ) string ( ) string { switch t { case nodetypeelement : return " " case nodetypeattribute : return " " case nodetypetext : return " " case nodetypecdata : return " " case nodetypeentityreference : return " " case nodetypeentity : return " " case nodetypeprocessinginstruction : return " " case nodetypecomment : return " " case nodetypedocument : return " " case nodetypedocumenttype : return " " case nodetypedocumentfragment : return " " case nodetypenotation : return " " } return fmt . sprintf ( " " , t ) } 
func ( t nodetype ) marshaleasyjson ( out * jwriter . writer ) { out . int64 ( int64 ( t ) ) } 
func ( t * nodetype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch nodetype ( in . int64 ( ) ) { case nodetypeelement : * t = nodetypeelement case nodetypeattribute : * t = nodetypeattribute case nodetypetext : * t = nodetypetext case nodetypecdata : * t = nodetypecdata case nodetypeentityreference : * t = nodetypeentityreference case nodetypeentity : * t = nodetypeentity case nodetypeprocessinginstruction : * t = nodetypeprocessinginstruction case nodetypecomment : * t = nodetypecomment case nodetypedocument : * t = nodetypedocument case nodetypedocumenttype : * t = nodetypedocumenttype case nodetypedocumentfragment : * t = nodetypedocumentfragment case nodetypenotation : * t = nodetypenotation default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * nodetype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t monotonictime ) marshaleasyjson ( out * jwriter . writer ) { v : = float64 ( time . time ( t ) . sub ( * monotonictimeepoch ) ) / float64 ( time . second ) out . buffer . ensurespace ( 20 ) out . buffer . buf = strconv . appendfloat ( out . buffer . buf , v , ' f ' , - 1 , 64 ) } 
func ( t * monotonictime ) unmarshaleasyjson ( in * jlexer . lexer ) { * t = monotonictime ( monotonictimeepoch . add ( time . duration ( in . float64 ( ) * float64 ( time . second ) ) ) ) } 
func ( t * monotonictime ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t * frameid ) unmarshaleasyjson ( in * jlexer . lexer ) { buf : = in . raw ( ) if l : = len ( buf ) ; l > 2 && buf [ 0 ] == ' " ' && buf [ l - 1 ] == ' " ' { buf = buf [ 1 : l - 1 ] } * t = frameid ( buf ) } 
func ( t * frameid ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( fs framestate ) string ( ) string { var s [ ] string for k , v : = range framestatenames { if fs & k ! = 0 { s = append ( s , v ) } } return " " + strings . join ( s , " " ) + " " } 
func ( p enableparams ) withpresentationurl ( presentationurl string ) * enableparams { p . presentationurl = presentationurl return & p } 
func ( p * setsinktouseparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetsinktouse , p , nil ) } 
func ( p * starttabmirroringparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstarttabmirroring , p , nil ) } 
func ( p * stopcastingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopcasting , p , nil ) } 
func ( v requestentriesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestentriesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage ( & r , v ) return r . error ( ) } 
func ( v requestentriesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestentriesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage1 ( & r , v ) return r . error ( ) } 
func ( v requestcachedresponsereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestcachedresponsereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage2 ( & r , v ) return r . error ( ) } 
func ( v requestcachedresponseparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestcachedresponseparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage3 ( & r , v ) return r . error ( ) } 
func ( v requestcachenamesreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestcachenamesreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage4 ( & r , v ) return r . error ( ) } 
func ( v requestcachenamesparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * requestcachenamesparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage5 ( & r , v ) return r . error ( ) } 
func ( v header ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * header ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage6 ( & r , v ) return r . error ( ) } 
func ( v deleteentryparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * deleteentryparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage7 ( & r , v ) return r . error ( ) } 
func ( v deletecacheparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * deletecacheparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage8 ( & r , v ) return r . error ( ) } 
func ( v dataentry ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v cachedresponse ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocachestorage10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cachedresponse ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage10 ( & r , v ) return r . error ( ) } 
func ( v * cache ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocachestorage11 ( & r , v ) return r . error ( ) } 
func ( v processinfo ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosysteminfo ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * processinfo ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosysteminfo ( & r , v ) return r . error ( ) } 
func ( v getprocessinforeturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosysteminfo1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getprocessinforeturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosysteminfo1 ( & r , v ) return r . error ( ) } 
func ( v getprocessinfoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosysteminfo2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getprocessinfoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosysteminfo2 ( & r , v ) return r . error ( ) } 
func ( v getinforeturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosysteminfo3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getinforeturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosysteminfo3 ( & r , v ) return r . error ( ) } 
func ( v getinfoparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosysteminfo4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getinfoparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosysteminfo4 ( & r , v ) return r . error ( ) } 
func ( v gpuinfo ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosysteminfo5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gpuinfo ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosysteminfo5 ( & r , v ) return r . error ( ) } 
func ( v gpudevice ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosysteminfo6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gpudevice ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosysteminfo6 ( & r , v ) return r . error ( ) } 
func ( v unbindparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototethering ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * unbindparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototethering ( & r , v ) return r . error ( ) } 
func ( v eventaccepted ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototethering1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventaccepted ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototethering1 ( & r , v ) return r . error ( ) } 
func ( v bindparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprototethering2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * bindparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprototethering2 ( & r , v ) return r . error ( ) } 
func ( p * startobservingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstartobserving , p , nil ) } 
func ( p * stopobservingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopobserving , p , nil ) } 
func ( p * setrecordingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetrecording , p , nil ) } 
func ( p * cleareventsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandclearevents , p , nil ) } 
func ( t inspectmode ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * inspectmode ) unmarshaleasyjson ( in * jlexer . lexer ) { switch inspectmode ( in . string ( ) ) { case inspectmodesearchfornode : * t = inspectmodesearchfornode case inspectmodesearchforuashadowdom : * t = inspectmodesearchforuashadowdom case inspectmodecaptureareascreenshot : * t = inspectmodecaptureareascreenshot case inspectmodeshowdistances : * t = inspectmodeshowdistances case inspectmodenone : * t = inspectmodenone default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * inspectmode ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t * type ) unmarshaleasyjson ( in * jlexer . lexer ) { switch type ( in . string ( ) ) { case typecsstransition : * t = typecsstransition case typecssanimation : * t = typecssanimation case typewebanimation : * t = typewebanimation default : in . adderror ( errors . new ( " " ) ) } } 
func ( p awaitpromiseparams ) withreturnbyvalue ( returnbyvalue bool ) * awaitpromiseparams { p . returnbyvalue = returnbyvalue return & p } 
func ( p awaitpromiseparams ) withgeneratepreview ( generatepreview bool ) * awaitpromiseparams { p . generatepreview = generatepreview return & p } 
func ( p * awaitpromiseparams ) do ( ctx context . context ) ( result * remoteobject , exceptiondetails * exceptiondetails , err error ) { var res awaitpromisereturns err = cdp . execute ( ctx , commandawaitpromise , p , & res ) if err ! = nil { return nil , nil , err } return res . result , res . exceptiondetails , nil } 
func ( p callfunctiononparams ) withobjectid ( objectid remoteobjectid ) * callfunctiononparams { p . objectid = objectid return & p } 
func ( p callfunctiononparams ) witharguments ( arguments [ ] * callargument ) * callfunctiononparams { p . arguments = arguments return & p } 
func ( p callfunctiononparams ) withsilent ( silent bool ) * callfunctiononparams { p . silent = silent return & p } 
func ( p callfunctiononparams ) withreturnbyvalue ( returnbyvalue bool ) * callfunctiononparams { p . returnbyvalue = returnbyvalue return & p } 
func ( p callfunctiononparams ) withgeneratepreview ( generatepreview bool ) * callfunctiononparams { p . generatepreview = generatepreview return & p } 
func ( p callfunctiononparams ) withusergesture ( usergesture bool ) * callfunctiononparams { p . usergesture = usergesture return & p } 
func ( p callfunctiononparams ) withawaitpromise ( awaitpromise bool ) * callfunctiononparams { p . awaitpromise = awaitpromise return & p } 
func ( p callfunctiononparams ) withexecutioncontextid ( executioncontextid executioncontextid ) * callfunctiononparams { p . executioncontextid = executioncontextid return & p } 
func ( p callfunctiononparams ) withobjectgroup ( objectgroup string ) * callfunctiononparams { p . objectgroup = objectgroup return & p } 
func ( p * callfunctiononparams ) do ( ctx context . context ) ( result * remoteobject , exceptiondetails * exceptiondetails , err error ) { var res callfunctiononreturns err = cdp . execute ( ctx , commandcallfunctionon , p , & res ) if err ! = nil { return nil , nil , err } return res . result , res . exceptiondetails , nil } 
func ( p compilescriptparams ) withexecutioncontextid ( executioncontextid executioncontextid ) * compilescriptparams { p . executioncontextid = executioncontextid return & p } 
func ( p * compilescriptparams ) do ( ctx context . context ) ( scriptid scriptid , exceptiondetails * exceptiondetails , err error ) { var res compilescriptreturns err = cdp . execute ( ctx , commandcompilescript , p , & res ) if err ! = nil { return " " , nil , err } return res . scriptid , res . exceptiondetails , nil } 
func ( p * discardconsoleentriesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddiscardconsoleentries , nil , nil ) } 
func ( p evaluateparams ) withobjectgroup ( objectgroup string ) * evaluateparams { p . objectgroup = objectgroup return & p } 
func ( p evaluateparams ) withincludecommandlineapi ( includecommandlineapi bool ) * evaluateparams { p . includecommandlineapi = includecommandlineapi return & p } 
func ( p evaluateparams ) withsilent ( silent bool ) * evaluateparams { p . silent = silent return & p } 
func ( p evaluateparams ) withcontextid ( contextid executioncontextid ) * evaluateparams { p . contextid = contextid return & p } 
func ( p evaluateparams ) withreturnbyvalue ( returnbyvalue bool ) * evaluateparams { p . returnbyvalue = returnbyvalue return & p } 
func ( p evaluateparams ) withgeneratepreview ( generatepreview bool ) * evaluateparams { p . generatepreview = generatepreview return & p } 
func ( p evaluateparams ) withusergesture ( usergesture bool ) * evaluateparams { p . usergesture = usergesture return & p } 
func ( p evaluateparams ) withawaitpromise ( awaitpromise bool ) * evaluateparams { p . awaitpromise = awaitpromise return & p } 
func ( p evaluateparams ) withthrowonsideeffect ( throwonsideeffect bool ) * evaluateparams { p . throwonsideeffect = throwonsideeffect return & p } 
func ( p evaluateparams ) withtimeout ( timeout timedelta ) * evaluateparams { p . timeout = timeout return & p } 
func ( p * evaluateparams ) do ( ctx context . context ) ( result * remoteobject , exceptiondetails * exceptiondetails , err error ) { var res evaluatereturns err = cdp . execute ( ctx , commandevaluate , p , & res ) if err ! = nil { return nil , nil , err } return res . result , res . exceptiondetails , nil } 
func ( p * getisolateidparams ) do ( ctx context . context ) ( id string , err error ) { var res getisolateidreturns err = cdp . execute ( ctx , commandgetisolateid , nil , & res ) if err ! = nil { return " " , err } return res . id , nil } 
func ( p * getheapusageparams ) do ( ctx context . context ) ( usedsize float64 , totalsize float64 , err error ) { var res getheapusagereturns err = cdp . execute ( ctx , commandgetheapusage , nil , & res ) if err ! = nil { return 0 , 0 , err } return res . usedsize , res . totalsize , nil } 
func ( p getpropertiesparams ) withownproperties ( ownproperties bool ) * getpropertiesparams { p . ownproperties = ownproperties return & p } 
func ( p getpropertiesparams ) withaccessorpropertiesonly ( accessorpropertiesonly bool ) * getpropertiesparams { p . accessorpropertiesonly = accessorpropertiesonly return & p } 
func ( p getpropertiesparams ) withgeneratepreview ( generatepreview bool ) * getpropertiesparams { p . generatepreview = generatepreview return & p } 
func ( p * getpropertiesparams ) do ( ctx context . context ) ( result [ ] * propertydescriptor , internalproperties [ ] * internalpropertydescriptor , privateproperties [ ] * privatepropertydescriptor , exceptiondetails * exceptiondetails , err error ) { var res getpropertiesreturns err = cdp . execute ( ctx , commandgetproperties , p , & res ) if err ! = nil { return nil , nil , nil , nil , err } return res . result , res . internalproperties , res . privateproperties , res . exceptiondetails , nil } 
func ( p globallexicalscopenamesparams ) withexecutioncontextid ( executioncontextid executioncontextid ) * globallexicalscopenamesparams { p . executioncontextid = executioncontextid return & p } 
func ( p * globallexicalscopenamesparams ) do ( ctx context . context ) ( names [ ] string , err error ) { var res globallexicalscopenamesreturns err = cdp . execute ( ctx , commandgloballexicalscopenames , p , & res ) if err ! = nil { return nil , err } return res . names , nil } 
func ( p queryobjectsparams ) withobjectgroup ( objectgroup string ) * queryobjectsparams { p . objectgroup = objectgroup return & p } 
func ( p * queryobjectsparams ) do ( ctx context . context ) ( objects * remoteobject , err error ) { var res queryobjectsreturns err = cdp . execute ( ctx , commandqueryobjects , p , & res ) if err ! = nil { return nil , err } return res . objects , nil } 
func ( p * releaseobjectparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandreleaseobject , p , nil ) } 
func ( p * releaseobjectgroupparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandreleaseobjectgroup , p , nil ) } 
func ( p * runifwaitingfordebuggerparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandrunifwaitingfordebugger , nil , nil ) } 
func ( p runscriptparams ) withexecutioncontextid ( executioncontextid executioncontextid ) * runscriptparams { p . executioncontextid = executioncontextid return & p } 
func ( p runscriptparams ) withobjectgroup ( objectgroup string ) * runscriptparams { p . objectgroup = objectgroup return & p } 
func ( p runscriptparams ) withsilent ( silent bool ) * runscriptparams { p . silent = silent return & p } 
func ( p runscriptparams ) withincludecommandlineapi ( includecommandlineapi bool ) * runscriptparams { p . includecommandlineapi = includecommandlineapi return & p } 
func ( p runscriptparams ) withreturnbyvalue ( returnbyvalue bool ) * runscriptparams { p . returnbyvalue = returnbyvalue return & p } 
func ( p runscriptparams ) withgeneratepreview ( generatepreview bool ) * runscriptparams { p . generatepreview = generatepreview return & p } 
func ( p runscriptparams ) withawaitpromise ( awaitpromise bool ) * runscriptparams { p . awaitpromise = awaitpromise return & p } 
func ( p * runscriptparams ) do ( ctx context . context ) ( result * remoteobject , exceptiondetails * exceptiondetails , err error ) { var res runscriptreturns err = cdp . execute ( ctx , commandrunscript , p , & res ) if err ! = nil { return nil , nil , err } return res . result , res . exceptiondetails , nil } 
func ( p * setcustomobjectformatterenabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetcustomobjectformatterenabled , p , nil ) } 
func ( p * setmaxcallstacksizetocaptureparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetmaxcallstacksizetocapture , p , nil ) } 
func ( p * terminateexecutionparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandterminateexecution , nil , nil ) } 
func ( p addbindingparams ) withexecutioncontextid ( executioncontextid executioncontextid ) * addbindingparams { p . executioncontextid = executioncontextid return & p } 
func ( p * addbindingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandaddbinding , p , nil ) } 
func ( p * removebindingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremovebinding , p , nil ) } 
func ( p * endparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandend , nil , nil ) } 
func ( p * getcategoriesparams ) do ( ctx context . context ) ( categories [ ] string , err error ) { var res getcategoriesreturns err = cdp . execute ( ctx , commandgetcategories , nil , & res ) if err ! = nil { return nil , err } return res . categories , nil } 
func ( p * recordclocksyncmarkerparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandrecordclocksyncmarker , p , nil ) } 
func ( p * requestmemorydumpparams ) do ( ctx context . context ) ( dumpguid string , success bool , err error ) { var res requestmemorydumpreturns err = cdp . execute ( ctx , commandrequestmemorydump , nil , & res ) if err ! = nil { return " " , false , err } return res . dumpguid , res . success , nil } 
func ( p startparams ) withbufferusagereportinginterval ( bufferusagereportinginterval float64 ) * startparams { p . bufferusagereportinginterval = bufferusagereportinginterval return & p } 
func ( p startparams ) withtransfermode ( transfermode transfermode ) * startparams { p . transfermode = transfermode return & p } 
func ( p startparams ) withstreamformat ( streamformat streamformat ) * startparams { p . streamformat = streamformat return & p } 
func ( p startparams ) withstreamcompression ( streamcompression streamcompression ) * startparams { p . streamcompression = streamcompression return & p } 
func ( p startparams ) withtraceconfig ( traceconfig * traceconfig ) * startparams { p . traceconfig = traceconfig return & p } 
func ( v stateexplanation ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosecurity ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stateexplanation ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosecurity ( & r , v ) return r . error ( ) } 
func ( v setignorecertificateerrorsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosecurity1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setignorecertificateerrorsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosecurity1 ( & r , v ) return r . error ( ) } 
func ( v eventsecuritystatechanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotosecurity2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventsecuritystatechanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotosecurity2 ( & r , v ) return r . error ( ) } 
func ( p beginframeparams ) withframetimeticks ( frametimeticks float64 ) * beginframeparams { p . frametimeticks = frametimeticks return & p } 
func ( p beginframeparams ) withinterval ( interval float64 ) * beginframeparams { p . interval = interval return & p } 
func ( p beginframeparams ) withnodisplayupdates ( nodisplayupdates bool ) * beginframeparams { p . nodisplayupdates = nodisplayupdates return & p } 
func ( p beginframeparams ) withscreenshot ( screenshot * screenshotparams ) * beginframeparams { p . screenshot = screenshot return & p } 
func ( p * beginframeparams ) do ( ctx context . context ) ( hasdamage bool , screenshotdata [ ] byte , err error ) { var res beginframereturns err = cdp . execute ( ctx , commandbeginframe , p , & res ) if err ! = nil { return false , nil , err } var dec [ ] byte dec , err = base64 . stdencoding . decodestring ( res . screenshotdata ) if err ! = nil { return false , nil , err } return res . hasdamage , dec , nil } 
func ( v valuesource ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * valuesource ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaccessibility ( & r , v ) return r . error ( ) } 
func ( v value ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * value ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaccessibility1 ( & r , v ) return r . error ( ) } 
func ( v relatednode ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * relatednode ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaccessibility2 ( & r , v ) return r . error ( ) } 
func ( v node ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v getpartialaxtreereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getpartialaxtreereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaccessibility5 ( & r , v ) return r . error ( ) } 
func ( v getpartialaxtreeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getpartialaxtreeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaccessibility6 ( & r , v ) return r . error ( ) } 
func ( v getfullaxtreereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getfullaxtreereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaccessibility7 ( & r , v ) return r . error ( ) } 
func ( v getfullaxtreeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoaccessibility8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getfullaxtreeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoaccessibility8 ( & r , v ) return r . error ( ) } 
func ( p getencodedresponseparams ) withquality ( quality float64 ) * getencodedresponseparams { p . quality = quality return & p } 
func ( p getencodedresponseparams ) withsizeonly ( sizeonly bool ) * getencodedresponseparams { p . sizeonly = sizeonly return & p } 
func ( p * getencodedresponseparams ) do ( ctx context . context ) ( body [ ] byte , originalsize int64 , encodedsize int64 , err error ) { var res getencodedresponsereturns err = cdp . execute ( ctx , commandgetencodedresponse , p , & res ) if err ! = nil { return nil , 0 , 0 , err } var dec [ ] byte dec , err = base64 . stdencoding . decodestring ( res . body ) if err ! = nil { return nil , 0 , 0 , err } return dec , res . originalsize , res . encodedsize , nil } 
func ( t servicename ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * servicename ) unmarshaleasyjson ( in * jlexer . lexer ) { switch servicename ( in . string ( ) ) { case servicenamebackgroundfetch : * t = servicenamebackgroundfetch case servicenamebackgroundsync : * t = servicenamebackgroundsync default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * servicename ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t virtualtimepolicy ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * virtualtimepolicy ) unmarshaleasyjson ( in * jlexer . lexer ) { switch virtualtimepolicy ( in . string ( ) ) { case virtualtimepolicyadvance : * t = virtualtimepolicyadvance case virtualtimepolicypause : * t = virtualtimepolicypause case virtualtimepolicypauseifnetworkfetchespending : * t = virtualtimepolicypauseifnetworkfetchespending default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * virtualtimepolicy ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t orientationtype ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * orientationtype ) unmarshaleasyjson ( in * jlexer . lexer ) { switch orientationtype ( in . string ( ) ) { case orientationtypeportraitprimary : * t = orientationtypeportraitprimary case orientationtypeportraitsecondary : * t = orientationtypeportraitsecondary case orientationtypelandscapeprimary : * t = orientationtypelandscapeprimary case orientationtypelandscapesecondary : * t = orientationtypelandscapesecondary default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * orientationtype ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( t setemittoucheventsformouseconfiguration ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * setemittoucheventsformouseconfiguration ) unmarshaleasyjson ( in * jlexer . lexer ) { switch setemittoucheventsformouseconfiguration ( in . string ( ) ) { case setemittoucheventsformouseconfigurationmobile : * t = setemittoucheventsformouseconfigurationmobile case setemittoucheventsformouseconfigurationdesktop : * t = setemittoucheventsformouseconfigurationdesktop default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * setemittoucheventsformouseconfiguration ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v screenshotparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheadlessexperimental ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * screenshotparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheadlessexperimental ( & r , v ) return r . error ( ) } 
func ( v eventneedsbeginframeschanged ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheadlessexperimental1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventneedsbeginframeschanged ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheadlessexperimental1 ( & r , v ) return r . error ( ) } 
func ( v beginframereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheadlessexperimental4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * beginframereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheadlessexperimental4 ( & r , v ) return r . error ( ) } 
func ( v beginframeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoheadlessexperimental5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * beginframeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoheadlessexperimental5 ( & r , v ) return r . error ( ) } 
func ( v rgba ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocdp ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * rgba ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocdp ( & r , v ) return r . error ( ) } 
func ( v * node ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocdp1 ( & r , v ) return r . error ( ) } 
func ( v frame ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocdp2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * frame ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocdp2 ( & r , v ) return r . error ( ) } 
func ( v backendnode ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotocdp3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * backendnode ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotocdp3 ( & r , v ) return r . error ( ) } 
func ( p addscripttoevaluateonnewdocumentparams ) withworldname ( worldname string ) * addscripttoevaluateonnewdocumentparams { p . worldname = worldname return & p } 
func ( p * addscripttoevaluateonnewdocumentparams ) do ( ctx context . context ) ( identifier scriptidentifier , err error ) { var res addscripttoevaluateonnewdocumentreturns err = cdp . execute ( ctx , commandaddscripttoevaluateonnewdocument , p , & res ) if err ! = nil { return " " , err } return res . identifier , nil } 
func ( p * bringtofrontparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandbringtofront , nil , nil ) } 
func ( p capturescreenshotparams ) withformat ( format capturescreenshotformat ) * capturescreenshotparams { p . format = format return & p } 
func ( p capturescreenshotparams ) withquality ( quality int64 ) * capturescreenshotparams { p . quality = quality return & p } 
func ( p capturescreenshotparams ) withclip ( clip * viewport ) * capturescreenshotparams { p . clip = clip return & p } 
func ( p capturescreenshotparams ) withfromsurface ( fromsurface bool ) * capturescreenshotparams { p . fromsurface = fromsurface return & p } 
func ( p * capturescreenshotparams ) do ( ctx context . context ) ( data [ ] byte , err error ) { var res capturescreenshotreturns err = cdp . execute ( ctx , commandcapturescreenshot , p , & res ) if err ! = nil { return nil , err } var dec [ ] byte dec , err = base64 . stdencoding . decodestring ( res . data ) if err ! = nil { return nil , err } return dec , nil } 
func ( p capturesnapshotparams ) withformat ( format capturesnapshotformat ) * capturesnapshotparams { p . format = format return & p } 
func ( p * capturesnapshotparams ) do ( ctx context . context ) ( data string , err error ) { var res capturesnapshotreturns err = cdp . execute ( ctx , commandcapturesnapshot , p , & res ) if err ! = nil { return " " , err } return res . data , nil } 
func ( p createisolatedworldparams ) withworldname ( worldname string ) * createisolatedworldparams { p . worldname = worldname return & p } 
func ( p createisolatedworldparams ) withgrantuniveralaccess ( grantuniveralaccess bool ) * createisolatedworldparams { p . grantuniveralaccess = grantuniveralaccess return & p } 
func ( p * createisolatedworldparams ) do ( ctx context . context ) ( executioncontextid runtime . executioncontextid , err error ) { var res createisolatedworldreturns err = cdp . execute ( ctx , commandcreateisolatedworld , p , & res ) if err ! = nil { return 0 , err } return res . executioncontextid , nil } 
func ( p * getappmanifestparams ) do ( ctx context . context ) ( url string , errors [ ] * appmanifesterror , data string , err error ) { var res getappmanifestreturns err = cdp . execute ( ctx , commandgetappmanifest , nil , & res ) if err ! = nil { return " " , nil , " " , err } return res . url , res . errors , res . data , nil } 
func ( p * getinstallabilityerrorsparams ) do ( ctx context . context ) ( errors [ ] string , err error ) { var res getinstallabilityerrorsreturns err = cdp . execute ( ctx , commandgetinstallabilityerrors , nil , & res ) if err ! = nil { return nil , err } return res . errors , nil } 
func ( p * getframetreeparams ) do ( ctx context . context ) ( frametree * frametree , err error ) { var res getframetreereturns err = cdp . execute ( ctx , commandgetframetree , nil , & res ) if err ! = nil { return nil , err } return res . frametree , nil } 
func ( p * getlayoutmetricsparams ) do ( ctx context . context ) ( layoutviewport * layoutviewport , visualviewport * visualviewport , contentsize * dom . rect , err error ) { var res getlayoutmetricsreturns err = cdp . execute ( ctx , commandgetlayoutmetrics , nil , & res ) if err ! = nil { return nil , nil , nil , err } return res . layoutviewport , res . visualviewport , res . contentsize , nil } 
func ( p * getnavigationhistoryparams ) do ( ctx context . context ) ( currentindex int64 , entries [ ] * navigationentry , err error ) { var res getnavigationhistoryreturns err = cdp . execute ( ctx , commandgetnavigationhistory , nil , & res ) if err ! = nil { return 0 , nil , err } return res . currentindex , res . entries , nil } 
func ( p * resetnavigationhistoryparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandresetnavigationhistory , nil , nil ) } 
func ( p * getresourcecontentparams ) do ( ctx context . context ) ( content [ ] byte , err error ) { var res getresourcecontentreturns err = cdp . execute ( ctx , commandgetresourcecontent , p , & res ) if err ! = nil { return nil , err } var dec [ ] byte if res . base64encoded { dec , err = base64 . stdencoding . decodestring ( res . content ) if err ! = nil { return nil , err } } else { dec = [ ] byte ( res . content ) } return dec , nil } 
func ( p * getresourcetreeparams ) do ( ctx context . context ) ( frametree * frameresourcetree , err error ) { var res getresourcetreereturns err = cdp . execute ( ctx , commandgetresourcetree , nil , & res ) if err ! = nil { return nil , err } return res . frametree , nil } 
func ( p handlejavascriptdialogparams ) withprompttext ( prompttext string ) * handlejavascriptdialogparams { p . prompttext = prompttext return & p } 
func ( p * handlejavascriptdialogparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandhandlejavascriptdialog , p , nil ) } 
func ( p navigateparams ) withreferrer ( referrer string ) * navigateparams { p . referrer = referrer return & p } 
func ( p navigateparams ) withtransitiontype ( transitiontype transitiontype ) * navigateparams { p . transitiontype = transitiontype return & p } 
func ( p navigateparams ) withframeid ( frameid cdp . frameid ) * navigateparams { p . frameid = frameid return & p } 
func ( p * navigateparams ) do ( ctx context . context ) ( frameid cdp . frameid , loaderid cdp . loaderid , errortext string , err error ) { var res navigatereturns err = cdp . execute ( ctx , commandnavigate , p , & res ) if err ! = nil { return " " , " " , " " , err } return res . frameid , res . loaderid , res . errortext , nil } 
func ( p * navigatetohistoryentryparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandnavigatetohistoryentry , p , nil ) } 
func ( p printtopdfparams ) withlandscape ( landscape bool ) * printtopdfparams { p . landscape = landscape return & p } 
func ( p printtopdfparams ) withdisplayheaderfooter ( displayheaderfooter bool ) * printtopdfparams { p . displayheaderfooter = displayheaderfooter return & p } 
func ( p printtopdfparams ) withprintbackground ( printbackground bool ) * printtopdfparams { p . printbackground = printbackground return & p } 
func ( p printtopdfparams ) withscale ( scale float64 ) * printtopdfparams { p . scale = scale return & p } 
func ( p printtopdfparams ) withpaperwidth ( paperwidth float64 ) * printtopdfparams { p . paperwidth = paperwidth return & p } 
func ( p printtopdfparams ) withpaperheight ( paperheight float64 ) * printtopdfparams { p . paperheight = paperheight return & p } 
func ( p printtopdfparams ) withmargintop ( margintop float64 ) * printtopdfparams { p . margintop = margintop return & p } 
func ( p printtopdfparams ) withmarginbottom ( marginbottom float64 ) * printtopdfparams { p . marginbottom = marginbottom return & p } 
func ( p printtopdfparams ) withmarginleft ( marginleft float64 ) * printtopdfparams { p . marginleft = marginleft return & p } 
func ( p printtopdfparams ) withmarginright ( marginright float64 ) * printtopdfparams { p . marginright = marginright return & p } 
func ( p printtopdfparams ) withpageranges ( pageranges string ) * printtopdfparams { p . pageranges = pageranges return & p } 
func ( p printtopdfparams ) withignoreinvalidpageranges ( ignoreinvalidpageranges bool ) * printtopdfparams { p . ignoreinvalidpageranges = ignoreinvalidpageranges return & p } 
func ( p printtopdfparams ) withheadertemplate ( headertemplate string ) * printtopdfparams { p . headertemplate = headertemplate return & p } 
func ( p printtopdfparams ) withfootertemplate ( footertemplate string ) * printtopdfparams { p . footertemplate = footertemplate return & p } 
func ( p printtopdfparams ) withprefercsspagesize ( prefercsspagesize bool ) * printtopdfparams { p . prefercsspagesize = prefercsspagesize return & p } 
func ( p * printtopdfparams ) do ( ctx context . context ) ( data [ ] byte , err error ) { var res printtopdfreturns err = cdp . execute ( ctx , commandprinttopdf , p , & res ) if err ! = nil { return nil , err } var dec [ ] byte dec , err = base64 . stdencoding . decodestring ( res . data ) if err ! = nil { return nil , err } return dec , nil } 
func ( p reloadparams ) withignorecache ( ignorecache bool ) * reloadparams { p . ignorecache = ignorecache return & p } 
func ( p reloadparams ) withscripttoevaluateonload ( scripttoevaluateonload string ) * reloadparams { p . scripttoevaluateonload = scripttoevaluateonload return & p } 
func ( p * reloadparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandreload , p , nil ) } 
func ( p * removescripttoevaluateonnewdocumentparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremovescripttoevaluateonnewdocument , p , nil ) } 
func ( p * screencastframeackparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandscreencastframeack , p , nil ) } 
func ( p searchinresourceparams ) withcasesensitive ( casesensitive bool ) * searchinresourceparams { p . casesensitive = casesensitive return & p } 
func ( p searchinresourceparams ) withisregex ( isregex bool ) * searchinresourceparams { p . isregex = isregex return & p } 
func ( p * searchinresourceparams ) do ( ctx context . context ) ( result [ ] * debugger . searchmatch , err error ) { var res searchinresourcereturns err = cdp . execute ( ctx , commandsearchinresource , p , & res ) if err ! = nil { return nil , err } return res . result , nil } 
func ( p * setadblockingenabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetadblockingenabled , p , nil ) } 
func ( p * setbypasscspparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetbypasscsp , p , nil ) } 
func ( p * setfontfamiliesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetfontfamilies , p , nil ) } 
func ( p * setfontsizesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetfontsizes , p , nil ) } 
func ( p * setdocumentcontentparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdocumentcontent , p , nil ) } 
func ( p setdownloadbehaviorparams ) withdownloadpath ( downloadpath string ) * setdownloadbehaviorparams { p . downloadpath = downloadpath return & p } 
func ( p * setdownloadbehaviorparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdownloadbehavior , p , nil ) } 
func ( p * setlifecycleeventsenabledparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetlifecycleeventsenabled , p , nil ) } 
func ( p startscreencastparams ) withformat ( format screencastformat ) * startscreencastparams { p . format = format return & p } 
func ( p startscreencastparams ) withquality ( quality int64 ) * startscreencastparams { p . quality = quality return & p } 
func ( p startscreencastparams ) withmaxwidth ( maxwidth int64 ) * startscreencastparams { p . maxwidth = maxwidth return & p } 
func ( p startscreencastparams ) withmaxheight ( maxheight int64 ) * startscreencastparams { p . maxheight = maxheight return & p } 
func ( p startscreencastparams ) witheverynthframe ( everynthframe int64 ) * startscreencastparams { p . everynthframe = everynthframe return & p } 
func ( p * startscreencastparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstartscreencast , p , nil ) } 
func ( p * stoploadingparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstoploading , nil , nil ) } 
func ( p * setweblifecyclestateparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetweblifecyclestate , p , nil ) } 
func ( p * stopscreencastparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstopscreencast , nil , nil ) } 
func ( p * setproducecompilationcacheparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetproducecompilationcache , p , nil ) } 
func ( p * addcompilationcacheparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandaddcompilationcache , p , nil ) } 
func ( p * clearcompilationcacheparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandclearcompilationcache , nil , nil ) } 
func ( p generatetestreportparams ) withgroup ( group string ) * generatetestreportparams { p . group = group return & p } 
func ( p * generatetestreportparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandgeneratetestreport , p , nil ) } 
func ( p * waitfordebuggerparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandwaitfordebugger , nil , nil ) } 
func ( v setshowviewportsizeonresizeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setshowviewportsizeonresizeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay ( & r , v ) return r . error ( ) } 
func ( v setshowscrollbottleneckrectsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setshowscrollbottleneckrectsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay1 ( & r , v ) return r . error ( ) } 
func ( v setshowpaintrectsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setshowpaintrectsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay2 ( & r , v ) return r . error ( ) } 
func ( v setshowhittestbordersparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setshowhittestbordersparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay3 ( & r , v ) return r . error ( ) } 
func ( v setshowfpscounterparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setshowfpscounterparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay4 ( & r , v ) return r . error ( ) } 
func ( v setshowdebugbordersparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setshowdebugbordersparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay5 ( & r , v ) return r . error ( ) } 
func ( v setshowadhighlightsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setshowadhighlightsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay6 ( & r , v ) return r . error ( ) } 
func ( v setpausedindebuggermessageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setpausedindebuggermessageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay7 ( & r , v ) return r . error ( ) } 
func ( v setinspectmodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setinspectmodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay8 ( & r , v ) return r . error ( ) } 
func ( v highlightrectparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * highlightrectparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay9 ( & r , v ) return r . error ( ) } 
func ( v highlightquadparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * highlightquadparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay10 ( & r , v ) return r . error ( ) } 
func ( v highlightnodeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * highlightnodeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay11 ( & r , v ) return r . error ( ) } 
func ( v highlightframeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * highlightframeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay12 ( & r , v ) return r . error ( ) } 
func ( v highlightconfig ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * highlightconfig ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay13 ( & r , v ) return r . error ( ) } 
func ( v hidehighlightparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * hidehighlightparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay14 ( & r , v ) return r . error ( ) } 
func ( v gethighlightobjectfortestreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gethighlightobjectfortestreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay15 ( & r , v ) return r . error ( ) } 
func ( v gethighlightobjectfortestparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay16 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * gethighlightobjectfortestparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay16 ( & r , v ) return r . error ( ) } 
func ( v eventscreenshotrequested ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventscreenshotrequested ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay17 ( & r , v ) return r . error ( ) } 
func ( v eventnodehighlightrequested ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay18 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventnodehighlightrequested ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay18 ( & r , v ) return r . error ( ) } 
func ( v eventinspectnoderequested ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventinspectnoderequested ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay19 ( & r , v ) return r . error ( ) } 
func ( v eventinspectmodecanceled ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotooverlay20 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventinspectmodecanceled ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotooverlay20 ( & r , v ) return r . error ( ) } 
func ( t settimedomaintimedomain ) marshaleasyjson ( out * jwriter . writer ) { out . string ( string ( t ) ) } 
func ( t * settimedomaintimedomain ) unmarshaleasyjson ( in * jlexer . lexer ) { switch settimedomaintimedomain ( in . string ( ) ) { case settimedomaintimedomaintimeticks : * t = settimedomaintimedomaintimeticks case settimedomaintimedomainthreadticks : * t = settimedomaintimedomainthreadticks default : in . adderror ( errors . new ( " " ) ) } } 
func ( t * settimedomaintimedomain ) unmarshaljson ( buf [ ] byte ) error { return easyjson . unmarshal ( buf , t ) } 
func ( v setxhrbreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setxhrbreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger ( & r , v ) return r . error ( ) } 
func ( v setinstrumentationbreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setinstrumentationbreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger1 ( & r , v ) return r . error ( ) } 
func ( v seteventlistenerbreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * seteventlistenerbreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger2 ( & r , v ) return r . error ( ) } 
func ( v setdombreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdombreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger3 ( & r , v ) return r . error ( ) } 
func ( v removexhrbreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removexhrbreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger4 ( & r , v ) return r . error ( ) } 
func ( v removeinstrumentationbreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removeinstrumentationbreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger5 ( & r , v ) return r . error ( ) } 
func ( v removeeventlistenerbreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removeeventlistenerbreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger6 ( & r , v ) return r . error ( ) } 
func ( v removedombreakpointparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * removedombreakpointparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger7 ( & r , v ) return r . error ( ) } 
func ( v geteventlistenersreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * geteventlistenersreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger8 ( & r , v ) return r . error ( ) } 
func ( v geteventlistenersparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * geteventlistenersparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger9 ( & r , v ) return r . error ( ) } 
func ( v eventlistener ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodomdebugger10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventlistener ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodomdebugger10 ( & r , v ) return r . error ( ) } 
func ( v version ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * version ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker ( & r , v ) return r . error ( ) } 
func ( v updateregistrationparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * updateregistrationparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker1 ( & r , v ) return r . error ( ) } 
func ( v unregisterparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * unregisterparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker2 ( & r , v ) return r . error ( ) } 
func ( v stopworkerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopworkerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker3 ( & r , v ) return r . error ( ) } 
func ( v stopallworkersparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * stopallworkersparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker4 ( & r , v ) return r . error ( ) } 
func ( v startworkerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * startworkerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker5 ( & r , v ) return r . error ( ) } 
func ( v skipwaitingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * skipwaitingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker6 ( & r , v ) return r . error ( ) } 
func ( v setforceupdateonpageloadparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker7 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setforceupdateonpageloadparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker7 ( & r , v ) return r . error ( ) } 
func ( v registration ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * registration ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker8 ( & r , v ) return r . error ( ) } 
func ( v inspectworkerparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * inspectworkerparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker9 ( & r , v ) return r . error ( ) } 
func ( v eventworkerversionupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventworkerversionupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker10 ( & r , v ) return r . error ( ) } 
func ( v eventworkerregistrationupdated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventworkerregistrationupdated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker11 ( & r , v ) return r . error ( ) } 
func ( v eventworkererrorreported ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventworkererrorreported ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker12 ( & r , v ) return r . error ( ) } 
func ( v errormessage ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * errormessage ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker13 ( & r , v ) return r . error ( ) } 
func ( v dispatchsynceventparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * dispatchsynceventparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker15 ( & r , v ) return r . error ( ) } 
func ( v deliverpushmessageparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoserviceworker17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * deliverpushmessageparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoserviceworker17 ( & r , v ) return r . error ( ) } 
func ( v settimingparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * settimingparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation ( & r , v ) return r . error ( ) } 
func ( v setplaybackrateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setplaybackrateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation1 ( & r , v ) return r . error ( ) } 
func ( v setpausedparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation2 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setpausedparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation2 ( & r , v ) return r . error ( ) } 
func ( v seekanimationsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation3 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * seekanimationsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation3 ( & r , v ) return r . error ( ) } 
func ( v resolveanimationreturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation4 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resolveanimationreturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation4 ( & r , v ) return r . error ( ) } 
func ( v resolveanimationparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation5 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * resolveanimationparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation5 ( & r , v ) return r . error ( ) } 
func ( v releaseanimationsparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation6 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * releaseanimationsparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation6 ( & r , v ) return r . error ( ) } 
func ( v * keyframesrule ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation7 ( & r , v ) return r . error ( ) } 
func ( v keyframestyle ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation8 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * keyframestyle ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation8 ( & r , v ) return r . error ( ) } 
func ( v getplaybackratereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation9 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getplaybackratereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation9 ( & r , v ) return r . error ( ) } 
func ( v getplaybackrateparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation10 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getplaybackrateparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation10 ( & r , v ) return r . error ( ) } 
func ( v getcurrenttimereturns ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation11 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcurrenttimereturns ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation11 ( & r , v ) return r . error ( ) } 
func ( v getcurrenttimeparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation12 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * getcurrenttimeparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation12 ( & r , v ) return r . error ( ) } 
func ( v eventanimationstarted ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation13 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventanimationstarted ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation13 ( & r , v ) return r . error ( ) } 
func ( v eventanimationcreated ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation14 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventanimationcreated ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation14 ( & r , v ) return r . error ( ) } 
func ( v eventanimationcanceled ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation15 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * eventanimationcanceled ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation15 ( & r , v ) return r . error ( ) } 
func ( v effect ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation17 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * effect ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation17 ( & r , v ) return r . error ( ) } 
func ( v animation ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotoanimation19 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * animation ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotoanimation19 ( & r , v ) return r . error ( ) } 
func ( p * executesqlparams ) do ( ctx context . context ) ( columnnames [ ] string , values [ ] easyjson . rawmessage , sqlerror * error , err error ) { var res executesqlreturns err = cdp . execute ( ctx , commandexecutesql , p , & res ) if err ! = nil { return nil , nil , nil , err } return res . columnnames , res . values , res . sqlerror , nil } 
func ( p * getdatabasetablenamesparams ) do ( ctx context . context ) ( tablenames [ ] string , err error ) { var res getdatabasetablenamesreturns err = cdp . execute ( ctx , commandgetdatabasetablenames , p , & res ) if err ! = nil { return nil , err } return res . tablenames , nil } 
func ( v setdeviceorientationoverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodeviceorientation ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * setdeviceorientationoverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodeviceorientation ( & r , v ) return r . error ( ) } 
func ( v cleardeviceorientationoverrideparams ) marshaljson ( ) ( [ ] byte , error ) { w : = jwriter . writer { } easyjsonc5a4559bencodegithubcomchromedpcdprotodeviceorientation1 ( & w , v ) return w . buffer . buildbytes ( ) , w . error } 
func ( v * cleardeviceorientationoverrideparams ) unmarshaljson ( data [ ] byte ) error { r : = jlexer . lexer { data : data } easyjsonc5a4559bdecodegithubcomchromedpcdprotodeviceorientation1 ( & r , v ) return r . error ( ) } 
func ( p * activatetargetparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandactivatetarget , p , nil ) } 
func ( p attachtotargetparams ) withflatten ( flatten bool ) * attachtotargetparams { p . flatten = flatten return & p } 
func ( p * attachtotargetparams ) do ( ctx context . context ) ( sessionid sessionid , err error ) { var res attachtotargetreturns err = cdp . execute ( ctx , commandattachtotarget , p , & res ) if err ! = nil { return " " , err } return res . sessionid , nil } 
func ( p * attachtobrowsertargetparams ) do ( ctx context . context ) ( sessionid sessionid , err error ) { var res attachtobrowsertargetreturns err = cdp . execute ( ctx , commandattachtobrowsertarget , nil , & res ) if err ! = nil { return " " , err } return res . sessionid , nil } 
func ( p * closetargetparams ) do ( ctx context . context ) ( success bool , err error ) { var res closetargetreturns err = cdp . execute ( ctx , commandclosetarget , p , & res ) if err ! = nil { return false , err } return res . success , nil } 
func ( p exposedevtoolsprotocolparams ) withbindingname ( bindingname string ) * exposedevtoolsprotocolparams { p . bindingname = bindingname return & p } 
func ( p * exposedevtoolsprotocolparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandexposedevtoolsprotocol , p , nil ) } 
func ( p * createbrowsercontextparams ) do ( ctx context . context ) ( browsercontextid browsercontextid , err error ) { var res createbrowsercontextreturns err = cdp . execute ( ctx , commandcreatebrowsercontext , nil , & res ) if err ! = nil { return " " , err } return res . browsercontextid , nil } 
func ( p * getbrowsercontextsparams ) do ( ctx context . context ) ( browsercontextids [ ] browsercontextid , err error ) { var res getbrowsercontextsreturns err = cdp . execute ( ctx , commandgetbrowsercontexts , nil , & res ) if err ! = nil { return nil , err } return res . browsercontextids , nil } 
func ( p createtargetparams ) withwidth ( width int64 ) * createtargetparams { p . width = width return & p } 
func ( p createtargetparams ) withheight ( height int64 ) * createtargetparams { p . height = height return & p } 
func ( p createtargetparams ) withbrowsercontextid ( browsercontextid browsercontextid ) * createtargetparams { p . browsercontextid = browsercontextid return & p } 
func ( p createtargetparams ) withenablebeginframecontrol ( enablebeginframecontrol bool ) * createtargetparams { p . enablebeginframecontrol = enablebeginframecontrol return & p } 
func ( p * createtargetparams ) do ( ctx context . context ) ( targetid id , err error ) { var res createtargetreturns err = cdp . execute ( ctx , commandcreatetarget , p , & res ) if err ! = nil { return " " , err } return res . targetid , nil } 
func ( p detachfromtargetparams ) withsessionid ( sessionid sessionid ) * detachfromtargetparams { p . sessionid = sessionid return & p } 
func ( p * detachfromtargetparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddetachfromtarget , p , nil ) } 
func ( p * disposebrowsercontextparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commanddisposebrowsercontext , p , nil ) } 
func ( p gettargetinfoparams ) withtargetid ( targetid id ) * gettargetinfoparams { p . targetid = targetid return & p } 
func ( p * gettargetinfoparams ) do ( ctx context . context ) ( targetinfo * info , err error ) { var res gettargetinforeturns err = cdp . execute ( ctx , commandgettargetinfo , p , & res ) if err ! = nil { return nil , err } return res . targetinfo , nil } 
func ( p * gettargetsparams ) do ( ctx context . context ) ( targetinfos [ ] * info , err error ) { var res gettargetsreturns err = cdp . execute ( ctx , commandgettargets , nil , & res ) if err ! = nil { return nil , err } return res . targetinfos , nil } 
func ( p sendmessagetotargetparams ) withsessionid ( sessionid sessionid ) * sendmessagetotargetparams { p . sessionid = sessionid return & p } 
func ( p * sendmessagetotargetparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsendmessagetotarget , p , nil ) } 
func ( p setautoattachparams ) withflatten ( flatten bool ) * setautoattachparams { p . flatten = flatten return & p } 
func ( p * setautoattachparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetautoattach , p , nil ) } 
func ( p * setdiscovertargetsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetdiscovertargets , p , nil ) } 
func ( p * setremotelocationsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetremotelocations , p , nil ) } 
func ( p enableparams ) withpatterns ( patterns [ ] * requestpattern ) * enableparams { p . patterns = patterns return & p } 
func ( p enableparams ) withhandleauthrequests ( handleauthrequests bool ) * enableparams { p . handleauthrequests = handleauthrequests return & p } 
func ( p * failrequestparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandfailrequest , p , nil ) } 
func ( p fulfillrequestparams ) withbody ( body string ) * fulfillrequestparams { p . body = body return & p } 
func ( p fulfillrequestparams ) withresponsephrase ( responsephrase string ) * fulfillrequestparams { p . responsephrase = responsephrase return & p } 
func ( p * fulfillrequestparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandfulfillrequest , p , nil ) } 
func ( p continuerequestparams ) withurl ( url string ) * continuerequestparams { p . url = url return & p } 
func ( p continuerequestparams ) withmethod ( method string ) * continuerequestparams { p . method = method return & p } 
func ( p continuerequestparams ) withpostdata ( postdata string ) * continuerequestparams { p . postdata = postdata return & p } 
func ( p continuerequestparams ) withheaders ( headers [ ] * headerentry ) * continuerequestparams { p . headers = headers return & p } 
func ( p * continuerequestparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcontinuerequest , p , nil ) } 
func ( p * continuewithauthparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcontinuewithauth , p , nil ) } 
func ( p * takeresponsebodyasstreamparams ) do ( ctx context . context ) ( stream io . streamhandle , err error ) { var res takeresponsebodyasstreamreturns err = cdp . execute ( ctx , commandtakeresponsebodyasstream , p , & res ) if err ! = nil { return " " , err } return res . stream , nil } 
func ( p continuetolocationparams ) withtargetcallframes ( targetcallframes continuetolocationtargetcallframes ) * continuetolocationparams { p . targetcallframes = targetcallframes return & p } 
func ( p * continuetolocationparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandcontinuetolocation , p , nil ) } 
func ( p enableparams ) withmaxscriptscachesize ( maxscriptscachesize float64 ) * enableparams { p . maxscriptscachesize = maxscriptscachesize return & p } 
func ( p * enableparams ) do ( ctx context . context ) ( debuggerid runtime . uniquedebuggerid , err error ) { var res enablereturns err = cdp . execute ( ctx , commandenable , p , & res ) if err ! = nil { return " " , err } return res . debuggerid , nil } 
func ( p evaluateoncallframeparams ) withobjectgroup ( objectgroup string ) * evaluateoncallframeparams { p . objectgroup = objectgroup return & p } 
func ( p evaluateoncallframeparams ) withincludecommandlineapi ( includecommandlineapi bool ) * evaluateoncallframeparams { p . includecommandlineapi = includecommandlineapi return & p } 
func ( p evaluateoncallframeparams ) withsilent ( silent bool ) * evaluateoncallframeparams { p . silent = silent return & p } 
func ( p evaluateoncallframeparams ) withreturnbyvalue ( returnbyvalue bool ) * evaluateoncallframeparams { p . returnbyvalue = returnbyvalue return & p } 
func ( p evaluateoncallframeparams ) withgeneratepreview ( generatepreview bool ) * evaluateoncallframeparams { p . generatepreview = generatepreview return & p } 
func ( p evaluateoncallframeparams ) withthrowonsideeffect ( throwonsideeffect bool ) * evaluateoncallframeparams { p . throwonsideeffect = throwonsideeffect return & p } 
func ( p evaluateoncallframeparams ) withtimeout ( timeout runtime . timedelta ) * evaluateoncallframeparams { p . timeout = timeout return & p } 
func ( p * evaluateoncallframeparams ) do ( ctx context . context ) ( result * runtime . remoteobject , exceptiondetails * runtime . exceptiondetails , err error ) { var res evaluateoncallframereturns err = cdp . execute ( ctx , commandevaluateoncallframe , p , & res ) if err ! = nil { return nil , nil , err } return res . result , res . exceptiondetails , nil } 
func ( p getpossiblebreakpointsparams ) withend ( end * location ) * getpossiblebreakpointsparams { p . end = end return & p } 
func ( p getpossiblebreakpointsparams ) withrestricttofunction ( restricttofunction bool ) * getpossiblebreakpointsparams { p . restricttofunction = restricttofunction return & p } 
func ( p * getpossiblebreakpointsparams ) do ( ctx context . context ) ( locations [ ] * breaklocation , err error ) { var res getpossiblebreakpointsreturns err = cdp . execute ( ctx , commandgetpossiblebreakpoints , p , & res ) if err ! = nil { return nil , err } return res . locations , nil } 
func ( p * getscriptsourceparams ) do ( ctx context . context ) ( scriptsource string , err error ) { var res getscriptsourcereturns err = cdp . execute ( ctx , commandgetscriptsource , p , & res ) if err ! = nil { return " " , err } return res . scriptsource , nil } 
func ( p * getstacktraceparams ) do ( ctx context . context ) ( stacktrace * runtime . stacktrace , err error ) { var res getstacktracereturns err = cdp . execute ( ctx , commandgetstacktrace , p , & res ) if err ! = nil { return nil , err } return res . stacktrace , nil } 
func ( p * pauseparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandpause , nil , nil ) } 
func ( p * pauseonasynccallparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandpauseonasynccall , p , nil ) } 
func ( p * removebreakpointparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandremovebreakpoint , p , nil ) } 
func ( p * restartframeparams ) do ( ctx context . context ) ( callframes [ ] * callframe , asyncstacktrace * runtime . stacktrace , asyncstacktraceid * runtime . stacktraceid , err error ) { var res restartframereturns err = cdp . execute ( ctx , commandrestartframe , p , & res ) if err ! = nil { return nil , nil , nil , err } return res . callframes , res . asyncstacktrace , res . asyncstacktraceid , nil } 
func ( p * resumeparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandresume , nil , nil ) } 
func ( p searchincontentparams ) withcasesensitive ( casesensitive bool ) * searchincontentparams { p . casesensitive = casesensitive return & p } 
func ( p searchincontentparams ) withisregex ( isregex bool ) * searchincontentparams { p . isregex = isregex return & p } 
func ( p * searchincontentparams ) do ( ctx context . context ) ( result [ ] * searchmatch , err error ) { var res searchincontentreturns err = cdp . execute ( ctx , commandsearchincontent , p , & res ) if err ! = nil { return nil , err } return res . result , nil } 
func ( p * setasynccallstackdepthparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetasynccallstackdepth , p , nil ) } 
func ( p * setblackboxpatternsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetblackboxpatterns , p , nil ) } 
func ( p * setblackboxedrangesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetblackboxedranges , p , nil ) } 
func ( p setbreakpointparams ) withcondition ( condition string ) * setbreakpointparams { p . condition = condition return & p } 
func ( p * setbreakpointparams ) do ( ctx context . context ) ( breakpointid breakpointid , actuallocation * location , err error ) { var res setbreakpointreturns err = cdp . execute ( ctx , commandsetbreakpoint , p , & res ) if err ! = nil { return " " , nil , err } return res . breakpointid , res . actuallocation , nil } 
func ( p setbreakpointbyurlparams ) withurl ( url string ) * setbreakpointbyurlparams { p . url = url return & p } 
func ( p setbreakpointbyurlparams ) withurlregex ( urlregex string ) * setbreakpointbyurlparams { p . urlregex = urlregex return & p } 
func ( p setbreakpointbyurlparams ) withscripthash ( scripthash string ) * setbreakpointbyurlparams { p . scripthash = scripthash return & p } 
func ( p setbreakpointbyurlparams ) withcolumnnumber ( columnnumber int64 ) * setbreakpointbyurlparams { p . columnnumber = columnnumber return & p } 
func ( p setbreakpointbyurlparams ) withcondition ( condition string ) * setbreakpointbyurlparams { p . condition = condition return & p } 
func ( p * setbreakpointbyurlparams ) do ( ctx context . context ) ( breakpointid breakpointid , locations [ ] * location , err error ) { var res setbreakpointbyurlreturns err = cdp . execute ( ctx , commandsetbreakpointbyurl , p , & res ) if err ! = nil { return " " , nil , err } return res . breakpointid , res . locations , nil } 
func ( p setbreakpointonfunctioncallparams ) withcondition ( condition string ) * setbreakpointonfunctioncallparams { p . condition = condition return & p } 
func ( p * setbreakpointonfunctioncallparams ) do ( ctx context . context ) ( breakpointid breakpointid , err error ) { var res setbreakpointonfunctioncallreturns err = cdp . execute ( ctx , commandsetbreakpointonfunctioncall , p , & res ) if err ! = nil { return " " , err } return res . breakpointid , nil } 
func ( p * setbreakpointsactiveparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetbreakpointsactive , p , nil ) } 
func ( p * setpauseonexceptionsparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetpauseonexceptions , p , nil ) } 
func ( p * setreturnvalueparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetreturnvalue , p , nil ) } 
func ( p setscriptsourceparams ) withdryrun ( dryrun bool ) * setscriptsourceparams { p . dryrun = dryrun return & p } 
func ( p * setscriptsourceparams ) do ( ctx context . context ) ( callframes [ ] * callframe , stackchanged bool , asyncstacktrace * runtime . stacktrace , asyncstacktraceid * runtime . stacktraceid , exceptiondetails * runtime . exceptiondetails , err error ) { var res setscriptsourcereturns err = cdp . execute ( ctx , commandsetscriptsource , p , & res ) if err ! = nil { return nil , false , nil , nil , nil , err } return res . callframes , res . stackchanged , res . asyncstacktrace , res . asyncstacktraceid , res . exceptiondetails , nil } 
func ( p * setskipallpausesparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetskipallpauses , p , nil ) } 
func ( p * setvariablevalueparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandsetvariablevalue , p , nil ) } 
func ( p stepintoparams ) withbreakonasynccall ( breakonasynccall bool ) * stepintoparams { p . breakonasynccall = breakonasynccall return & p } 
func ( p * stepintoparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstepinto , p , nil ) } 
func ( p * stepoutparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstepout , nil , nil ) } 
func ( p * stepoverparams ) do ( ctx context . context ) ( err error ) { return cdp . execute ( ctx , commandstepover , nil , nil ) } 
func ( nb * notifybundle ) listen ( n network , a ma . multiaddr ) { if nb . listenf ! = nil { nb . listenf ( n , a ) } } 
func ( nb * notifybundle ) listenclose ( n network , a ma . multiaddr ) { if nb . listenclosef ! = nil { nb . listenclosef ( n , a ) } } 
func ( nb * notifybundle ) connected ( n network , c conn ) { if nb . connectedf ! = nil { nb . connectedf ( n , c ) } } 
func ( nb * notifybundle ) disconnected ( n network , c conn ) { if nb . disconnectedf ! = nil { nb . disconnectedf ( n , c ) } } 
func ( nb * notifybundle ) openedstream ( n network , s stream ) { if nb . openedstreamf ! = nil { nb . openedstreamf ( n , s ) } } 
func ( nb * notifybundle ) closedstream ( n network , s stream ) { if nb . closedstreamf ! = nil { nb . closedstreamf ( n , s ) } } 
func withnodial ( ctx context . context , reason string ) context . context { return context . withvalue ( ctx , nodial , reason ) } 
func getnodial ( ctx context . context ) ( nodial bool , reason string ) { v : = ctx . value ( nodial ) if v ! = nil { return true , v . ( string ) } return false , " " } 
func getdialpeertimeout ( ctx context . context ) time . duration { if to , ok : = ctx . value ( dialpeertimeoutctxkey { } ) . ( time . duration ) ; ok { return to } return dialpeertimeout } 
func withdialpeertimeout ( ctx context . context , timeout time . duration ) context . context { return context . withvalue ( ctx , dialpeertimeoutctxkey { } , timeout ) } 
func fullclose ( s stream ) error { if err : = s . close ( ) ; err ! = nil { s . reset ( ) return err } return awaiteof ( s ) } 
func awaiteof ( s stream ) error { s . setdeadline ( time . now ( ) . add ( eoftimeout ) ) n , err : = s . read ( [ ] byte { 0 } ) if n > 0 | | err == nil { s . reset ( ) return errexpectedeof } if err ! = io . eof { s . reset ( ) return err } return nil } 
func ( drv * driver ) open ( name string ) ( driver . conn , error ) { conn , err : = drv . driver . open ( name ) if err ! = nil { return conn , err } wrapped : = & conn { conn , drv . hooks } if isexecer ( conn ) && isqueryer ( conn ) && issessionresetter ( conn ) { return & execerqueryercontextwithsessionresetter { wrapped , & execercontext { wrapped } , & queryercontext { wrapped } , & sessionresetter { wrapped } } , nil } else if isexecer ( conn ) && isqueryer ( conn ) { return & execerqueryercontext { wrapped , & execercontext { wrapped } , & queryercontext { wrapped } } , nil } else if isexecer ( conn ) { return & execercontext { wrapped } , nil } else if isqueryer ( conn ) { return & queryercontext { wrapped } , nil } return wrapped , nil } 
func wrap ( driver driver . driver , hooks hooks ) driver . driver { return & driver { driver , hooks } } 
func ( b * fixedsizeringbuf ) contiglen ( ) int { extent : = b . beg + b . readable firstcontiglen : = intmin ( extent , b . n ) - b . beg return firstcontiglen } 
func ( b * fixedsizeringbuf ) bytes ( ) [ ] byte { extent : = b . beg + b . readable if extent <= b . n { return b . a [ b . use ] [ b . beg : ( b . beg + b . readable ) ] } src : = b . use dest : = 1 - b . use n : = copy ( b . a [ dest ] , b . a [ src ] [ b . beg : ] ) n += copy ( b . a [ dest ] [ n : ] , b . a [ src ] [ 0 : ( extent % b . n ) ] ) b . use = dest b . beg = 0 return b . a [ b . use ] [ : n ] } 
func ( b * fixedsizeringbuf ) bytestwo ( makecopy bool ) ( first [ ] byte , second [ ] byte ) { extent : = b . beg + b . readable if extent <= b . n { return b . a [ b . use ] [ b . beg : ( b . beg + b . readable ) ] , second } return b . a [ b . use ] [ b . beg : b . n ] , b . a [ b . use ] [ 0 : ( extent % b . n ) ] } 
func ( b * fixedsizeringbuf ) writeandmaybeoverwriteoldestdata ( p [ ] byte ) ( n int , err error ) { writecapacity : = b . n - b . readable if len ( p ) > writecapacity { b . advance ( len ( p ) - writecapacity ) } startpos : = 0 if len ( p ) > b . n { startpos = len ( p ) - b . n } n , err = b . write ( p [ startpos : ] ) if err ! = nil { return n , err } return len ( p ) , nil } 
func ( b * fixedsizeringbuf ) writeto ( w io . writer ) ( n int64 , err error ) { if b . readable == 0 { return 0 , io . eof } extent : = b . beg + b . readable firstwritelen : = intmin ( extent , b . n ) - b . beg secondwritelen : = b . readable - firstwritelen if firstwritelen > 0 { m , e : = w . write ( b . a [ b . use ] [ b . beg : ( b . beg + firstwritelen ) ] ) n += int64 ( m ) b . advance ( m ) if e ! = nil { return n , e } if m ! = firstwritelen { return n , io . errshortwrite } } if secondwritelen > 0 { m , e : = w . write ( b . a [ b . use ] [ 0 : secondwritelen ] ) n += int64 ( m ) b . advance ( m ) if e ! = nil { return n , e } if m ! = secondwritelen { return n , io . errshortwrite } } return n , nil } 
func ( b * fixedsizeringbuf ) readfrom ( r io . reader ) ( n int64 , err error ) { for { writecapacity : = b . n - b . readable if writecapacity <= 0 { return n , nil } writestart : = ( b . beg + b . readable ) % b . n upperlim : = intmin ( writestart + writecapacity , b . n ) m , e : = r . read ( b . a [ b . use ] [ writestart : upperlim ] ) n += int64 ( m ) b . readable += m if e == io . eof { return n , nil } if e ! = nil { return n , e } } } 
func ( b * fixedsizeringbuf ) advance ( n int ) { if n <= 0 { return } if n > b . readable { n = b . readable } b . readable - = n b . beg = ( b . beg + n ) % b . n } 
func ( f * fixedsizeringbuf ) nextpos ( from int ) int { if from >= f . n | | from < 0 { return - 2 } if f . readable == 0 { return - 1 } last : = f . last ( ) if from == last { return - 1 } a0 , a1 , b0 , b1 : = f . legalpos ( ) switch { case from >= a0 && from < a1 : return from + 1 case from == a1 : return b0 case from >= b0 && from < b1 : return from + 1 case from == b1 : return - 1 } return - 1 } 
func ( b * fixedsizeringbuf ) legalpos ( ) ( a0 , alast , b0 , blast int ) { a0 = - 1 alast = - 1 b0 = - 1 blast = - 1 if b . readable == 0 { return } a0 = b . beg last : = b . beg + b . readable - 1 if last < b . n { alast = last return } alast = b . n - 1 b0 = 0 blast = last % b . n return } 
func ( f * fixedsizeringbuf ) prevpos ( from int ) int { if from >= f . n | | from < 0 { return - 2 } if f . readable == 0 { return - 1 } if from == f . beg { return - 1 } a0 , a1 , b0 , b1 : = f . legalpos ( ) switch { case from == a0 : return - 1 case from > a0 && from <= a1 : return from - 1 case from == b0 : return a1 case from > b0 && from <= b1 : return from - 1 } return - 1 } 
func ( f * fixedsizeringbuf ) last ( ) int { if f . readable == 0 { return - 1 } last : = f . beg + f . readable - 1 if last < f . n { return last } return last % f . n } 
func ( f * fixedsizeringbuf ) kth ( k int ) int { if f . readable == 0 | | k < 0 | | k >= f . readable { return - 1 } return ( f . beg + k ) % f . n } 
func ( f * fixedsizeringbuf ) deletemostrecentbytes ( n int ) { if n <= 0 { return } if n >= f . readable { f . readable = 0 return } f . readable - = n } 
func ( b * float64ringbuf ) twocontig ( makecopy bool ) ( first [ ] float64 , second [ ] float64 ) { extent : = b . beg + b . readable if extent <= b . n { return b . a [ b . beg : ( b . beg + b . readable ) ] , second } return b . a [ b . beg : b . n ] , b . a [ 0 : ( extent % b . n ) ] } 
func ( b * float64ringbuf ) earliest ( ) ( v float64 , ok bool ) { if b . readable == 0 { return } return b . a [ b . beg ] , true } 
func ( b * float64ringbuf ) values ( ) [ ] float64 { first , second : = b . twocontig ( false ) if len ( first ) == 0 { return second } if len ( second ) == 0 { return first } out : = make ( [ ] float64 , len ( first ) + len ( second ) ) copy ( out , first ) copy ( out [ len ( first ) : ] , second ) return out } 
func ( b * float64ringbuf ) readfloat64 ( p [ ] float64 ) ( n int , err error ) { return b . readandmaybeadvance ( p , true ) } 
func ( b * float64ringbuf ) readwithoutadvance ( p [ ] float64 ) ( n int , err error ) { return b . readandmaybeadvance ( p , false ) } 
func ( b * float64ringbuf ) writeandmaybeoverwriteoldestdata ( p [ ] float64 ) ( n int , err error ) { writecapacity : = b . n - b . readable if len ( p ) > writecapacity { b . advance ( len ( p ) - writecapacity ) } startpos : = 0 if len ( p ) > b . n { startpos = len ( p ) - b . n } n , err = b . write ( p [ startpos : ] ) if err ! = nil { return n , err } return len ( p ) , nil } 
func ( b * float64ringbuf ) write ( p [ ] float64 ) ( n int , err error ) { for { if len ( p ) == 0 { return } writecapacity : = b . n - b . readable if writecapacity <= 0 { return n , io . errshortwrite } if len ( p ) > writecapacity { err = io . errshortwrite } writestart : = ( b . beg + b . readable ) % b . n upperlim : = intmin ( writestart + writecapacity , b . n ) k : = copy ( b . a [ writestart : upperlim ] , p ) n += k b . readable += k p = p [ k : ] } } 
func ( b * float64ringbuf ) advance ( n int ) { if n <= 0 { return } if n > b . readable { n = b . readable } b . readable - = n b . beg = ( b . beg + n ) % b . n } 
func ( b * float64ringbuf ) adopt ( me [ ] float64 ) { n : = len ( me ) if n > b . n { b . a = me b . n = n b . beg = 0 b . readable = n } else { copy ( b . a , me ) b . beg = 0 b . readable = n } } 
func ( b * atomicfixedsizeringbuf ) readable ( ) int { b . tex . lock ( ) defer b . tex . unlock ( ) return b . readable } 
func ( b * atomicfixedsizeringbuf ) contiglen ( ) int { b . tex . lock ( ) defer b . tex . unlock ( ) extent : = b . beg + b . readable firstcontiglen : = intmin2 ( extent , b . n ) - b . beg return firstcontiglen } 
func ( b * atomicfixedsizeringbuf ) bytes ( makecopy bool ) [ ] byte { b . tex . lock ( ) defer b . tex . unlock ( ) extent : = b . beg + b . readable if extent <= b . n { return b . a [ b . use ] [ b . beg : ( b . beg + b . readable ) ] } src : = b . use dest : = 1 - b . use n : = copy ( b . a [ dest ] , b . a [ src ] [ b . beg : ] ) n += copy ( b . a [ dest ] [ n : ] , b . a [ src ] [ 0 : ( extent % b . n ) ] ) b . use = dest b . beg = 0 if makecopy { ret : = make ( [ ] byte , n ) copy ( ret , b . a [ b . use ] [ : n ] ) return ret } return b . a [ b . use ] [ : n ] } 
func ( b * atomicfixedsizeringbuf ) bytestwo ( ) twobuffers { b . tex . lock ( ) defer b . tex . unlock ( ) return b . unatomic bytestwo ( ) } 
func ( b * atomicfixedsizeringbuf ) advancebytestwo ( tb twobuffers ) { b . tex . lock ( ) defer b . tex . unlock ( ) tblen : = len ( tb . first ) + len ( tb . second ) if tblen == 0 { return } if tblen > b . readable { panic ( fmt . sprintf ( " " , tblen , b . readable ) ) } tbnow : = b . unatomic bytestwo ( ) if len ( tb . first ) > 0 { if tb . first [ 0 ] ! = tbnow . first [ 0 ] { panic ( fmt . sprintf ( " " , string ( tb . first ) , string ( tbnow . first ) ) ) } } if len ( tb . second ) > 0 { if len ( tb . first ) > len ( tbnow . first ) { panic ( fmt . sprintf ( " " , len ( tbnow . first ) , len ( tb . first ) ) ) } if len ( tbnow . second ) == 0 { panic ( fmt . sprintf ( " " ) ) } if tb . second [ 0 ] ! = tbnow . second [ 0 ] { panic ( fmt . sprintf ( " " , string ( tb . second ) , string ( tbnow . second ) ) ) } } b . unatomic advance ( tblen ) } 
func ( b * atomicfixedsizeringbuf ) readwithoutadvance ( p [ ] byte ) ( n int , err error ) { return b . readandmaybeadvance ( p , false ) } 
func ( b * atomicfixedsizeringbuf ) write ( p [ ] byte ) ( n int , err error ) { b . tex . lock ( ) defer b . tex . unlock ( ) for { if len ( p ) == 0 { return } writecapacity : = b . n - b . readable if writecapacity <= 0 { return n , io . errshortwrite } if len ( p ) > writecapacity { err = io . errshortwrite } writestart : = ( b . beg + b . readable ) % b . n upperlim : = intmin2 ( writestart + writecapacity , b . n ) k : = copy ( b . a [ b . use ] [ writestart : upperlim ] , p ) n += k b . readable += k p = p [ k : ] } } 
func ( b * atomicfixedsizeringbuf ) writeto ( w io . writer ) ( n int64 , err error ) { b . tex . lock ( ) defer b . tex . unlock ( ) if b . readable == 0 { return 0 , io . eof } extent : = b . beg + b . readable firstwritelen : = intmin2 ( extent , b . n ) - b . beg secondwritelen : = b . readable - firstwritelen if firstwritelen > 0 { m , e : = w . write ( b . a [ b . use ] [ b . beg : ( b . beg + firstwritelen ) ] ) n += int64 ( m ) b . unatomic advance ( m ) if e ! = nil { return n , e } if m ! = firstwritelen { return n , io . errshortwrite } } if secondwritelen > 0 { m , e : = w . write ( b . a [ b . use ] [ 0 : secondwritelen ] ) n += int64 ( m ) b . unatomic advance ( m ) if e ! = nil { return n , e } if m ! = secondwritelen { return n , io . errshortwrite } } return n , nil } 
func ( b * atomicfixedsizeringbuf ) readfrom ( r io . reader ) ( n int64 , err error ) { b . tex . lock ( ) defer b . tex . unlock ( ) for { writecapacity : = b . n - b . readable if writecapacity <= 0 { return n , nil } writestart : = ( b . beg + b . readable ) % b . n upperlim : = intmin2 ( writestart + writecapacity , b . n ) m , e : = r . read ( b . a [ b . use ] [ writestart : upperlim ] ) n += int64 ( m ) b . readable += m if e == io . eof { return n , nil } if e ! = nil { return n , e } } } 
func ( b * atomicfixedsizeringbuf ) reset ( ) { b . tex . lock ( ) defer b . tex . unlock ( ) b . beg = 0 b . readable = 0 b . use = 0 } 
func ( b * atomicfixedsizeringbuf ) advance ( n int ) { b . tex . lock ( ) defer b . tex . unlock ( ) b . unatomic advance ( n ) } 
func ( b * atomicfixedsizeringbuf ) unatomic advance ( n int ) { if n <= 0 { return } if n > b . readable { n = b . readable } b . readable - = n b . beg = ( b . beg + n ) % b . n } 
func ( b * atomicfixedsizeringbuf ) adopt ( me [ ] byte ) { b . tex . lock ( ) defer b . tex . unlock ( ) n : = len ( me ) if n > b . n { b . a [ 0 ] = me b . a [ 1 ] = make ( [ ] byte , n , n ) b . n = n b . use = 0 b . beg = 0 b . readable = n } else { copy ( b . a [ 0 ] , me ) b . use = 0 b . beg = 0 b . readable = n } } 
func ( b * pointerringbuf ) twocontig ( ) ( first [ ] interface { } , second [ ] interface { } ) { extent : = b . beg + b . readable if extent <= b . n { return b . a [ b . beg : ( b . beg + b . readable ) ] , second } return b . a [ b . beg : b . n ] , b . a [ 0 : ( extent % b . n ) ] } 
func ( b * pointerringbuf ) readptrs ( p [ ] interface { } ) ( n int , err error ) { return b . readandmaybeadvance ( p , true ) } 
func ( b * pointerringbuf ) readwithoutadvance ( p [ ] interface { } ) ( n int , err error ) { return b . readandmaybeadvance ( p , false ) } 
func ( b * pointerringbuf ) advance ( n int ) { if n <= 0 { return } if n > b . readable { n = b . readable } b . readable - = n b . beg = ( b . beg + n ) % b . n } 
func ( b * pointerringbuf ) adopt ( me [ ] interface { } ) { n : = len ( me ) if n > b . n { b . a = me b . n = n b . beg = 0 b . readable = n } else { copy ( b . a , me ) b . beg = 0 b . readable = n } } 
func ( b * pointerringbuf ) push ( p [ ] interface { } ) ( n int , err error ) { for { if len ( p ) == 0 { return } writecapacity : = b . n - b . readable if writecapacity <= 0 { return n , io . errshortwrite } if len ( p ) > writecapacity { err = io . errshortwrite } writestart : = ( b . beg + b . readable ) % b . n upperlim : = intmin ( writestart + writecapacity , b . n ) k : = copy ( b . a [ writestart : upperlim ] , p ) n += k b . readable += k p = p [ k : ] } } 
func ( b * pointerringbuf ) pushandmaybeoverwriteoldestdata ( p [ ] interface { } ) ( n int , err error ) { writecapacity : = b . n - b . readable if len ( p ) > writecapacity { b . advance ( len ( p ) - writecapacity ) } startpos : = 0 if len ( p ) > b . n { startpos = len ( p ) - b . n } n , err = b . push ( p [ startpos : ] ) if err ! = nil { return n , err } return len ( p ) , nil } 
func ( r * reader ) page ( num int ) page { num -- page : = r . trailer ( ) . key ( " " ) . key ( " " ) search : for page . key ( " " ) . name ( ) == " " { count : = int ( page . key ( " " ) . int64 ( ) ) if count < num { return page { } } kids : = page . key ( " " ) for i : = 0 ; i < kids . len ( ) ; i ++ { kid : = kids . index ( i ) if kid . key ( " " ) . name ( ) == " " { c : = int ( kid . key ( " " ) . int64 ( ) ) if num < c { page = kid continue search } num - = c continue } if kid . key ( " " ) . name ( ) == " " { if num == 0 { return page { kid } } num -- } } break } return page { } } 
func ( r * reader ) numpage ( ) int { return int ( r . trailer ( ) . key ( " " ) . key ( " " ) . key ( " " ) . int64 ( ) ) } 
func ( p page ) font ( name string ) font { return font { p . resources ( ) . key ( " " ) . key ( name ) } } 
func ( f font ) widths ( ) [ ] float64 { x : = f . v . key ( " " ) var out [ ] float64 for i : = 0 ; i < x . len ( ) ; i ++ { out = append ( out , x . index ( i ) . float64 ( ) ) } return out } 
func ( f font ) width ( code int ) float64 { first : = f . firstchar ( ) last : = f . lastchar ( ) if code < first | | last < code { return 0 } return f . v . key ( " " ) . index ( code - first ) . float64 ( ) } 
func ( f font ) encoder ( ) textencoding { enc : = f . v . key ( " " ) switch enc . kind ( ) { case name : switch enc . name ( ) { case " " : return & byteencoder { & winansiencoding } case " " : return & byteencoder { & macromanencoding } case " " : return & nopencoder { } default : println ( " " , enc . name ( ) ) return & nopencoder { } } case dict : return & dictencoder { enc . key ( " " ) } case null : default : println ( " " , enc . string ( ) ) return & nopencoder { } } tounicode : = f . v . key ( " " ) if tounicode . kind ( ) == dict { m : = readcmap ( tounicode ) if m == nil { return & nopencoder { } } return m } return & byteencoder { & pdfdocencoding } } 
func open ( file string ) ( * reader , error ) { f , err : = os . open ( file ) if err ! = nil { return nil , err } fi , err : = f . stat ( ) if err ! = nil { f . close ( ) return nil , err } return newreader ( f , fi . size ( ) ) } 
func newreader ( f io . readerat , size int64 ) ( * reader , error ) { return newreaderencrypted ( f , size , nil ) } 
func ( r * reader ) trailer ( ) value { return value { r , r . trailerptr , r . trailer } } 
func ( v value ) kind ( ) valuekind { switch v . data . ( type ) { default : return null case bool : return bool case int64 : return integer case float64 : return real case string : return string case name : return name case dict : return dict case array : return array case stream : return stream } } 
func ( v value ) bool ( ) bool { x , ok : = v . data . ( bool ) if ! ok { return false } return x } 
func ( v value ) int64 ( ) int64 { x , ok : = v . data . ( int64 ) if ! ok { return 0 } return x } 
func ( v value ) float64 ( ) float64 { x , ok : = v . data . ( float64 ) if ! ok { x , ok : = v . data . ( int64 ) if ok { return float64 ( x ) } return 0 } return x } 
func ( v value ) rawstring ( ) string { x , ok : = v . data . ( string ) if ! ok { return " " } return x } 
func ( v value ) text ( ) string { x , ok : = v . data . ( string ) if ! ok { return " " } if ispdfdocencoded ( x ) { return pdfdocdecode ( x ) } if isutf16 ( x ) { return utf16decode ( x [ 2 : ] ) } return x } 
func ( v value ) textfromutf16 ( ) string { x , ok : = v . data . ( string ) if ! ok { return " " } if len ( x ) % 2 == 1 { return " " } if x == " " { return " " } return utf16decode ( x ) } 
func ( v value ) name ( ) string { x , ok : = v . data . ( name ) if ! ok { return " " } return string ( x ) } 
func ( v value ) key ( key string ) value { x , ok : = v . data . ( dict ) if ! ok { strm , ok : = v . data . ( stream ) if ! ok { return value { } } x = strm . hdr } return v . r . resolve ( v . ptr , x [ name ( key ) ] ) } 
func ( v value ) keys ( ) [ ] string { x , ok : = v . data . ( dict ) if ! ok { strm , ok : = v . data . ( stream ) if ! ok { return nil } x = strm . hdr } keys : = [ ] string { } for k : = range x { keys = append ( keys , string ( k ) ) } sort . strings ( keys ) return keys } 
func ( v value ) index ( i int ) value { x , ok : = v . data . ( array ) if ! ok | | i < 0 | | i >= len ( x ) { return value { } } return v . r . resolve ( v . ptr , x [ i ] ) } 
func ( v value ) len ( ) int { x , ok : = v . data . ( array ) if ! ok { return 0 } return len ( x ) } 
func ( v value ) reader ( ) io . readcloser { x , ok : = v . data . ( stream ) if ! ok { return & errorreadcloser { fmt . errorf ( " " ) } } var rd io . reader rd = io . newsectionreader ( v . r . f , x . offset , v . key ( " " ) . int64 ( ) ) if v . r . key ! = nil { rd = decryptstream ( v . r . key , v . r . useaes , x . ptr , rd ) } filter : = v . key ( " " ) param : = v . key ( " " ) switch filter . kind ( ) { default : panic ( fmt . errorf ( " " , filter ) ) case null : case name : rd = applyfilter ( rd , filter . name ( ) , param ) case array : for i : = 0 ; i < filter . len ( ) ; i ++ { rd = applyfilter ( rd , filter . index ( i ) . name ( ) , param . index ( i ) ) } } return ioutil . nopcloser ( rd ) } 
func newbuffer ( r io . reader , offset int64 ) * buffer { return & buffer { r : r , offset : offset , buf : make ( [ ] byte , 0 , 4096 ) , allowobjptr : true , allowstream : true , } } 
func ( r * resultset ) paginate ( perpage , page int ) ( * paginationinfo , error ) { info : = new ( paginationinfo ) sess : = r . collection . connection . session . copy ( ) count , err : = sess . db ( r . collection . database ) . c ( r . collection . name ) . find ( r . params ) . count ( ) sess . close ( ) if err ! = nil { return info , err } totalpages : = int ( math . ceil ( float64 ( count ) / float64 ( perpage ) ) ) if page < 1 { page = 1 } else if page > totalpages { page = totalpages } skip : = ( page - 1 ) * perpage r . query . skip ( skip ) . limit ( perpage ) info . totalpages = totalpages info . perpage = perpage info . current = page info . totalrecords = count if info . current < info . totalpages { info . recordsonpage = info . perpage } else { info . recordsonpage = int ( math . mod ( float64 ( count ) , float64 ( perpage ) ) ) if info . recordsonpage == 0 && count > 0 { info . recordsonpage = perpage } } return info , nil } 
func cascadesave ( collection * collection , doc document ) error { if conv , ok : = doc . ( cascadingdocument ) ; ok { tocascade : = conv . getcascade ( collection ) for , conf : = range tocascade { if len ( conf . referencequery ) == 0 { conf . referencequery = [ ] * referencefield { & referencefield { " " , doc . getid ( ) } } } , err : = cascadesavewithconfig ( conf , doc ) if err ! = nil { return err } if conf . nest { results : = conf . collection . find ( conf . query ) for results . next ( conf . instance ) { err = cascadesave ( conf . collection , conf . instance ) if err ! = nil { return err } } } } } return nil } 
func cascadedelete ( collection * collection , doc interface { } ) { if conv , ok : = doc . ( interface { getcascade ( * collection ) [ ] * cascadeconfig } ) ; ok { tocascade : = conv . getcascade ( collection ) for , conf : = range tocascade { if len ( conf . referencequery ) == 0 { id , err : = reflections . getfield ( doc , " " ) if err ! = nil { panic ( err ) } conf . referencequery = [ ] * referencefield { & referencefield { " " , id } } } cascadedeletewithconfig ( conf ) } } } 
func cascadedeletewithconfig ( conf * cascadeconfig ) ( * mgo . changeinfo , error ) { switch conf . reltype { case rel one : update : = map [ string ] map [ string ] interface { } { " " : map [ string ] interface { } { } , } if len ( conf . throughprop ) > 0 { update [ " " ] [ conf . throughprop ] = nil } else { for , p : = range conf . properties { update [ " " ] [ p ] = nil } } return conf . collection . collection ( ) . updateall ( conf . query , update ) case rel many : update : = map [ string ] map [ string ] interface { } { " " : map [ string ] interface { } { } , } q : = bson . m { } for , f : = range conf . referencequery { q [ f . bsonname ] = f . value } update [ " " ] [ conf . throughprop ] = q return conf . collection . collection ( ) . updateall ( conf . query , update ) } return & mgo . changeinfo { } , errors . new ( " " ) } 
func mapfromcascadeproperties ( properties [ ] string , doc document ) map [ string ] interface { } { data : = make ( map [ string ] interface { } ) for , prop : = range properties { split : = strings . split ( prop , " " ) if len ( split ) == 1 { data [ prop ] , = dotaccess . get ( doc , prop ) } else { actualprop : = split [ len ( split ) - 1 ] split : = append ( [ ] string { } , split [ : len ( split ) - 1 ] ... ) curdata : = data for , s : = range split { if , ok : = curdata [ s ] ; ok { if mapped , ok : = curdata [ s ] . ( map [ string ] interface { } ) ; ok { curdata = mapped } else { panic ( " " ) } } else { curdata [ s ] = make ( map [ string ] interface { } ) if mapped , ok : = curdata [ s ] . ( map [ string ] interface { } ) ; ok { curdata = mapped } else { panic ( " " ) } } } val , : = dotaccess . get ( doc , prop ) curdata [ actualprop ] = val } } return data } 
func connect ( config * config ) ( * connection , error ) { conn : = & connection { config : config , context : & context { } , } err : = conn . connect ( ) return conn , err } 
func ( m * connection ) connect ( ) ( err error ) { defer func ( ) { if r : = recover ( ) ; r ! = nil { if e , ok : = r . ( error ) ; ok { err = e } else if e , ok : = r . ( string ) ; ok { err = errors . new ( e ) } else { err = errors . new ( fmt . sprint ( r ) ) } } } ( ) if m . config . dialinfo == nil { if m . config . dialinfo , err = mgo . parseurl ( m . config . connectionstring ) ; err ! = nil { panic ( fmt . sprintf ( " " , m . config . connectionstring , err . error ( ) ) ) } } session , err : = mgo . dialwithinfo ( m . config . dialinfo ) if err ! = nil { return err } m . session = session m . session . setmode ( mgo . monotonic , true ) return nil } 
func ( m * connection ) collectionfromdatabase ( name string , database string ) * collection { return & collection { connection : m , context : m . context , database : database , name : name , } } 
func lowerinitial ( str string ) string { for i , v : = range str { return string ( unicode . tolower ( v ) ) + str [ i + 1 : ] } return " " } 
func ( c * collection ) collectiononsession ( sess * mgo . session ) * mgo . collection { return sess . db ( c . database ) . c ( c . name ) } 
func ( c * collection ) find ( query interface { } ) * resultset { col : = c . collection ( ) q : = col . find ( query ) resultset : = new ( resultset ) resultset . query = q resultset . params = query resultset . collection = c return resultset } 
func ( c * collection ) delete ( query bson . m ) ( * mgo . changeinfo , error ) { sess : = c . connection . session . clone ( ) defer sess . close ( ) col : = c . collectiononsession ( sess ) return col . removeall ( query ) } 
func ( c * collection ) deleteone ( query bson . m ) error { sess : = c . connection . session . clone ( ) defer sess . close ( ) col : = c . collectiononsession ( sess ) return col . remove ( query ) } 
func ( c * client ) rawinformationquery ( from , to , id , iqtype , requestnamespace , body string ) ( string , error ) { const xmliq = " " , err : = fmt . fprintf ( c . conn , xmliq , xmlescape ( from ) , xmlescape ( to ) , id , iqtype , requestnamespace , body ) return id , err } 
func ( o options ) newclient ( ) ( * client , error ) { host : = o . host c , err : = connect ( host , o . user , o . password ) if err ! = nil { return nil , err } if strings . lastindex ( o . host , " " ) > 0 { host = host [ : strings . lastindex ( o . host , " " ) ] } client : = new ( client ) if o . notls { client . conn = c } else { var tlsconn * tls . conn if o . tlsconfig ! = nil { tlsconn = tls . client ( c , o . tlsconfig ) } else { defaultconfig . servername = host newconfig : = defaultconfig newconfig . servername = host tlsconn = tls . client ( c , & newconfig ) } if err = tlsconn . handshake ( ) ; err ! = nil { return nil , err } insecureskipverify : = defaultconfig . insecureskipverify if o . tlsconfig ! = nil { insecureskipverify = o . tlsconfig . insecureskipverify } if ! insecureskipverify { if err = tlsconn . verifyhostname ( host ) ; err ! = nil { return nil , err } } client . conn = tlsconn } if err : = client . init ( & o ) ; err ! = nil { client . close ( ) return nil , err } return client , nil } 
func newclient ( host , user , passwd string , debug bool ) ( * client , error ) { opts : = options { host : host , user : user , password : passwd , debug : debug , session : false , } return opts . newclient ( ) } 
func ( c * client ) close ( ) error { if c . conn ! = ( * tls . conn ) ( nil ) { return c . conn . close ( ) } return nil } 
func ( c * client ) starttlsifrequired ( f * streamfeatures , o * options , domain string ) ( * streamfeatures , error ) { switch { case f . starttls == nil : return f , nil case ! o . starttls && f . starttls . required == nil : return f , nil case f . starttls . required ! = nil : case ! o . starttls : } var err error fmt . fprintf ( c . conn , " \n " ) var k tlsproceed if err = c . p . decodeelement ( & k , nil ) ; err ! = nil { return f , errors . new ( " " + err . error ( ) ) } tc : = o . tlsconfig if tc == nil { tc = new ( tls . config ) * tc = defaultconfig tc . servername = domain } t : = tls . client ( c . conn , tc ) if err = t . handshake ( ) ; err ! = nil { return f , errors . new ( " " + err . error ( ) ) } c . conn = t tf , err : = c . startstream ( o , domain ) if err ! = nil { return f , err } return tf , nil } 
func ( c * client ) startstream ( o * options , domain string ) ( * streamfeatures , error ) { if o . debug { c . p = xml . newdecoder ( tee { c . conn , debugwriter } ) } else { c . p = xml . newdecoder ( c . conn ) } , err : = fmt . fprintf ( c . conn , " \n " + " \n " + " \n " , xmlescape ( domain ) , nsclient , nsstream ) if err ! = nil { return nil , err } se , err : = nextstart ( c . p ) if err ! = nil { return nil , err } if se . name . space ! = nsstream | | se . name . local ! = " " { return nil , fmt . errorf ( " " , se . name . local , se . name . space ) } f : = new ( streamfeatures ) if err = c . p . decodeelement ( f , nil ) ; err ! = nil { return f , errors . new ( " " + err . error ( ) ) } return f , nil } 
func ( c * client ) isencrypted ( ) bool { , ok : = c . conn . ( * tls . conn ) return ok } 
func ( c * client ) send ( chat chat ) ( n int , err error ) { var subtext = " var thdtext = " if chat . subject ! = " { subtext = ' < subject > ' + xmlescape ( chat . subject ) + ' < / subject > ' } if chat . thread ! = " { thdtext = ' < thread > ' + xmlescape ( chat . thread ) + ' < / thread > ' } stanza : = " " + subtext + " " + thdtext + " " return fmt . fprintf ( c . conn , stanza , xmlescape ( chat . remote ) , xmlescape ( chat . type ) , cnonce ( ) , xmlescape ( chat . text ) ) } 
func ( c * client ) sendorg ( org string ) ( n int , err error ) { return fmt . fprint ( c . conn , org ) } 
func ( c * client ) sendkeepalive ( ) ( n int , err error ) { return fmt . fprintf ( c . conn , " " ) } 
func ( c * client ) sendhtml ( chat chat ) ( n int , err error ) { return fmt . fprintf ( c . conn , " " + " " + " " , xmlescape ( chat . remote ) , xmlescape ( chat . type ) , xmlescape ( chat . text ) , chat . text ) } 
func nextstart ( p * xml . decoder ) ( xml . startelement , error ) { for { t , err : = p . token ( ) if err ! = nil | | t == nil { return xml . startelement { } , err } switch t : = t . ( type ) { case xml . startelement : return t , nil } } } 
func ( m * message ) attachbuffer ( filename string , buf [ ] byte , inline bool ) error { m . attachments [ filename ] = & attachment { filename : filename , data : buf , inline : inline , } return nil } 
func ( m * message ) attach ( file string ) error { return m . attach ( file , false ) } 
func ( m * message ) inline ( file string ) error { return m . attach ( file , true ) } 
func ( m * message ) addheader ( key string , value string ) header { newheader : = header { key : key , value : value } m . headers = append ( m . headers , newheader ) return newheader } 
func ( m * message ) tolist ( ) [ ] string { tolist : = m . to for , cc : = range m . cc { tolist = append ( tolist , cc ) } for , bcc : = range m . bcc { tolist = append ( tolist , bcc ) } return tolist } 
func send ( addr string , auth smtp . auth , m * message ) error { return smtp . sendmail ( addr , auth , m . from . address , m . tolist ( ) , m . bytes ( ) ) } 
func fromidheader ( v string ) string { if v == " " { return v } v = strings . trimleft ( v , " " ) v = strings . trimright ( v , " " ) r , err : = url . queryunescape ( v ) if err ! = nil { return v } return r } 
func toidheader ( v string ) string { v = url . queryescape ( v ) return " " + strings . replace ( v , " " , " " , - 1 ) + " " } 
func ( e * envelope ) getheaderkeys ( ) ( headers [ ] string ) { if e . header == nil { return } for key : = range * e . header { headers = append ( headers , key ) } return headers } 
func ( e * envelope ) getheader ( name string ) string { if e . header == nil { return " " } return decodeheader ( e . header . get ( name ) ) } 
func ( e * envelope ) getheadervalues ( name string ) [ ] string { if e . header == nil { return [ ] string { } } rawvalues : = ( * e . header ) [ textproto . canonicalmimeheaderkey ( name ) ] var values [ ] string for , v : = range rawvalues { values = append ( values , decodeheader ( v ) ) } return values } 
func ( e * envelope ) setheader ( name string , value [ ] string ) error { if name == " " { return fmt . errorf ( " " ) } for i , v : = range value { if i == 0 { e . header . set ( name , mime . bencoding . encode ( " " , v ) ) continue } e . header . add ( name , mime . bencoding . encode ( " " , v ) ) } return nil } 
func ( e * envelope ) addheader ( name string , value string ) error { if name == " " { return fmt . errorf ( " " ) } e . header . add ( name , mime . bencoding . encode ( " " , value ) ) return nil } 
func ( e * envelope ) deleteheader ( name string ) error { if name == " " { return fmt . errorf ( " " ) } e . header . del ( name ) return nil } 
func ( e * envelope ) addresslist ( key string ) ( [ ] * mail . address , error ) { if e . header == nil { return nil , fmt . errorf ( " " ) } if ! addressheaders [ strings . tolower ( key ) ] { return nil , fmt . errorf ( " " , key ) } str : = decodetoutf8base64header ( e . header . get ( key ) ) if str == " " { return nil , mail . errheadernotpresent } ret , err : = mail . parseaddresslist ( str ) switch { case err == nil : case err . error ( ) == " " : ret , err = mail . parseaddresslist ( ensurecommadelimitedaddresses ( str ) ) if err ! = nil { return nil , err } default : return nil , err } return ret , nil } 
func ( e * envelope ) clone ( ) * envelope { if e == nil { return nil } newenvelope : = & envelope { e . text , e . html , e . root . clone ( nil ) , e . attachments , e . inlines , e . otherparts , e . errors , e . header , } return newenvelope } 
func readenvelope ( r io . reader ) ( * envelope , error ) { root , err : = readparts ( r ) if err ! = nil { return nil , errors . withmessage ( err , " " ) } return envelopefrompart ( root ) } 
func envelopefrompart ( root * part ) ( * envelope , error ) { e : = & envelope { root : root , header : & root . header , } if detectmultipartmessage ( root ) { if err : = parsemultipartbody ( root , e ) ; err ! = nil { return nil , err } } else { if detectbinarybody ( root ) { if root . disposition == cdinline { e . inlines = append ( e . inlines , root ) } else { e . attachments = append ( e . attachments , root ) } } else { if err : = parsetextonlybody ( root , e ) ; err ! = nil { return nil , err } } } if e . text == " " && e . html ! = " " { e . root . addwarning ( errorplaintextfromhtml , " " ) var err error if e . text , err = html2text . fromstring ( e . html ) ; err ! = nil { e . text = " " p : = e . root . breadthmatchfirst ( matchhtmlbodypart ) p . adderror ( errorplaintextfromhtml , " " , err ) } } if e . root ! = nil { = e . root . depthmatchall ( func ( part * part ) bool { for i : = range part . errors { e . errors = append ( e . errors , part . errors [ i ] ) } return false } ) } return e , nil } 
func parsetextonlybody ( root * part , e * envelope ) error { var charset string var ishtml bool if ctype : = root . header . get ( hncontenttype ) ; ctype ! = " " { if mediatype , mparams , , err : = parsemediatype ( ctype ) ; err == nil { ishtml = ( mediatype == cttexthtml ) if mparams [ hpcharset ] ! = " " { charset = mparams [ hpcharset ] } } } if ishtml { rawhtml : = string ( root . content ) e . html = rawhtml if charset == " " { if charset = coding . findcharsetinhtml ( rawhtml ) ; charset ! = " " { if convhtml , err : = coding . converttoutf8string ( charset , root . content ) ; err == nil { e . html = convhtml } else { root . addwarning ( errorcharsetconversion , err . error ( ) ) } } return nil } } else { e . text = string ( root . content ) } return nil } 
func matchhtmlbodypart ( p * part ) bool { return p . contenttype == cttexthtml && p . disposition ! = cdattachment } 
func ensurecommadelimitedaddresses ( s string ) string { s = strings . join ( strings . fields ( s ) , " " ) inquotes : = false indomain : = false escapesequence : = false sb : = strings . builder { } for , r : = range s { if escapesequence { escapesequence = false sb . writerune ( r ) continue } if r == ' " ' { inquotes = ! inquotes sb . writerune ( r ) continue } if inquotes { if r == ' \ \ ' { escapesequence = true sb . writerune ( r ) continue } } else { if r == ' @ ' { indomain = true sb . writerune ( r ) continue } if indomain { if r == ' ; ' { sb . writerune ( r ) break } if r == ' , ' { indomain = false sb . writerune ( r ) continue } if r == ' ' { indomain = false sb . writerune ( ' , ' ) sb . writerune ( r ) continue } } } sb . writerune ( r ) } return sb . string ( ) } 
func ( p mailbuilder ) date ( date time . time ) mailbuilder { p . date = date return p } 
func ( p mailbuilder ) from ( name , addr string ) mailbuilder { p . from = mail . address { name : name , address : addr } return p } 
func ( p mailbuilder ) subject ( subject string ) mailbuilder { p . subject = subject return p } 
func ( p mailbuilder ) to ( name , addr string ) mailbuilder { p . to = append ( p . to , mail . address { name : name , address : addr } ) return p } 
func ( p mailbuilder ) toaddrs ( to [ ] mail . address ) mailbuilder { p . to = to return p } 
func ( p mailbuilder ) cc ( name , addr string ) mailbuilder { p . cc = append ( p . cc , mail . address { name : name , address : addr } ) return p } 
func ( p mailbuilder ) ccaddrs ( cc [ ] mail . address ) mailbuilder { p . cc = cc return p } 
func ( p mailbuilder ) bcc ( name , addr string ) mailbuilder { p . bcc = append ( p . bcc , mail . address { name : name , address : addr } ) return p } 
func ( p mailbuilder ) bccaddrs ( bcc [ ] mail . address ) mailbuilder { p . bcc = bcc return p } 
func ( p mailbuilder ) replyto ( name , addr string ) mailbuilder { p . replyto = mail . address { name : name , address : addr } return p } 
func ( p mailbuilder ) header ( name , value string ) mailbuilder { h : = textproto . mimeheader { } for k , v : = range p . header { h [ k ] = v } h . add ( name , value ) p . header = h return p } 
func ( p mailbuilder ) text ( body [ ] byte ) mailbuilder { p . text = body return p } 
func ( p mailbuilder ) html ( body [ ] byte ) mailbuilder { p . html = body return p } 
func ( p mailbuilder ) addattachment ( b [ ] byte , contenttype string , filename string ) mailbuilder { part : = newpart ( contenttype ) part . content = b part . filename = filename part . disposition = cdattachment p . attachments = append ( p . attachments , part ) return p } 
func ( p mailbuilder ) addfileattachment ( path string ) mailbuilder { if p . err ! = nil { return p } f , err : = os . open ( path ) if err ! = nil { p . err = err return p } b , err : = ioutil . readall ( f ) if err ! = nil { p . err = err return p } name : = filepath . base ( path ) ctype : = mime . typebyextension ( filepath . ext ( name ) ) return p . addattachment ( b , ctype , name ) } 
func ( p mailbuilder ) addinline ( b [ ] byte , contenttype string , filename string , contentid string , ) mailbuilder { part : = newpart ( contenttype ) part . content = b part . filename = filename part . disposition = cdinline part . contentid = contentid p . inlines = append ( p . inlines , part ) return p } 
func ( p mailbuilder ) send ( addr string , a smtp . auth ) error { buf : = & bytes . buffer { } root , err : = p . build ( ) if err ! = nil { return err } err = root . encode ( buf ) if err ! = nil { return err } recips : = make ( [ ] string , 0 , len ( p . to ) + len ( p . cc ) + len ( p . bcc ) ) for , a : = range p . to { recips = append ( recips , a . address ) } for , a : = range p . cc { recips = append ( recips , a . address ) } for , a : = range p . bcc { recips = append ( recips , a . address ) } return smtp . sendmail ( addr , a , p . from . address , recips , buf . bytes ( ) ) } 
func ( p mailbuilder ) equals ( o mailbuilder ) bool { return reflect . deepequal ( p , o ) } 
func ( p * part ) encode ( writer io . writer ) error { if p . header == nil { p . header = make ( textproto . mimeheader ) } cte : = p . setupmimeheaders ( ) b : = bufio . newwriter ( writer ) p . encodeheader ( b ) if len ( p . content ) > 0 { b . write ( crnl ) if err : = p . encodecontent ( b , cte ) ; err ! = nil { return err } } if p . firstchild == nil { return b . flush ( ) } endmarker : = [ ] byte ( " \n " + p . boundary + " " ) marker : = endmarker [ : len ( endmarker ) - 2 ] c : = p . firstchild for c ! = nil { b . write ( marker ) b . write ( crnl ) if err : = c . encode ( b ) ; err ! = nil { return err } c = c . nextsibling } b . write ( endmarker ) b . write ( crnl ) return b . flush ( ) } 
func ( p * part ) encodeheader ( b * bufio . writer ) { keys : = make ( [ ] string , 0 , len ( p . header ) ) for k : = range p . header { keys = append ( keys , k ) } sort . strings ( keys ) for , k : = range keys { for , v : = range p . header [ k ] { encv : = v switch selecttransferencoding ( [ ] byte ( v ) , true ) { case tebase64 : encv = mime . bencoding . encode ( utf8 , v ) case tequoted : encv = mime . qencoding . encode ( utf8 , v ) } wb : = stringutil . wrap ( 76 , k , " " , encv , " \n " ) wb [ len ( k ) + 1 ] = ' ' b . write ( wb ) } } } 
func ( p * part ) encodecontent ( b * bufio . writer , cte transferencoding ) ( err error ) { switch cte { case tebase64 : enc : = base64 . stdencoding text : = make ( [ ] byte , enc . encodedlen ( len ( p . content ) ) ) base64 . stdencoding . encode ( text , p . content ) linelen : = 76 for len ( text ) > 0 { if linelen > len ( text ) { linelen = len ( text ) } if , err = b . write ( text [ : linelen ] ) ; err ! = nil { return err } b . write ( crnl ) text = text [ linelen : ] } case tequoted : qp : = quotedprintable . newwriter ( b ) if , err = qp . write ( p . content ) ; err ! = nil { return err } err = qp . close ( ) default : , err = b . write ( p . content ) } return err } 
func selecttransferencoding ( content [ ] byte , quotelinebreaks bool ) transferencoding { if len ( content ) == 0 { return te7bit } threshold : = b64percent * len ( content ) / 100 bincount : = 0 for , b : = range content { if ( b < ' ' | | ' ~ ' < b ) && b ! = ' \ t ' { if ! quotelinebreaks && ( b == ' ' | | b == ' \n ' ) { continue } bincount ++ if bincount >= threshold { return tebase64 } } } if bincount == 0 { return te7bit } return tequoted } 
func setparamvalue ( p map [ string ] string , k , v string ) { if v ! = " " { p [ k ] = v } } 
func newbase64cleaner ( r io . reader ) * base64cleaner { return & base64cleaner { errors : make ( [ ] error , 0 ) , r : r , } } 
func ( bc * base64cleaner ) read ( p [ ] byte ) ( n int , err error ) { size : = len ( bc . buffer ) if size > len ( p ) { size = len ( p ) } buf : = bc . buffer [ : size ] bn , err : = bc . r . read ( buf ) for i : = 0 ; i < bn ; i ++ { switch base64cleanertable [ buf [ i ] & 0x7f ] { case - 2 : case - 1 : bc . errors = append ( bc . errors , fmt . errorf ( " " , buf [ i ] ) ) default : p [ n ] = buf [ i ] n ++ } } return } 
func decodetoutf8base64header ( input string ) string { if ! strings . contains ( input , " " ) { return input } tokens : = strings . fieldsfunc ( input , whitespacerune ) output : = make ( [ ] string , len ( tokens ) ) for i , token : = range tokens { if len ( token ) > 4 && strings . contains ( token , " " ) { prefix : = " " suffix : = " " if token [ 0 ] == ' ( ' { prefix = " " token = token [ 1 : ] } if token [ len ( token ) - 1 ] == ' ) ' { suffix = " " token = token [ : len ( token ) - 1 ] } output [ i ] = prefix + mime . bencoding . encode ( " " , decodeheader ( token ) ) + suffix } else { output [ i ] = token } } return strings . join ( output , " " ) } 
func parsemediatype ( ctype string ) ( mtype string , params map [ string ] string , invalidparams [ ] string , err error ) { mtype , params , err = mime . parsemediatype ( ctype ) if err ! = nil { mctype : = fixmangledmediatype ( ctype , " " ) mtype , params , err = mime . parsemediatype ( mctype ) if err ! = nil { mctype : = fixmangledmediatype ( ctype , " " ) if strings . contains ( mctype , ' name= " " ' ) { mctype = strings . replace ( mctype , ' name= " " ' , ' name= " " ' , - 1 ) } mtype , params , err = mime . parsemediatype ( mctype ) if err ! = nil { mtype , params , err = mime . parsemediatype ( fixunquotedspecials ( mctype ) ) if err ! = nil { return " " , nil , nil , errors . withstack ( err ) } } } } if mtype == ctplaceholder { mtype = " " } for name , value : = range params { if value ! = pvplaceholder { continue } invalidparams = append ( invalidparams , name ) delete ( params , name ) } return mtype , params , invalidparams , err } 
func fixmangledmediatype ( mtype , sep string ) string { if mtype == " " { return " " } parts : = strings . split ( mtype , sep ) mtype = " " for i , p : = range parts { switch i { case 0 : if p == " " { p = ctplaceholder } default : if ! strings . contains ( p , " " ) { p = p + " " + pvplaceholder } p = rfc2047attributename ( p ) pair : = strings . split ( p , " " ) if strings . contains ( mtype , pair [ 0 ] + " " ) { continue } if strings . containsany ( pair [ 0 ] , " " \ \ " ) { continue } } mtype += p if i ! = len ( parts ) - 1 && ! strings . hassuffix ( mtype , " " ) { mtype += " " } } if strings . hassuffix ( mtype , " " ) { mtype = mtype [ : len ( mtype ) - 1 ] } return mtype } 
func rfc2047attributename ( s string ) string { if ! strings . contains ( s , " " ) { return s } pair : = strings . splitafter ( s , " " ) pair [ 0 ] = decodeheader ( pair [ 0 ] ) return strings . join ( pair , " " ) } 
func detectmultipartmessage ( root * part ) bool { ctype : = root . header . get ( hncontenttype ) mediatype , , , err : = parsemediatype ( ctype ) if err ! = nil { return false } return strings . hasprefix ( mediatype , ctmultipartprefix ) } 
func detectattachmentheader ( header textproto . mimeheader ) bool { mediatype , params , , : = parsemediatype ( header . get ( hncontentdisposition ) ) if strings . tolower ( mediatype ) == cdattachment | | ( strings . tolower ( mediatype ) == cdinline && len ( params ) > 0 ) { return true } mediatype , , , = parsemediatype ( header . get ( hncontenttype ) ) return strings . tolower ( mediatype ) == cdattachment } 
func detecttextheader ( header textproto . mimeheader , emptycontenttypeistext bool ) bool { ctype : = header . get ( hncontenttype ) if ctype == " " && emptycontenttypeistext { return true } mediatype , , , err : = parsemediatype ( ctype ) if err ! = nil { return false } switch mediatype { case cttextplain , cttexthtml : return true } return false } 
func detectbinarybody ( root * part ) bool { if detecttextheader ( root . header , true ) { return false } isbin : = detectattachmentheader ( root . header ) if ! isbin { mediatype , , , : = parsemediatype ( root . header . get ( hncontenttype ) ) mediatype = strings . tolower ( mediatype ) if mediatype ! = cttextplain && mediatype ! = cttexthtml { return true } } return isbin } 
func ( p * part ) breadthmatchfirst ( matcher partmatcher ) * part { q : = list . new ( ) q . pushback ( p ) for q . len ( ) > 0 { e : = q . front ( ) p : = e . value . ( * part ) if matcher ( p ) { return p } q . remove ( e ) c : = p . firstchild for c ! = nil { q . pushback ( c ) c = c . nextsibling } } return nil } 
func ( p * part ) breadthmatchall ( matcher partmatcher ) [ ] * part { q : = list . new ( ) q . pushback ( p ) matches : = make ( [ ] * part , 0 , 10 ) for q . len ( ) > 0 { e : = q . front ( ) p : = e . value . ( * part ) if matcher ( p ) { matches = append ( matches , p ) } q . remove ( e ) c : = p . firstchild for c ! = nil { q . pushback ( c ) c = c . nextsibling } } return matches } 
func ( p * part ) depthmatchfirst ( matcher partmatcher ) * part { root : = p for { if matcher ( p ) { return p } c : = p . firstchild if c ! = nil { p = c } else { for p . nextsibling == nil { if p == root { return nil } p = p . parent } p = p . nextsibling } } } 
func ( p * part ) depthmatchall ( matcher partmatcher ) [ ] * part { root : = p matches : = make ( [ ] * part , 0 , 10 ) for { if matcher ( p ) { matches = append ( matches , p ) } c : = p . firstchild if c ! = nil { p = c } else { for p . nextsibling == nil { if p == root { return matches } p = p . parent } p = p . nextsibling } } } 
func toascii ( s string ) string { tr : = transform . chain ( norm . nfd , runes . remove ( runes . in ( unicode . mn ) ) , runes . map ( maplatinspecial ) , norm . nfc ) r , , : = transform . string ( tr , s ) return r } 
func newpart ( contenttype string ) * part { return & part { header : make ( textproto . mimeheader ) , contenttype : contenttype , } } 
func ( p * part ) addchild ( child * part ) { if p == child { return } if p ! = nil { if p . firstchild == nil { p . firstchild = child } else { current : = p . firstchild for current . nextsibling ! = nil { current = current . nextsibling } if current == child { return } current . nextsibling = child } } for c : = child ; c ! = nil ; c = c . nextsibling { if c == c . nextsibling { return } c . parent = p } } 
func ( p * part ) textcontent ( ) bool { if p . contenttype == " " { return true } return strings . hasprefix ( p . contenttype , " " ) | | strings . hasprefix ( p . contenttype , ctmultipartprefix ) } 
func ( p * part ) setupheaders ( r * bufio . reader , defaultcontenttype string ) error { header , err : = readheader ( r , p ) if err ! = nil { return err } p . header = header ctype : = header . get ( hncontenttype ) if ctype == " " { if defaultcontenttype == " " { p . addwarning ( errormissingcontenttype , " " ) return nil } ctype = defaultcontenttype } mtype , mparams , minvalidparams , err : = parsemediatype ( ctype ) if err ! = nil { return err } if mtype == " " && len ( mparams ) > 0 { p . addwarning ( errormissingcontenttype , " " ) } for i : = range minvalidparams { p . addwarning ( errormalformedheader , " " , minvalidparams [ i ] ) } p . contenttype = mtype p . setupcontentheaders ( mparams ) p . boundary = mparams [ hpboundary ] p . contentid = coding . fromidheader ( header . get ( hncontentid ) ) return nil } 
func ( p * part ) setupcontentheaders ( mediaparams map [ string ] string ) { disposition , dparams , , err : = parsemediatype ( p . header . get ( hncontentdisposition ) ) if err == nil { p . disposition = disposition p . filename = decodeheader ( dparams [ hpfilename ] ) } if p . filename == " " && mediaparams [ hpname ] ! = " " { p . filename = decodeheader ( mediaparams [ hpname ] ) } if p . filename == " " && mediaparams [ hpfile ] ! = " " { p . filename = decodeheader ( mediaparams [ hpfile ] ) } if p . charset == " " { p . charset = mediaparams [ hpcharset ] } if p . filemoddate . iszero ( ) { p . filemoddate , = time . parse ( time . rfc822 , mediaparams [ hpmoddate ] ) } } 
func ( p * part ) convertfromdetectedcharset ( r io . reader ) ( io . reader , error ) { var cd * chardet . detector switch p . contenttype { case " " : cd = chardet . newhtmldetector ( ) default : cd = chardet . newtextdetector ( ) } buf , err : = ioutil . readall ( r ) if err ! = nil { return nil , errors . withstack ( err ) } cs , err : = cd . detectbest ( buf ) switch err { case nil : case chardet . notdetectederror : p . addwarning ( errorcharsetdeclaration , " " , err ) default : return nil , errors . withstack ( err ) } r = bytes . newreader ( buf ) if cs == nil | | cs . confidence < mincharsetconfidence { return p . convertfromstatedcharset ( r ) , nil } if p . charset ! = " " && ! strings . equalfold ( cs . charset , p . charset ) { p . addwarning ( errorcharsetdeclaration , " " , p . charset , cs . charset , cs . confidence ) } reader , err : = coding . newcharsetreader ( cs . charset , r ) if err ! = nil { p . addwarning ( errorcharsetconversion , err . error ( ) ) } else { r = reader p . origcharset = p . charset p . charset = cs . charset } return r , nil } 
func ( p * part ) convertfromstatedcharset ( r io . reader ) io . reader { if p . charset == " " { return r } reader , err : = coding . newcharsetreader ( p . charset , r ) if err ! = nil { p . addwarning ( errorcharsetconversion , " " , p . charset , err ) } else { return reader } charsetp : = strings . split ( p . charset , " " ) if strings . tolower ( charsetp [ 0 ] ) == " " && len ( charsetp ) > 1 { p . charset = charsetp [ 1 ] reader , err = coding . newcharsetreader ( p . charset , r ) if err ! = nil { p . addwarning ( errorcharsetconversion , " " , p . charset , err ) } else { return reader } } return r } 
func ( p * part ) decodecontent ( r io . reader ) error { contentreader : = r var b64cleaner * coding . base64cleaner encoding : = p . header . get ( hncontentencoding ) validencoding : = true switch strings . tolower ( encoding ) { case ctequotedprintable : contentreader = coding . newqpcleaner ( contentreader ) contentreader = quotedprintable . newreader ( contentreader ) case ctebase64 : b64cleaner = coding . newbase64cleaner ( contentreader ) contentreader = base64 . newdecoder ( base64 . rawstdencoding , b64cleaner ) case cte8bit , cte7bit , ctebinary , " " : default : validencoding = false p . addwarning ( errorcontentencoding , " " , encoding ) } if validencoding && strings . hasprefix ( p . contenttype , " " ) { var err error contentreader , err = p . convertfromdetectedcharset ( contentreader ) if err ! = nil { return err } } content , err : = ioutil . readall ( contentreader ) if err ! = nil { return errors . withstack ( err ) } p . content = content if b64cleaner ! = nil { for , err : = range b64cleaner . errors { p . errors = append ( p . errors , & error { name : errormalformedbase64 , detail : err . error ( ) , severe : false , } ) } } return nil } 
func ( p * part ) clone ( parent * part ) * part { if p == nil { return nil } newpart : = & part { partid : p . partid , header : p . header , parent : parent , boundary : p . boundary , contentid : p . contentid , contenttype : p . contenttype , disposition : p . disposition , filename : p . filename , charset : p . charset , errors : p . errors , content : p . content , epilogue : p . epilogue , } newpart . firstchild = p . firstchild . clone ( newpart ) newpart . nextsibling = p . nextsibling . clone ( parent ) return newpart } 
func readparts ( r io . reader ) ( * part , error ) { br : = bufio . newreader ( r ) root : = & part { partid : " " } err : = root . setupheaders ( br , ' text / plain ; charset= " us - ascii " ' ) if err ! = nil { return nil , err } if strings . hasprefix ( root . contenttype , ctmultipartprefix ) { err = parseparts ( root , br ) if err ! = nil { return nil , err } } else { if err : = root . decodecontent ( br ) ; err ! = nil { return nil , err } } return root , nil } 
func uuid ( ) string { uuid : = make ( [ ] byte , 16 ) uuidmutex . lock ( ) , = uuidrand . read ( uuid ) uuidmutex . unlock ( ) uuid [ 8 ] = uuid [ 8 ] & ^ 0xc0 | 0x80 uuid [ 6 ] = uuid [ 6 ] & ^ 0xf0 | 0x40 return fmt . sprintf ( " " , uuid [ 0 : 4 ] , uuid [ 4 : 6 ] , uuid [ 6 : 8 ] , uuid [ 8 : 10 ] , uuid [ 10 : ] ) } 
func newqpcleaner ( r io . reader ) * qpcleaner { return & qpcleaner { in : bufio . newreader ( r ) , } } 
func ( qp * qpcleaner ) read ( dest [ ] byte ) ( n int , err error ) { destlen : = len ( dest ) - 3 for n < destlen { b , err : = qp . in . readbyte ( ) if err ! = nil { return n , err } switch { case b == ' = ' : hexbytes , err : = qp . in . peek ( 2 ) if err ! = nil && err ! = io . eof { return 0 , err } if validhexbytes ( hexbytes ) { dest [ n ] = b n ++ } else { s : = fmt . sprintf ( " " , b ) n += copy ( dest [ n : ] , s ) } case b == ' \ t ' | | b == ' ' | | b == ' \n ' : dest [ n ] = b n ++ case b < ' ' | | ' ~ ' < b : s : = fmt . sprintf ( " " , b ) n += copy ( dest [ n : ] , s ) default : dest [ n ] = b n ++ } } return n , err } 
func ( e * error ) error ( ) string { sev : = " " if e . severe { sev = " " } return fmt . sprintf ( " " , sev , e . name , e . detail ) } 
func ( p * part ) adderror ( name string , detailfmt string , args ... interface { } ) { p . errors = append ( p . errors , & error { name , fmt . sprintf ( detailfmt , args ... ) , true , } ) } 
func ( p * part ) addwarning ( name string , detailfmt string , args ... interface { } ) { p . errors = append ( p . errors , & error { name , fmt . sprintf ( detailfmt , args ... ) , false , } ) } 
func wrap ( max int , strs ... string ) [ ] byte { input : = make ( [ ] byte , 0 ) output : = make ( [ ] byte , 0 ) for , s : = range strs { input = append ( input , [ ] byte ( s ) ... ) } if len ( input ) < max { return input } ls : = - 1 lw : = - 1 ll : = 0 for i : = 0 ; i < len ( input ) ; i ++ { ll ++ switch input [ i ] { case ' ' , ' \ t ' : ls = i } if ll >= max { if ls >= 0 { output = append ( output , input [ lw + 1 : ls ] ... ) output = append ( output , ' ' , ' \n ' , ' ' ) lw = ls ll = 1 i = lw + 1 ls = - 1 } } } return append ( output , input [ lw + 1 : ] ... ) } 
func converttoutf8string ( charset string , textbytes [ ] byte ) ( string , error ) { if strings . tolower ( charset ) == utf8 { return string ( textbytes ) , nil } csentry , ok : = encodings [ strings . tolower ( charset ) ] if ! ok { return " " , fmt . errorf ( " " , charset ) } input : = bytes . newreader ( textbytes ) reader : = transform . newreader ( input , csentry . e . newdecoder ( ) ) output , err : = ioutil . readall ( reader ) if err ! = nil { return " " , err } return string ( output ) , nil } 
func findcharsetinhtml ( html string ) string { charsetmatches : = metatagcharsetregexp . findallstringsubmatch ( html , - 1 ) if len ( charsetmatches ) > 0 { return charsetmatches [ 0 ] [ metatagcharsetindex ] } return " " } 
func joinaddress ( addrs [ ] mail . address ) string { if len ( addrs ) == 0 { return " " } buf : = & bytes . buffer { } for i , a : = range addrs { if i > 0 { , = buf . writestring ( " " ) } , = buf . writestring ( a . string ( ) ) } return buf . string ( ) } 
func ( md * markdown ) printf ( format string , args ... interface { } ) { fmt . fprintf ( md , format , args ... ) } 
func formatpart ( w io . writer , p * enmime . part , indent string ) { if p == nil { return } sibling : = p . nextsibling child : = p . firstchild myindent : = indent + " " childindent : = indent + " " if sibling ! = nil { myindent = indent + " " childindent = indent + " " } if p . parent == nil { myindent = indent childindent = indent } ctype : = " " if p . contenttype ! = " " { ctype = p . contenttype } disposition : = " " if p . disposition ! = " " { disposition = fmt . sprintf ( " " , p . disposition ) } filename : = " " if p . filename ! = " " { filename = fmt . sprintf ( " " , p . filename ) } errors : = " " if len ( p . errors ) > 0 { errors = fmt . sprintf ( " " , len ( p . errors ) ) } fmt . fprintf ( w , " \n " , myindent , ctype , disposition , filename , errors ) formatpart ( w , child , childindent ) formatpart ( w , sibling , indent ) } 
func newboundaryreader ( reader * bufio . reader , boundary string ) * boundaryreader { fullboundary : = [ ] byte ( " \n " + boundary + " " ) return & boundaryreader { r : reader , nlprefix : fullboundary [ : len ( fullboundary ) - 2 ] , prefix : fullboundary [ 1 : len ( fullboundary ) - 2 ] , final : fullboundary [ 1 : ] , buffer : new ( bytes . buffer ) , } } 
func ( b * boundaryreader ) read ( dest [ ] byte ) ( n int , err error ) { if b . buffer . len ( ) >= len ( dest ) { return b . buffer . read ( dest ) } peek , err : = b . r . peek ( peekbuffersize ) peekeof : = ( err == io . eof ) if err ! = nil && ! peekeof && err ! = bufio . errbufferfull { return 0 , errors . withstack ( err ) } var ncopy int idx , complete : = locateboundary ( peek , b . nlprefix ) if idx ! = - 1 { ncopy = idx if ! complete && ncopy == 0 { ncopy = 1 } } else { if ncopy = len ( peek ) - len ( b . nlprefix ) - 1 ; ncopy <= 0 { ncopy = 0 if peekeof { return 0 , errors . withstack ( io . errunexpectedeof ) } } } if ncopy > 0 { if , err = io . copyn ( b . buffer , b . r , int64 ( ncopy ) ) ; err ! = nil { return 0 , errors . withstack ( err ) } } n , err = b . buffer . read ( dest ) if err == io . eof && ! complete { return n , nil } return n , err } 
func ( b * boundaryreader ) next ( ) ( bool , error ) { if b . finished { return false , nil } if b . partsread > 0 { , = io . copy ( ioutil . discard , b ) } for { line , err : = b . r . readslice ( ' \n ' ) if err ! = nil && err ! = io . eof { return false , errors . withstack ( err ) } if len ( line ) > 0 && ( line [ 0 ] == ' ' | | line [ 0 ] == ' \n ' ) { continue } if b . isterminator ( line ) { b . finished = true return false , nil } if err ! = io . eof && b . isdelimiter ( line ) { b . partsread ++ return true , nil } if err == io . eof { return false , io . eof } if b . partsread == 0 { continue } b . finished = true return false , errors . errorf ( " " , string ( b . prefix ) , string ( line ) ) } } 
func ( b * boundaryreader ) isdelimiter ( buf [ ] byte ) bool { idx : = bytes . index ( buf , b . prefix ) if idx == - 1 { return false } buf = buf [ idx + len ( b . prefix ) : ] buf = bytes . trimleft ( buf , " \ t " ) if len ( buf ) > 0 { if buf [ 0 ] == ' ' | | buf [ 0 ] == ' \n ' { return true } } return false } 
func ( b * boundaryreader ) isterminator ( buf [ ] byte ) bool { idx : = bytes . index ( buf , b . final ) return idx ! = - 1 } 
func locateboundary ( buf , boundaryprefix [ ] byte ) ( idx int , complete bool ) { bplen : = len ( boundaryprefix ) idx = bytes . index ( buf , boundaryprefix ) if idx == - 1 { return } if idx > 0 && buf [ idx - 1 ] == ' ' { idx -- bplen ++ } buf = buf [ idx + bplen : ] if len ( buf ) == 0 { return } if len ( buf ) > 1 { if buf [ 0 ] == ' - ' && buf [ 1 ] == ' - ' { return idx , true } } buf = bytes . trimleft ( buf , " \ t " ) if len ( buf ) > 0 { if buf [ 0 ] == ' ' | | buf [ 0 ] == ' \n ' { return idx , true } } return } 
func parse ( buf [ ] byte , offset int ) ( interface { } , error ) { obj , , err : = parsereturningoffset ( buf , offset ) return obj , err } 
func assign ( symbol string , value interface { } ) ( [ ] byte , error ) { switch value . ( type ) { case [ ] float64 : return assigndoublearray ( symbol , value . ( [ ] float64 ) ) case [ ] int32 : return assignintarray ( symbol , value . ( [ ] int32 ) ) case [ ] string : return assignstrarray ( symbol , value . ( [ ] string ) ) case [ ] byte : return assignbytearray ( symbol , value . ( [ ] byte ) ) case string : return assignstr ( symbol , value . ( string ) ) case int32 : return assignint ( symbol , value . ( int32 ) ) case float64 : return assigndouble ( symbol , value . ( float64 ) ) default : return nil , errors . new ( " " ) } } 
func newrclient ( host string , port int64 ) ( rclient , error ) { return newrclientwithauth ( host , port , " " , " " ) } 
func newrclientwithauth ( host string , port int64 , user , password string ) ( rclient , error ) { addr , err : = net . resolvetcpaddr ( " " , host + " " + strconv . formatint ( port , 10 ) ) if err ! = nil { return nil , err } rclient : = & roger { address : addr , user : user , password : password , } if , err = rclient . eval ( " " ) ; err ! = nil { return nil , err } return rclient , nil } 
func register ( identifier string , generator func ( ) string ) { faketype : = inflect . camelize ( identifier ) customgenerators [ faketype ] = generator } 
func fuzz ( e interface { } ) { ty : = reflect . typeof ( e ) if ty . kind ( ) == reflect . ptr { ty = ty . elem ( ) } if ty . kind ( ) == reflect . struct { value : = reflect . valueof ( e ) . elem ( ) for i : = 0 ; i < ty . numfield ( ) ; i ++ { field : = value . field ( i ) if field . canset ( ) { field . set ( fuzzvaluefor ( field . kind ( ) ) ) } } } } 
func findfakefunctionfor ( fako string ) func ( ) string { result : = func ( ) string { return " " } for kind , function : = range allgenerators ( ) { if fako == kind { result = function break } } return result } 
func fuzzvaluefor ( kind reflect . kind ) reflect . value { r : = rand . new ( rand . newsource ( time . now ( ) . unixnano ( ) ) ) switch kind { case reflect . string : return reflect . valueof ( randomstring ( 25 ) ) case reflect . int : return reflect . valueof ( r . int ( ) ) case reflect . int32 : return reflect . valueof ( r . int31 ( ) ) case reflect . int64 : return reflect . valueof ( r . int63 ( ) ) case reflect . float32 : return reflect . valueof ( r . float32 ( ) ) case reflect . float64 : return reflect . valueof ( r . float64 ( ) ) case reflect . bool : val : = r . intn ( 2 ) > 0 return reflect . valueof ( val ) } return reflect . valueof ( " " ) } 
func ( opts * options ) apply ( options ... option ) error { for , o : = range options { if err : = o ( opts ) ; err ! = nil { return err } } return nil } 
func ( opts * options ) tooption ( ) option { return func ( nopts * options ) error { * nopts = * opts if opts . other ! = nil { nopts . other = make ( map [ interface { } ] interface { } , len ( opts . other ) ) for k , v : = range opts . other { nopts . other [ k ] = v } } return nil } } 
func ( e * eventchannel ) waitthenclose ( ) { < - e . ctx . done ( ) e . mu . lock ( ) close ( e . ch ) e . ch = nil e . mu . unlock ( ) } 
func ( e * eventchannel ) send ( ctx context . context , ev * queryevent ) { e . mu . lock ( ) if e . ch == nil { e . mu . unlock ( ) return } select { case e . ch < - ev : case < - e . ctx . done ( ) : case < - ctx . done ( ) : } e . mu . unlock ( ) } 
func getpublickey ( r valuestore , ctx context . context , p peer . id ) ( ci . pubkey , error ) { switch k , err : = p . extractpublickey ( ) ; err { case peer . errnopublickey : case nil : return k , nil default : return nil , err } if dht , ok : = r . ( pubkeyfetcher ) ; ok { return dht . getpublickey ( ctx , p ) } key : = keyforpublickey ( p ) pkval , err : = r . getvalue ( ctx , key ) if err ! = nil { return nil , err } return ci . unmarshalpublickey ( pkval ) } 
func newmovingaverage ( age ... float64 ) movingaverage { if len ( age ) == 0 | | age [ 0 ] == avg metric age { return new ( simpleewma ) } return & variableewma { decay : 2 / ( age [ 0 ] + 1 ) , } } 
func ( e * simpleewma ) add ( value float64 ) { if e . value == 0 { e . value = value } else { e . value = ( value * decay ) + ( e . value * ( 1 - decay ) ) } } 
func ( e * variableewma ) add ( value float64 ) { switch { case e . count < warmup samples : e . count ++ e . value += value case e . count == warmup samples : e . count ++ e . value = e . value / float64 ( warmup samples ) e . value = ( value * e . decay ) + ( e . value * ( 1 - e . decay ) ) default : e . value = ( value * e . decay ) + ( e . value * ( 1 - e . decay ) ) } } 
func ( e * variableewma ) set ( value float64 ) { e . value = value if e . count <= warmup samples { e . count = warmup samples + 1 } } 
func calckeys50 ( pass , salt [ ] byte , kdfcount int ) [ ] [ ] byte { if len ( salt ) > maxpbkdf2salt { salt = salt [ : maxpbkdf2salt ] } keys : = make ( [ ] [ ] byte , 3 ) if len ( keys ) == 0 { return keys } prf : = hmac . new ( sha256 . new , pass ) prf . write ( salt ) prf . write ( [ ] byte { 0 , 0 , 0 , 1 } ) t : = prf . sum ( nil ) u : = append ( [ ] byte ( nil ) , t ... ) kdfcount -- for i , iter : = range [ ] int { kdfcount , 16 , 16 } { for iter > 0 { prf . reset ( ) prf . write ( u ) u = prf . sum ( u [ : 0 ] ) for j : = range u { t [ j ] ^ = u [ j ] } iter -- } keys [ i ] = append ( [ ] byte ( nil ) , t ... ) } pwcheck : = keys [ 2 ] for i , v : = range pwcheck [ pwchecksize : ] { pwcheck [ i & ( pwchecksize - 1 ) ] ^ = v } keys [ 2 ] = pwcheck [ : pwchecksize ] return keys } 
func ( a * archive50 ) getkeys ( b * readbuf ) ( keys [ ] [ ] byte , err error ) { if len ( * b ) < 17 { return nil , errcorruptencrypt } kdfcount : = int ( b . byte ( ) ) if kdfcount > maxkdfcount { return nil , errcorruptencrypt } kdfcount = 1 < < uint ( kdfcount ) salt : = b . bytes ( 16 ) for , v : = range a . keycache { if kdfcount == v . kdfcount && bytes . equal ( salt , v . salt ) { return v . keys , nil } } keys = calckeys50 ( a . pass , salt , kdfcount ) copy ( a . keycache [ 1 : ] , a . keycache [ : ] ) a . keycache [ 0 ] . kdfcount = kdfcount a . keycache [ 0 ] . salt = append ( [ ] byte ( nil ) , salt ... ) a . keycache [ 0 ] . keys = keys return keys , nil } 
func checkpassword ( b * readbuf , keys [ ] [ ] byte ) error { if len ( * b ) < 12 { return nil } pwcheck : = b . bytes ( 8 ) sum : = b . bytes ( 4 ) csum : = sha256 . sum256 ( pwcheck ) if bytes . equal ( sum , csum [ : len ( sum ) ] ) && ! bytes . equal ( pwcheck , keys [ 2 ] ) { return errbadpassword } return nil } 
func ( a * archive50 ) parsefileencryptionrecord ( b readbuf , f * fileblockheader ) error { if ver : = b . uvarint ( ) ; ver ! = 0 { return errunknownencmethod } flags : = b . uvarint ( ) keys , err : = a . getkeys ( & b ) if err ! = nil { return err } f . key = keys [ 0 ] if len ( b ) < 16 { return errcorruptencrypt } f . iv = b . bytes ( 16 ) if flags & file5enccheckpresent > 0 { if err : = checkpassword ( & b , keys ) ; err ! = nil { return err } } if flags & file5encusemac > 0 { a . checksum . key = keys [ 1 ] } return nil } 
func ( a * archive50 ) parseencryptionblock ( b readbuf ) error { if ver : = b . uvarint ( ) ; ver ! = 0 { return errunknownencmethod } flags : = b . uvarint ( ) keys , err : = a . getkeys ( & b ) if err ! = nil { return err } if flags & enc5checkpresent > 0 { if err : = checkpassword ( & b , keys ) ; err ! = nil { return err } } a . blockkey = keys [ 0 ] return nil } 
func ( a * archive50 ) next ( ) ( * fileblockheader , error ) { for { h , err : = a . readblockheader ( ) if err ! = nil { return nil , err } a . bytereader = limitbytereader ( a . v , h . datasize ) switch h . htype { case block5file : return a . parsefileheader ( h ) case block5arc : flags : = h . data . uvarint ( ) a . multi = flags & arc5multivol > 0 a . solid = flags & arc5solid > 0 case block5encrypt : err = a . parseencryptionblock ( h . data ) case block5end : flags : = h . data . uvarint ( ) if flags & endarc5notlast == 0 | | ! a . multi { return nil , errarchiveend } return nil , errarchivecontinues default : , err = io . copy ( ioutil . discard , a . bytereader ) } if err ! = nil { return nil , err } } } 
func newarchive50 ( r * bufio . reader , password string ) fileblockreader { a : = new ( archive50 ) a . v = r a . pass = [ ] byte ( password ) a . buf = make ( [ ] byte , 100 ) return a } 
func ( cr * cipherblockreader ) read ( p [ ] byte ) ( n int , err error ) { bs : = cr . mode . blocksize ( ) l : = len ( p ) - len ( p ) % bs p = p [ : l ] l = len ( cr . inbuf ) if l > 0 { copy ( p , cr . inbuf ) cr . inbuf = cr . inbuf [ : 0 ] } n , err = io . readatleast ( cr . r , p [ l : ] , bs - l ) n += l p = p [ : n ] l = n % bs if l > 0 { n - = l cr . inbuf = append ( cr . inbuf , p [ n : ] ... ) p = p [ : n ] } if err ! = nil { if err == io . errunexpectedeof | | err == io . errshortbuffer { err = io . eof } return 0 , err } cr . mode . cryptblocks ( p , p ) return n , nil } 
func ( cr * cipherblockreader ) read ( p [ ] byte ) ( n int , err error ) { for { if cr . n < len ( cr . outbuf ) { n = copy ( p , cr . outbuf [ cr . n : ] ) cr . n += n return n , nil } if cr . err ! = nil { err = cr . err cr . err = nil return 0 , err } if len ( p ) >= cap ( cr . outbuf ) { break } n , cr . err = cr . read ( cr . outbuf [ : cap ( cr . outbuf ) ] ) cr . outbuf = cr . outbuf [ : n ] cr . n = 0 } return cr . read ( p ) } 
func ( cr * cipherblockreader ) readbyte ( ) ( byte , error ) { for { if cr . n < len ( cr . outbuf ) { c : = cr . outbuf [ cr . n ] cr . n ++ return c , nil } if cr . err ! = nil { err : = cr . err cr . err = nil return 0 , err } var n int n , cr . err = cr . read ( cr . outbuf [ : cap ( cr . outbuf ) ] ) cr . outbuf = cr . outbuf [ : n ] cr . n = 0 } } 
func newcipherblockreader ( r io . reader , mode cipher . blockmode ) * cipherblockreader { cr : = & cipherblockreader { r : r , mode : mode } cr . outbuf = make ( [ ] byte , 0 , mode . blocksize ( ) ) cr . inbuf = make ( [ ] byte , 0 , mode . blocksize ( ) ) return cr } 
func newaesdecryptreader ( r io . reader , key , iv [ ] byte ) * cipherblockreader { block , err : = aes . newcipher ( key ) if err ! = nil { panic ( err ) } mode : = cipher . newcbcdecrypter ( block , iv ) return newcipherblockreader ( r , mode ) } 
func limitbytereader ( r bytereader , n int64 ) * limitedbytereader { return & limitedbytereader { limitedreader { r , n , io . errunexpectedeof } , r } } 
func ( f * fileheader ) mode ( ) os . filemode { var m os . filemode if f . isdir { m = os . modedir } if f . hostos == hostoswindows { if f . isdir { m | = 0777 } else if f . attributes & 1 > 0 { m | = 0444 } else { m | = 0666 } return m } m | = os . filemode ( f . attributes ) & os . modeperm if f . hostos ! = hostosunix { return m } if f . attributes & 0x200 ! = 0 { m | = os . modesticky } if f . attributes & 0x400 ! = 0 { m | = os . modesetgid } if f . attributes & 0x800 ! = 0 { m | = os . modesetuid } if f . attributes & 0xf000 == 0xa000 { m | = os . modesymlink } return m } 
func ( f * packedfilereader ) nextblockinfile ( ) error { h , err : = f . r . next ( ) if err ! = nil { if err == io . eof { return errunexpectedarcend } return err } if h . first | | h . name ! = f . h . name { return errinvalidfileblock } f . h = h return nil } 
func ( f * packedfilereader ) next ( ) ( * fileblockheader , error ) { if f . h ! = nil { for ! f . h . last { if , err : = io . copy ( ioutil . discard , f . r ) ; err ! = nil { return nil , err } if err : = f . nextblockinfile ( ) ; err ! = nil { return nil , err } } if , err : = io . copy ( ioutil . discard , f . r ) ; err ! = nil { return nil , err } } var err error f . h , err = f . r . next ( ) if err ! = nil { if err == errarchiveend { return nil , io . eof } return nil , err } if ! f . h . first { return nil , errinvalidfileblock } return f . h , nil } 
func ( f * packedfilereader ) read ( p [ ] byte ) ( int , error ) { n , err : = f . r . read ( p ) for err == io . eof { if n > 0 { return n , nil } if f . h == nil | | f . h . last { return 0 , io . eof } if err : = f . nextblockinfile ( ) ; err ! = nil { return 0 , err } n , err = f . r . read ( p ) } return n , err } 
func ( r * reader ) read ( p [ ] byte ) ( int , error ) { n , err : = r . r . read ( p ) if err == io . eof && r . cksum ! = nil && ! r . cksum . valid ( ) { return n , errbadfilechecksum } return n , err } 
func ( r * reader ) next ( ) ( * fileheader , error ) { if r . solidr ! = nil { if , err : = io . copy ( ioutil . discard , r . solidr ) ; err ! = nil { return nil , err } } h , err : = r . pr . next ( ) if err ! = nil { return nil , err } r . solidr = nil br : = bytereader ( & r . pr ) if len ( h . key ) > 0 && len ( h . iv ) > 0 { br = newaesdecryptreader ( br , h . key , h . iv ) } r . r = br if h . decoder ! = nil { err = r . dr . init ( br , h . decoder , h . winsize , ! h . solid ) if err ! = nil { return nil , err } r . r = & r . dr if r . pr . r . issolid ( ) { r . solidr = r . r } } if h . unpackedsize >= 0 && ! h . unknownsize { r . r = & limitedreader { r . r , h . unpackedsize , errshortfile } } r . cksum = h . cksum if r . cksum ! = nil { r . r = io . teereader ( r . r , h . cksum ) } fh : = new ( fileheader ) * fh = h . fileheader return fh , nil } 
func newreader ( r io . reader , password string ) ( * reader , error ) { br , ok : = r . ( * bufio . reader ) if ! ok { br = bufio . newreader ( r ) } fbr , err : = newfileblockreader ( br , password ) if err ! = nil { return nil , err } rr : = new ( reader ) rr . init ( fbr ) return rr , nil } 
func openreader ( name , password string ) ( * readcloser , error ) { v , err : = openvolume ( name , password ) if err ! = nil { return nil , err } rc : = new ( readcloser ) rc . v = v rc . reader . init ( v ) return rc , nil } 
func getv3filter ( code [ ] byte ) ( v3filter , error ) { c : = crc32 . checksumieee ( code ) for , f : = range standardv3filters { if f . crc == c && f . len == len ( code ) { return f . f , nil } } f : = new ( vmfilter ) r : = newrarbitreader ( bytes . newreader ( code [ 1 : ] ) ) n , err : = r . readbits ( 1 ) if err ! = nil { return nil , err } if n > 0 { m , err : = r . readuint32 ( ) if err ! = nil { return nil , err } f . static = make ( [ ] byte , m + 1 ) err = r . readfull ( f . static ) if err ! = nil { return nil , err } } f . code , err = readcommands ( r ) if err == io . eof { err = nil } return f . execute , err } 
func ( d * decoder29 ) init ( r io . bytereader , reset bool ) error { if d . br == nil { d . br = newrarbitreader ( r ) } else { d . br . reset ( r ) } d . eof = false if reset { d . initfilters ( ) d . lz . reset ( ) d . ppm . reset ( ) d . decode = nil } if d . decode == nil { return d . readblockheader ( ) } return nil } 
func readvmcode ( br * rarbitreader ) ( [ ] byte , error ) { n , err : = br . readuint32 ( ) if err ! = nil { return nil , err } if n > maxcodesize | | n == 0 { return nil , errinvalidfilter } buf : = make ( [ ] byte , n ) err = br . readfull ( buf ) if err ! = nil { return nil , err } var x byte for , c : = range buf [ 1 : ] { x ^ = c } if x ! = buf [ 0 ] { return nil , errinvalidfilter } return buf , nil } 
func ( d * decoder29 ) readblockheader ( ) error { d . br . alignbyte ( ) n , err : = d . br . readbits ( 1 ) if err == nil { if n > 0 { d . decode = d . ppm . decode err = d . ppm . init ( d . br ) } else { d . decode = d . lz . decode err = d . lz . init ( d . br ) } } if err == io . eof { err = errdecoderoutofdata } return err } 
func readcodelengthtable ( br bitreader , codelength [ ] byte , addold bool ) error { var bitlength [ 20 ] byte for i : = 0 ; i < len ( bitlength ) ; i ++ { n , err : = br . readbits ( 4 ) if err ! = nil { return err } if n == 0xf { cnt , err : = br . readbits ( 4 ) if err ! = nil { return err } if cnt > 0 { i += cnt + 1 continue } } bitlength [ i ] = byte ( n ) } var bl huffmandecoder bl . init ( bitlength [ : ] ) for i : = 0 ; i < len ( codelength ) ; i ++ { l , err : = bl . readsym ( br ) if err ! = nil { return err } if l < 16 { if addold { codelength [ i ] = ( codelength [ i ] + byte ( l ) ) & 0xf } else { codelength [ i ] = byte ( l ) } continue } var count int var value byte switch l { case 16 , 18 : count , err = br . readbits ( 3 ) count += 3 default : count , err = br . readbits ( 7 ) count += 11 } if err ! = nil { return err } if l < 18 { if i == 0 { return errinvalidlengthtable } value = codelength [ i - 1 ] } for ; count > 0 && i < len ( codelength ) ; i ++ { codelength [ i ] = value count -- } i -- } return nil } 
func ( c * context ) shrinkstates ( states [ ] state , size int ) [ ] state { i1 : = units2index [ ( len ( states ) + 1 ) > > 1 ] i2 : = units2index [ ( size + 1 ) > > 1 ] if size == 1 { n : = c . statesindex ( ) c . s [ 1 ] = states [ 0 ] states = c . s [ 1 : ] c . a . addfreeblock ( n , i1 ) } else if i1 ! = i2 { if n : = c . a . removefreeblock ( i2 ) ; n > 0 { copy ( c . a . states [ n : ] , states [ : size ] ) states = c . a . states [ n : ] c . a . addfreeblock ( c . statesindex ( ) , i1 ) c . setstatesindex ( n ) } else { n = c . statesindex ( ) + index2units [ i2 ] < < 1 u : = index2units [ i1 ] - index2units [ i2 ] c . a . freeunits ( n , u ) } } c . setnumstates ( size ) return states [ : size ] } 
func ( c * context ) expandstates ( ) [ ] state { states : = c . states ( ) ns : = len ( states ) if ns == 1 { s : = states [ 0 ] n : = c . a . allocunits ( 1 ) if n == 0 { return nil } c . setstatesindex ( n ) states = c . a . states [ n : ] states [ 0 ] = s } else if ns & 0x1 == 0 { u : = ns > > 1 i1 : = units2index [ u ] i2 : = units2index [ u + 1 ] if i1 ! = i2 { n : = c . a . allocunits ( i2 ) if n == 0 { return nil } copy ( c . a . states [ n : ] , states ) c . a . addfreeblock ( c . statesindex ( ) , i1 ) c . setstatesindex ( n ) states = c . a . states [ n : ] } } c . setnumstates ( ns + 1 ) return states [ : ns + 1 ] } 
func ( a * suballocator ) pushbyte ( c byte ) int32 { si : = a . heap1lo / 6 oi : = a . heap1lo % 6 switch oi { case 0 : a . states [ si ] . sym = c case 1 : a . states [ si ] . freq = c default : n : = ( uint ( oi ) - 2 ) * 8 mask : = ^ ( uint32 ( 0xff ) < < n ) succ : = uint32 ( a . states [ si ] . succ ) & mask succ | = uint32 ( c ) < < n a . states [ si ] . succ = int32 ( succ ) } a . heap1lo ++ if a . heap1lo >= a . heap1hi { return 0 } return - a . heap1lo } 
func ( a * suballocator ) succbyte ( i int32 ) byte { i = - i si : = i / 6 oi : = i % 6 switch oi { case 0 : return a . states [ si ] . sym case 1 : return a . states [ si ] . freq default : n : = ( uint ( oi ) - 2 ) * 8 succ : = uint32 ( a . states [ si ] . succ ) > > n return byte ( succ & 0xff ) } } 
func ( a * suballocator ) succcontext ( i int32 ) * context { if i <= 0 { return nil } return & context { i : i , s : a . states [ i : i + 2 : i + 2 ] , a : a } } 
func calcaes30params ( pass [ ] uint16 , salt [ ] byte ) ( key , iv [ ] byte ) { p : = make ( [ ] byte , 0 , len ( pass ) * 2 + len ( salt ) ) for , v : = range pass { p = append ( p , byte ( v ) , byte ( v > > 8 ) ) } p = append ( p , salt ... ) hash : = sha1 . new ( ) iv = make ( [ ] byte , 16 ) s : = make ( [ ] byte , 0 , hash . size ( ) ) for i : = 0 ; i < hashrounds ; i ++ { hash . write ( p ) hash . write ( [ ] byte { byte ( i ) , byte ( i > > 8 ) , byte ( i > > 16 ) } ) if i % ( hashrounds / 16 ) == 0 { s = hash . sum ( s [ : 0 ] ) iv [ i / ( hashrounds / 16 ) ] = s [ 4 * 4 + 3 ] } } key = hash . sum ( s [ : 0 ] ) key = key [ : 16 ] for k : = key ; len ( k ) >= 4 ; k = k [ 4 : ] { k [ 0 ] , k [ 1 ] , k [ 2 ] , k [ 3 ] = k [ 3 ] , k [ 2 ] , k [ 1 ] , k [ 0 ] } return key , iv } 
func parsedostime ( t uint32 ) time . time { n : = int ( t ) sec : = n & 0x1f < < 1 min : = n > > 5 & 0x3f hr : = n > > 11 & 0x1f day : = n > > 16 & 0x1f mon : = time . month ( n > > 21 & 0x0f ) yr : = n > > 25 & 0x7f + 1980 return time . date ( yr , mon , day , hr , min , sec , 0 , time . local ) } 
func readexttimes ( f * fileblockheader , b * readbuf ) { if len ( * b ) < 2 { return } flags : = b . uint16 ( ) ts : = [ ] * time . time { & f . modificationtime , & f . creationtime , & f . accesstime } for i , t : = range ts { n : = flags > > uint ( ( 3 - i ) * 4 ) if n & 0x8 == 0 { continue } if i ! = 0 { if len ( * b ) < 4 { return } * t = parsedostime ( b . uint32 ( ) ) } if n & 0x4 > 0 { * t = t . add ( time . second ) } n &= 0x3 if n == 0 { continue } if len ( * b ) < int ( n ) { return } d : = time . duration ( 0 ) for j : = 3 - n ; j < n ; j ++ { d | = time . duration ( b . byte ( ) ) < < ( j * 8 ) } d * = 100 * t = t . add ( d ) } } 
func ( a * archive15 ) next ( ) ( * fileblockheader , error ) { for { h , err : = a . readblockheader ( ) if err ! = nil { return nil , err } a . bytereader = limitbytereader ( a . v , h . datasize ) switch h . htype { case blockfile : return a . parsefileheader ( h ) case blockarc : a . encrypted = h . flags & arcencrypted > 0 a . multi = h . flags & arcvolume > 0 a . old = h . flags & arcnewnaming == 0 a . solid = h . flags & arcsolid > 0 case blockend : if h . flags & endarcnotlast == 0 | | ! a . multi { return nil , errarchiveend } return nil , errarchivecontinues default : , err = io . copy ( ioutil . discard , a . bytereader ) } if err ! = nil { return nil , err } } } 
func newarchive15 ( r * bufio . reader , password string ) fileblockreader { a : = new ( archive15 ) a . v = r a . pass = utf16 . encode ( [ ] rune ( password ) ) a . checksum . hash32 = crc32 . newieee ( ) a . buf = readbuf ( make ( [ ] byte , 100 ) ) return a } 
func readfilter5data ( br bitreader ) ( int , error ) { bytes , err : = br . readbits ( 2 ) if err ! = nil { return 0 , err } bytes ++ var data int for i : = 0 ; i < bytes ; i ++ { n , err : = br . readbits ( 8 ) if err ! = nil { return 0 , err } data | = n < < ( uint ( i ) * 8 ) } return data , nil } 
func ( w * window ) writebyte ( c byte ) { w . buf [ w . w ] = c w . w = ( w . w + 1 ) & w . mask } 
func ( w * window ) copybytes ( len , off int ) { len &= w . mask n : = w . available ( ) if len > n { w . l = len - n w . o = off len = n } i : = ( w . w - off ) & w . mask for ; len > 0 ; len -- { w . buf [ w . w ] = w . buf [ i ] w . w = ( w . w + 1 ) & w . mask i = ( i + 1 ) & w . mask } } 
func ( w * window ) read ( p [ ] byte ) ( n int ) { if w . r > w . w { n = copy ( p , w . buf [ w . r : ] ) w . r = ( w . r + n ) & w . mask p = p [ n : ] } if w . r < w . w { l : = copy ( p , w . buf [ w . r : w . w ] ) w . r += l n += l } if w . l > 0 && n > 0 { l : = w . l w . l = 0 w . copybytes ( l , w . o ) } return n } 
func ( d * decodereader ) queuefilter ( f * filterblock ) error { if f . reset { d . filters = nil } if len ( d . filters ) >= maxqueuedfilters { return errtoomanyfilters } f . offset &= d . win . mask f . length &= d . win . mask for , fb : = range d . filters { if f . offset < fb . offset { return errinvalidfilter } f . offset - = fb . offset } d . filters = append ( d . filters , f ) return nil } 
func ( d * decodereader ) processfilters ( ) ( err error ) { f : = d . filters [ 0 ] if f . offset > 0 { return nil } d . filters = d . filters [ 1 : ] if d . win . buffered ( ) < f . length { err = d . readerr ( ) if err == nil | | err == io . eof { return errinvalidfilter } return err } if cap ( d . buf ) < f . length { d . buf = make ( [ ] byte , f . length ) } d . outbuf = d . buf [ : f . length ] n : = d . win . read ( d . outbuf ) for { d . outbuf , err = f . filter ( d . outbuf , d . tot ) if err ! = nil { return err } if cap ( d . outbuf ) > cap ( d . buf ) { d . buf = d . outbuf } if len ( d . filters ) == 0 { return nil } f = d . filters [ 0 ] if f . offset ! = 0 { f . offset - = n return nil } if f . length ! = len ( d . outbuf ) { return errinvalidfilter } d . filters = d . filters [ 1 : ] if cap ( d . outbuf ) < cap ( d . buf ) { d . outbuf = append ( d . buf [ : 0 ] , d . outbuf ... ) } } } 
func ( d * decodereader ) fill ( ) { if d . err ! = nil { return } var fl [ ] * filterblock fl , d . err = d . dec . fill ( & d . win ) for , f : = range fl { err : = d . queuefilter ( f ) if err ! = nil { d . err = err return } } } 
func ( d * decodereader ) read ( p [ ] byte ) ( n int , err error ) { if len ( d . outbuf ) == 0 { if d . win . buffered ( ) == 0 { d . fill ( ) if d . win . buffered ( ) == 0 { return 0 , d . readerr ( ) } } else if len ( d . filters ) > 0 { f : = d . filters [ 0 ] if f . offset == 0 && f . length > d . win . buffered ( ) { d . fill ( ) } } if len ( d . filters ) > 0 { if err : = d . processfilters ( ) ; err ! = nil { return 0 , err } } } if len ( d . outbuf ) > 0 { n = copy ( p , d . outbuf ) d . outbuf = d . outbuf [ n : ] } else if len ( d . filters ) > 0 { f : = d . filters [ 0 ] if f . offset < len ( p ) { p = p [ : f . offset ] } n = d . win . read ( p ) f . offset - = n } else { n = d . win . read ( p ) } d . tot += int64 ( n ) return n , nil } 
func readfull ( r io . reader , buf [ ] byte ) error { , err : = io . readfull ( r , buf ) if err == io . eof { return io . errunexpectedeof } return err } 
func findsig ( br * bufio . reader ) ( int , error ) { for n : = 0 ; n <= maxsfxsize ; { b , err : = br . readslice ( sigprefix [ 0 ] ) n += len ( b ) if err == bufio . errbufferfull { continue } else if err ! = nil { if err == io . eof { err = errnosig } return 0 , err } b , err = br . peek ( len ( sigprefix [ 1 : ] ) + 2 ) if err ! = nil { if err == io . eof { err = errnosig } return 0 , err } if ! bytes . hasprefix ( b , [ ] byte ( sigprefix [ 1 : ] ) ) { continue } b = b [ len ( sigprefix ) - 1 : ] var ver int switch { case b [ 0 ] == 0 : ver = filefmt15 case b [ 0 ] == 1 && b [ 1 ] == 0 : ver = filefmt50 default : continue } , = br . readslice ( ' \ x00 ' ) return ver , nil } return 0 , errnosig } 
func ( v * vm ) execute ( cmd [ ] command ) { v . ip = 0 for n : = 0 ; n < maxcommands ; n ++ { ip : = v . ip if ip >= uint32 ( len ( cmd ) ) { return } ins : = cmd [ ip ] ins . f ( v , ins . bm , ins . op ) if v . ipmod { v . ipmod = false } else { v . ip ++ } } } 
func newvm ( mem [ ] byte ) * vm { v : = new ( vm ) if cap ( mem ) < vmsize + 4 { v . m = make ( [ ] byte , vmsize + 4 ) copy ( v . m , mem ) } else { v . m = mem [ : vmsize + 4 ] for i : = len ( mem ) ; i < len ( v . m ) ; i ++ { v . m [ i ] = 0 } } v . r [ 7 ] = vmsize return v } 
func limitbitreader ( br bitreader , n int , err error ) bitreader { return & limitedbitreader { br , n , err } } 
func ( r * rarbitreader ) readuint32 ( ) ( uint32 , error ) { n , err : = r . readbits ( 2 ) if err ! = nil { return 0 , err } if n ! = 1 { n , err = r . readbits ( 4 < < uint ( n ) ) return uint32 ( n ) , err } n , err = r . readbits ( 4 ) if err ! = nil { return 0 , err } if n == 0 { n , err = r . readbits ( 8 ) n | = - 1 < < 8 return uint32 ( n ) , err } nlow , err : = r . readbits ( 4 ) n = n < < 4 | nlow return uint32 ( n ) , err } 
func ( r * rarbitreader ) readfull ( p [ ] byte ) error { for i : = range p { c , err : = r . readbyte ( ) if err ! = nil { return err } p [ i ] = c } return nil } 
func step3 ( word * snowballword . snowballword ) bool { suffix , : = word . removefirstsuffixin ( word . r2start , " "   if suffix ! = " " { return true } return false } 
func stem ( word string , stemstopwwords bool ) string { word = strings . tolower ( strings . trimspace ( word ) ) if len ( word ) <= 2 | | ( stemstopwwords == false && isstopword ( word ) ) { return word } if specialversion : = stemspecialword ( word ) ; specialversion ! = " " { word = specialversion return word } w : = snowballword . new ( word ) preprocess ( w ) step0 ( w ) step1a ( w ) step1b ( w ) step1c ( w ) step2 ( w ) step3 ( w ) step4 ( w ) step5 ( w ) postprocess ( w ) return w . string ( ) } 
func step6 ( word * snowballword . snowballword ) bool { numnonvowels : = 0 for i : = len ( word . rs ) - 1 ; i >= 0 ; i -- { r : = word . rs [ i ] if islowervowel ( r ) == false { numnonvowels += 1 } else { if ( r == 233 | | r == 232 ) && numnonvowels > 0 { word . rs [ i ] = 101 return true } return false } } return false } 
func step5 ( word * snowballword . snowballword ) bool { suffix , : = word . firstsuffix ( " " , " " , " " , " " , " " ) if suffix ! = " " { word . removelastnrunes ( 1 ) } return false } 
func step2a ( word * snowballword . snowballword ) bool { suffix , suffixrunes : = word . firstsuffixin ( word . rvstart , len ( word . rs ) , " " , " " , " " , " " , " " , " " , " " , " , y , y , y , y ) if suffix ! = " " { idx : = len ( word . rs ) - len ( suffixrunes ) - 1 if idx >= 0 && word . rs [ idx ] == 117 { word . removelastnrunes ( len ( suffixrunes ) ) return true } } return false } 
func step3 ( w * snowballword . snowballword ) bool { suffix , suffixrunes : = w . firstsuffixin ( w . r1start , len ( w . rs ) , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , ) if suffix == " " | | len ( suffixrunes ) > len ( w . rs ) - w . r1start { return false } w . replacesuffixrunes ( suffixrunes , [ ] rune ( " " ) , true ) return true } 
func step4 ( word * snowballword . snowballword ) bool { if word . hassuffixrunes ( [ ] rune ( " ) { word . removelastnrunes ( 1 ) return true } suffix , : = word . removefirstsuffix ( "   " if suffix ! = " " { if word . hassuffixrunes ( [ ] rune ( " ) { word . removelastnrunes ( 1 ) } return true } if rslen : = len ( word . rs ) ; rslen > 0 && word . rs [ rslen - 1 ] == '  ' word . removelastnrunes ( 1 ) return true } return false } 
func stem ( word , language string , stemstopwords bool ) ( stemmed string , err error ) { var f func ( string , bool ) string switch language { case " " : f = english . stem case " " : f = spanish . stem case " " : f = french . stem case " " : f = russian . stem case " " : f = swedish . stem case " " : f = norwegian . stem default : err = fmt . errorf ( " " , language ) return } stemmed = f ( word , stemstopwords ) return } 
func findregions ( word * snowballword . snowballword ) ( r1start , r2start , rvstart int ) { r1start = romance . vnvsuffix ( word , islowervowel , 0 ) r2start = romance . vnvsuffix ( word , islowervowel , r1start ) rvstart = len ( word . rs ) if len ( word . rs ) >= 3 { switch { case ! islowervowel ( word . rs [ 1 ] ) : for i : = 2 ; i < len ( word . rs ) ; i ++ { if islowervowel ( word . rs [ i ] ) { rvstart = i + 1 break } } case islowervowel ( word . rs [ 0 ] ) && islowervowel ( word . rs [ 1 ] ) : for i : = 2 ; i < len ( word . rs ) ; i ++ { if ! islowervowel ( word . rs [ i ] ) { rvstart = i + 1 break } } default : rvstart = 3 } } return } 
func step1c ( w * snowballword . snowballword ) bool { rslen : = len ( w . rs ) if len ( w . rs ) > 2 && ( w . rs [ rslen - 1 ] == 121 | | w . rs [ rslen - 1 ] == 89 ) && ! islowervowel ( w . rs [ rslen - 2 ] ) { w . rs [ rslen - 1 ] = 105 return true } return false } 
func step3 ( w * snowballword . snowballword ) bool { suffix , suffixrunes : = w . firstsuffix ( " " , " " , " " , " " , " " , " " , " " , " " , " " , ) if suffix == " " | | len ( suffixrunes ) > len ( w . rs ) - w . r1start { return false } if suffix == " " { if len ( w . rs ) - w . r2start >= 5 { w . removelastnrunes ( len ( suffixrunes ) ) return true } return false } var repl string switch suffix { case " " : repl = " " case " " : repl = " " case " " : repl = " " case " " , " " , " " : repl = " " case " " , " " : repl = " " } w . replacesuffixrunes ( suffixrunes , [ ] rune ( repl ) , true ) return true } 
func step4 ( w * snowballword . snowballword ) bool { suffix , suffixrunes : = w . firstsuffix ( " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , ) if len ( suffixrunes ) > len ( w . rs ) - w . r2start { return false } switch suffix { case " " : return false case " " : rslen : = len ( w . rs ) if rslen >= 4 { switch w . rs [ rslen - 4 ] { case 115 , 116 : w . removelastnrunes ( len ( suffixrunes ) ) return true } } return false } w . removelastnrunes ( len ( suffixrunes ) ) return true } 
func capitalizeyui ( word * snowballword . snowballword ) { vowelpreviously : = false vowelnext : = func ( j int ) bool { return ( j + 1 < len ( word . rs ) && islowervowel ( word . rs [ j + 1 ] ) ) } for i : = 0 ; i < len ( word . rs ) ; i ++ { if islowervowel ( word . rs [ i ] ) == false { vowelpreviously = false continue } vowelhere : = true switch word . rs [ i ] { case 121 : if vowelpreviously | | vowelnext ( i ) { word . rs [ i ] = 89 vowelhere = false } case 117 : if ( vowelpreviously && vowelnext ( i ) ) | | ( i >= 1 && word . rs [ i - 1 ] == 113 ) { word . rs [ i ] = 85 vowelhere = false } case 105 : if vowelpreviously && vowelnext ( i ) { word . rs [ i ] = 73 vowelhere = false } } vowelpreviously = vowelhere } } 
func step3 ( word * snowballword . snowballword ) bool { suffix , suffixrunes : = word . firstsuffixifin ( word . rvstart , len ( word . rs ) , " " , " " , " " , " ,  " " " e , "  , ) if suffix == " " { return false } word . removelastnrunes ( len ( suffixrunes ) ) if suffix == " " | | suffix == " gusuffix , : = word . firstsuffix ( " " ) if gusuffix ! = " " { word . removelastnrunes ( 1 ) } } return true } 
func step0 ( w * snowballword . snowballword ) bool { suffix , suffixrunes : = w . firstsuffix ( " " , " " , " " ) if suffix == " " { return false } w . removelastnrunes ( len ( suffixrunes ) ) return true } 
func vnvsuffix ( word * snowballword . snowballword , f isvowelfunc , start int ) int { for i : = 1 ; i < len ( word . rs [ start : ] ) ; i ++ { j : = start + i if f ( word . rs [ j - 1 ] ) && ! f ( word . rs [ j ] ) { return j + 1 } } return len ( word . rs ) } 
func step1 ( w * snowballword . snowballword ) bool { suffixes : = [ ] string { " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , } suffix , suffixrunes : = w . firstsuffixin ( w . r1start , len ( w . rs ) , suffixes ... ) if suffix == " " | | len ( suffixrunes ) > len ( w . rs ) - w . r1start { return false } if suffix == " " { rslen : = len ( w . rs ) if rslen >= 2 { switch w . rs [ rslen - 2 ] { case ' b ' , ' c ' , ' d ' , ' f ' , ' g ' , ' h ' , ' j ' , ' k ' , ' l ' , ' m ' , ' n ' , ' o ' , ' p ' , ' r ' , ' t ' , ' v ' , ' y ' : w . removelastnrunes ( len ( suffixrunes ) ) return true } } return false } w . removelastnrunes ( len ( suffixrunes ) ) return true } 
func findregions ( word * snowballword . snowballword ) ( r1start , r2start , rvstart int ) { r1start = romance . vnvsuffix ( word , islowervowel , 0 ) r2start = romance . vnvsuffix ( word , islowervowel , r1start ) rvstart = len ( word . rs ) for i : = 0 ; i < len ( word . rs ) ; i ++ { if islowervowel ( word . rs [ i ] ) { rvstart = i + 1 break } } return } 
func step1 ( word * snowballword . snowballword ) bool { var stop bool stop = removeperfectivegerundending ( word ) if stop { return true } word . removefirstsuffixin ( word . rvstart , " "  stop = removeadjectivalending ( word ) if stop { return true } stop = removeverbending ( word ) if stop { return true } suffix , : = word . removefirstsuffixin ( word . rvstart , "   " " , " "    " "  " "    , " , " "    , " , " " "    , " , " "    , " , " " ,  " " "  ,  " " , " ,  " " "  , ) if suffix ! = " " { return true } return false } 
func removeperfectivegerundending ( word * snowballword . snowballword ) bool { suffix , suffixrunes : = word . firstsuffixin ( word . rvstart , len ( word . rs ) , "    "   ,  " , " , ) switch suffix { case " ,     if precededbyarinrv ( word , len ( suffixrunes ) ) == false { suffix = " " } } if suffix ! = " " { word . removelastnrunes ( len ( suffixrunes ) ) return true } return false } 
func removeadjectivalending ( word * snowballword . snowballword ) bool { suffix , : = word . removefirstsuffixin ( word . rvstart , " "    " "    , "  " "    , " , " "    , " , " " "    , " , " "    , " , " ) if suffix ! = " " { newsuffix , newsuffixrunes : = word . firstsuffixin ( word . rvstart , len ( word . rs ) , " "    " " "    , " , " ) switch newsuffix { case " "    , " , " if precededbyarinrv ( word , len ( newsuffixrunes ) ) == false { newsuffix = " " } } if newsuffix ! = " " { word . removelastnrunes ( len ( newsuffixrunes ) ) } return true } return false } 
func step5 ( w * snowballword . snowballword ) bool { lri : = len ( w . rs ) - 1 if w . r1start > lri { return false } if w . rs [ lri ] == 101 { if w . r2start <= lri | | ! endsshortsyllable ( w , lri ) { w . replacesuffix ( " " , " " , true ) return true } return false } else if w . r2start <= lri && w . rs [ lri ] == 108 && lri - 1 >= 0 && w . rs [ lri - 1 ] == 108 { w . replacesuffix ( " " , " " , true ) return true } return false } 
func stem ( word string , stemstopwwords bool ) string { word = strings . tolower ( strings . trimspace ( word ) ) if len ( word ) <= 2 | | ( stemstopwwords == false && isstopword ( word ) ) { return word } w : = snowballword . new ( word ) preprocess ( w ) step0 ( w ) changeinstep1 : = step1 ( w ) if changeinstep1 == false { changeinstep2a : = step2a ( w ) if changeinstep2a == false { step2b ( w ) } } step3 ( w ) postprocess ( w ) return w . string ( ) } 
func stem ( word string , stemstopwwords bool ) string { word = strings . tolower ( strings . trimspace ( word ) ) w : = snowballword . new ( word ) if len ( w . rs ) <= 2 | | ( stemstopwwords == false && isstopword ( word ) ) { return word } preprocess ( w ) step1 ( w ) step2 ( w ) step3 ( w ) step4 ( w ) return w . string ( ) } 
func new ( in string ) ( word * snowballword ) { word = & snowballword { rs : [ ] rune ( in ) } word . r1start = len ( word . rs ) word . r2start = len ( word . rs ) word . rvstart = len ( word . rs ) return } 
func ( w * snowballword ) replacesuffix ( suffix , replacement string , force bool ) bool { var ( doreplacement bool suffixrunes [ ] rune ) if force { doreplacement = true suffixrunes = [ ] rune ( suffix ) } else { var foundsuffix string foundsuffix , suffixrunes = w . firstsuffix ( suffix ) if foundsuffix == suffix { doreplacement = true } } if doreplacement == false { return false } w . replacesuffixrunes ( suffixrunes , [ ] rune ( replacement ) , true ) return true } 
func ( w * snowballword ) removelastnrunes ( n int ) { w . rs = w . rs [ : len ( w . rs ) - n ] w . resetr1r2 ( ) } 
func ( w * snowballword ) replacesuffixrunes ( suffixrunes [ ] rune , replacementrunes [ ] rune , force bool ) bool { if force | | w . hassuffixrunes ( suffixrunes ) { lenwithoutsuffix : = len ( w . rs ) - len ( suffixrunes ) w . rs = append ( w . rs [ : lenwithoutsuffix ] , replacementrunes ... ) w . resetr1r2 ( ) return true } return false } 
func ( w * snowballword ) resetr1r2 ( ) { rslen : = len ( w . rs ) if w . r1start > rslen { w . r1start = rslen } if w . r2start > rslen { w . r2start = rslen } if w . rvstart > rslen { w . rvstart = rslen } } 
func ( w * snowballword ) slice ( start , stop int ) [ ] rune { startmin : = 0 if start < startmin { start = startmin } max : = len ( w . rs ) - 1 if start > max { start = max } if stop > max { stop = max } return w . rs [ start : stop ] } 
func ( w * snowballword ) fitsinr1 ( x int ) bool { return w . r1start <= len ( w . rs ) - x } 
func ( w * snowballword ) fitsinr2 ( x int ) bool { return w . r2start <= len ( w . rs ) - x } 
func ( w * snowballword ) fitsinrv ( x int ) bool { return w . rvstart <= len ( w . rs ) - x } 
func ( w * snowballword ) firstprefix ( prefixes ... string ) ( foundprefix string , foundprefixrunes [ ] rune ) { found : = false rslen : = len ( w . rs ) for , prefix : = range prefixes { prefixrunes : = [ ] rune ( prefix ) if len ( prefixrunes ) > rslen { continue } found = true for i , r : = range prefixrunes { if i > rslen - 1 | | ( w . rs ) [ i ] ! = r { found = false break } } if found { foundprefix = prefix foundprefixrunes = prefixrunes break } } return } 
func ( w * snowballword ) hassuffixrunesin ( startpos , endpos int , suffixrunes [ ] rune ) bool { maxlen : = endpos - startpos suffixlen : = len ( suffixrunes ) if suffixlen > maxlen { return false } nummatching : = 0 for i : = 0 ; i < maxlen && i < suffixlen ; i ++ { if w . rs [ endpos - i - 1 ] ! = suffixrunes [ suffixlen - i - 1 ] { break } else { nummatching += 1 } } if nummatching == suffixlen { return true } return false } 
func ( w * snowballword ) hassuffixrunes ( suffixrunes [ ] rune ) bool { return w . hassuffixrunesin ( 0 , len ( w . rs ) , suffixrunes ) } 
func ( w * snowballword ) firstsuffixifin ( startpos , endpos int , suffixes ... string ) ( suffix string , suffixrunes [ ] rune ) { for , suffix : = range suffixes { suffixrunes : = [ ] rune ( suffix ) if w . hassuffixrunesin ( 0 , endpos , suffixrunes ) { if endpos - len ( suffixrunes ) >= startpos { return suffix , suffixrunes } else { suffixrunes = suffixrunes [ : 0 ] return " " , suffixrunes } } } suffixrunes = suffixrunes [ : 0 ] return " " , suffixrunes } 
func ( w * snowballword ) removefirstsuffixifin ( startpos int , suffixes ... string ) ( suffix string , suffixrunes [ ] rune ) { suffix , suffixrunes = w . firstsuffixifin ( startpos , len ( w . rs ) , suffixes ... ) if suffix ! = " " { w . removelastnrunes ( len ( suffixrunes ) ) } return } 
func ( w * snowballword ) removefirstsuffixin ( startpos int , suffixes ... string ) ( suffix string , suffixrunes [ ] rune ) { suffix , suffixrunes = w . firstsuffixin ( startpos , len ( w . rs ) , suffixes ... ) if suffix ! = " " { w . removelastnrunes ( len ( suffixrunes ) ) } return } 
func ( w * snowballword ) removefirstsuffix ( suffixes ... string ) ( suffix string , suffixrunes [ ] rune ) { return w . removefirstsuffixin ( 0 , suffixes ... ) } 
func ( w * snowballword ) firstsuffix ( suffixes ... string ) ( suffix string , suffixrunes [ ] rune ) { return w . firstsuffixifin ( 0 , len ( w . rs ) , suffixes ... ) } 
func preprocess ( word * snowballword . snowballword ) { normalizeapostrophes ( word ) trimleftapostrophes ( word ) capitalizeys ( word ) r1start , r2start : = r1r2 ( word ) word . r1start = r1start word . r2start = r2start } 
func step3 ( w * snowballword . snowballword ) bool { suffix , suffixrunes : = w . firstsuffixin ( w . r1start , len ( w . rs ) , " " , " , l , e , i , ) if suffix == " " | | len ( suffixrunes ) > len ( w . rs ) - w . r1start { return false } var repl string switch suffix { case " " : repl = " " case " : repl = " case " " , " " , " " : repl = " " } w . replacesuffixrunes ( suffixrunes , [ ] rune ( repl ) , true ) return true } 
func step2 ( w * snowballword . snowballword ) bool { suffix , suffixrunes : = w . firstsuffix ( " " , " " , ) if suffix == " " | | len ( suffixrunes ) > len ( w . rs ) - w . r1start { return false } w . removelastnrunes ( 1 ) return true } 
func normalizeapostrophes ( word * snowballword . snowballword ) ( numsubstitutions int ) { for i , r : = range word . rs { switch r { case 8217 , 8216 , 8219 : word . rs [ i ] = 39 numsubstitutions += 1 } } return } 
func trimleftapostrophes ( word * snowballword . snowballword ) { var ( numapostrophes int r rune ) for numapostrophes , r = range word . rs { if r ! = 39 { break } } if numapostrophes > 0 { word . rs = word . rs [ numapostrophes : ] word . r1start = word . r1start - numapostrophes word . r2start = word . r2start - numapostrophes } } 
func capitalizeys ( word * snowballword . snowballword ) ( numcapitalizations int ) { for i , r : = range word . rs { if r == 121 && ( i == 0 | | islowervowel ( word . rs [ i - 1 ] ) ) { word . rs [ i ] = 89 numcapitalizations += 1 } } return } 
func uncapitalizeys ( word * snowballword . snowballword ) { for i , r : = range word . rs { if r == 89 { word . rs [ i ] = 121 } } return } 
func isshortword ( w * snowballword . snowballword ) ( isshort bool ) { if w . r1start < len ( w . rs ) { return } return endsshortsyllable ( w , len ( w . rs ) ) } 
func endsshortsyllable ( w * snowballword . snowballword , i int ) bool { if i == 2 { if islowervowel ( w . rs [ 0 ] ) && ! islowervowel ( w . rs [ 1 ] ) { return true } else { return false } } else if i >= 3 { s1 : = w . rs [ i - 1 ] s2 : = w . rs [ i - 2 ] s3 : = w . rs [ i - 3 ] if ! islowervowel ( s1 ) && s1 ! = 119 && s1 ! = 120 && s1 ! = 89 && islowervowel ( s2 ) && ! islowervowel ( s3 ) { return true } else { return false } } return false } 
func step1a ( w * snowballword . snowballword ) bool { suffix , suffixrunes : = w . firstsuffix ( " " , " " , " " , " " , " " , " " ) switch suffix { case " " : w . replacesuffixrunes ( suffixrunes , [ ] rune ( " " ) , true ) return true case " " , " " : var repl string if len ( w . rs ) > 4 { repl = " " } else { repl = " " } w . replacesuffixrunes ( suffixrunes , [ ] rune ( repl ) , true ) return true case " " , " " : return false case " " : for i : = 0 ; i < len ( w . rs ) - 2 ; i ++ { if islowervowel ( w . rs [ i ] ) { w . removelastnrunes ( len ( suffixrunes ) ) return true } } } return false } 
func set ( key string , value interface { } ) { gid : = curgoroutineid ( ) datalock . lock ( ) if data [ gid ] == nil { data [ gid ] = values { } } data [ gid ] [ key ] = value datalock . unlock ( ) } 
func get ( key string ) interface { } { gid : = curgoroutineid ( ) datalock . rlock ( ) if data [ gid ] == nil { datalock . runlock ( ) return nil } value : = data [ gid ] [ key ] datalock . runlock ( ) return value } 
func cleanup ( ) { gid : = curgoroutineid ( ) datalock . lock ( ) delete ( data , gid ) datalock . unlock ( ) } 
func getvalues ( ) values { gid : = curgoroutineid ( ) datalock . lock ( ) values : = data [ gid ] datalock . unlock ( ) return values } 
func linkgrs ( parentdata values ) { childid : = curgoroutineid ( ) datalock . lock ( ) data [ childid ] = parentdata datalock . unlock ( ) } 
func unlinkgrs ( ) { childid : = curgoroutineid ( ) datalock . lock ( ) delete ( data , childid ) datalock . unlock ( ) } 
func appuri ( appname , path string , config helpersinternal . curlconfig ) string { uricreator : = & helpersinternal . appuricreator { curlconfig : config } return uricreator . appuri ( appname , path ) } 
func curlappwithtimeout ( cfg helpersinternal . curlconfig , appname , path string , timeout time . duration , args ... string ) string { appcurler : = helpersinternal . newappcurler ( curl , cfg ) return appcurler . curlandwait ( cfg , appname , path , timeout , args ... ) } 
func curlapp ( cfg helpersinternal . curlconfig , appname , path string , args ... string ) string { appcurler : = helpersinternal . newappcurler ( curl , cfg ) return appcurler . curlandwait ( cfg , appname , path , curl timeout , args ... ) } 
func curlapproot ( cfg helpersinternal . curlconfig , appname string ) string { appcurler : = helpersinternal . newappcurler ( curl , cfg ) return appcurler . curlandwait ( cfg , appname , " " , curl timeout ) } 
func generatepassword ( ) string { const randombyteslength = 16 encoding : = base64 . rawurlencoding randombytes : = make ( [ ] byte , encoding . decodedlen ( randombyteslength ) ) , err : = rand . read ( randombytes ) if err ! = nil { panic ( fmt . errorf ( " " , err . error ( ) ) ) } return " " + encoding . encodetostring ( randombytes ) } 
func gettags ( prefix rune , str string , terminator ... rune ) ( tags [ ] tag ) { if len ( terminator ) == 0 { terminator = [ ] rune ( " " ) } termindexes : = [ ] int { - 1 } for i , char : = range str { if isterminator ( char , terminator ... ) { termindexes = append ( termindexes , i ) } } termindexes = append ( termindexes , len ( str ) ) for i , t : = range termindexes { if t >= ( len ( str ) - 1 ) { break } if str [ t + 1 ] == byte ( prefix ) { tagtext : = strings . trimleft ( str [ t + 2 : termindexes [ i + 1 ] ] , string ( prefix ) ) if tagtext == " " { continue } index : = t + 1 tags = append ( tags , tag { prefix , tagtext , index } ) } } return } 
func gettagsasuniquestrings ( prefix rune , str string , terminator ... rune ) ( strs [ ] string ) { tags : = gettags ( prefix , str , terminator ... ) for , tag : = range tags { strs = append ( strs , tag . tag ) } return uniquify ( strs ) } 
func isterminator ( r rune , terminator ... rune ) bool { for , t : = range terminator { if r == t { return true } } return unicode . isspace ( r ) | | ! unicode . isprint ( r ) } 
func uniquify ( in [ ] string ) ( out [ ] string ) { for , i : = range in { if i == " " { continue } for , o : = range out { if i == o { continue } } out = append ( out , i ) } return } 
func ( r * repoinfo ) link ( ) string { switch r . repohost { case googlecode : return fmt . sprintf ( " " , r . fullname ) default : return ( & url . url { scheme : " " , host : string ( r . repohost ) , path : " " + r . fullname } ) . string ( ) } } 
func ( x * vcs ) scan ( v interface { } ) error { if data , ok : = v . ( [ ] byte ) ; ok { * x = vcs ( data ) return nil } return fmt . errorf ( " " , x , v ) } 
func new ( config config ) gin . handlerfunc { location : = newlocation ( config ) return func ( c * gin . context ) { location . applytocontext ( c ) } } 
func generatersakeypair ( bits int , src io . reader ) ( privkey , pubkey , error ) { if bits < 512 { return nil , nil , errrsakeytoosmall } priv , err : = rsa . generatekey ( src , bits ) if err ! = nil { return nil , nil , err } pk : = & priv . publickey return & rsaprivatekey { sk : priv } , & rsapublickey { pk } , nil } 
func ( pk * rsapublickey ) verify ( data , sig [ ] byte ) ( bool , error ) { hashed : = sha256 . sum256 ( data ) err : = rsa . verifypkcs1v15 ( pk . k , crypto . sha256 , hashed [ : ] , sig ) if err ! = nil { return false , err } return true , nil } 
func ( pk * rsapublickey ) encrypt ( b [ ] byte ) ( [ ] byte , error ) { return rsa . encryptpkcs1v15 ( rand . reader , pk . k , b ) } 
func ( sk * rsaprivatekey ) sign ( message [ ] byte ) ( [ ] byte , error ) { hashed : = sha256 . sum256 ( message ) return rsa . signpkcs1v15 ( rand . reader , sk . sk , crypto . sha256 , hashed [ : ] ) } 
func ( sk * rsaprivatekey ) getpublic ( ) pubkey { if sk . pk == nil { sk . pk = & sk . sk . publickey } return & rsapublickey { sk . pk } } 
func ( sk * rsaprivatekey ) decrypt ( b [ ] byte ) ( [ ] byte , error ) { return rsa . decryptpkcs1v15 ( rand . reader , sk . sk , b ) } 
func unmarshalrsaprivatekey ( b [ ] byte ) ( privkey , error ) { sk , err : = x509 . parsepkcs1privatekey ( b ) if err ! = nil { return nil , err } if sk . n . bitlen ( ) < 512 { return nil , errrsakeytoosmall } return & rsaprivatekey { sk : sk } , nil } 
func generatekeypair ( typ , bits int ) ( privkey , pubkey , error ) { return generatekeypairwithreader ( typ , bits , rand . reader ) } 
func generatekeypairwithreader ( typ , bits int , src io . reader ) ( privkey , pubkey , error ) { switch typ { case rsa : return generatersakeypair ( bits , src ) case ed25519 : return generateed25519key ( src ) case secp256k1 : return generatesecp256k1key ( src ) case ecdsa : return generateecdsakeypair ( src ) default : return nil , nil , errbadkeytype } } 
func generateekeypair ( curvename string ) ( [ ] byte , gensharedkey , error ) { var curve elliptic . curve switch curvename { case " " : curve = elliptic . p256 ( ) case " " : curve = elliptic . p384 ( ) case " " : curve = elliptic . p521 ( ) } priv , x , y , err : = elliptic . generatekey ( curve , rand . reader ) if err ! = nil { return nil , nil , err } pubkey : = elliptic . marshal ( curve , x , y ) done : = func ( theirpub [ ] byte ) ( [ ] byte , error ) { x , y : = elliptic . unmarshal ( curve , theirpub ) if x == nil { return nil , fmt . errorf ( " " , len ( theirpub ) , theirpub ) } if ! curve . isoncurve ( x , y ) { return nil , errors . new ( " " ) } secret , : = curve . scalarmult ( x , y , priv ) return secret . bytes ( ) , nil } return pubkey , done , nil } 
func unmarshalpublickey ( data [ ] byte ) ( pubkey , error ) { pmes : = new ( pb . publickey ) err : = proto . unmarshal ( data , pmes ) if err ! = nil { return nil , err } um , ok : = pubkeyunmarshallers [ pmes . gettype ( ) ] if ! ok { return nil , errbadkeytype } return um ( pmes . getdata ( ) ) } 
func marshalpublickey ( k pubkey ) ( [ ] byte , error ) { pbmes : = new ( pb . publickey ) pbmes . type = k . type ( ) data , err : = k . raw ( ) if err ! = nil { return nil , err } pbmes . data = data return proto . marshal ( pbmes ) } 
func unmarshalprivatekey ( data [ ] byte ) ( privkey , error ) { pmes : = new ( pb . privatekey ) err : = proto . unmarshal ( data , pmes ) if err ! = nil { return nil , err } um , ok : = privkeyunmarshallers [ pmes . gettype ( ) ] if ! ok { return nil , errbadkeytype } return um ( pmes . getdata ( ) ) } 
func marshalprivatekey ( k privkey ) ( [ ] byte , error ) { pbmes : = new ( pb . privatekey ) pbmes . type = k . type ( ) data , err : = k . raw ( ) if err ! = nil { return nil , err } pbmes . data = data return proto . marshal ( pbmes ) } 
func keyequal ( k1 , k2 key ) bool { if k1 == k2 { return true } b1 , err1 : = k1 . bytes ( ) b2 , err2 : = k2 . bytes ( ) return bytes . equal ( b1 , b2 ) && err1 == err2 } 
func generateecdsakeypair ( src io . reader ) ( privkey , pubkey , error ) { return generateecdsakeypairwithcurve ( ecdsacurve , src ) } 
func generateecdsakeypairwithcurve ( curve elliptic . curve , src io . reader ) ( privkey , pubkey , error ) { priv , err : = ecdsa . generatekey ( curve , src ) if err ! = nil { return nil , nil , err } return & ecdsaprivatekey { priv } , & ecdsapublickey { & priv . publickey } , nil } 
func ecdsakeypairfromkey ( priv * ecdsa . privatekey ) ( privkey , pubkey , error ) { if priv == nil { return nil , nil , errnilprivatekey } return & ecdsaprivatekey { priv } , & ecdsapublickey { & priv . publickey } , nil } 
func unmarshalecdsaprivatekey ( data [ ] byte ) ( privkey , error ) { priv , err : = x509 . parseecprivatekey ( data ) if err ! = nil { return nil , err } return & ecdsaprivatekey { priv } , nil } 
func unmarshalecdsapublickey ( data [ ] byte ) ( pubkey , error ) { pubifc , err : = x509 . parsepkixpublickey ( data ) if err ! = nil { return nil , err } pub , ok : = pubifc . ( * ecdsa . publickey ) if ! ok { return nil , errnotecdsapubkey } return & ecdsapublickey { pub } , nil } 
func ( epriv * ecdsaprivatekey ) equals ( o key ) bool { opriv , ok : = o . ( * ecdsaprivatekey ) if ! ok { return false } return epriv . priv . d . cmp ( opriv . priv . d ) == 0 } 
func ( epriv * ecdsaprivatekey ) sign ( data [ ] byte ) ( [ ] byte , error ) { hash : = sha256 . sum256 ( data ) r , s , err : = ecdsa . sign ( rand . reader , epriv . priv , hash [ : ] ) if err ! = nil { return nil , err } return asn1 . marshal ( ecdsasig { r : r , s : s , } ) } 
func ( epub * ecdsapublickey ) equals ( o key ) bool { opub , ok : = o . ( * ecdsapublickey ) if ! ok { return false } return epub . pub . x ! = nil && epub . pub . y ! = nil && opub . pub . x ! = nil && opub . pub . y ! = nil && 0 == epub . pub . x . cmp ( opub . pub . x ) && 0 == epub . pub . y . cmp ( opub . pub . y ) } 
func ( epub * ecdsapublickey ) verify ( data , sigbytes [ ] byte ) ( bool , error ) { sig : = new ( ecdsasig ) if , err : = asn1 . unmarshal ( sigbytes , sig ) ; err ! = nil { return false , err } if sig == nil { return false , errnilsig } hash : = sha256 . sum256 ( data ) return ecdsa . verify ( epub . pub , hash [ : ] , sig . r , sig . s ) , nil } 
func generatesecp256k1key ( src io . reader ) ( privkey , pubkey , error ) { privk , err : = btcec . newprivatekey ( btcec . s256 ( ) ) if err ! = nil { return nil , nil , err } k : = ( * secp256k1privatekey ) ( privk ) return k , k . getpublic ( ) , nil } 
func unmarshalsecp256k1privatekey ( data [ ] byte ) ( privkey , error ) { if len ( data ) ! = btcec . privkeybyteslen { return nil , fmt . errorf ( " " , btcec . privkeybyteslen ) } privk , : = btcec . privkeyfrombytes ( btcec . s256 ( ) , data ) return ( * secp256k1privatekey ) ( privk ) , nil } 
func unmarshalsecp256k1publickey ( data [ ] byte ) ( pubkey , error ) { k , err : = btcec . parsepubkey ( data , btcec . s256 ( ) ) if err ! = nil { return nil , err } return ( * secp256k1publickey ) ( k ) , nil } 
func ( k * secp256k1privatekey ) raw ( ) ( [ ] byte , error ) { return ( * btcec . privatekey ) ( k ) . serialize ( ) , nil } 
func ( k * secp256k1privatekey ) equals ( o key ) bool { sk , ok : = o . ( * secp256k1privatekey ) if ! ok { return false } return k . d . cmp ( sk . d ) == 0 } 
func ( k * secp256k1privatekey ) sign ( data [ ] byte ) ( [ ] byte , error ) { hash : = sha256 . sum256 ( data ) sig , err : = ( * btcec . privatekey ) ( k ) . sign ( hash [ : ] ) if err ! = nil { return nil , err } return sig . serialize ( ) , nil } 
func ( k * secp256k1publickey ) raw ( ) ( [ ] byte , error ) { return ( * btcec . publickey ) ( k ) . serializecompressed ( ) , nil } 
func ( k * secp256k1publickey ) equals ( o key ) bool { sk , ok : = o . ( * secp256k1publickey ) if ! ok { return false } return ( * btcec . publickey ) ( k ) . isequal ( ( * btcec . publickey ) ( sk ) ) } 
func ( k * secp256k1publickey ) verify ( data [ ] byte , sigstr [ ] byte ) ( bool , error ) { sig , err : = btcec . parsedersignature ( sigstr , btcec . s256 ( ) ) if err ! = nil { return false , err } hash : = sha256 . sum256 ( data ) return sig . verify ( hash [ : ] , ( * btcec . publickey ) ( k ) ) , nil } 
func ( k * ed25519privatekey ) raw ( ) ( [ ] byte , error ) { buf : = make ( [ ] byte , len ( k . k ) ) copy ( buf , k . k ) return buf , nil } 
func ( k * ed25519privatekey ) sign ( msg [ ] byte ) ( [ ] byte , error ) { return ed25519 . sign ( k . k , msg ) , nil } 
func ( k * ed25519publickey ) equals ( o key ) bool { edk , ok : = o . ( * ed25519publickey ) if ! ok { return false } return bytes . equal ( k . k , edk . k ) } 
func ( k * ed25519publickey ) verify ( data [ ] byte , sig [ ] byte ) ( bool , error ) { return ed25519 . verify ( k . k , data , sig ) , nil } 
func unmarshaled25519publickey ( data [ ] byte ) ( pubkey , error ) { if len ( data ) ! = 32 { return nil , errors . new ( " " ) } return & ed25519publickey { k : ed25519 . publickey ( data ) , } , nil } 
func unmarshaled25519privatekey ( data [ ] byte ) ( privkey , error ) { switch len ( data ) { case ed25519 . privatekeysize + ed25519 . publickeysize : redundantpk : = data [ ed25519 . privatekeysize : ] pk : = data [ ed25519 . privatekeysize - ed25519 . publickeysize : ed25519 . privatekeysize ] if ! bytes . equal ( pk , redundantpk ) { return nil , errors . new ( " " ) } newkey : = make ( [ ] byte , ed25519 . privatekeysize ) copy ( newkey , data [ : ed25519 . privatekeysize ] ) data = newkey case ed25519 . privatekeysize : default : return nil , fmt . errorf ( " " , ed25519 . privatekeysize , ed25519 . privatekeysize + ed25519 . publickeysize , len ( data ) , ) } return & ed25519privatekey { k : ed25519 . privatekey ( data ) , } , nil } 
func distanceforstrings ( source [ ] rune , target [ ] rune , op options ) int { height : = len ( source ) + 1 width : = len ( target ) + 1 matrix : = make ( [ ] [ ] int , 2 ) for i : = 0 ; i < 2 ; i ++ { matrix [ i ] = make ( [ ] int , width ) matrix [ i ] [ 0 ] = i } for j : = 1 ; j < width ; j ++ { matrix [ 0 ] [ j ] = j } for i : = 1 ; i < height ; i ++ { cur : = matrix [ i % 2 ] prev : = matrix [ ( i - 1 ) % 2 ] cur [ 0 ] = i for j : = 1 ; j < width ; j ++ { delcost : = prev [ j ] + op . delcost matchsubcost : = prev [ j - 1 ] if ! op . matches ( source [ i - 1 ] , target [ j - 1 ] ) { matchsubcost += op . subcost } inscost : = cur [ j - 1 ] + op . inscost cur [ j ] = min ( delcost , min ( matchsubcost , inscost ) ) } } return matrix [ ( height - 1 ) % 2 ] [ width - 1 ] } 
func ratioforstrings ( source [ ] rune , target [ ] rune , op options ) float64 { matrix : = matrixforstrings ( source , target , op ) return ratioformatrix ( matrix ) } 
func ratioformatrix ( matrix [ ] [ ] int ) float64 { sourcelength : = len ( matrix ) - 1 targetlength : = len ( matrix [ 0 ] ) - 1 sum : = sourcelength + targetlength if sum == 0 { return 0 } dist : = distanceformatrix ( matrix ) return float64 ( sum - dist ) / float64 ( sum ) } 
func editscriptforstrings ( source [ ] rune , target [ ] rune , op options ) editscript { return backtrace ( len ( source ) , len ( target ) , matrixforstrings ( source , target , op ) , op ) } 
func editscriptformatrix ( matrix [ ] [ ] int , op options ) editscript { return backtrace ( len ( matrix ) - 1 , len ( matrix [ 0 ] ) - 1 , matrix , op ) } 
func writematrix ( source [ ] rune , target [ ] rune , matrix [ ] [ ] int , writer io . writer ) { fmt . fprintf ( writer , " " ) for , targetrune : = range target { fmt . fprintf ( writer , " " , targetrune ) } fmt . fprintf ( writer , " \n " ) fmt . fprintf ( writer , " " , matrix [ 0 ] [ 0 ] ) for j , : = range target { fmt . fprintf ( writer , " " , matrix [ 0 ] [ j + 1 ] ) } fmt . fprintf ( writer , " \n " ) for i , sourcerune : = range source { fmt . fprintf ( writer , " " , sourcerune , matrix [ i + 1 ] [ 0 ] ) for j , : = range target { fmt . fprintf ( writer , " " , matrix [ i + 1 ] [ j + 1 ] ) } fmt . fprintf ( writer , " \n " ) } } 
func logmatrix ( source [ ] rune , target [ ] rune , matrix [ ] [ ] int ) { writematrix ( source , target , matrix , os . stderr ) } 
func new ( path string ) ( lockfile , error ) { if ! filepath . isabs ( path ) { return lockfile ( " " ) , errneedabspath } return lockfile ( path ) , nil } 
func ( l lockfile ) getowner ( ) ( * os . process , error ) { name : = string ( l ) content , err : = ioutil . readfile ( name ) if err ! = nil { return nil , err } pid , err : = scanpidline ( content ) if err ! = nil { return nil , err } running , err : = isrunning ( pid ) if err ! = nil { return nil , err } if running { proc , err : = os . findprocess ( pid ) if err ! = nil { return nil , err } return proc , nil } return nil , errdeadowner } 
func ( l lockfile ) unlock ( ) error { proc , err : = l . getowner ( ) switch err { case errinvalidpid , errdeadowner : return errroguedeletion case nil : if proc . pid == os . getpid ( ) { return os . remove ( string ( l ) ) } return errroguedeletion default : if os . isnotexist ( err ) { return errroguedeletion } return err } } 
func newbase ( configs ... baseconfigfunc ) * base { b : = & base { clock : glock . newrealclock ( ) , config : newconfig ( ) , loglevel : leveldebug , sequence : 0 , baseattrs : newattrs ( ) , loggers : make ( [ ] logger , 0 ) , hookprequeue : make ( [ ] hookprequeue , 0 ) , } for , f : = range configs { f ( b ) } return b } 
func ( b * base ) setfallbacklogger ( logger logger ) error { if logger == nil { if b . fallbacklogger ! = nil && b . fallbacklogger . isinitialized ( ) { b . fallbacklogger . shutdownlogger ( ) } b . fallbacklogger = nil return nil } if ! logger . isinitialized ( ) { err : = logger . initlogger ( ) if err ! = nil { return err } } if b . fallbacklogger ! = nil && b . fallbacklogger . isinitialized ( ) { b . fallbacklogger . shutdownlogger ( ) } b . fallbacklogger = logger return nil } 
func ( b * base ) addlogger ( logger logger ) error { if b . isinitialized ( ) && ! logger . isinitialized ( ) { err : = logger . initlogger ( ) if err ! = nil { return err } } else if ! b . isinitialized ( ) && logger . isinitialized ( ) { err : = logger . shutdownlogger ( ) if err ! = nil { return err } } b . loggers = append ( b . loggers , logger ) if hook , ok : = logger . ( hookprequeue ) ; ok { b . hookprequeue = append ( b . hookprequeue , hook ) } logger . setbase ( b ) return nil } 
func ( b * base ) removelogger ( logger logger ) error { for idx , rlogger : = range b . loggers { if rlogger == logger { err : = rlogger . shutdownlogger ( ) if err ! = nil { return err } b . loggers [ idx ] = b . loggers [ len ( b . loggers ) - 1 ] b . loggers [ len ( b . loggers ) - 1 ] = nil b . loggers = b . loggers [ : len ( b . loggers ) - 1 ] return nil } } for idx , hooklogger : = range b . hookprequeue { if hooklogger == logger { b . hookprequeue [ idx ] = b . hookprequeue [ len ( b . hookprequeue ) - 1 ] b . hookprequeue [ len ( b . hookprequeue ) - 1 ] = nil b . hookprequeue = b . hookprequeue [ : len ( b . hookprequeue ) - 1 ] } } return nil } 
func ( b * base ) clearloggers ( ) error { for , logger : = range b . loggers { err : = logger . shutdownlogger ( ) if err ! = nil { return err } } b . loggers = make ( [ ] logger , 0 ) b . hookprequeue = make ( [ ] hookprequeue , 0 ) return nil } 
func ( b * base ) initloggers ( ) error { if b . queue == nil { b . queue = newqueue ( b , b . config . maxqueuesize ) } for , logger : = range b . loggers { err : = logger . initlogger ( ) if err ! = nil { return err } } b . queue . startworker ( ) b . isinitialized = true return nil } 
func ( b * base ) shutdownloggers ( ) error { b . flush ( ) for , logger : = range b . loggers { err : = logger . shutdownlogger ( ) if err ! = nil { return err } } if b . queue ! = nil { b . queue . stopworker ( ) b . queue = nil } if b . errorchan ! = nil { close ( b . errorchan ) b . errorchan = nil } b . isinitialized = false return nil } 
func ( b * base ) setattr ( key string , value interface { } ) { b . baseattrs . setattr ( key , value ) } 
func ( b * base ) logwithtime ( level loglevel , ts time . time , m * attrs , msg string , a ... interface { } ) error { if ! b . shouldlog ( level ) { return nil } if ! b . isinitialized { return errnotinitialized } if len ( b . config . filenameattr ) > 0 | | len ( b . config . linenumberattr ) > 0 { file , line : = getcallerinfo ( ) if m == nil { m = newattrs ( ) } if len ( b . config . filenameattr ) > 0 { m . setattr ( b . config . filenameattr , file ) } if len ( b . config . linenumberattr ) > 0 { m . setattr ( b . config . linenumberattr , line ) } } if len ( b . config . sequenceattr ) > 0 { if m == nil { m = newattrs ( ) } seq : = atomic . adduint64 ( & b . sequence , 1 ) m . setattr ( b . config . sequenceattr , seq ) } nm : = newmessage ( ts , b , level , m , msg , a ... ) for , hook : = range b . hookprequeue { err : = hook . prequeue ( nm ) if err ! = nil { return err } } return b . queue . queuemessage ( nm ) } 
func ( b * base ) log ( level loglevel , m * attrs , msg string , a ... interface { } ) error { return b . logwithtime ( level , b . clock . now ( ) , m , msg , a ... ) } 
func ( b * base ) dbgf ( msg string , a ... interface { } ) error { return b . debugf ( msg , a ... ) } 
func ( b * base ) debug ( msg string ) error { return b . log ( leveldebug , nil , msg ) } 
func ( b * base ) debugf ( msg string , a ... interface { } ) error { return b . log ( leveldebug , nil , msg , a ... ) } 
func ( b * base ) debugm ( m * attrs , msg string , a ... interface { } ) error { return b . log ( leveldebug , m , msg , a ... ) } 
func ( b * base ) info ( msg string ) error { return b . log ( levelinfo , nil , msg ) } 
func ( b * base ) infof ( msg string , a ... interface { } ) error { return b . log ( levelinfo , nil , msg , a ... ) } 
func ( b * base ) infom ( m * attrs , msg string , a ... interface { } ) error { return b . log ( levelinfo , m , msg , a ... ) } 
func ( b * base ) warnf ( msg string , a ... interface { } ) error { return b . warningf ( msg , a ... ) } 
func ( b * base ) warnm ( m * attrs , msg string , a ... interface { } ) error { return b . warningm ( m , msg , a ... ) } 
func ( b * base ) warning ( msg string ) error { return b . log ( levelwarning , nil , msg ) } 
func ( b * base ) warningf ( msg string , a ... interface { } ) error { return b . log ( levelwarning , nil , msg , a ... ) } 
func ( b * base ) warningm ( m * attrs , msg string , a ... interface { } ) error { return b . log ( levelwarning , m , msg , a ... ) } 
func ( b * base ) errf ( msg string , a ... interface { } ) error { return b . errorf ( msg , a ... ) } 
func ( b * base ) error ( msg string ) error { return b . log ( levelerror , nil , msg ) } 
func ( b * base ) errorf ( msg string , a ... interface { } ) error { return b . log ( levelerror , nil , msg , a ... ) } 
func ( b * base ) errorm ( m * attrs , msg string , a ... interface { } ) error { return b . log ( levelerror , m , msg , a ... ) } 
func ( b * base ) fatal ( msg string ) error { return b . log ( levelfatal , nil , msg ) } 
func ( b * base ) fatalf ( msg string , a ... interface { } ) error { return b . log ( levelfatal , nil , msg , a ... ) } 
func ( b * base ) fatalm ( m * attrs , msg string , a ... interface { } ) error { return b . log ( levelfatal , m , msg , a ... ) } 
func ( b * base ) die ( exitcode int , msg string ) { b . log ( levelfatal , nil , msg ) b . shutdownloggers ( ) curexiter . exit ( exitcode ) } 
func ( b * base ) diem ( exitcode int , m * attrs , msg string , a ... interface { } ) { b . log ( levelfatal , m , msg , a ... ) b . shutdownloggers ( ) curexiter . exit ( exitcode ) } 
func newtemplatewithfuncmap ( tpl string , funcmap template . funcmap ) ( * template , error ) { var levels = [ ] loglevel { levelnone , leveldebug , levelinfo , levelwarning , levelerror , levelfatal } tpls : = make ( map [ loglevel ] * template . template , 0 ) for , level : = range levels { , forcereset : = funcmap [ " " ] fmap : = getfuncmap ( level , forcereset ) for name , f : = range funcmap { fmap [ name ] = f } parsedtpl , err : = template . new ( getlevelname ( level ) ) . funcs ( fmap ) . parse ( tpl ) if err ! = nil { return nil , err } tpls [ level ] = parsedtpl } newtpl : = & template { tpls : tpls , } return newtpl , nil } 
func ( t * template ) execute ( msg * templatemsg , colorize bool ) ( string , error ) { tpllevel : = msg . level if ! colorize { tpllevel = levelnone } var buf bytes . buffer exectpl : = t . tpls [ tpllevel ] if exectpl == nil { return " " , errunknownlevel } err : = exectpl . execute ( & buf , msg ) if err ! = nil { return " " , err } return buf . string ( ) , nil } 
func newtemplatemsg ( timestamp time . time , level loglevel , m map [ string ] interface { } , msg string ) * templatemsg { msgattrs : = m if msgattrs == nil { msgattrs = make ( map [ string ] interface { } ) } tplmsg : = & templatemsg { timestamp : timestamp , message : msg , level : level , levelname : level . string ( ) , attrs : msgattrs , } return tplmsg } 
func newlogadapterfor ( base wrappablelogger , attrs * attrs ) * logadapter { if attrs == nil { attrs = newattrs ( ) } return & logadapter { base : base , attrs : attrs , } } 
func ( la * logadapter ) setattr ( key string , value interface { } ) { la . attrs . setattr ( key , value ) } 
func ( la * logadapter ) logwithtime ( level loglevel , ts time . time , attrs * attrs , msg string , a ... interface { } ) error { if la . loglevel ! = nil && level > * la . loglevel { return nil } mergedattrs : = la . attrs . clone ( ) mergedattrs . mergeattrs ( attrs ) return la . base . logwithtime ( level , ts , mergedattrs , msg , a ... ) } 
func ( la * logadapter ) log ( level loglevel , attrs * attrs , msg string , a ... interface { } ) error { if la . loglevel ! = nil && level > * la . loglevel { return nil } mergedattrs : = la . attrs . clone ( ) mergedattrs . mergeattrs ( attrs ) return la . base . log ( level , mergedattrs , msg , a ... ) } 
func ( la * logadapter ) dbgf ( msg string , a ... interface { } ) error { return la . debugf ( msg , a ... ) } 
func ( la * logadapter ) dbgm ( m * attrs , msg string , a ... interface { } ) error { return la . debugm ( m , msg , a ... ) } 
func ( la * logadapter ) debug ( msg string ) error { return la . log ( leveldebug , nil , msg ) } 
func ( la * logadapter ) debugf ( msg string , a ... interface { } ) error { return la . log ( leveldebug , nil , msg , a ... ) } 
func ( la * logadapter ) debugm ( m * attrs , msg string , a ... interface { } ) error { return la . log ( leveldebug , m , msg , a ... ) } 
func ( la * logadapter ) info ( msg string ) error { return la . log ( levelinfo , nil , msg ) } 
func ( la * logadapter ) infof ( msg string , a ... interface { } ) error { return la . log ( levelinfo , nil , msg , a ... ) } 
func ( la * logadapter ) infom ( m * attrs , msg string , a ... interface { } ) error { return la . log ( levelinfo , m , msg , a ... ) } 
func ( la * logadapter ) warnf ( msg string , a ... interface { } ) error { return la . warningf ( msg , a ... ) } 
func ( la * logadapter ) warning ( msg string ) error { return la . log ( levelwarning , nil , msg ) } 
func ( la * logadapter ) warningf ( msg string , a ... interface { } ) error { return la . log ( levelwarning , nil , msg , a ... ) } 
func ( la * logadapter ) warningm ( m * attrs , msg string , a ... interface { } ) error { return la . log ( levelwarning , m , msg , a ... ) } 
func ( la * logadapter ) errf ( msg string , a ... interface { } ) error { return la . errorf ( msg , a ... ) } 
func ( la * logadapter ) error ( msg string ) error { return la . log ( levelerror , nil , msg ) } 
func ( la * logadapter ) errorf ( msg string , a ... interface { } ) error { return la . log ( levelerror , nil , msg , a ... ) } 
func ( la * logadapter ) errorm ( m * attrs , msg string , a ... interface { } ) error { return la . log ( levelerror , m , msg , a ... ) } 
func ( la * logadapter ) fatal ( msg string ) error { return la . log ( levelfatal , nil , msg ) } 
func ( la * logadapter ) fatalf ( msg string , a ... interface { } ) error { return la . log ( levelfatal , nil , msg , a ... ) } 
func ( la * logadapter ) fatalm ( m * attrs , msg string , a ... interface { } ) error { return la . log ( levelfatal , m , msg , a ... ) } 
func ( la * logadapter ) die ( exitcode int , msg string ) { la . log ( levelfatal , nil , msg ) la . base . shutdownloggers ( ) curexiter . exit ( exitcode ) } 
func ( la * logadapter ) diem ( exitcode int , m * attrs , msg string , a ... interface { } ) { la . log ( levelfatal , m , msg , a ... ) la . base . shutdownloggers ( ) curexiter . exit ( exitcode ) } 
func newattrsfrommap ( attrs map [ string ] interface { } ) * attrs { newattrs : = newattrs ( ) for attrkey , attrval : = range attrs { newattrs . setattr ( attrkey , attrval ) } return newattrs } 
func newattrsfromattrs ( attrs ... * attrs ) * attrs { newattrs : = newattrs ( ) for , attr : = range attrs { newattrs . mergeattrs ( attr ) } return newattrs } 
func ( a * attrs ) mergeattrs ( attrs * attrs ) { if attrs == nil { return } a . attrslock . lock ( ) defer a . attrslock . unlock ( ) for hash , val : = range attrs . attrs { a . attrs [ hash ] = val } } 
func ( a * attrs ) setattr ( key string , value interface { } ) * attrs { a . attrslock . lock ( ) defer a . attrslock . unlock ( ) valval : = reflect . valueof ( value ) switch valval . kind ( ) { case reflect . func : value = valval . type ( ) . string ( ) } hash : = getattrhash ( key ) a . attrs [ hash ] = value return a } 
func ( a * attrs ) getattr ( key string ) interface { } { a . attrslock . rlock ( ) defer a . attrslock . runlock ( ) return a . attrs [ getattrhash ( key ) ] } 
func ( a * attrs ) removeattr ( key string ) { a . attrslock . lock ( ) defer a . attrslock . unlock ( ) delete ( a . attrs , getattrhash ( key ) ) } 
func ( a * attrs ) attrs ( ) map [ string ] interface { } { a . attrslock . rlock ( ) defer a . attrslock . runlock ( ) attrs : = make ( map [ string ] interface { } ) for hash , val : = range a . attrs { key , : = gethashattr ( hash ) attrs [ key ] = val } return attrs } 
func debugm ( m * attrs , msg string , a ... interface { } ) error { return curdefault . debugm ( m , msg , a ... ) } 
func infom ( m * attrs , msg string , a ... interface { } ) error { return curdefault . infom ( m , msg , a ... ) } 
func warningm ( m * attrs , msg string , a ... interface { } ) error { return curdefault . warningm ( m , msg , a ... ) } 
func errm ( m * attrs , msg string , a ... interface { } ) error { return errorm ( m , msg , a ... ) } 
func errorm ( m * attrs , msg string , a ... interface { } ) error { return curdefault . errorm ( m , msg , a ... ) } 
func fatalm ( m * attrs , msg string , a ... interface { } ) error { return curdefault . fatalm ( m , msg , a ... ) } 
func dief ( exitcode int , msg string , a ... interface { } ) { curdefault . dief ( exitcode , msg , a ... ) } 
func diem ( exitcode int , m * attrs , msg string , a ... interface { } ) { curdefault . diem ( exitcode , m , msg , a ... ) } 
func tologlevel ( level string ) ( loglevel , error ) { lowlevel : = strings . tolower ( level ) switch lowlevel { case " " : fallthrough case " " : return leveldebug , nil case " " : return levelinfo , nil case " " : fallthrough case " " : return levelwarning , nil case " " : fallthrough case " " : return levelerror , nil case " " : return levelfatal , nil case " " : return levelnone , nil } return 0 , errunknownlevel } 
func run ( run func ( ) ) { callqueue = make ( chan func ( ) , callqueuecap ) done : = make ( chan struct { } ) go func ( ) { run ( ) done < - struct { } { } } ( ) for { select { case f : = < - callqueue : f ( ) case < - done : return } } } 
func callerr ( f func ( ) error ) error { checkrun ( ) errchan : = make ( chan error ) callqueue < - func ( ) { errchan < - f ( ) } return < - errchan } 
func new ( opts ... option ) ( * stackdriverhook , error ) { var err error sh : = & stackdriverhook { levels : logrus . alllevels , } for , o : = range opts { err = o ( sh ) if err ! = nil { return nil , err } } if sh . service == nil && sh . agentclient == nil { return nil , errors . new ( " " ) } if sh . resource == nil && sh . agentclient == nil { return nil , errors . new ( " " ) } if sh . projectid == " " && sh . agentclient == nil { return nil , errors . new ( " " ) } if sh . logname == " " { err = logname ( defaultname ) ( sh ) if err ! = nil { return nil , err } } if sh . errorreportinglogname == " " { sh . errorreportinglogname = sh . logname + " " } return sh , nil } 
func ( sh * stackdriverhook ) fire ( entry * logrus . entry ) error { sh . waitgroup . add ( 1 ) go func ( entry * logrus . entry ) { defer sh . waitgroup . done ( ) var httpreq * logging . httprequest labels : = make ( map [ string ] string , len ( entry . data ) ) for k , v : = range entry . data { switch x : = v . ( type ) { case string : labels [ k ] = x case * http . request : httpreq = & logging . httprequest { referer : x . referer ( ) , remoteip : x . remoteaddr , requestmethod : x . method , requesturl : x . url . string ( ) , useragent : x . useragent ( ) , } case * logging . httprequest : httpreq = x default : labels [ k ] = fmt . sprintf ( " " , v ) } } if sh . agentclient ! = nil { sh . sendlogmessageviaagent ( entry , labels , httpreq ) } else { sh . sendlogmessageviaapi ( entry , labels , httpreq ) } } ( sh . copyentry ( entry ) ) return nil } 
func levels ( levels ... logrus . level ) option { return func ( sh * stackdriverhook ) error { sh . levels = levels return nil } } 
func projectid ( projectid string ) option { return func ( sh * stackdriverhook ) error { sh . projectid = projectid return nil } } 
func entriesservice ( service * logging . entriesservice ) option { return func ( sh * stackdriverhook ) error { sh . service = service return nil } } 
func loggingservice ( service * logging . service ) option { return func ( sh * stackdriverhook ) error { sh . service = service . entries return nil } } 
func errorservice ( errorservice * errorreporting . service ) option { return func ( sh * stackdriverhook ) error { sh . errorservice = errorservice return nil } } 
func monitoredresource ( resource * logging . monitoredresource ) option { return func ( sh * stackdriverhook ) error { sh . resource = resource return nil } } 
func logname ( name string ) option { return func ( sh * stackdriverhook ) error { if sh . projectid == " " { sh . logname = name } else { sh . logname = fmt . sprintf ( " " , sh . projectid , name ) } return nil } } 
func errorreportinglogname ( name string ) option { return func ( sh * stackdriverhook ) error { sh . errorreportinglogname = name return nil } } 
func labels ( labels map [ string ] string ) option { return func ( sh * stackdriverhook ) error { sh . labels = labels return nil } } 
func partialsuccess ( enabled bool ) option { return func ( sh * stackdriverhook ) error { sh . partialsuccess = enabled return nil } } 
func googlecomputecredentials ( serviceaccount string ) option { return func ( sh * stackdriverhook ) error { var err error scopes , err : = metadata . scopes ( serviceaccount ) if err ! = nil { return err } for , s : = range requiredscopes { if ! slicecontains ( scopes , s ) { return fmt . errorf ( " " , s ) } } return httpclient ( & http . client { transport : & oauth2 . transport { source : google . computetokensource ( serviceaccount ) , } , } ) ( sh ) } } 
func ( c codec ) newencoder ( w io . writer ) * encoder { return newencoder ( c . newemitter ( w ) ) } 
func ( c codec ) newdecoder ( r io . reader ) * decoder { return newdecoder ( c . newparser ( r ) ) } 
func ( c codec ) newstreamencoder ( w io . writer ) * streamencoder { return newstreamencoder ( c . newemitter ( w ) ) } 
func ( c codec ) newstreamdecoder ( r io . reader ) * streamdecoder { return newstreamdecoder ( c . newparser ( r ) ) } 
func ( reg * registry ) register ( mimetype string , codec codec ) { defer reg . mutex . unlock ( ) reg . mutex . lock ( ) if reg . codecs == nil { reg . codecs = make ( map [ string ] codec ) } reg . codecs [ mimetype ] = codec } 
func ( reg * registry ) unregister ( mimetype string ) { defer reg . mutex . unlock ( ) reg . mutex . lock ( ) delete ( reg . codecs , mimetype ) } 
func ( reg * registry ) lookup ( mimetype string ) ( codec codec , ok bool ) { reg . mutex . rlock ( ) codec , ok = reg . codecs [ mimetype ] reg . mutex . runlock ( ) return } 
func ( reg * registry ) codecs ( ) ( codecs map [ string ] codec ) { codecs = make ( map [ string ] codec ) reg . mutex . rlock ( ) for mimetype , codec : = range reg . codecs { codecs [ mimetype ] = codec } reg . mutex . runlock ( ) return } 
func ( e * error ) type ( ) string { s : = e . error ( ) if i : = strings . indexbyte ( s , ' ' ) ; i < 0 { s = " " } else { s = s [ : i ] for , c : = range s { if ! unicode . isupper ( c ) { s = " " break } } } return s } 
func parseint ( b [ ] byte ) ( int64 , error ) { var val int64 if len ( b ) == 0 { return 0 , errorinvaliduint64 ( b ) } if b [ 0 ] == ' - ' { const max = int64min const lim = max / 10 if b = b [ 1 : ] ; len ( b ) == 0 { return 0 , errorinvaliduint64 ( b ) } for , d : = range b { if ! ( d >= ' 0 ' && d <= ' 9 ' ) { return 0 , errorinvalidint64 ( b ) } if val < lim { return 0 , erroroverflowint64 ( b ) } val * = 10 x : = int64 ( d - ' 0 ' ) if val < ( max + x ) { return 0 , erroroverflowint64 ( b ) } val - = x } } else { const max = int64max const lim = max / 10 for , d : = range b { if ! ( d >= ' 0 ' && d <= ' 9 ' ) { return 0 , errorinvalidint64 ( b ) } x : = int64 ( d - ' 0 ' ) if val > lim { return 0 , erroroverflowint64 ( b ) } if val * = 10 ; val > ( max - x ) { return 0 , erroroverflowint64 ( b ) } val += x } } return val , nil } 
func parseuinthex ( b [ ] byte ) ( uint64 , error ) { const max = uint64max const lim = max / 0x10 var val uint64 if len ( b ) == 0 { return 0 , errorinvaliduint64 ( b ) } for , d : = range b { var x uint64 switch { case d >= ' 0 ' && d <= ' 9 ' : x = uint64 ( d - ' 0 ' ) case d >= ' a ' && d <= ' f ' : x = uint64 ( d - ' a ' ) + 0xa case d >= ' a ' && d <= ' f ' : x = uint64 ( d - ' a ' ) + 0xa default : return 0 , errorinvaliduint64 ( b ) } if val > lim { return 0 , erroroverflowuint64 ( b ) } if val * = 0x10 ; val > ( max - x ) { return 0 , erroroverflowuint64 ( b ) } val += x } return val , nil } 
func install ( typ reflect . type , adapter adapter ) { if adapter . encode == nil { panic ( " " ) } if adapter . decode == nil { panic ( " " ) } adaptermutex . lock ( ) adapterstore [ typ ] = adapter adaptermutex . unlock ( ) structcache . clear ( ) } 
func adapterof ( typ reflect . type ) ( a adapter , ok bool ) { adaptermutex . rlock ( ) a , ok = adapterstore [ typ ] adaptermutex . runlock ( ) return } 
func appendduration ( b [ ] byte , d time . duration ) [ ] byte { var buf [ 32 ] byte w : = len ( buf ) u : = uint64 ( d ) neg : = d < 0 if neg { u = - u } if u < uint64 ( time . second ) { var prec int w -- buf [ w ] = ' s ' w -- switch { case u == 0 : return append ( b , ' 0 ' , ' s ' ) case u < uint64 ( time . microsecond ) : prec = 0 buf [ w ] = ' n ' case u < uint64 ( time . millisecond ) : prec = 3 w -- copy ( buf [ w : ] , " ) default : prec = 6 buf [ w ] = ' m ' } w , u = fmtfrac ( buf [ : w ] , u , prec ) w = fmtint ( buf [ : w ] , u ) } else { w -- buf [ w ] = ' s ' w , u = fmtfrac ( buf [ : w ] , u , 9 ) w = fmtint ( buf [ : w ] , u % 60 ) u / = 60 if u > 0 { w -- buf [ w ] = ' m ' w = fmtint ( buf [ : w ] , u % 60 ) u / = 60 if u > 0 { w -- buf [ w ] = ' h ' w = fmtint ( buf [ : w ] , u ) } } } if neg { w -- buf [ w ] = ' - ' } return append ( b , buf [ w : ] ... ) } 
func fmtfrac ( buf [ ] byte , v uint64 , prec int ) ( nw int , nv uint64 ) { w : = len ( buf ) print : = false for i : = 0 ; i < prec ; i ++ { digit : = v % 10 print = print | | digit ! = 0 if print { w -- buf [ w ] = byte ( digit ) + ' 0 ' } v / = 10 } if print { w -- buf [ w ] = ' . ' } return w , v } 
func fmtint ( buf [ ] byte , v uint64 ) int { w : = len ( buf ) if v == 0 { w -- buf [ w ] = ' 0 ' } else { for v > 0 { w -- buf [ w ] = byte ( v % 10 ) + ' 0 ' v / = 10 } } return w } 
func newdecoder ( r io . reader ) * objconv . decoder { return objconv . newdecoder ( newparser ( r ) ) } 
func newstreamdecoder ( r io . reader ) * objconv . streamdecoder { return objconv . newstreamdecoder ( newparser ( r ) ) } 
func unmarshal ( b [ ] byte , v interface { } ) error { u : = unmarshalerpool . get ( ) . ( * unmarshaler ) u . reset ( b ) err : = ( objconv . decoder { parser : u } ) . decode ( v ) u . reset ( nil ) unmarshalerpool . put ( u ) return err } 
func ( t type ) string ( ) string { switch t { case nil : return " " case bool : return " " case int : return " " case uint : return " " case float : return " " case string : return " " case bytes : return " " case time : return " " case duration : return " " case error : return " " case array : return " " case map : return " " default : return " " } } 
func zerovalueof ( t reflect . type ) reflect . value { zeromutex . rlock ( ) v , ok : = zerocache [ t ] zeromutex . runlock ( ) if ! ok { v = reflect . zero ( t ) zeromutex . lock ( ) zerocache [ t ] = v zeromutex . unlock ( ) } return v } 
func newvalueparser ( v interface { } ) * valueparser { return & valueparser { stack : [ ] reflect . value { reflect . valueof ( v ) } , } } 
func parsetag ( s string ) tag { var name string var omitzero bool var omitempty bool name , s = parsenexttagtoken ( s ) for len ( s ) ! = 0 { var token string switch token , s = parsenexttagtoken ( s ) ; token { case " " : omitempty = true case " " : omitzero = true } } return tag { name : name , omitempty : omitempty , omitzero : omitzero , } } 
func parsetagjson ( s string ) tag { var name string var omitempty bool name , s = parsenexttagtoken ( s ) for len ( s ) ! = 0 { var token string switch token , s = parsenexttagtoken ( s ) ; token { case " " : omitempty = true } } return tag { name : name , omitempty : omitempty , } } 
func newencoder ( w io . writer ) * objconv . encoder { return objconv . newencoder ( newemitter ( w ) ) } 
func newstreamencoder ( w io . writer ) * objconv . streamencoder { return objconv . newstreamencoder ( newemitter ( w ) ) } 
func newprettyencoder ( w io . writer ) * objconv . encoder { return objconv . newencoder ( newprettyemitter ( w ) ) } 
func newprettystreamencoder ( w io . writer ) * objconv . streamencoder { return objconv . newstreamencoder ( newprettyemitter ( w ) ) } 
func marshal ( v interface { } ) ( b [ ] byte , err error ) { m : = marshalerpool . get ( ) . ( * marshaler ) m . b . truncate ( 0 ) if err = ( objconv . encoder { emitter : m } ) . encode ( v ) ; err == nil { b = make ( [ ] byte , m . b . len ( ) ) copy ( b , m . b . bytes ( ) ) } marshalerpool . put ( m ) return } 
func newencoder ( e emitter ) * encoder { if e == nil { panic ( " " ) } return & encoder { emitter : e } } 
func ( e encoder ) encodearray ( n int , f func ( encoder ) error ) ( err error ) { if e . key { if e . key , err = false , e . emitter . emitmapvalue ( ) ; err ! = nil { return } } if err = e . emitter . emitarraybegin ( n ) ; err ! = nil { return } encodearray : for i : = 0 ; n < 0 | | i < n ; i ++ { if i ! = 0 { if e . emitter . emitarraynext ( ) ; err ! = nil { return } } switch err = f ( e ) ; err { case nil : case end : break encodearray default : return } } return e . emitter . emitarrayend ( ) } 
func ( e encoder ) encodemap ( n int , f func ( encoder , encoder ) error ) ( err error ) { if e . key { if e . key , err = false , e . emitter . emitmapvalue ( ) ; err ! = nil { return } } if err = e . emitter . emitmapbegin ( n ) ; err ! = nil { return } encodemap : for i : = 0 ; n < 0 | | i < n ; i ++ { if i ! = 0 { if err = e . emitter . emitmapnext ( ) ; err ! = nil { return } } e . key = true err = f ( encoder { emitter : e . emitter , sortmapkeys : e . sortmapkeys } , encoder { emitter : e . emitter , sortmapkeys : e . sortmapkeys , key : true } , ) e . key = false switch err { case nil : case end : break encodemap default : return } } return e . emitter . emitmapend ( ) } 
func newstreamencoder ( e emitter ) * streamencoder { if e == nil { panic ( " " ) } return & streamencoder { emitter : e } } 
func ( e * streamencoder ) open ( n int ) error { if err : = e . err ; err ! = nil { return err } if e . closed { return io . errclosedpipe } if ! e . opened { e . max = n e . opened = true if ! e . oneshot { e . err = e . emitter . emitarraybegin ( n ) } } return e . err } 
func ( e * streamencoder ) close ( ) error { if ! e . closed { if err : = e . open ( - 1 ) ; err ! = nil { return err } e . closed = true if ! e . oneshot { e . err = e . emitter . emitarrayend ( ) } } return e . err } 
func ( e * streamencoder ) encode ( v interface { } ) error { if err : = e . open ( - 1 ) ; err ! = nil { return err } if e . max >= 0 && e . cnt >= e . max { return fmt . errorf ( " " , e . max ) } if ! e . oneshot && e . cnt ! = 0 { e . err = e . emitter . emitarraynext ( ) } if e . err == nil { e . err = ( encoder { emitter : e . emitter , sortmapkeys : e . sortmapkeys , } ) . encode ( v ) if e . cnt ++ ; e . max >= 0 && e . cnt >= e . max { e . close ( ) } } return e . err } 
func newstructtype ( t reflect . type , c map [ reflect . type ] * structtype ) * structtype { if s : = c [ t ] ; s ! = nil { return s } n : = t . numfield ( ) s : = & structtype { fields : make ( [ ] structfield , 0 , n ) , fieldsbyname : make ( map [ string ] * structfield ) , } c [ t ] = s for i : = 0 ; i ! = n ; i ++ { ft : = t . field ( i ) if ft . anonymous | | len ( ft . pkgpath ) ! = 0 { continue } sf : = makestructfield ( ft , c ) if sf . name == " " { continue } s . fields = append ( s . fields , sf ) s . fieldsbyname [ sf . name ] = & s . fields [ len ( s . fields ) - 1 ] } return s } 
func ( cache * structtypecache ) lookup ( t reflect . type ) ( s * structtype ) { cache . mutex . rlock ( ) s = cache . store [ t ] cache . mutex . runlock ( ) if s == nil { s = newstructtype ( t , map [ reflect . type ] * structtype { } ) cache . mutex . lock ( ) cache . store [ t ] = s cache . mutex . unlock ( ) } return } 
func ( cache * structtypecache ) clear ( ) { cache . mutex . lock ( ) for typ : = range cache . store { delete ( cache . store , typ ) } cache . mutex . unlock ( ) } 
func checkuint64bounds ( v uint64 , max uint64 , t reflect . type ) ( err error ) { if v > max { err = fmt . errorf ( " " , v , max , t ) } return } 
func checkint64bounds ( v int64 , min int64 , max uint64 , t reflect . type ) ( err error ) { if v < min { err = fmt . errorf ( " " , v , min , t ) } if v > 0 && uint64 ( v ) > max { err = fmt . errorf ( " " , v , max , t ) } return } 
func newdecoder ( p parser ) * decoder { if p == nil { panic ( " " ) } return & decoder { parser : p } } 
func ( d decoder ) decode ( v interface { } ) error { to : = reflect . valueof ( v ) if d . off ! = 0 { var err error if d . off , err = 0 , d . parser . parsemapvalue ( d . off - 1 ) ; err ! = nil { return err } } if ! to . isvalid ( ) { , err : = d . decodeinterface ( to ) return err } switch x : = v . ( type ) { case valuedecoder : return x . decodevalue ( d ) } if to . kind ( ) == reflect . ptr { to = to . elem ( ) } , err : = d . decode ( to ) return err } 
func ( d decoder ) decodearray ( f func ( decoder ) error ) ( err error ) { var typ type if d . off ! = 0 { if d . off , err = 0 , d . parser . parsemapvalue ( d . off - 1 ) ; err ! = nil { return } } if typ , err = d . parser . parsetype ( ) ; err ! = nil { return } err = d . decodearrayimpl ( typ , f ) return } 
func ( d decoder ) decodemap ( f func ( decoder , decoder ) error ) ( err error ) { var typ type if d . off ! = 0 { if d . off , err = 0 , d . parser . parsemapvalue ( d . off - 1 ) ; err ! = nil { return } } if typ , err = d . parser . parsetype ( ) ; err ! = nil { return } err = d . decodemapimpl ( typ , f ) return } 
func newstreamdecoder ( p parser ) * streamdecoder { if p == nil { panic ( " " ) } return & streamdecoder { parser : p } } 
func ( d * streamdecoder ) len ( ) int { if d . err ! = nil { return 0 } if d . typ == unknown { if d . init ( ) ! = nil { return 0 } } return d . max - d . cnt } 
func ( d * streamdecoder ) err ( ) error { if d . err == end { return nil } return d . err } 
func ( d * streamdecoder ) decode ( v interface { } ) error { if d . err ! = nil { return d . err } err : = error ( nil ) cnt : = d . cnt max : = d . max dec : = decoder { parser : d . parser , maptype : d . maptype , } switch d . typ { case unknown : err = d . init ( ) max = d . max case array : if cnt == max { err = dec . parser . parsearrayend ( cnt ) } else if cnt ! = 0 { err = dec . parser . parsearraynext ( cnt ) } } if err == nil { if cnt == max { err = end } else { switch err = dec . decode ( v ) ; err { case nil : cnt ++ case end : cnt ++ max = cnt default : if max < 0 && dec . parser . parsearrayend ( cnt ) == nil { err = end } } } } d . err = err d . cnt = cnt d . max = max return err } 
func ( d * streamdecoder ) encoder ( e emitter ) ( enc * streamencoder , err error ) { var typ type if typ , err = d . parser . parsetype ( ) ; err == nil { enc = newstreamencoder ( e ) enc . oneshot = typ ! = array } return } 
func init ( ) { for , f : = range strings . split ( os . getenv ( " " ) , " " ) { switch f { case " " : defaultflags | = llongfile case " " : defaultflags | = lshortfile } } } 
func levelfromstring ( s string ) ( l level , ok bool ) { switch strings . tolower ( s ) { case " " , " " : return leveltrace , true case " " , " " : return leveldebug , true case " " , " " : return levelinfo , true case " " , " " : return levelwarn , true case " " , " " : return levelerror , true case " " , " " : return levelcritical , true case " " : return leveloff , true default : return levelinfo , false } } 
func newbackend ( w io . writer , opts ... backendoption ) * backend { b : = & backend { w : w , flag : defaultflags } for , o : = range opts { o ( b ) } return b } 
func formatheader ( buf * [ ] byte , t time . time , lvl , tag string , file string , line int ) { year , month , day : = t . date ( ) hour , min , sec : = t . clock ( ) ms : = t . nanosecond ( ) / 1e6 itoa ( buf , year , 4 ) * buf = append ( * buf , ' - ' ) itoa ( buf , int ( month ) , 2 ) * buf = append ( * buf , ' - ' ) itoa ( buf , day , 2 ) * buf = append ( * buf , ' ' ) itoa ( buf , hour , 2 ) * buf = append ( * buf , ' : ' ) itoa ( buf , min , 2 ) * buf = append ( * buf , ' : ' ) itoa ( buf , sec , 2 ) * buf = append ( * buf , ' . ' ) itoa ( buf , ms , 3 ) * buf = append ( * buf , " " ... ) * buf = append ( * buf , lvl ... ) * buf = append ( * buf , " " ... ) * buf = append ( * buf , tag ... ) if file ! = " " { * buf = append ( * buf , ' ' ) * buf = append ( * buf , file ... ) * buf = append ( * buf , ' : ' ) itoa ( buf , line , - 1 ) } * buf = append ( * buf , " " ... ) } 
func callsite ( flag uint32 ) ( string , int ) { , file , line , ok : = runtime . caller ( calldepth ) if ! ok { return " " , 0 } if flag & lshortfile ! = 0 { short : = file for i : = len ( file ) - 1 ; i > 0 ; i -- { if os . ispathseparator ( file [ i ] ) { short = file [ i + 1 : ] break } } file = short } return file , line } 
func ( b * backend ) print ( lvl , tag string , args ... interface { } ) { t : = time . now ( ) bytebuf : = buffer ( ) var file string var line int if b . flag & ( lshortfile | llongfile ) ! = 0 { file , line = callsite ( b . flag ) } formatheader ( bytebuf , t , lvl , tag , file , line ) buf : = bytes . newbuffer ( * bytebuf ) fmt . fprintln ( buf , args ... ) * bytebuf = buf . bytes ( ) b . mu . lock ( ) b . w . write ( * bytebuf ) b . mu . unlock ( ) recyclebuffer ( bytebuf ) } 
func ( b * backend ) logger ( subsystemtag string ) logger { return & slog { levelinfo , subsystemtag , b } } 
func ( l * slog ) trace ( args ... interface { } ) { lvl : = l . level ( ) if lvl <= leveltrace { l . b . print ( " " , l . tag , args ... ) } } 
func ( l * slog ) tracef ( format string , args ... interface { } ) { lvl : = l . level ( ) if lvl <= leveltrace { l . b . printf ( " " , l . tag , format , args ... ) } } 
func ( l * slog ) debug ( args ... interface { } ) { lvl : = l . level ( ) if lvl <= leveldebug { l . b . print ( " " , l . tag , args ... ) } } 
func ( l * slog ) debugf ( format string , args ... interface { } ) { lvl : = l . level ( ) if lvl <= leveldebug { l . b . printf ( " " , l . tag , format , args ... ) } } 
func ( l * slog ) info ( args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelinfo { l . b . print ( " " , l . tag , args ... ) } } 
func ( l * slog ) infof ( format string , args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelinfo { l . b . printf ( " " , l . tag , format , args ... ) } } 
func ( l * slog ) warn ( args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelwarn { l . b . print ( " " , l . tag , args ... ) } } 
func ( l * slog ) warnf ( format string , args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelwarn { l . b . printf ( " " , l . tag , format , args ... ) } } 
func ( l * slog ) error ( args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelerror { l . b . print ( " " , l . tag , args ... ) } } 
func ( l * slog ) errorf ( format string , args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelerror { l . b . printf ( " " , l . tag , format , args ... ) } } 
func ( l * slog ) critical ( args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelcritical { l . b . print ( " " , l . tag , args ... ) } } 
func ( l * slog ) criticalf ( format string , args ... interface { } ) { lvl : = l . level ( ) if lvl <= levelcritical { l . b . printf ( " " , l . tag , format , args ... ) } } 
func ( l * slog ) level ( ) level { return level ( atomic . loaduint32 ( ( * uint32 ) ( & l . lvl ) ) ) } 
func ( l * slog ) setlevel ( level level ) { atomic . storeuint32 ( ( * uint32 ) ( & l . lvl ) , uint32 ( level ) ) } 
func allow ( mode permissionmode , roles ... string ) * permission { return global . allow ( mode , roles ... ) } 
func deny ( mode permissionmode , roles ... string ) * permission { return global . deny ( mode , roles ... ) } 
func matchedroles ( req * http . request , user interface { } ) [ ] string { return global . matchedroles ( req , user ) } 
func hasrole ( req * http . request , user interface { } , roles ... string ) bool { return global . hasrole ( req , user ) } 
func ( permission * permission ) concat ( newpermission * permission ) * permission { var result = permission { role : global , allowedroles : map [ permissionmode ] [ ] string { } , deniedroles : map [ permissionmode ] [ ] string { } , } var appendroles = func ( p * permission ) { if p ! = nil { result . role = p . role for mode , roles : = range p . deniedroles { result . deniedroles [ mode ] = append ( result . deniedroles [ mode ] , roles ... ) } for mode , roles : = range p . allowedroles { result . allowedroles [ mode ] = append ( result . allowedroles [ mode ] , roles ... ) } } } appendroles ( newpermission ) appendroles ( permission ) return & result } 
func ( permission * permission ) allow ( mode permissionmode , roles ... string ) * permission { if mode == crud { return permission . allow ( create , roles ... ) . allow ( update , roles ... ) . allow ( read , roles ... ) . allow ( delete , roles ... ) } if permission . allowedroles [ mode ] == nil { permission . allowedroles [ mode ] = [ ] string { } } permission . allowedroles [ mode ] = append ( permission . allowedroles [ mode ] , roles ... ) return permission } 
func ( permission * permission ) deny ( mode permissionmode , roles ... string ) * permission { if mode == crud { return permission . deny ( create , roles ... ) . deny ( update , roles ... ) . deny ( read , roles ... ) . deny ( delete , roles ... ) } if permission . deniedroles [ mode ] == nil { permission . deniedroles [ mode ] = [ ] string { } } permission . deniedroles [ mode ] = append ( permission . deniedroles [ mode ] , roles ... ) return permission } 
func ( permission permission ) haspermission ( mode permissionmode , roles ... interface { } ) bool { var rolenames [ ] string for , role : = range roles { if r , ok : = role . ( string ) ; ok { rolenames = append ( rolenames , r ) } else if roler , ok : = role . ( roler ) ; ok { rolenames = append ( rolenames , roler . getroles ( ) ... ) } else { fmt . printf ( " \n " , role ) return false } } if len ( permission . deniedroles ) ! = 0 { if deniedroles : = permission . deniedroles [ mode ] ; deniedroles ! = nil { if includeroles ( deniedroles , rolenames ) { return false } } } if len ( permission . allowedroles ) == 0 { return true } if allowedroles : = permission . allowedroles [ mode ] ; allowedroles ! = nil { if includeroles ( allowedroles , rolenames ) { return true } } return false } 
func concatpermissioner ( ps ... permissioner ) permissioner { var newps [ ] permissioner for , p : = range ps { if p ! = nil { newps = append ( newps , p ) } } return permissioners ( newps ) } 
func ( ps permissioners ) haspermission ( mode permissionmode , roles ... interface { } ) bool { for , p : = range ps { if p ! = nil && ! p . haspermission ( mode , roles ) { return false } } return true } 
func ( role * role ) register ( name string , fc checker ) { if role . definitions == nil { role . definitions = map [ string ] checker { } } definition : = role . definitions [ name ] if definition ! = nil { fmt . printf ( " \n " , name ) } role . definitions [ name ] = fc } 
func ( role * role ) newpermission ( ) * permission { return & permission { role : role , allowedroles : map [ permissionmode ] [ ] string { } , deniedroles : map [ permissionmode ] [ ] string { } , } } 
func ( role * role ) allow ( mode permissionmode , roles ... string ) * permission { return role . newpermission ( ) . allow ( mode , roles ... ) } 
func ( role * role ) get ( name string ) ( checker , bool ) { fc , ok : = role . definitions [ name ] return fc , ok } 
func ( role * role ) matchedroles ( req * http . request , user interface { } ) ( roles [ ] string ) { if definitions : = role . definitions ; definitions ! = nil { for name , definition : = range definitions { if definition ( req , user ) { roles = append ( roles , name ) } } } return } 
func ( role * role ) hasrole ( req * http . request , user interface { } , roles ... string ) bool { if definitions : = role . definitions ; definitions ! = nil { for , name : = range roles { if definition , ok : = definitions [ name ] ; ok { if definition ( req , user ) { return true } } } } return false } 
func ( p * process ) isptrfromheap ( a core . address ) bool { return p . findheapinfo ( a ) . isptr ( a , p . proc . ptrsize ( ) ) } 
func ( p * process ) isptr ( a core . address ) bool { h : = p . findheapinfo ( a ) if h ! = nil { return h . isptr ( a , p . proc . ptrsize ( ) ) } for , m : = range p . modules { for , s : = range [ 2 ] string { " " , " " } { min : = core . address ( m . r . field ( s ) . uintptr ( ) ) max : = core . address ( m . r . field ( " " + s ) . uintptr ( ) ) if a < min | | a >= max { continue } gc : = m . r . field ( " " + s + " " ) . field ( " " ) . address ( ) i : = a . sub ( min ) return p . proc . readuint8 ( gc . add ( i / 8 ) ) > > uint ( i % 8 ) ! = 0 } } return false } 
func ( p * process ) findobject ( a core . address ) ( object , int64 ) { h : = p . findheapinfo ( a ) if h == nil { return 0 , 0 } x : = h . base . add ( a . sub ( h . base ) / h . size * h . size ) h = p . findheapinfo ( x ) if h . mark > > ( uint64 ( x ) % heapinfosize / 8 ) & 1 == 0 { return 0 , 0 } return object ( x ) , a . sub ( x ) } 
func ( p * process ) foreachobject ( fn func ( x object ) bool ) { for , k : = range p . pages { pt : = p . pagetable [ k ] for i : = range pt { h : = & pt [ i ] m : = h . mark for m ! = 0 { j : = bits . trailingzeros64 ( m ) m &= m - 1 x : = object ( k ) * pagetablesize * heapinfosize + object ( i ) * heapinfosize + object ( j ) * 8 if ! fn ( x ) { return } } } } } 
func ( p * process ) foreachroot ( fn func ( r * root ) bool ) { for , r : = range p . globals { if ! fn ( r ) { return } } for , g : = range p . goroutines { for , f : = range g . frames { for , r : = range f . roots { if ! fn ( r ) { return } } } } } 
func ( p * process ) addr ( x object ) core . address { return core . address ( x ) } 
func ( p * process ) size ( x object ) int64 { return p . findheapinfo ( core . address ( x ) ) . size } 
func ( p * process ) type ( x object ) ( * type , int64 ) { p . typeheap ( ) i , : = p . findobjectindex ( core . address ( x ) ) return p . types [ i ] . t , p . types [ i ] . r } 
func ( p * process ) foreachptr ( x object , fn func ( int64 , object , int64 ) bool ) { size : = p . size ( x ) for i : = int64 ( 0 ) ; i < size ; i += p . proc . ptrsize ( ) { a : = core . address ( x ) . add ( i ) if ! p . isptrfromheap ( a ) { continue } ptr : = p . proc . readptr ( a ) y , off : = p . findobject ( ptr ) if y ! = 0 { if ! fn ( i , y , off ) { return } } } } 
func ( p * process ) foreachrootptr ( r * root , fn func ( int64 , object , int64 ) bool ) { edges1 ( p , r , 0 , r . type , fn ) } 
func edges1 ( p * process , r * root , off int64 , t * type , fn func ( int64 , object , int64 ) bool ) bool { switch t . kind { case kindbool , kindint , kinduint , kindfloat , kindcomplex : case kindiface , kindeface : a : = r . addr . add ( off ) if r . frame == nil | | r . frame . live [ a ] { dst , off2 : = p . findobject ( p . proc . readptr ( a ) ) if dst ! = 0 { if ! fn ( off , dst , off2 ) { return false } } } off += p . proc . ptrsize ( ) fallthrough case kindptr , kindstring , kindslice , kindfunc : a : = r . addr . add ( off ) if r . frame == nil | | r . frame . live [ a ] { dst , off2 : = p . findobject ( p . proc . readptr ( a ) ) if dst ! = 0 { if ! fn ( off , dst , off2 ) { return false } } } case kindarray : s : = t . elem . size for i : = int64 ( 0 ) ; i < t . count ; i ++ { if ! edges1 ( p , r , off + i * s , t . elem , fn ) { return false } } case kindstruct : for , f : = range t . fields { if ! edges1 ( p , r , off + f . off , f . type , fn ) { return false } } } return true } 
func ( p * process ) setheapptr ( a core . address ) { h : = p . allocheapinfo ( a ) if p . proc . ptrsize ( ) == 8 { i : = uint ( a % heapinfosize ) / 8 h . ptr [ 0 ] | = uint64 ( 1 ) < < i return } i : = a % heapinfosize / 4 h . ptr [ i / 64 ] | = uint64 ( 1 ) < < ( i % 64 ) } 
func ( p * process ) findheapinfo ( a core . address ) * heapinfo { k : = a / heapinfosize / pagetablesize i : = a / heapinfosize % pagetablesize t : = p . pagetable [ k ] if t == nil { return nil } h : = & t [ i ] if h . base == 0 { return nil } return h } 
func ( p * process ) allocheapinfo ( a core . address ) * heapinfo { k : = a / heapinfosize / pagetablesize i : = a / heapinfosize % pagetablesize t : = p . pagetable [ k ] if t == nil { t = new ( pagetableentry ) for j : = 0 ; j < pagetablesize ; j ++ { t [ j ] . firstidx = - 1 } p . pagetable [ k ] = t p . pages = append ( p . pages , k ) } return & t [ i ] } 
func dwarfsize ( dt dwarf . type , ptrsize int64 ) int64 { s : = dt . size ( ) if s >= 0 { return s } switch x : = dt . ( type ) { case * dwarf . functype : return ptrsize case * dwarf . arraytype : return x . count * dwarfsize ( x . type , ptrsize ) case * dwarf . typedeftype : return dwarfsize ( x . type , ptrsize ) default : panic ( fmt . sprintf ( " " , x , x ) ) } } 
func gocorename ( dt dwarf . type ) string { switch x : = dt . ( type ) { case * dwarf . ptrtype : if , ok : = x . type . ( * dwarf . voidtype ) ; ok { return " " } return " " + gocorename ( x . type ) case * dwarf . arraytype : return fmt . sprintf ( " " , x . count , gocorename ( x . type ) ) case * dwarf . structtype : if ! strings . hasprefix ( x . structname , " " ) { return x . structname } s : = " " first : = true for , f : = range x . field { if ! first { s += " " } name : = f . name if i : = strings . index ( name , " " ) ; i >= 0 { name = name [ i + 1 : ] } s += fmt . sprintf ( " " , name , gocorename ( f . type ) ) first = false } s += " " return s default : return dt . string ( ) } } 
func ( t * functab ) add ( min , max core . address , f * func ) { t . entries = append ( t . entries , functabentry { min : min , max : max , f : f } ) } 
func ( t * functab ) sort ( ) { sort . slice ( t . entries , func ( i , j int ) bool { return t . entries [ i ] . min < t . entries [ j ] . min } ) } 
func ( t * functab ) find ( pc core . address ) * func { n : = sort . search ( len ( t . entries ) , func ( i int ) bool { return t . entries [ i ] . max > pc } ) if n == len ( t . entries ) | | pc < t . entries [ n ] . min | | pc >= t . entries [ n ] . max { return nil } return t . entries [ n ] . f } 
func ( t * pctab ) read ( core * core . process , data core . address ) { var pcquantum int64 switch core . arch ( ) { case " " , " " , " " : pcquantum = 1 case " " : pcquantum = 2 case " " , " " , " " , " " , " " , " " , " " , " " : pcquantum = 4 default : panic ( " " + core . arch ( ) ) } val : = int64 ( - 1 ) first : = true for { v , n : = readvarint ( core , data ) if v == 0 && ! first { return } data = data . add ( n ) if v & 1 ! = 0 { val += ^ ( v > > 1 ) } else { val += v > > 1 } v , n = readvarint ( core , data ) data = data . add ( n ) t . entries = append ( t . entries , pctabentry { bytes : v * pcquantum , val : val } ) first = false } } 
func readvarint ( core * core . process , a core . address ) ( val , n int64 ) { for { b : = core . readuint8 ( a ) val | = int64 ( b & 0x7f ) < < uint ( n * 7 ) n ++ a ++ if b & 0x80 == 0 { return } } } 
func useline ( c * cobra . command ) string { var useline string if c . hasparent ( ) { useline = commandpath ( c . parent ( ) ) + " " + c . use } else { useline = c . use } if c . disableflagsinuseline { return useline } if c . hasavailableflags ( ) && ! strings . contains ( useline , " " ) { useline += " " } return useline } 
func commandpath ( c * cobra . command ) string { if c . hasparent ( ) { return commandpath ( c ) + " " + c . name ( ) } return c . use } 
func readcore ( ) ( * core . process , * gocore . process , error ) { cc : = corecache if cc . cfg == cfg { return cc . corep , cc . gocorep , cc . err } c , err : = core . core ( cfg . corefile , cfg . base , cfg . exepath ) if err ! = nil { return nil , nil , err } p , err : = gocore . core ( c ) if os . isnotexist ( err ) && cfg . exepath == " " { return nil , nil , fmt . errorf ( " " , err ) } if err ! = nil { return nil , nil , err } for , w : = range c . warnings ( ) { fmt . fprintf ( os . stderr , " \n " , w ) } cc . cfg = cfg cc . corep = c cc . gocorep = p cc . err = nil return c , p , nil } 
func typename ( c * gocore . process , x gocore . object ) string { size : = c . size ( x ) typ , repeat : = c . type ( x ) if typ == nil { return fmt . sprintf ( " " , size ) } name : = typ . string ( ) n : = size / typ . size if n > 1 { if repeat < n { name = fmt . sprintf ( " " , repeat , n - repeat , name ) } else { name = fmt . sprintf ( " " , repeat , name ) } } return name } 
func fieldname ( c * gocore . process , x gocore . object , off int64 ) string { size : = c . size ( x ) typ , repeat : = c . type ( x ) if typ == nil { return fmt . sprintf ( " " , off ) } n : = size / typ . size i : = off / typ . size if i == 0 && repeat == 1 { return typefieldname ( typ , off ) } if i >= n { return fmt . sprintf ( " " , off ) } q : = " " if i >= repeat { q = " " } return fmt . sprintf ( " " , i , typefieldname ( typ , off - i * typ . size ) , q ) } 
func typefieldname ( t * gocore . type , off int64 ) string { switch t . kind { case gocore . kindbool , gocore . kindint , gocore . kinduint , gocore . kindfloat : return " " case gocore . kindcomplex : if off == 0 { return " " } return " " case gocore . kindiface , gocore . kindeface : if off == 0 { return " " } return " " case gocore . kindptr , gocore . kindfunc : return " " case gocore . kindstring : if off == 0 { return " " } return " " case gocore . kindslice : if off == 0 { return " " } if off <= t . size / 2 { return " " } return " " case gocore . kindarray : s : = t . elem . size i : = off / s return fmt . sprintf ( " " , i , typefieldname ( t . elem , off - i * s ) ) case gocore . kindstruct : for , f : = range t . fields { if f . off <= off && off < f . off + f . type . size { return " " + f . name + typefieldname ( f . type , off - f . off ) } } } return " " } 
func ( p * process ) findfunc ( pc core . address ) * func { return p . functab . find ( pc ) } 
func core ( proc * core . process ) ( p * process , err error ) { if , err : = proc . dwarf ( ) ; err ! = nil { return nil , err } p = & process { proc : proc , runtimemap : map [ core . address ] * type { } , dwarfmap : map [ dwarf . type ] * type { } , } p . readdwarftypes ( ) p . readruntimeconstants ( ) p . readglobals ( ) p . rtglobals = map [ string ] region { } for , g : = range p . globals { if strings . hasprefix ( g . name , " " ) { p . rtglobals [ g . name [ 8 : ] ] = region { p : p , a : g . addr , typ : g . type } } } p . buildversion = p . rtglobals [ " " ] . string ( ) p . readmodules ( ) p . readheap ( ) p . readgs ( ) p . readstackvars ( ) p . markobjects ( ) return p , nil } 
func ( p * process ) foreachreverseptr ( y object , fn func ( x object , r * root , i , j int64 ) bool ) { p . reverseedges ( ) idx , : = p . findobjectindex ( p . addr ( y ) ) for , a : = range p . redge [ p . ridx [ idx ] : p . ridx [ idx + 1 ] ] { ptr : = p . proc . readptr ( a ) j : = ptr . sub ( p . addr ( y ) ) x , i : = p . findobject ( a ) if x ! = 0 { if ! fn ( x , nil , i , j ) { return } continue } k : = sort . search ( len ( p . rootidx ) , func ( k int ) bool { r : = p . rootidx [ k ] return a < r . addr . add ( r . type . size ) } ) r : = p . rootidx [ k ] if ! fn ( 0 , r , a . sub ( r . addr ) , j ) { return } } } 
func ( r region ) address ( ) core . address { if r . typ . kind ! = kindptr { panic ( " " + r . typ . name ) } return r . p . proc . readptr ( r . a ) } 
func ( r region ) int ( ) int64 { if r . typ . kind ! = kindint | | r . typ . size ! = r . p . proc . ptrsize ( ) { panic ( " " + r . typ . name ) } return r . p . proc . readint ( r . a ) } 
func ( r region ) uintptr ( ) uint64 { if r . typ . kind ! = kinduint | | r . typ . size ! = r . p . proc . ptrsize ( ) { panic ( " " + r . typ . name ) } return r . p . proc . readuintptr ( r . a ) } 
func ( r region ) cast ( typ string ) region { return region { p : r . p , a : r . a , typ : r . p . findtype ( typ ) } } 
func ( r region ) deref ( ) region { if r . typ . kind ! = kindptr { panic ( " " + r . typ . name ) } if r . typ . elem == nil { panic ( " " ) } p : = r . p . proc . readptr ( r . a ) return region { p : r . p , a : p , typ : r . typ . elem } } 
func ( r region ) uint64 ( ) uint64 { if r . typ . kind ! = kinduint | | r . typ . size ! = 8 { panic ( " " + r . typ . name ) } return r . p . proc . readuint64 ( r . a ) } 
func ( r region ) uint32 ( ) uint32 { if r . typ . kind ! = kinduint | | r . typ . size ! = 4 { panic ( " " + r . typ . name ) } return r . p . proc . readuint32 ( r . a ) } 
func ( r region ) int32 ( ) int32 { if r . typ . kind ! = kindint | | r . typ . size ! = 4 { panic ( " " + r . typ . name ) } return r . p . proc . readint32 ( r . a ) } 
func ( r region ) uint16 ( ) uint16 { if r . typ . kind ! = kinduint | | r . typ . size ! = 2 { panic ( " " + r . typ . name ) } return r . p . proc . readuint16 ( r . a ) } 
func ( r region ) uint8 ( ) uint8 { if r . typ . kind ! = kinduint | | r . typ . size ! = 1 { panic ( " " + r . typ . name ) } return r . p . proc . readuint8 ( r . a ) } 
func ( r region ) string ( ) string { if r . typ . kind ! = kindstring { panic ( " " + r . typ . name ) } p : = r . p . proc . readptr ( r . a ) n : = r . p . proc . readuintptr ( r . a . add ( r . p . proc . ptrsize ( ) ) ) b : = make ( [ ] byte , n ) r . p . proc . readat ( b , p ) return string ( b ) } 
func ( r region ) sliceindex ( n int64 ) region { if r . typ . kind ! = kindslice { panic ( " " ) } p : = r . p . proc . readptr ( r . a ) return region { p : r . p , a : p . add ( n * r . typ . elem . size ) , typ : r . typ . elem } } 
func ( r region ) sliceptr ( ) region { if r . typ . kind ! = kindslice { panic ( " " ) } return region { p : r . p , a : r . a , typ : & type { name : " " + r . typ . name [ 2 : ] , size : r . p . proc . ptrsize ( ) , kind : kindptr , elem : r . typ . elem } } } 
func ( r region ) slicelen ( ) int64 { if r . typ . kind ! = kindslice { panic ( " " ) } return r . p . proc . readint ( r . a . add ( r . p . proc . ptrsize ( ) ) ) } 
func ( r region ) field ( f string ) region { finfo : = r . typ . field ( f ) if finfo == nil { panic ( " " + r . typ . name + " " + f ) } return region { p : r . p , a : r . a . add ( finfo . off ) , typ : finfo . type } } 
func ( p * process ) readat ( b [ ] byte , a address ) { for { m : = p . findmapping ( a ) if m == nil { panic ( fmt . errorf ( " " , a ) ) } n : = copy ( b , m . contents [ a . sub ( m . min ) : ] ) if n == len ( b ) { return } b = b [ n : ] a = a . add ( int64 ( n ) ) } } 
func ( p * process ) readuint8 ( a address ) uint8 { m : = p . findmapping ( a ) if m == nil { panic ( fmt . errorf ( " " , a ) ) } return m . contents [ a . sub ( m . min ) ] } 
func ( p * process ) readuint16 ( a address ) uint16 { m : = p . findmapping ( a ) if m == nil { panic ( fmt . errorf ( " " , a ) ) } b : = m . contents [ a . sub ( m . min ) : ] if len ( b ) < 2 { var buf [ 2 ] byte b = buf [ : ] p . readat ( b , a ) } if p . littleendian { return binary . littleendian . uint16 ( b ) } return binary . bigendian . uint16 ( b ) } 
func ( p * process ) readuint32 ( a address ) uint32 { m : = p . findmapping ( a ) if m == nil { panic ( fmt . errorf ( " " , a ) ) } b : = m . contents [ a . sub ( m . min ) : ] if len ( b ) < 4 { var buf [ 4 ] byte b = buf [ : ] p . readat ( b , a ) } if p . littleendian { return binary . littleendian . uint32 ( b ) } return binary . bigendian . uint32 ( b ) } 
func ( p * process ) readuint64 ( a address ) uint64 { m : = p . findmapping ( a ) if m == nil { panic ( fmt . errorf ( " " , a ) ) } b : = m . contents [ a . sub ( m . min ) : ] if len ( b ) < 8 { var buf [ 8 ] byte b = buf [ : ] p . readat ( b , a ) } if p . littleendian { return binary . littleendian . uint64 ( b ) } return binary . bigendian . uint64 ( b ) } 
func ( p * process ) readint8 ( a address ) int8 { return int8 ( p . readuint8 ( a ) ) } 
func ( p * process ) readint16 ( a address ) int16 { return int16 ( p . readuint16 ( a ) ) } 
func ( p * process ) readint32 ( a address ) int32 { return int32 ( p . readuint32 ( a ) ) } 
func ( p * process ) readint64 ( a address ) int64 { return int64 ( p . readuint64 ( a ) ) } 
func ( p * process ) readuintptr ( a address ) uint64 { if p . ptrsize == 4 { return uint64 ( p . readuint32 ( a ) ) } return p . readuint64 ( a ) } 
func ( p * process ) readint ( a address ) int64 { if p . ptrsize == 4 { return int64 ( p . readint32 ( a ) ) } return p . readint64 ( a ) } 
func ( p * process ) readptr ( a address ) address { return address ( p . readuintptr ( a ) ) } 
func ( p * process ) readcstring ( a address ) string { for n : = int64 ( 0 ) ; ; n ++ { if p . readuint8 ( a . add ( n ) ) == 0 { b : = make ( [ ] byte , n ) p . readat ( b , a ) return string ( b ) } } } 
func ( m * mapping ) source ( ) ( string , int64 ) { if m . f == nil { return " " , 0 } return m . f . name ( ) , m . off } 
func ( m * mapping ) origsource ( ) ( string , int64 ) { if m . origf == nil { return " " , 0 } return m . origf . name ( ) , m . origoff } 
func ( p * process ) findmapping ( a address ) * mapping { t3 : = p . pagetable [ a > > 52 ] if t3 == nil { return nil } t2 : = t3 [ a > > 42 % ( 1 < < 10 ) ] if t2 == nil { return nil } t1 : = t2 [ a > > 32 % ( 1 < < 10 ) ] if t1 == nil { return nil } t0 : = t1 [ a > > 22 % ( 1 < < 10 ) ] if t0 == nil { return nil } return t0 [ a > > 12 % ( 1 < < 10 ) ] } 
func ( a address ) max ( b address ) address { if a > b { return a } return b } 
func ( a address ) min ( b address ) address { if a < b { return a } return b } 
func ( a address ) align ( x int64 ) address { return ( a + address ( x ) - 1 ) & ^ ( address ( x ) - 1 ) } 
func ( d * ltdom ) findvertexbyname ( n vname ) ( * root , object ) { if n == 0 { return nil , 0 } if int ( n ) < len ( d . p . rootidx ) + 1 { return d . p . rootidx [ n - 1 ] , 0 } return nil , d . objs [ int ( n ) - len ( d . p . rootidx ) - 1 ] } 
func ( d * ltdom ) eval ( v vname ) vname { if d . ancestor [ v ] == - 1 { return v } d . compress ( v ) return d . labels [ v ] } 
func ( d * ltdom ) compress ( v vname ) { var stackbuf [ 20 ] vname stack : = stackbuf [ : 0 ] for d . ancestor [ d . ancestor [ v ] ] ! = - 1 { stack = append ( stack , v ) v = d . ancestor [ v ] } for len ( stack ) ! = 0 { v : = stack [ len ( stack ) - 1 ] stack = stack [ : len ( stack ) - 1 ] if d . semis [ d . labels [ d . ancestor [ v ] ] ] < d . semis [ d . labels [ v ] ] { d . labels [ v ] = d . labels [ d . ancestor [ v ] ] } d . ancestor [ v ] = d . ancestor [ d . ancestor [ v ] ] } } 
func ( d * ltdom ) link ( v , w vname ) { d . ancestor [ w ] = v } 
func ( d * dominators ) reverse ( ) { cnt : = make ( [ ] int , len ( d . idom ) + 2 ) tmp : = cnt [ 2 : ] for , idom : = range d . idom { tmp [ idom ] ++ } var n int for idx , c : = range tmp { n += c tmp [ idx ] = n } redge : = make ( [ ] vname , len ( d . idom ) ) tmp = cnt [ 1 : ] for i , idom : = range d . idom { redge [ tmp [ idom ] ] = vname ( i ) tmp [ idom ] ++ } d . redge , d . ridx = redge , cnt [ : len ( cnt ) - 1 ] } 
func ( d * dominators ) calcsize ( p * process ) { d . size = make ( [ ] int64 , len ( d . idom ) ) type workitem struct { v vname mode dfsmode } work : = [ ] workitem { { pseudoroot , down } } for len ( work ) > 0 { item : = & work [ len ( work ) - 1 ] kids : = d . redge [ d . ridx [ item . v ] : d . ridx [ item . v + 1 ] ] if item . mode == down && len ( kids ) ! = 0 { item . mode = up for , w : = range kids { if w == 0 { continue } work = append ( work , workitem { w , down } ) } continue } work = work [ : len ( work ) - 1 ] root , obj : = d . findvertexbyname ( item . v ) var size int64 switch { case item . v == pseudoroot : break case root ! = nil : size += root . type . size default : size += p . size ( obj ) } for , w : = range kids { size += d . size [ w ] } d . size [ item . v ] = size } } 
func objfield ( c * gocore . process , x gocore . object , off int64 ) string { t , r : = c . type ( x ) if t == nil { return fmt . sprintf ( " " , off ) } s : = " " if r > 1 { s = fmt . sprintf ( " " , off / t . size ) off % = t . size } return s + typefieldname ( t , off ) } 
func ( p * process ) readable ( a address ) bool { return p . findmapping ( a ) ! = nil } 
func ( p * process ) readablen ( a address , n int64 ) bool { for { m : = p . findmapping ( a ) if m == nil | | m . perm & read == 0 { return false } c : = m . max . sub ( a ) if n <= c { return true } n - = c a = a . add ( c ) } } 
func ( p * process ) writeable ( a address ) bool { m : = p . findmapping ( a ) if m == nil { return false } return m . perm & write ! = 0 } 
func ( p * process ) symbols ( ) ( map [ string ] address , error ) { return p . syms , p . symerr } 
func ( p * process ) splitmappingsat ( a address ) { for , m : = range p . memory . mappings { if a < m . min | | a > m . max { continue } if a == m . min | | a == m . max { return } m2 : = new ( mapping ) * m2 = * m m . max = a m2 . min = a if m2 . f ! = nil { m2 . off += m . size ( ) } if m2 . origf ! = nil { m2 . origoff += m . size ( ) } p . memory . mappings = append ( p . memory . mappings , m2 ) return } } 
func ( p * process ) dynamictype ( t * type , a core . address ) * type { switch t . kind { default : panic ( " " ) case kindeface : x : = p . proc . readptr ( a ) if x == 0 { return nil } return p . runtimetype2type ( x ) case kindiface : x : = p . proc . readptr ( a ) if x == 0 { return nil } x = p . proc . readptr ( x . add ( p . proc . ptrsize ( ) ) ) return p . runtimetype2type ( x ) } } 
func ( fs * btrfsfilesystem ) create ( bytes uint64 ) error { idempotent : = exec . command ( " " , " " , " " , " " , + fs . mkfsbin + ) idempotent . env = [ ] string { " " + os . getenv ( " " ) , " " + fs . mountpath , " " + fs . imagepath , fmt . sprintf ( " " , bytes ) , } , err : = fs . run ( idempotent ) return err } 
func splithostport ( u * url . url ) ( host , port string , err error ) { if u == nil { return " " , " " , & url . error { op : " " , url : host , err : errors . new ( " " ) } } host = u . host if i : = strings . lastindex ( host , " " ) ; i ! = - 1 { if len ( host ) > i && ! strings . contains ( host [ i : ] , " " ) { port = host [ i + 1 : ] host = host [ : i ] } } if port ! = " " { if , err : = strconv . atoi ( port ) ; err ! = nil { return " " , " " , & url . error { op : " " , url : host , err : err } } } return host , port , nil } 
func normalizestring ( rawurl string ) ( string , error ) { u , err : = parse ( rawurl ) if err ! = nil { return " " , err } return normalize ( u ) } 
func resolve ( u * url . url ) ( * net . ipaddr , error ) { host , , err : = splithostport ( u ) if err ! = nil { return nil , err } addr , err : = net . resolveipaddr ( " " , host ) if err ! = nil { return nil , err } return addr , nil } 
func resolvestring ( rawurl string ) ( * net . ipaddr , error ) { u , err : = parse ( rawurl ) if err ! = nil { return nil , err } return resolve ( u ) } 
func ( a * token ) equal ( b * token ) bool { if a == nil | | b == nil { return false } if a . tokentype ! = b . tokentype { return false } return a . value == b . value } 
func newdefaultclassifier ( ) tokenclassifier { t : = tokenclassifier { } t . addruneclass ( spacerunes , spaceruneclass ) t . addruneclass ( escapingquoterunes , escapingquoteruneclass ) t . addruneclass ( nonescapingquoterunes , nonescapingquoteruneclass ) t . addruneclass ( escaperunes , escaperuneclass ) t . addruneclass ( commentrunes , commentruneclass ) return t } 
func ( l * lexer ) next ( ) ( string , error ) { for { token , err : = ( * tokenizer ) ( l ) . next ( ) if err ! = nil { return " " , err } switch token . tokentype { case wordtoken : return token . value , nil case commenttoken : default : return " " , fmt . errorf ( " " , token . tokentype ) } } } 
func newtokenizer ( r io . reader ) * tokenizer { input : = bufio . newreader ( r ) classifier : = newdefaultclassifier ( ) return & tokenizer { input : * input , classifier : classifier } } 
func split ( s string ) ( [ ] string , error ) { l : = newlexer ( strings . newreader ( s ) ) substrings : = make ( [ ] string , 0 ) for { word , err : = l . next ( ) if err ! = nil { if err == io . eof { return substrings , nil } return substrings , err } substrings = append ( substrings , word ) } } 
func between ( s , left , right string ) string { l : = len ( left ) startpos : = strings . index ( s , left ) if startpos < 0 { return " " } endpos : = indexof ( s , right , startpos + l ) if endpos < 0 { return " " } else if right == " " { return s [ endpos : ] } else { return s [ startpos + l : endpos ] } } 
func betweenf ( left , right string ) func ( string ) string { return func ( s string ) string { return between ( s , left , right ) } } 
func camelize ( s string ) string { return camelizere . replaceallstringfunc ( s , func ( val string ) string { val = strings . toupper ( val ) val = camelizere2 . replaceallstring ( val , " " ) return val } ) } 
func capitalize ( s string ) string { return strings . toupper ( s [ 0 : 1 ] ) + strings . tolower ( s [ 1 : ] ) } 
func charat ( s string , index int ) string { l : = len ( s ) shortcut : = index < 0 | | index > l - 1 | | l == 0 if shortcut { return " " } return s [ index : index + 1 ] } 
func charatf ( index int ) func ( string ) string { return func ( s string ) string { return charat ( s , index ) } } 
func chompleft ( s , prefix string ) string { if strings . hasprefix ( s , prefix ) { return s [ len ( prefix ) : ] } return s } 
func chompleftf ( prefix string ) func ( string ) string { return func ( s string ) string { return chompleft ( s , prefix ) } } 
func chompright ( s , suffix string ) string { if strings . hassuffix ( s , suffix ) { return s [ : len ( s ) - len ( suffix ) ] } return s } 
func chomprightf ( suffix string ) func ( string ) string { return func ( s string ) string { return chompright ( s , suffix ) } } 
func classifyf ( s string ) func ( string ) string { return func ( s string ) string { return classify ( s ) } } 
func clean ( s string ) string { s = spacesre . replaceallstring ( s , " " ) s = beginendspacesre . replaceallstring ( s , " " ) return s } 
func dasherize ( s string ) string { s = strings . trimspace ( s ) s = spaceunderscorere . replaceallstring ( s , " " ) s = capitalsre . replaceallstring ( s , " " ) s = dashesre . replaceallstring ( s , " " ) s = strings . tolower ( s ) return s } 
func escapehtml ( s string ) string { if verbose { fmt . println ( " " ) } return html . escapestring ( s ) } 
func decodehtmlentities ( s string ) string { if verbose { fmt . println ( " " ) } return html . unescapestring ( s ) } 
func ensureprefixf ( prefix string ) func ( string ) string { return func ( s string ) string { return ensureprefix ( s , prefix ) } } 
func ensuresuffixf ( suffix string ) func ( string ) string { return func ( s string ) string { return ensuresuffix ( s , suffix ) } } 
func humanize ( s string ) string { if s == " " { return s } s = underscore ( s ) var humanizere = regexp . mustcompile ( ' id$ ' ) s = humanizere . replaceallstring ( s , " " ) s = strings . replace ( s , " " , " " , - 1 ) s = strings . trimspace ( s ) s = capitalize ( s ) return s } 
func iif ( condition bool , truthy string , falsey string ) string { if condition { return truthy } return falsey } 
func indexof ( s string , needle string , start int ) int { l : = len ( s ) if needle == " " { if start < 0 { return 0 } else if start < l { return start } else { return l } } if start < 0 | | start > l - 1 { return - 1 } pos : = strings . index ( s [ start : ] , needle ) if pos == - 1 { return - 1 } return start + pos } 
func islower ( s string ) bool { return isalpha ( s ) && s == strings . tolower ( s ) } 
func isupper ( s string ) bool { return isalpha ( s ) && s == strings . toupper ( s ) } 
func left ( s string , n int ) string { if n < 0 { return right ( s , - n ) } return substr ( s , 0 , n ) } 
func leftf ( n int ) func ( string ) string { return func ( s string ) string { return left ( s , n ) } } 
func letters ( s string ) [ ] string { result : = [ ] string { } for , r : = range s { result = append ( result , string ( r ) ) } return result } 
func lines ( s string ) [ ] string { s = strings . replace ( s , " \n " , " \n " , - 1 ) return strings . split ( s , " \n " ) } 
func map ( arr [ ] string , iterator func ( string ) string ) [ ] string { r : = [ ] string { } for , item : = range arr { r = append ( r , iterator ( item ) ) } return r } 
func match ( s , pattern string ) bool { r : = regexp . mustcompile ( pattern ) return r . matchstring ( s ) } 
func tasks ( p * do . project ) { p . task ( " " , do . s { " " } , nil ) p . task ( " " , nil , func ( c * do . context ) { c . run ( " " ) } ) p . task ( " " , nil , func ( c * do . context ) { c . run ( " " ) c . run ( " " ) c . run ( " " ) c . run ( " " ) } ) p . task ( " " , nil , func ( c * do . context ) { c . run ( " " ) packagename , : = util . packagename ( " " ) goa . pipe ( f . load ( " " ) , f . str ( str . replacef ( " " , " \n " + packagename + " \n " , 1 ) ) , f . write ( ) , ) } ) . src ( " " ) p . task ( " " , nil , func ( c * do . context ) { c . run ( " " ) } ) } 
func pad ( s , c string , n int ) string { l : = len ( s ) if l >= n { return s } n - = l left : = strings . repeat ( c , int ( math . ceil ( float64 ( n ) / 2 ) ) ) right : = strings . repeat ( c , int ( math . floor ( float64 ( n ) / 2 ) ) ) return left + s + right } 
func padf ( c string , n int ) func ( string ) string { return func ( s string ) string { return pad ( s , c , n ) } } 
func padleft ( s , c string , n int ) string { l : = len ( s ) if l > n { return s } return strings . repeat ( c , ( n - l ) ) + s } 
func padleftf ( c string , n int ) func ( string ) string { return func ( s string ) string { return padleft ( s , c , n ) } } 
func padrightf ( c string , n int ) func ( string ) string { return func ( s string ) string { return padright ( s , c , n ) } } 
func pipe ( s string , funcs ... func ( string ) string ) string { for , fn : = range funcs { s = fn ( s ) } return s } 
func quoteitems ( arr [ ] string ) [ ] string { return map ( arr , func ( s string ) string { return strconv . quote ( s ) } ) } 
func replacef ( old , new string , n int ) func ( string ) string { return func ( s string ) string { return strings . replace ( s , old , new , n ) } } 
func replacepattern ( s , pattern , repl string ) string { r : = regexp . mustcompile ( pattern ) return r . replaceallstring ( s , repl ) } 
func replacepatternf ( pattern , repl string ) func ( string ) string { return func ( s string ) string { return replacepattern ( s , pattern , repl ) } } 
func rightf ( n int ) func ( string ) string { return func ( s string ) string { return right ( s , n ) } } 
func slice ( s string , start , end int ) string { if end > - 1 { return s [ start : end ] } l : = len ( s ) if l + end > 0 { return s [ start : l - end ] } return s [ start : ] } 
func slicef ( start , end int ) func ( string ) string { return func ( s string ) string { return slice ( s , start , end ) } } 
func slicecontains ( slice [ ] string , val string ) bool { if slice == nil { return false } for , it : = range slice { if it == val { return true } } return false } 
func sliceindexof ( slice [ ] string , val string ) int { if slice == nil { return - 1 } for i , it : = range slice { if it == val { return i } } return - 1 } 
func slugify ( s string ) string { sl : = slugifyre . replaceallstring ( s , " " ) sl = strings . tolower ( sl ) sl = dasherize ( sl ) return sl } 
func strippunctuation ( s string ) string { s = strippuncre . replaceallstring ( s , " " ) s = nwhitespacere . replaceallstring ( s , " " ) return s } 
func striptags ( s string , tags ... string ) string { if len ( tags ) == 0 { tags = append ( tags , " " ) } for , tag : = range tags { striptagsre : = regexp . mustcompile ( ' ( ?i ) < \ / ? ' + tag + ' [ ^ < > ] * > ' ) s = striptagsre . replaceallstring ( s , " " ) } return s } 
func substr ( s string , index int , n int ) string { l : = len ( s ) if index < 0 | | index >= l | | s == " " { return " " } end : = index + n if end >= l { end = l } if end <= index { return " " } return s [ index : end ] } 
func substrf ( index , n int ) func ( string ) string { return func ( s string ) string { return substr ( s , index , n ) } } 
func template ( s string , values map [ string ] interface { } ) string { return templatewithdelimiters ( s , values , templateopen , templateclose ) } 
func templatewithdelimiters ( s string , values map [ string ] interface { } , opening , closing string ) string { escapedelimiter : = func ( delim string ) string { result : = templatere . replaceallstring ( delim , " \ \ " ) return templatere2 . replaceallstring ( result , " \ \ " ) } openingdelim : = escapedelimiter ( opening ) closingdelim : = escapedelimiter ( closing ) r : = regexp . mustcompile ( openingdelim + ' ( . +? ) ' + closingdelim ) matches : = r . findallstringsubmatch ( s , - 1 ) for , submatches : = range matches { match : = submatches [ 0 ] key : = submatches [ 1 ] if values [ key ] ! = nil { v : = fmt . sprintf ( " " , values [ key ] ) s = strings . replace ( s , match , v , - 1 ) } } return s } 
func tobool ( s string ) bool { s = strings . tolower ( s ) return s == " " | | s == " " | | s == " " | | s == " " } 
func toboolor ( s string , defaultvalue bool ) bool { b , err : = strconv . parsebool ( s ) if err ! = nil { return defaultvalue } return b } 
func tointor ( s string , defaultvalue int ) int { n , err : = strconv . atoi ( s ) if err ! = nil { return defaultvalue } return n } 
func tofloat32or ( s string , defaultvalue float32 ) float32 { f , err : = strconv . parsefloat ( s , 32 ) if err ! = nil { return defaultvalue } return float32 ( f ) } 
func tofloat64or ( s string , defaultvalue float64 ) float64 { f , err : = strconv . parsefloat ( s , 64 ) if err ! = nil { return defaultvalue } return f } 
func underscore ( s string ) string { if s == " " { return " " } u : = strings . trimspace ( s ) u = underscorere . replaceallstring ( u , " " ) u = dashspacere . replaceallstring ( u , " " ) u = strings . tolower ( u ) if isupper ( s [ 0 : 1 ] ) { return " " + u } return u } 
func unescapehtml ( s string ) string { if verbose { fmt . println ( " " ) } return html . unescapestring ( s ) } 
func wraphtml ( s string , tag string , attrs map [ string ] string ) string { escapehtmlattributequotes : = func ( v string ) string { v = strings . replace ( v , " " , " " , - 1 ) v = strings . replace ( v , " " , " " , - 1 ) v = strings . replace ( v , " " " , " " , - 1 ) return v } if tag == " " { tag = " " } el : = " " + tag for name , val : = range attrs { el += " " + name + " " " + escapehtmlattributequotes ( val ) + " " " } el += " " + s + " " + tag + " " return el } 
func wraphtmlf ( tag string , attrs map [ string ] string ) func ( string ) string { return func ( s string ) string { return wraphtml ( s , tag , attrs ) } } 
func reapchildren ( pids pidch , errors errorch , done chan struct { } , reaplock * sync . rwmutex ) { c : = make ( chan os . signal , 1 ) signal . notify ( c , unix . sigchld ) for { select { case < - c : case < - done : return } func ( ) { if reaplock ! = nil { reaplock . lock ( ) defer reaplock . unlock ( ) } poll : var status unix . waitstatus pid , err : = unix . wait4 ( - 1 , & status , unix . wnohang , nil ) switch err { case nil : if pid > 0 { if pids ! = nil { pids < - pid } goto poll } return case unix . echild : return case unix . eintr : goto poll default : if errors ! = nil { errors < - err } return } } ( ) } } 
func sdnotify ( state string ) error { name : = os . getenv ( " " ) if name == " " { return errsdnotifynosocket } conn , err : = net . dialunix ( " " , nil , & net . unixaddr { name : name , net : " " } ) if err ! = nil { return err } defer conn . close ( ) , err = conn . write ( [ ] byte ( state ) ) return err } 
func newauthenticator ( store * coal . store , policy * policy ) * authenticator { coal . init ( policy . token ) for , model : = range policy . clients { coal . init ( model ) } return & authenticator { store : store , policy : policy , } } 
func f ( m model , field string ) string { prefixed : = strings . hasprefix ( field , " " ) if prefixed { field = strings . trimleft ( field , " " ) } f : = init ( m ) . meta ( ) . fields [ field ] if f == nil { panic ( fmt . sprintf ( ' coal : field " %s " not found on " %s " ' , field , m . meta ( ) . name ) ) } bsonfield : = f . bsonfield if prefixed { bsonfield = " " + bsonfield } return bsonfield } 
func a ( m model , field string ) string { f : = init ( m ) . meta ( ) . fields [ field ] if f == nil { panic ( fmt . sprintf ( ' coal : field " %s " not found on " %s " ' , field , m . meta ( ) . name ) ) } return f . jsonkey } 
func r ( m model , field string ) string { f : = init ( m ) . meta ( ) . fields [ field ] if f == nil { panic ( fmt . sprintf ( ' coal : field " %s " not found on " %s " ' , field , m . meta ( ) . name ) ) } return f . relname } 
func l ( m model , flag string , force bool ) string { fields , : = init ( m ) . meta ( ) . flaggedfields [ flag ] if len ( fields ) > 1 | | ( force && len ( fields ) == 0 ) { panic ( fmt . sprintf ( ' coal : no or multiple fields flagged as " %s " found on " %s " ' , flag , m . meta ( ) . name ) ) } if len ( fields ) > 0 { return fields [ 0 ] . name } return " " } 
func unique ( ids [ ] bson . objectid ) [ ] bson . objectid { m : = make ( map [ bson . objectid ] bool ) l : = make ( [ ] bson . objectid , 0 , len ( ids ) ) for , id : = range ids { if , ok : = m [ id ] ; ! ok { m [ id ] = true l = append ( l , id ) } } return l } 
func contains ( list [ ] bson . objectid , id bson . objectid ) bool { for , item : = range list { if item == id { return true } } return false } 
func includes ( all , subset [ ] bson . objectid ) bool { for , item : = range subset { if ! contains ( all , item ) { return false } } return true } 
func require ( m model , flags ... string ) { for , f : = range flags { l ( m , f , true ) } } 
func addjobindexes ( indexer * coal . indexer , removeafter time . duration ) { indexer . add ( & job { } , false , 0 , " " ) indexer . add ( & job { } , false , 0 , " " ) indexer . add ( & job { } , false , removeafter , " " ) } 
func enqueue ( store * coal . substore , name string , data model , delay time . duration ) ( * job , error ) { if data == nil { data = bson . m { } } now : = time . now ( ) job : = coal . init ( & job { name : name , status : statusenqueued , created : now , available : now . add ( delay ) , } ) . ( * job ) raw , err : = bson . marshal ( data ) if err ! = nil { return nil , err } err = bson . unmarshal ( raw , & job . data ) if err ! = nil { return nil , err } err = store . c ( job ) . insert ( job ) if err ! = nil { return nil , err } return job , nil } 
func a ( name string , m fire . matcher , h handler ) * authorizer { if m == nil | | h == nil { panic ( " " ) } return & authorizer { matcher : m , handler : func ( ctx * fire . context ) ( [ ] * enforcer , error ) { ctx . tracer . push ( name ) enforcers , err : = h ( ctx ) if err ! = nil { return nil , err } ctx . tracer . pop ( ) return enforcers , nil } , } } 
func run ( enforcers ... * enforcer ) * authorizer { return a ( " " , fire . all ( ) , func ( ctx * fire . context ) ( [ ] * enforcer , error ) { return enforcers , nil } ) } 
func and ( a , b * authorizer ) * authorizer { return a ( " " , func ( ctx * fire . context ) bool { return a . matcher ( ctx ) && b . matcher ( ctx ) } , func ( ctx * fire . context ) ( [ ] * enforcer , error ) { enforcers1 , err : = a . handler ( ctx ) if err ! = nil { return nil , err } else if enforcers1 == nil { return nil , nil } enforcers2 , err : = b . handler ( ctx ) if err ! = nil { return nil , err } else if enforcers2 == nil { return nil , nil } enforcers : = append ( s { } , enforcers1 ... ) enforcers = append ( enforcers , enforcers2 ... ) return enforcers , nil } ) } 
func or ( a , b * authorizer ) * authorizer { return a ( " " , func ( ctx * fire . context ) bool { return a . matcher ( ctx ) | | b . matcher ( ctx ) } , func ( ctx * fire . context ) ( [ ] * enforcer , error ) { if a . matcher ( ctx ) { enforcers , err : = a . handler ( ctx ) if err ! = nil { return nil , err } if enforcers ! = nil { return enforcers , nil } } if b . matcher ( ctx ) { enforcers , err : = b . handler ( ctx ) if err ! = nil { return nil , err } if enforcers ! = nil { return enforcers , nil } } return nil , nil } ) } 
func ( q * queue ) enqueue ( name string , data model , delay time . duration ) ( * job , error ) { store : = q . store . copy ( ) defer store . close ( ) job , err : = enqueue ( store , name , data , delay ) if err ! = nil { return nil , err } return job , nil } 
func ( q * queue ) callback ( name string , delay time . duration , matcher fire . matcher , cb func ( ctx * fire . context ) model ) * fire . callback { return fire . c ( " " , matcher , func ( ctx * fire . context ) error { ctx . tracer . tag ( " " , name ) var data model if cb ! = nil { data = cb ( ctx ) } if q . store == ctx . controller . store { , err : = enqueue ( ctx . store , name , data , delay ) if err ! = nil { return err } } else { , err : = q . enqueue ( name , data , delay ) if err ! = nil { return err } } if ctx . operation . action ( ) { err : = ctx . respond ( fire . map { } ) if err ! = nil { return err } } return nil } ) } 
func newwatcher ( ) * watcher { w : = & watcher { streams : make ( map [ string ] * stream ) , } w . manager = newmanager ( w ) return w } 
func ( w * watcher ) add ( stream * stream ) { coal . init ( stream . model ) if w . streams [ stream . name ( ) ] ! = nil { panic ( fmt . sprintf ( ' spark : stream with name " %s " already exists ' , stream . name ( ) ) ) } w . streams [ stream . name ( ) ] = stream coal . openstream ( stream . store , stream . model , nil , func ( e coal . event , id bson . objectid , m coal . model , token [ ] byte ) { if stream . softdelete && e == coal . deleted { return } if stream . softdelete && e == coal . updated { softdeletefield : = coal . l ( stream . model , " " , true ) t : = m . mustget ( softdeletefield ) . ( * time . time ) if t ! = nil && ! t . iszero ( ) { e = coal . deleted } } evt : = & event { type : e , id : id , model : m , stream : stream , } w . manager . broadcast ( evt ) } , nil , func ( err error ) bool { w . reporter ( err ) return true } ) } 
func ( w * watcher ) action ( ) * fire . action { return & fire . action { methods : [ ] string { " " } , callback : fire . c ( " " , fire . all ( ) , func ( ctx * fire . context ) error { w . manager . handle ( ctx ) return nil } ) , } } 
func ( o operation ) write ( ) bool { return o == create | | o == update | | o == delete } 
func ( o operation ) string ( ) string { switch o { case list : return " " case find : return " " case create : return " " case update : return " " case delete : return " " case collectionaction : return " " case resourceaction : return " " } return " " } 
func ( c * context ) query ( ) bson . m { return bson . m { " " : append ( [ ] bson . m { c . selector } , c . filters ... ) } } 
func ( c * context ) original ( ) ( coal . model , error ) { c . tracer . push ( " " ) if c . operation ! = update { panic ( " " ) } if c . original ! = nil { c . tracer . pop ( ) return c . original , nil } m : = c . model . meta ( ) . make ( ) c . tracer . push ( " " ) c . tracer . tag ( " " , c . model . id ( ) ) err : = c . store . c ( c . model ) . findid ( c . model . id ( ) ) . one ( m ) if err ! = nil { return nil , err } c . tracer . pop ( ) c . original = coal . init ( m ) c . tracer . pop ( ) return c . original , nil } 
func ( c * context ) respond ( value interface { } ) error { bytes , err : = json . marshal ( value ) if err ! = nil { return err } , err = c . responsewriter . write ( bytes ) if err ! = nil { return err } return nil } 
func tokenmigrator ( remove bool ) func ( http . handler ) http . handler { return func ( next http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { accesstoken : = r . url . query ( ) . get ( " " ) if accesstoken ! = " " { if r . header . get ( " " ) == " " { r . header . set ( " " , " " + accesstoken ) } if remove { q : = r . url . query ( ) q . del ( " " ) r . url . rawquery = q . encode ( ) } } next . servehttp ( w , r ) } ) } } 
func ensureapplication ( store * coal . store , name , key , secret string ) ( string , error ) { s : = store . copy ( ) defer s . close ( ) var apps [ ] application err : = s . c ( & application { } ) . find ( bson . m { coal . f ( & application { } , " " ) : name , } ) . all ( & apps ) if err ! = nil { return " " , err } if len ( apps ) > 1 { return " " , errors . new ( " " ) } else if len ( apps ) == 1 { return apps [ 0 ] . key , nil } app : = coal . init ( & application { } ) . ( * application ) app . key = key app . name = name app . secret = secret err = app . validate ( ) if err ! = nil { return " " , err } err = s . c ( app ) . insert ( app ) if err ! = nil { return " " , err } return app . key , nil } 
func ensurefirstuser ( store * coal . store , name , email , password string ) error { s : = store . copy ( ) defer s . close ( ) n , err : = s . c ( & user { } ) . count ( ) if err ! = nil { return err } else if n > 0 { return nil } user : = coal . init ( & user { } ) . ( * user ) user . name = name user . email = email user . password = password err = user . validate ( ) if err ! = nil { return err } err = s . c ( user ) . insert ( user ) if err ! = nil { return err } return nil } 
func ( s * strategy ) callback ( ) * fire . callback { if s . collectionaction == nil { s . collectionaction = make ( map [ string ] [ ] * authorizer ) } if s . resourceaction == nil { s . resourceaction = make ( map [ string ] [ ] * authorizer ) } return fire . c ( " " , fire . all ( ) , func ( ctx * fire . context ) ( err error ) { switch ctx . operation { case fire . list : err = s . call ( ctx , s . list , s . read , s . all ) case fire . find : err = s . call ( ctx , s . find , s . read , s . all ) case fire . create : err = s . call ( ctx , s . create , s . write , s . all ) case fire . update : err = s . call ( ctx , s . update , s . write , s . all ) case fire . delete : err = s . call ( ctx , s . delete , s . write , s . all ) case fire . collectionaction : err = s . call ( ctx , s . collectionaction [ ctx . jsonapirequest . collectionaction ] , s . collectionactions , s . actions , s . all ) case fire . resourceaction : err = s . call ( ctx , s . resourceaction [ ctx . jsonapirequest . resourceaction ] , s . resourceactions , s . actions , s . all ) } return err } ) } 
func openstream ( store * store , model model , token [ ] byte , receiver receiver , opened func ( ) , manager func ( error ) bool ) * stream { var resumetoken * bson . raw if token ! = nil { resumetoken = & bson . raw { kind : bson . elementdocument , data : token , } } s : = & stream { store : store , model : model , token : resumetoken , receiver : receiver , opened : opened , manager : manager , } go s . open ( ) return s } 
func ( s * stream ) close ( ) { s . mutex . lock ( ) defer s . mutex . unlock ( ) s . closed = true if s . current ! = nil { = s . current . close ( ) } } 
func addtokenindexes ( i * coal . indexer , autoexpire bool ) { i . add ( & token { } , false , 0 , " " ) i . add ( & token { } , false , 0 , " " ) i . add ( & token { } , false , 0 , " " ) if autoexpire { i . add ( & token { } , false , time . minute , " " ) } } 
func ( t * token ) gettokendata ( ) ( tokentype , [ ] string , time . time , bson . objectid , * bson . objectid ) { return t . type , t . scope , t . expiresat , t . application , t . user } 
func ( t * token ) settokendata ( typ tokentype , scope [ ] string , expiresat time . time , client client , resourceowner resourceowner ) { t . type = typ t . scope = scope t . expiresat = expiresat t . application = client . id ( ) if resourceowner ! = nil { t . user = coal . p ( resourceowner . id ( ) ) } } 
func ( t * token ) validate ( ) error { if ! t . id ( ) . valid ( ) { return fire . e ( " " ) } if t . expiresat . iszero ( ) { return fire . e ( " " ) } return nil } 
func ( a * application ) validsecret ( secret string ) bool { return bcrypt . comparehashandpassword ( a . secrethash , [ ] byte ( secret ) ) == nil } 
func ( a * application ) validate ( ) error { err : = a . hashsecret ( ) if err ! = nil { return err } if ! a . id ( ) . valid ( ) { return fire . e ( " " ) } if a . name == " " { return fire . e ( " " ) } if a . key == " " { return fire . e ( " " ) } if len ( a . secrethash ) == 0 { return fire . e ( " " ) } if a . redirecturl ! = " " && ! govalidator . isurl ( a . redirecturl ) { return fire . e ( " " ) } return nil } 
func ( a * application ) hashsecret ( ) error { if len ( a . secret ) == 0 { return nil } hash , err : = bcrypt . generatefrompassword ( [ ] byte ( a . secret ) , bcrypt . defaultcost ) if err ! = nil { return err } a . secrethash = hash a . secret = " " return nil } 
func ( u * user ) validpassword ( password string ) bool { return bcrypt . comparehashandpassword ( u . passwordhash , [ ] byte ( password ) ) == nil } 
func ( u * user ) validate ( ) error { err : = u . hashpassword ( ) if err ! = nil { return err } if ! u . id ( ) . valid ( ) { return fire . e ( " " ) } if u . name == " " { return fire . e ( " " ) } if u . email == " " | | ! govalidator . isemail ( u . email ) { return fire . e ( " " ) } if len ( u . passwordhash ) == 0 { return fire . e ( " " ) } return nil } 
func ( u * user ) hashpassword ( ) error { if len ( u . password ) == 0 { return nil } hash , err : = bcrypt . generatefrompassword ( [ ] byte ( u . password ) , bcrypt . defaultcost ) if err ! = nil { return err } u . passwordhash = hash u . password = " " return nil } 
func mustcreatestore ( uri string ) * store { store , err : = createstore ( uri ) if err ! = nil { panic ( err ) } return store } 
func createstore ( uri string ) ( * store , error ) { session , err : = mgo . dial ( uri ) if err ! = nil { return nil , err } return newstore ( session ) , nil } 
func ( s * substore ) c ( model model ) * mgo . collection { return s . db ( ) . c ( c ( model ) ) } 
func newassetserver ( prefix , directory string ) http . handler { prefix = " " + strings . trim ( prefix , " " ) dir : = http . dir ( directory ) fs : = http . fileserver ( dir ) h : = func ( w http . responsewriter , r * http . request ) { f , err : = dir . open ( r . url . path ) if err ! = nil { r . url . path = " " } else if f ! = nil { = f . close ( ) } fs . servehttp ( w , r ) } return http . stripprefix ( prefix , http . handlerfunc ( h ) ) } 
func defaultgrantstrategy ( scope oauth2 . scope , client , resourceowner ) ( oauth2 . scope , error ) { if ! scope . empty ( ) { return nil , errinvalidscope } return scope , nil } 
func defaulttokendata ( client , ro resourceowner , generictoken ) map [ string ] interface { } { if ro ! = nil { return map [ string ] interface { } { " " : ro . id ( ) , } } return nil } 
func defaultpolicy ( secret string ) * policy { return & policy { secret : [ ] byte ( secret ) , token : & token { } , clients : [ ] client { & application { } } , resourceowners : func ( client ) [ ] resourceowner { return [ ] resourceowner { & user { } } } , grantstrategy : defaultgrantstrategy , tokendata : defaulttokendata , accesstokenlifespan : time . hour , refreshtokenlifespan : 7 * 24 * time . hour , } } 
func ( p * policy ) generatetoken ( id bson . objectid , issuedat , expiresat time . time , client client , resourceowner resourceowner , token generictoken ) ( string , error ) { claims : = & tokenclaims { } claims . id = id . hex ( ) claims . issuedat = issuedat . unix ( ) claims . expiresat = expiresat . unix ( ) if p . tokendata ! = nil { claims . data = p . tokendata ( client , resourceowner , token ) } tkn : = jwt . newwithclaims ( jwt . signingmethodhs256 , claims ) str , err : = tkn . signedstring ( p . secret ) if err ! = nil { return " " , nil } return str , nil } 
func ( p * policy ) parsetoken ( str string ) ( * tokenclaims , bool , error ) { var claims tokenclaims , err : = jwt . parsewithclaims ( str , & claims , func ( * jwt . token ) ( interface { } , error ) { return p . secret , nil } ) if valerr , ok : = err . ( * jwt . validationerror ) ; ok && valerr . errors == jwt . validationerrorexpired { return nil , true , err } else if err ! = nil { return nil , false , err } else if ! bson . isobjectidhex ( claims . id ) { return nil , false , errors . new ( " " ) } return & claims , false , nil } 
func e ( name string , m fire . matcher , h fire . handler ) * enforcer { return fire . c ( name , m , h ) } 
func grantaccess ( ) * enforcer { return e ( " " , fire . all ( ) , func ( * fire . context ) error { return nil } ) } 
func denyaccess ( ) * enforcer { return e ( " " , fire . all ( ) , func ( * fire . context ) error { return fire . erraccessdenied } ) } 
func addfilter ( filter bson . m ) * enforcer { return e ( " " , fire . except ( fire . create , fire . collectionaction ) , func ( ctx * fire . context ) error { ctx . filters = append ( ctx . filters , filter ) return nil } ) } 
func whitelistreadablefields ( fields ... string ) * enforcer { return e ( " " , fire . except ( fire . delete , fire . resourceaction , fire . collectionaction ) , func ( ctx * fire . context ) error { ctx . readablefields = fire . intersect ( ctx . readablefields , fields ) return nil } ) } 
func whitelistwritablefields ( fields ... string ) * enforcer { return e ( " " , fire . only ( fire . create , fire . update ) , func ( ctx * fire . context ) error { ctx . writablefields = fire . intersect ( ctx . writablefields , fields ) return nil } ) } 
func initslice ( ptr interface { } ) [ ] model { slice : = reflect . valueof ( ptr ) . elem ( ) models : = make ( [ ] model , slice . len ( ) ) for i : = 0 ; i < slice . len ( ) ; i ++ { m : = init ( slice . index ( i ) . interface ( ) . ( model ) ) models [ i ] = m } return models } 
func ( b * base ) mustget ( name string ) interface { } { field : = b . meta . fields [ name ] if field == nil { panic ( fmt . sprintf ( ' coal : field " %s " not found on " %s " ' , name , b . meta . name ) ) } structfield : = reflect . valueof ( b . model ) . elem ( ) . field ( field . index ) return structfield . interface ( ) } 
func ( b * base ) mustset ( name string , value interface { } ) { field : = b . meta . fields [ name ] if field == nil { panic ( fmt . sprintf ( ' coal : field " %s " not found on " %s " ' , name , b . meta . name ) ) } reflect . valueof ( b . model ) . elem ( ) . field ( field . index ) . set ( reflect . valueof ( value ) ) } 
func newgroup ( ) * group { return & group { controllers : make ( map [ string ] * controller ) , actions : make ( map [ string ] * groupaction ) , } } 
func ( g * group ) add ( controllers ... * controller ) { for , controller : = range controllers { controller . prepare ( ) name : = controller . model . meta ( ) . pluralname if g . controllers [ name ] ! = nil { panic ( fmt . sprintf ( ' fire : controller with name " %s " already exists ' , name ) ) } g . controllers [ name ] = controller } } 
func ( g * group ) handle ( name string , a * groupaction ) { if name == " " { panic ( fmt . sprintf ( ' fire : invalid group action " %s " ' , name ) ) } if a . action . bodylimit == 0 { a . action . bodylimit = datasize ( " " ) } if g . actions [ name ] ! = nil { panic ( fmt . sprintf ( ' fire : action with name " %s " already exists ' , name ) ) } g . actions [ name ] = a } 
func ( m * meta ) make ( ) model { pointer : = reflect . new ( reflect . typeof ( m . model ) . elem ( ) ) . interface ( ) return init ( pointer . ( model ) ) } 
func ( m * meta ) makeslice ( ) interface { } { slice : = reflect . makeslice ( reflect . sliceof ( reflect . typeof ( m . model ) ) , 0 , 0 ) pointer : = reflect . new ( slice . type ( ) ) pointer . elem ( ) . set ( slice ) return pointer . interface ( ) } 
func ( i * indexer ) add ( model model , unique bool , expireafter time . duration , fields ... string ) { var key [ ] string for , f : = range fields { key = append ( key , f ( model , f ) ) } i . addraw ( c ( model ) , mgo . index { key : key , unique : unique , expireafter : expireafter , background : true , } ) } 
func ( i * indexer ) addraw ( coll string , idx mgo . index ) { i . indexes = append ( i . indexes , index { coll : coll , index : idx , } ) } 
func ( i * indexer ) ensure ( store * store ) error { s : = store . copy ( ) defer s . close ( ) for , i : = range i . indexes { err : = s . db ( ) . c ( i . coll ) . ensureindex ( i . index ) if err ! = nil { return err } } return nil } 
func newcatalog ( models ... model ) * catalog { c : = & catalog { models : make ( map [ string ] model ) , } c . add ( models ... ) return c } 
func ( c * catalog ) add ( models ... model ) { for , model : = range models { name : = init ( model ) . meta ( ) . pluralname if c . models [ name ] ! = nil { panic ( fmt . sprintf ( ' coal : model with name " %s " already exists in catalog ' , name ) ) } c . models [ name ] = model } } 
func ( c * catalog ) all ( ) [ ] model { models : = make ( [ ] model , 0 , len ( c . models ) ) for , model : = range c . models { models = append ( models , model ) } return models } 
func callback ( force bool , scope ... string ) * fire . callback { return fire . c ( " " , fire . all ( ) , func ( ctx * fire . context ) error { s : = oauth2 . scope ( scope ) accesstoken , : = ctx . httprequest . context ( ) . value ( accesstokencontextkey ) . ( generictoken ) if accesstoken == nil { if force { return fire . erraccessdenied } return nil } , scope , , , : = accesstoken . gettokendata ( ) if ! oauth2 . scope ( scope ) . includes ( s ) { return fire . erraccessdenied } client : = ctx . httprequest . context ( ) . value ( clientcontextkey ) . ( client ) resourceowner , : = ctx . httprequest . context ( ) . value ( resourceownercontextkey ) . ( resourceowner ) ctx . data [ authinfodatakey ] = & authinfo { client : client , resourceowner : resourceowner , accesstoken : accesstoken , } return nil } ) } 
func newerrorreporter ( out io . writer ) func ( error ) { return func ( err error ) { , = fmt . fprintf ( out , " \n " , err . error ( ) ) , = out . write ( debug . stack ( ) ) , = fmt . fprintln ( out , " " ) } } 
func ensureindexes ( store * coal . store ) error { err : = indexer . ensure ( store ) if err ! = nil { return err } return nil } 
func ( i * item ) validate ( ) error { if utf8 . runecountinstring ( i . name ) < 1 { return fire . e ( " " ) } if i . created . iszero ( ) | | i . updated . iszero ( ) { return fire . e ( " " ) } return nil } 
func defaultprotector ( ) func ( http . handler ) http . handler { return newprotector ( " " , cors . options { allowedorigins : [ ] string { " " } , allowedheaders : [ ] string { " " , " " , " " , " " } , allowedmethods : [ ] string { " " , " " , " " , " " } , } ) } 
func newprotector ( maxbody string , corsoptions cors . options ) func ( http . handler ) http . handler { c : = cors . new ( corsoptions ) return func ( next http . handler ) http . handler { return c . handler ( http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { fire . limitbody ( w , r , int64 ( fire . datasize ( maxbody ) ) ) next . servehttp ( w , r ) } ) ) } } 
func e ( format string , a ... interface { } ) error { return safe ( fmt . errorf ( format , a ... ) ) } 
func compose ( chain ... interface { } ) http . handler { if len ( chain ) < 2 { panic ( " " ) } h , ok : = chain [ len ( chain ) - 1 ] . ( http . handler ) if ! ok { panic ( ' fire : expected last chain item to be a " http . handler " ' ) } for i : = len ( chain ) - 2 ; i >= 0 ; i -- { m , ok : = chain [ i ] . ( func ( http . handler ) http . handler ) if ! ok { panic ( ' fire : expected intermediary chain item to be a " func ( http . handler ) http . handler " ' ) } h = m ( h ) } return h } 
func datasize ( str string ) uint64 { const msg = " " if len ( str ) < 2 { panic ( msg ) } sym : = string ( str [ len ( str ) - 1 ] ) num , err : = strconv . parseuint ( str [ : len ( str ) - 1 ] , 10 , 64 ) if err ! = nil { panic ( msg ) } switch sym { case " " : return num * 1000 case " " : return num * 1000 * 1000 case " " : return num * 1000 * 1000 * 1000 } panic ( msg ) } 
func includes ( all , subset [ ] string ) bool { for , item : = range subset { if ! contains ( all , item ) { return false } } return true } 
func intersect ( lista , listb [ ] string ) [ ] string { list : = make ( [ ] string , 0 , len ( lista ) ) for , item : = range lista { if contains ( listb , item ) { list = append ( list , item ) } } return list } 
func e ( reason string , retry bool ) * error { return & error { reason : reason , retry : retry , } } 
func roottracer ( ) func ( http . handler ) http . handler { return func ( next http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { segments : = strings . split ( r . url . path , " " ) for i , s : = range segments { if bson . isobjectidhex ( s ) { segments [ i ] = " " } } path : = strings . join ( segments , " " ) name : = fmt . sprintf ( " " , r . method , path ) tracer : = newtracerfromrequest ( r , name ) tracer . tag ( " " , r . remoteaddr ) tracer . tag ( " " , r . proto ) tracer . tag ( " " , r . method ) tracer . tag ( " " , r . host ) tracer . log ( " " , r . url . string ( ) ) tracer . log ( " " , r . contentlength ) tracer . log ( " " , r . header ) r = r . withcontext ( tracer . context ( r . context ( ) ) ) defer tracer . finish ( true ) next . servehttp ( w , r ) } ) } } 
func newtracerfromrequest ( r * http . request , name string ) * tracer { span , : = opentracing . startspanfromcontext ( r . context ( ) , name ) return newtracer ( span ) } 
func newtracer ( root opentracing . span ) * tracer { return & tracer { root : root , spans : make ( [ ] opentracing . span , 0 , 32 ) , } } 
func ( t * tracer ) push ( name string ) { var ctx opentracing . spancontext if len ( t . spans ) > 0 { ctx = t . last ( ) . context ( ) } else { ctx = t . root . context ( ) } span : = opentracing . startspan ( name , opentracing . childof ( ctx ) ) t . spans = append ( t . spans , span ) } 
func ( t * tracer ) last ( ) opentracing . span { if len ( t . spans ) == 0 { return t . root } return t . spans [ len ( t . spans ) - 1 ] } 
func ( t * tracer ) tag ( key string , value interface { } ) { t . last ( ) . settag ( key , value ) } 
func ( t * tracer ) log ( key string , value interface { } ) { t . last ( ) . logkv ( key , value ) } 
func ( t * tracer ) context ( ctx context . context ) context . context { return opentracing . contextwithspan ( ctx , t . last ( ) ) } 
func ( t * tracer ) pop ( ) { if len ( t . spans ) == 0 { return } t . last ( ) . finish ( ) t . spans = t . spans [ : len ( t . spans ) - 1 ] } 
func ( t * tracer ) finish ( root bool ) { for , span : = range t . spans { span . finish ( ) } if root { t . root . finish ( ) } } 
func newpool ( ) * pool { return & pool { tasks : make ( map [ string ] * task ) , queues : make ( map [ * queue ] bool ) , closed : make ( chan struct { } ) , } } 
func ( p * pool ) add ( task * task ) { if p . tasks [ task . name ] ! = nil { panic ( fmt . sprintf ( ' axe : task with name " %s " already exists ' , task . name ) ) } p . tasks [ task . name ] = task task . queue . tasks = append ( task . queue . tasks , task . name ) p . queues [ task . queue ] = true } 
func ( p * pool ) run ( ) { for queue : = range p . queues { queue . start ( p ) } for , task : = range p . tasks { task . start ( p ) } } 
func newbodylimiter ( w http . responsewriter , r * http . request , n int64 ) * bodylimiter { return & bodylimiter { original : r . body , readcloser : http . maxbytesreader ( w , r . body , n ) , } } 
func limitbody ( w http . responsewriter , r * http . request , n int64 ) { if bl , ok : = r . body . ( * bodylimiter ) ; ok { r . body = bl . original } r . body = newbodylimiter ( w , r , n ) } 
func c ( name string , m matcher , h handler ) * callback { if m == nil | | h == nil { panic ( " " ) } return & callback { matcher : m , handler : func ( ctx * context ) error { ctx . tracer . push ( name ) err : = h ( ctx ) if err ! = nil { return err } ctx . tracer . pop ( ) return nil } , } } 
func only ( ops ... operation ) matcher { return func ( ctx * context ) bool { for , op : = range ops { if op == ctx . operation { return true } } return false } } 
func basicauthorizer ( credentials map [ string ] string ) * callback { return c ( " " , all ( ) , func ( ctx * context ) error { user , password , ok : = ctx . httprequest . basicauth ( ) if ! ok { return erraccessdenied } if val , ok : = credentials [ user ] ; ! ok | | val ! = password { return erraccessdenied } return nil } ) } 
func modelvalidator ( ) * callback { return c ( " " , only ( create , update ) , func ( ctx * context ) error { m , ok : = ctx . model . ( validatablemodel ) if ! ok { return fmt . errorf ( " " ) } err : = m . validate ( ) if err ! = nil { return err } return nil } ) } 
func timestampvalidator ( ) * callback { return c ( " " , only ( create , update ) , func ( ctx * context ) error { now : = time . now ( ) ctf : = coal . l ( ctx . model , " " , false ) utf : = coal . l ( ctx . model , " " , false ) if ctf ! = " " { if ctx . operation == create { ctx . model . mustset ( ctf , now ) } else if t : = ctx . model . mustget ( ctf ) . ( time . time ) ; t . iszero ( ) { ctx . model . mustset ( ctf , ctx . model . id ( ) . time ( ) ) } } if utf ! = " " { ctx . model . mustset ( utf , now ) } return nil } ) } 
func protectedfieldsvalidator ( pairs map [ string ] interface { } ) * callback { return c ( " " , only ( create , update ) , func ( ctx * context ) error { if ctx . operation == create { for field , def : = range pairs { if def == nodefault { continue } if ! reflect . deepequal ( ctx . model . mustget ( field ) , def ) { return e ( " " + field + " " ) } } } if ctx . operation == update { original , err : = ctx . original ( ) if err ! = nil { return err } for field : = range pairs { if ! reflect . deepequal ( ctx . model . mustget ( field ) , original . mustget ( field ) ) { return e ( " " + field + " " ) } } } return nil } ) } 
func dependentresourcesvalidator ( pairs map [ coal . model ] string ) * callback { return c ( " " , only ( delete ) , func ( ctx * context ) error { for model , field : = range pairs { query : = bson . m { coal . f ( model , field ) : ctx . model . id ( ) } if sdm : = coal . l ( model , " " , false ) ; sdm ! = " " { query [ coal . f ( model , sdm ) ] = nil } ctx . tracer . push ( " " ) ctx . tracer . tag ( " " , query ) n , err : = ctx . store . db ( ) . c ( coal . c ( model ) ) . find ( query ) . limit ( 1 ) . count ( ) if err ! = nil { return err } ctx . tracer . pop ( ) if n ! = 0 { return e ( " " ) } } return nil } ) } 
func matchingreferencesvalidator ( reference string , target coal . model , matcher map [ string ] string ) * callback { return c ( " " , only ( create , update ) , func ( ctx * context ) error { var ids [ ] bson . objectid ref : = ctx . model . mustget ( reference ) if id , ok : = ref . ( bson . objectid ) ; ok { ids = [ ] bson . objectid { id } } if oid , ok : = ref . ( * bson . objectid ) ; ok { if oid == nil { return nil } ids = [ ] bson . objectid { * oid } } if list , ok : = ref . ( [ ] bson . objectid ) ; ok { if len ( list ) == 0 { return nil } ids = list } ids = coal . unique ( ids ) query : = bson . m { " " : bson . m { " " : ids , } , } for sourcefield , targetfield : = range matcher { query [ coal . f ( target , targetfield ) ] = ctx . model . mustget ( sourcefield ) } ctx . tracer . push ( " " ) ctx . tracer . tag ( " " , query ) n , err : = ctx . store . db ( ) . c ( coal . c ( target ) ) . find ( query ) . count ( ) if err ! = nil { return err } ctx . tracer . pop ( ) if n ! = len ( ids ) { return e ( " " ) } return nil } ) } 
func uniquefieldvalidator ( field string , zero interface { } , filters ... string ) * callback { return c ( " " , only ( create , update ) , func ( ctx * context ) error { if ctx . operation == update { original , err : = ctx . original ( ) if err ! = nil { return err } if reflect . deepequal ( ctx . model . mustget ( field ) , original . mustget ( field ) ) { return nil } } value : = ctx . model . mustget ( field ) if value ! = nozero && reflect . deepequal ( value , zero ) { return nil } query : = bson . m { coal . f ( ctx . model , field ) : value , } for , field : = range filters { query [ coal . f ( ctx . model , field ) ] = ctx . model . mustget ( field ) } if sdm : = coal . l ( ctx . model , " " , false ) ; sdm ! = " " { query [ coal . f ( ctx . model , sdm ) ] = nil } ctx . tracer . push ( " " ) ctx . tracer . tag ( " " , query ) n , err : = ctx . store . c ( ctx . model ) . find ( query ) . limit ( 1 ) . count ( ) if err ! = nil { return err } else if n ! = 0 { return e ( " " , field ) } ctx . tracer . pop ( ) return nil } ) } 
func ( s * seekret ) inspect ( nworkers int ) { jobs : = make ( chan workerjob ) results : = make ( chan workerresult ) for w : = 1 ; w <= nworkers ; w ++ { go inspect worker ( w , jobs , results ) } objectgroupmap : = s . groupobjectsbyprimarykeyhash ( ) go func ( ) { for , objectgroup : = range objectgroupmap { jobs < - workerjob { objectgroup : objectgroup , rulelist : s . rulelist , exceptionlist : s . exceptionlist , } } close ( jobs ) } ( ) for i : = 0 ; i < len ( objectgroupmap ) ; i ++ { result : = < - results s . secretlist = append ( s . secretlist , result . secretlist ... ) } } 
func newrule ( name string , match string ) ( * rule , error ) { matchregexp , err : = regexp . compile ( " " + match ) if err ! = nil { return nil , err } if err ! = nil { fmt . println ( err ) } r : = & rule { enabled : false , name : name , match : matchregexp , } return r , nil } 
func ( r * rule ) addunmatch ( unmatch string ) error { unmatchregexp , err : = regexp . compile ( " " + unmatch ) if err ! = nil { return err } r . unmatch = append ( r . unmatch , unmatchregexp ) return nil } 
func ( r * rule ) run ( content [ ] byte ) [ ] runresult { var results [ ] runresult b : = bufio . newscanner ( bytes . newreader ( content ) ) nline : = 0 for b . scan ( ) { nline = nline + 1 line : = b . text ( ) if r . match . matchstring ( line ) { unmatch : = false for , unmatch : = range r . unmatch { if unmatch . matchstring ( line ) { unmatch = true } } if ! unmatch { results = append ( results , runresult { line : line , nline : nline , } ) } } } return results } 
func newsecret ( object * object , rule * rule , nline int , line string ) * secret { s : = & secret { object : object , rule : rule , nline : nline , line : line , } return s } 
func newobject ( name string , t string , st string , content [ ] byte ) * object { if len ( content ) > maxobjectcontentlen { content = content [ : maxobjectcontentlen ] } o : = & object { type : t , subtype : st , name : name , content : content , metadata : make ( map [ string ] metadatadata ) , primarykeyhash : nil , } return o } 
func ( o * object ) setmetadata ( key string , value string , attr metadataattributes ) error { o . metadata [ key ] = metadatadata { value : value , attr : attr , } if attr . primarykey { o . updateprimarykeyhash ( ) } return nil } 
func ( o * object ) getmetadata ( key string ) ( string , error ) { data , ok : = o . metadata [ key ] if ! ok { return " " , fmt . errorf ( " " , key ) } return data . value , nil } 
func ( o * object ) getmetadataall ( attr bool ) map [ string ] string { metadataall : = make ( map [ string ] string ) for k , v : = range o . metadata { metadataall [ k ] = v . value } return metadataall } 
func ( x * exception ) setrule ( rule string ) error { ruleregexp , err : = regexp . compile ( " " + rule ) if err ! = nil { return err } x . rule = ruleregexp return nil } 
func ( x * exception ) setobject ( object string ) error { objectregexp , err : = regexp . compile ( " " + object ) if err ! = nil { return err } x . object = objectregexp return nil } 
func ( x * exception ) setnline ( nline int ) error { x . nline = & nline return nil } 
func ( x * exception ) setcontent ( content string ) error { contentregexp , err : = regexp . compile ( " " + content ) if err ! = nil { return err } x . content = contentregexp return nil } 
func ( x * exception ) run ( s * secret ) bool { match : = true if match && x . rule ! = nil && ! x . rule . matchstring ( s . rule . name ) { match = false } if match && x . object ! = nil && ! x . object . matchstring ( s . object . name ) { match = false } if match && x . nline ! = nil && * x . nline ! = s . nline { match = false } if match && x . content ! = nil && ! x . content . matchstring ( s . line ) { match = false } return match } 
func ( s * seekret ) addrule ( rule models . rule , enabled bool ) { if enabled { rule . enable ( ) } s . rulelist = append ( s . rulelist , rule ) } 
func ( s * seekret ) loadrulesfromfile ( file string , defaulenabled bool ) error { var ruleyamlmap map [ string ] ruleyaml if file == " " { return nil } filename , : = filepath . abs ( file ) rulebase : = filepath . base ( filename ) if filepath . ext ( rulebase ) == " " { rulebase = rulebase [ 0 : len ( rulebase ) - 5 ] } yamldata , err : = ioutil . readfile ( filename ) if err ! = nil { return err } err = yaml . unmarshal ( yamldata , & ruleyamlmap ) if err ! = nil { return err } for k , v : = range ruleyamlmap { rule , err : = models . newrule ( rulebase + " " + k , v . match ) if err ! = nil { return err } for , e : = range v . unmatch { rule . addunmatch ( e ) } s . addrule ( * rule , defaulenabled ) } return nil } 
func ( s * seekret ) loadrulesfromdir ( dir string , defaulenabled bool ) error { fi , err : = os . stat ( dir ) if err ! = nil { return err } if ! fi . isdir ( ) { err : = fmt . errorf ( " " , dir ) return err } filelist , err : = filepath . glob ( dir + " " ) if err ! = nil { return err } for , file : = range filelist { if strings . hassuffix ( file , " " ) { err : = s . loadrulesfromfile ( file , defaulenabled ) if err ! = nil { return err } } } return nil } 
func ( s * seekret ) loadrulesfrompath ( path string , defaulenabled bool ) error { if path == " " { path = defaultrulespath ( ) } dirlist : = strings . split ( path , " " ) for , dir : = range dirlist { err : = s . loadrulesfromdir ( dir , defaulenabled ) if err ! = nil { return err } } return nil } 
func defaultrulespath ( ) string { rulespath : = os . getenv ( " " ) if rulespath == " " { rulespath = os . expandenv ( defaultrulesdir ) } return rulespath } 
func ( s * seekret ) enablerule ( name string ) error { return setruleenabled ( s . rulelist , name , true ) } 
func ( s * seekret ) disablerule ( name string ) error { return setruleenabled ( s . rulelist , name , false ) } 
func ( s * seekret ) enablerulebyregexp ( name string ) int { return setruleenabledbyregexp ( s . rulelist , name , true ) } 
func ( s * seekret ) disablerulebyregexp ( name string ) int { return setruleenabledbyregexp ( s . rulelist , name , false ) } 
func ( s * seekret ) loadobjects ( st sourcetype , source string , opt loadoptions ) error { objectlist , err : = st . loadobjects ( source , opt ) if err ! = nil { return err } s . objectlist = append ( s . objectlist , objectlist ... ) return nil } 
func ( s * seekret ) groupobjectsbymetadata ( k string ) map [ string ] [ ] models . object { return models . groupobjectsbymetadata ( s . objectlist , k ) } 
func ( s * seekret ) groupobjectsbyprimarykeyhash ( ) map [ string ] [ ] models . object { return models . groupobjectsbyprimarykeyhash ( s . objectlist ) } 
func ( s * seekret ) addexception ( exception models . exception ) { s . exceptionlist = append ( s . exceptionlist , exception ) } 
func ( s * seekret ) loadexceptionsfromfile ( file string ) error { var exceptionyamllist [ ] exceptionyaml if file == " " { return nil } filename , : = filepath . abs ( file ) yamldata , err : = ioutil . readfile ( filename ) if err ! = nil { return err } err = yaml . unmarshal ( yamldata , & exceptionyamllist ) if err ! = nil { return err } for , v : = range exceptionyamllist { x : = models . newexception ( ) if v . rule ! = nil { err : = x . setrule ( * v . rule ) if err ! = nil { return err } } if v . object ! = nil { err : = x . setobject ( * v . object ) if err ! = nil { return err } } if v . line ! = nil { err : = x . setnline ( * v . line ) if err ! = nil { return err } } if v . content ! = nil { err : = x . setcontent ( * v . content ) if err ! = nil { return err } } s . addexception ( * x ) } return nil } 
func fs allocstats ( ) * c . char { s : = fmt . sprintf ( " " , sframesets . len ( ) , sfileseqs . len ( ) ) return c . cstring ( s ) } 
func frameset new ( frange * c . char ) ( framesetid , error ) { fset , e : = fileseq . newframeset ( c . gostring ( frange ) ) if e ! = nil { return 0 , c . cstring ( e . error ( ) ) } id : = sframesets . add ( * fset ) return id , nil } 
func frameset copy ( id framesetid ) framesetid { fs , ok : = sframesets . get ( id ) if ! ok { return 0 } copyfs , : = fileseq . newframeset ( fs . framerange ( ) ) copyid : = sframesets . add ( * copyfs ) return copyid } 
func frameset string ( id framesetid ) ( str * c . char ) { fs , ok : = sframesets . get ( id ) if ! ok { str = c . cstring ( " " ) } else { str = c . cstring ( fs . string ( ) ) } return str } 
func frameset len ( id framesetid ) c . size t { fs , ok : = sframesets . get ( id ) if ! ok { return c . size t ( 0 ) } return c . size t ( fs . len ( ) ) } 
func frameset index ( id framesetid , frame int ) c . int { fs , ok : = sframesets . get ( id ) if ! ok { return c . int ( - 1 ) } return c . int ( fs . index ( frame ) ) } 
func frameset frame ( id framesetid , index int ) ( c . int , error ) { fs , ok : = sframesets . get ( id ) if ! ok { return 0 , c . cstring ( " " ) } frame , err : = fs . frame ( index ) if err ! = nil { return 0 , c . cstring ( err . error ( ) ) } return c . int ( frame ) , nil } 
func frameset frames ( id framesetid , out * c . int ) c . int { fs , ok : = sframesets . get ( id ) if ! ok { return c . int ( 0 ) } goframes : = fs . frames ( ) size : = len ( goframes ) if size == 0 { return c . int ( 0 ) } intsize : = int ( unsafe . sizeof ( c . int ( 0 ) ) ) startptr : = uintptr ( unsafe . pointer ( out ) ) for i , frame : = range goframes { ptr : = unsafe . pointer ( startptr + uintptr ( intsize * i ) ) * ( * c . int ) ( ptr ) = c . int ( int32 ( frame ) ) } return c . int ( size ) } 
func frameset hasframe ( id framesetid , frame int ) bool { fs , ok : = sframesets . get ( id ) if ! ok { return false } return fs . hasframe ( frame ) } 
func frameset start ( id framesetid ) c . int { fs , ok : = sframesets . get ( id ) if ! ok { return c . int ( 0 ) } return c . int ( fs . start ( ) ) } 
func frameset end ( id framesetid ) c . int { fs , ok : = sframesets . get ( id ) if ! ok { return c . int ( 0 ) } return c . int ( fs . end ( ) ) } 
func frameset framerange ( id framesetid ) ( ret * c . char ) { fs , ok : = sframesets . get ( id ) if ! ok { ret = c . cstring ( " " ) } else { ret = c . cstring ( fs . framerange ( ) ) } return ret } 
func frameset framerangepadded ( id framesetid , pad int ) ( ret * c . char ) { fs , ok : = sframesets . get ( id ) if ! ok { ret = c . cstring ( " " ) } else { ret = c . cstring ( fs . framerangepadded ( pad ) ) } return ret } 
func frameset invert ( id framesetid ) framesetid { fs , ok : = sframesets . get ( id ) if ! ok { return 0 } inverted : = fs . invert ( ) invertedid : = sframesets . add ( * inverted ) return invertedid } 
func frameset invertedframerange ( id framesetid , pad int ) ( ret * c . char ) { fs , ok : = sframesets . get ( id ) if ! ok { ret = c . cstring ( " " ) } else { ret = c . cstring ( fs . invertedframerange ( pad ) ) } return ret } 
func frameset normalize ( id framesetid ) framesetid { fs , ok : = sframesets . get ( id ) if ! ok { return 0 } normalized : = fs . normalize ( ) normalizedid : = sframesets . add ( * normalized ) return normalizedid } 
func filesequence new ( frange * c . char ) ( fileseqid , error ) { fs , e : = fileseq . newfilesequence ( c . gostring ( frange ) ) if e ! = nil { return 0 , c . cstring ( e . error ( ) ) } id : = sfileseqs . add ( fs ) return id , nil } 
func filesequence new pad ( frange * c . char , padstyle c . int ) ( fileseqid , error ) { style : = fileseq . padstyle ( padstyle ) fs , e : = fileseq . newfilesequencepad ( c . gostring ( frange ) , style ) if e ! = nil { return 0 , c . cstring ( e . error ( ) ) } id : = sfileseqs . add ( fs ) return id , nil } 
func filesequence copy ( id fileseqid ) fileseqid { fs , ok : = sfileseqs . get ( id ) if ! ok { return 0 } copyfs , : = fileseq . newfilesequence ( fs . string ( ) ) copyid : = sfileseqs . add ( copyfs ) return copyid } 
func filesequence format ( id fileseqid , tpl * c . char ) ( * c . char , error ) { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) , nil } str , err : = fs . format ( c . gostring ( tpl ) ) if err ! = nil { return nil , c . cstring ( err . error ( ) ) } return c . cstring ( str ) , nil } 
func filesequence dirname ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . dirname ( ) ) } 
func filesequence basename ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . basename ( ) ) } 
func filesequence start ( id fileseqid ) c . int { fs , ok : = sfileseqs . get ( id ) if ! ok { return 0 } return c . int ( fs . start ( ) ) } 
func filesequence end ( id fileseqid ) c . int { fs , ok : = sfileseqs . get ( id ) if ! ok { return 0 } return c . int ( fs . end ( ) ) } 
func filesequence zfill ( id fileseqid ) c . int { fs , ok : = sfileseqs . get ( id ) if ! ok { return 0 } return c . int ( fs . zfill ( ) ) } 
func filesequence padding ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . padding ( ) ) } 
func filesequence paddingstyle ( id fileseqid ) c . int { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . int ( fileseq . padstyledefault ) } return c . int ( fs . paddingstyle ( ) ) } 
func filesequence framerange ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . framerange ( ) ) } 
func filesequence framerangepadded ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . framerangepadded ( ) ) } 
func filesequence invertedframerange ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . invertedframerange ( ) ) } 
func filesequence invertedframerangepadded ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . invertedframerangepadded ( ) ) } 
func filesequence frameset ( id fileseqid ) ( fsetid framesetid ) { fsetid = 0 fs , ok : = sfileseqs . get ( id ) if ! ok { return fsetid } fset : = fs . frameset ( ) if fset == nil { return 0 } fsetid = sframesets . add ( * fset ) return fsetid } 
func filesequence ext ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . ext ( ) ) } 
func filesequence frame int ( id fileseqid , frame int ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } framestr , : = fs . frame ( frame ) return c . cstring ( framestr ) } 
func filesequence frame fill ( id fileseqid , fill * c . char ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } gofill : = c . gostring ( fill ) framestr , : = fs . frame ( gofill ) return c . cstring ( framestr ) } 
func filesequence index ( id fileseqid , frame int ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . index ( frame ) ) } 
func filesequence len ( id fileseqid ) c . size t { fs , ok : = sfileseqs . get ( id ) if ! ok { return 0 } return c . size t ( fs . len ( ) ) } 
func filesequence string ( id fileseqid ) * c . char { fs , ok : = sfileseqs . get ( id ) if ! ok { return c . cstring ( " " ) } return c . cstring ( fs . string ( ) ) } 
func filesequence setdirname ( id fileseqid , dir * c . char ) { if fs , ok : = sfileseqs . get ( id ) ; ok { str : = c . gostring ( dir ) fs . setdirname ( str ) } } 
func filesequence setbasename ( id fileseqid , base * c . char ) { if fs , ok : = sfileseqs . get ( id ) ; ok { str : = c . gostring ( base ) fs . setbasename ( str ) } } 
func filesequence setpadding ( id fileseqid , padchars * c . char ) { if fs , ok : = sfileseqs . get ( id ) ; ok { str : = c . gostring ( padchars ) fs . setpadding ( str ) } } 
func filesequence setpaddingstyle ( id fileseqid , padstyle c . int ) { if fs , ok : = sfileseqs . get ( id ) ; ok { style : = fileseq . padstyle ( padstyle ) fs . setpaddingstyle ( style ) } } 
func filesequence setext ( id fileseqid , ext * c . char ) { if fs , ok : = sfileseqs . get ( id ) ; ok { str : = c . gostring ( ext ) fs . setext ( str ) } } 
func filesequence setframeset ( id fileseqid , fsetid framesetid ) bool { fs , ok : = sfileseqs . get ( id ) if ! ok { return false } fset , ok : = sframesets . get ( fsetid ) if ! ok { return false } fs . setframeset ( & fset . frameset ) return true } 
func filesequence setframerange ( id fileseqid , framerange * c . char ) error { if fs , ok : = sfileseqs . get ( id ) ; ok { str : = c . gostring ( framerange ) if err : = fs . setframerange ( str ) ; err ! = nil { return c . cstring ( err . error ( ) ) } } return nil } 
func framestoframerange ( frames * c . int , num c . size t , sorted bool , zfill int ) * c . char { if num == c . size t ( 0 ) { return c . cstring ( " " ) } n : = int ( num ) slice : = ( * [ 1 < < 30 ] c . int ) ( unsafe . pointer ( frames ) ) [ : n : n ] ints : = make ( [ ] int , n ) for i : = 0 ; i < n ; i ++ { ints [ i ] = int ( slice [ i ] ) } return c . cstring ( fileseq . framestoframerange ( ints , sorted , zfill ) ) } 
func isframerange ( frange * c . char ) bool { return fileseq . isframerange ( c . gostring ( frange ) ) } 
func padframerange ( frange * c . char , pad int ) * c . char { return c . cstring ( fileseq . padframerange ( c . gostring ( frange ) , pad ) ) } 
func paddingchars ( pad int ) * c . char { return c . cstring ( fileseq . paddingchars ( pad ) ) } 
func findsequenceondisk ( pattern * c . char ) ( fileseqid , error ) { return findsequenceondiskpad ( pattern , c . int ( fileseq . padstyledefault ) ) } 
func findsequenceondiskpad ( pattern * c . char , padstyle c . int ) ( fileseqid , error ) { str : = c . gostring ( pattern ) if str == " " { return 0 , c . cstring ( " " ) } fs , err : = fileseq . findsequenceondiskpad ( str , fileseq . padstyle ( padstyle ) ) if err ! = nil { return 0 , c . cstring ( err . error ( ) ) } if fs == nil { return 0 , nil } id : = sfileseqs . add ( fs ) return id , nil } 
func findsequencesondisk ( path * c . char , opts c . fileoption ) ( filesequences , uint64 , error ) { fileopts : = [ ] fileseq . fileoption { } if opts . hiddenfiles { fileopts = append ( fileopts , fileseq . hiddenfiles ) } if opts . singlefiles { fileopts = append ( fileopts , fileseq . singlefiles ) } switch fileseq . padstyle ( opts . padstyle ) { case fileseq . padstylehash1 : fileopts = append ( fileopts , fileseq . fileoptpadstylehash1 ) fmt . println ( " " ) case fileseq . padstylehash4 : fileopts = append ( fileopts , fileseq . fileoptpadstylehash4 ) fmt . println ( " " ) } gopath : = c . gostring ( path ) seqs , err : = fileseq . findsequencesondisk ( gopath , fileopts ... ) if err ! = nil { return nil , 0 , c . cstring ( err . error ( ) ) } num : = uint64 ( len ( seqs ) ) size : = uint64 ( unsafe . sizeof ( c . uint64 t ( 0 ) ) ) list : = c . malloc ( c . size t ( num * size ) ) startptr : = uintptr ( unsafe . pointer ( list ) ) for i , seq : = range seqs { id : = sfileseqs . add ( seq ) ptr : = unsafe . pointer ( startptr + uintptr ( size * uint64 ( i ) ) ) * ( * c . uint64 t ) ( ptr ) = c . uint64 t ( id ) } return filesequences ( list ) , num , nil } 
func printplainresults ( results results ) error { for , res : = range results { fmt . printf ( " \n " , res . origstring ) fmt . printf ( " \n " , res . string ) if res . error ! = " " { fmt . printf ( " \n " , res . error ) continue } typ : = reflect . typeof ( * res ) val : = reflect . valueof ( * res ) for i : = 0 ; i < typ . numfield ( ) ; i ++ { field : = typ . field ( i ) if field . name == " " | | field . name == " " { continue } if field . pkgpath ! = " " { continue } fmt . printf ( " \n " , field . name , val . field ( i ) . interface ( ) ) } fmt . print ( " \n " ) } return nil } 
func printjsonresults ( results results ) error { data , err : = json . marshalindent ( results , " " , " " ) if err ! = nil { return fmt . errorf ( " " , err . error ( ) ) } if , err = io . copy ( os . stdout , bytes . newreader ( data ) ) ; err ! = nil { return fmt . errorf ( " " , err . error ( ) ) } fmt . print ( " \n " ) return nil } 
func newxor64source ( seed int64 ) * xor64source { var s xor64source s . seed ( seed ) return & s } 
func xor64 ( x uint64 ) uint64 { x ^ = x < < 13 x ^ = x > > 7 x ^ = x < < 17 return x } 
func ( s * xor64source ) next ( ) uint64 { x : = xor64 ( uint64 ( * s ) ) * s = xor64source ( x ) return x } 
func ( s * xor64source ) seed ( seed int64 ) { if seed == 0 { seed = seed0 } * s = xor64source ( seed ) } 
func newframeset ( frange string ) ( * frameset , error ) { matches , err : = framerangematches ( frange ) if err ! = nil { return nil , err } frameset : = & frameset { frange , & ranges . inclusiveranges { } } for , match : = range matches { if err = frameset . handlematch ( match ) ; err ! = nil { return nil , err } } return frameset , nil } 
func ( s * frameset ) index ( frame int ) int { return s . rangeptr . index ( frame ) } 
func ( s * frameset ) frame ( index int ) ( int , error ) { return s . rangeptr . value ( index ) } 
func ( s * frameset ) frames ( ) [ ] int { size : = s . rangeptr . len ( ) frames : = make ( [ ] int , size , size ) i : = 0 for it : = s . rangeptr . itervalues ( ) ; ! it . isdone ( ) ; { frames [ i ] = it . next ( ) i ++ } return frames } 
func ( s * frameset ) hasframe ( frame int ) bool { return s . rangeptr . contains ( frame ) } 
func ( s * frameset ) framerangepadded ( pad int ) string { return padframerange ( s . frange , pad ) } 
func ( s * frameset ) invert ( ) * frameset { ptr : = s . rangeptr . inverted ( ) return & frameset { ptr . string ( ) , ptr } } 
func ( s * frameset ) invertedframerange ( pad int ) string { frange : = s . rangeptr . inverted ( ) . string ( ) if pad > 1 { frange = padframerange ( frange , pad ) } return frange } 
func ( s * frameset ) normalize ( ) * frameset { ptr : = s . rangeptr . normalized ( ) return & frameset { ptr . string ( ) , ptr } } 
func isframerange ( frange string ) bool { , err : = framerangematches ( frange ) if err == nil { return true } return false } 
func framerangematches ( frange string ) ( [ ] [ ] string , error ) { for , k : = range defaultpadding . allchars ( ) { frange = strings . replace ( frange , k , " " , - 1 ) } var ( matched bool match [ ] string rx * regexp . regexp ) frange = strings . replace ( frange , " " , " " , - 1 ) parts : = strings . split ( frange , " " ) size : = len ( parts ) matches : = make ( [ ] [ ] string , size , size ) for i , part : = range parts { matched = false for , rx = range rangepatterns { if match = rx . findstringsubmatch ( part ) ; match == nil { continue } matched = true matches [ i ] = match [ 1 : ] } if ! matched { err : = fmt . errorf ( " " , frange , part ) return nil , err } } return matches , nil } 
func torange ( start , end , step int ) [ ] int { nums : = [ ] int { } if step < 1 { step = 1 } if start <= end { for i : = start ; i <= end ; { nums = append ( nums , i ) i += step } } else { for i : = start ; i >= end ; { nums = append ( nums , i ) i - = step } } return nums } 
func minmaxframe ( frames [ ] int ) ( int , int ) { srcframes : = make ( [ ] int , len ( frames ) , len ( frames ) ) copy ( srcframes , frames ) sort . ints ( srcframes ) min , max : = srcframes [ 0 ] , srcframes [ len ( srcframes ) - 1 ] return min , max } 
func newworkmanager ( ) * workmanager { var fileopts [ ] fileseq . fileoption if options . allfiles { fileopts = append ( fileopts , fileseq . hiddenfiles ) } if ! options . seqsonly { fileopts = append ( fileopts , fileseq . singlefiles ) } s : = & workmanager { indirs : make ( chan string ) , inseqs : make ( chan * fileseq . filesequence ) , outseqs : make ( chan fileseq . filesequences ) , fileopts : fileopts , } return s } 
func ( w * workmanager ) process ( rootpaths [ ] string ) error { if w . hasrun { return errors . new ( " " ) } w . hasrun = true var wg sync . waitgroup for i : = 0 ; i < numworkers ; i ++ { wg . add ( 1 ) go func ( ) { w . processsources ( ) wg . done ( ) } ( ) } go func ( ) { if options . recurse { w . loadrecursive ( rootpaths ) } else { w . load ( rootpaths ) } w . closeinputs ( ) } ( ) go func ( ) { wg . wait ( ) w . closeoutput ( ) } ( ) w . processresults ( ) return nil } 
func ( w * workmanager ) processsources ( ) { var ( ok bool path string seq * fileseq . filesequence ) fileopts : = w . fileopts indirs : = w . indirs inseqs : = w . inseqs outseqs : = w . outseqs isdone : = func ( ) bool { return ( indirs == nil && inseqs == nil ) } for ! isdone ( ) { select { case path , ok = < - indirs : if ! ok { indirs = nil continue } seqs , err : = fileseq . findsequencesondisk ( path , fileopts ... ) if err ! = nil { fmt . fprintf ( errout , " \n " , errorpath , path , err ) continue } outseqs < - seqs case seq , ok = < - inseqs : if ! ok { inseqs = nil continue } path , err : = seq . format ( " " ) if err ! = nil { fmt . fprintf ( errout , " \n " , errorpattern , path ) continue } seq , err : = fileseq . findsequenceondisk ( path ) if err ! = nil { if ! os . isnotexist ( err ) { fmt . fprintf ( errout , " \n " , errorpattern , path , err ) } continue } if seq ! = nil { outseqs < - fileseq . filesequences { seq } } } } } 
func ( w * workmanager ) isinputdone ( ) bool { if w . indirs ! = nil { return false } if w . inseqs ! = nil { return false } return true } 
func ( w * workmanager ) closeinputs ( ) { if w . indirs ! = nil { close ( w . indirs ) } if w . inseqs ! = nil { close ( w . inseqs ) } } 
func ( w * workmanager ) load ( paths [ ] string ) { dirs , seqs : = preparepaths ( paths ) for , s : = range seqs { w . inseqs < - s } for , r : = range dirs { w . indirs < - r } } 
func ( w * workmanager ) loadrecursive ( paths [ ] string ) { walkfn : = func ( path string , info os . fileinfo , err error ) error { if err ! = nil { return nil } var isdir bool if info . isdir ( ) { isdir = true } else if info , err = os . stat ( path ) ; err == nil && info . isdir ( ) { isdir = true } if isdir { if ! options . allfiles { if len ( info . name ( ) ) > 1 && strings . hasprefix ( info . name ( ) , " " ) { return walk . skipdir } } w . indirs < - path } return nil } dirs , seqs : = preparepaths ( paths ) for , s : = range seqs { w . inseqs < - s } for , r : = range dirs { r : = r if err : = walk . walk ( r , walkfn ) ; err ! = nil { if err ! = walk . skipdir { fmt . fprintf ( errout , " \n " , errorpath , r , err ) } } } } 
func preparepaths ( paths [ ] string ) ( [ ] string , fileseq . filesequences ) { var ( fi os . fileinfo err error ) dirs : = make ( [ ] string , 0 ) seqs : = make ( fileseq . filesequences , 0 ) previous : = make ( map [ string ] struct { } ) for , p : = range paths { p : = strings . trimspace ( filepath . clean ( p ) ) if p == " " { continue } if , seen : = previous [ p ] ; seen { continue } previous [ p ] = struct { } { } if fi , err = os . stat ( p ) ; err ! = nil { if seq , err : = fileseq . newfilesequence ( p ) ; err == nil { seqs = append ( seqs , seq ) continue } fmt . fprintf ( errout , " \n " , errorpath , p , err ) continue } if ! fi . isdir ( ) { continue } dirs = append ( dirs , p ) } return dirs , seqs } 
func padframerange ( frange string , pad int ) string { if pad < 2 { return frange } size : = strings . count ( frange , " " ) + 1 parts : = make ( [ ] string , size , size ) for i , part : = range strings . split ( frange , " " ) { didmatch : = false for , rx : = range rangepatterns { matched : = rx . findstringsubmatch ( part ) if len ( matched ) == 0 { continue } matched = matched [ 1 : ] size = len ( matched ) switch size { case 1 : parts [ i ] = zfillstring ( matched [ 0 ] , pad ) case 2 : parts [ i ] = fmt . sprintf ( " " , zfillstring ( matched [ 0 ] , pad ) , zfillstring ( matched [ 1 ] , pad ) ) case 4 : parts [ i ] = fmt . sprintf ( " " , zfillstring ( matched [ 0 ] , pad ) , zfillstring ( matched [ 1 ] , pad ) , matched [ 2 ] , matched [ 3 ] ) default : continue } didmatch = true break } if ! didmatch { parts = append ( parts , part ) } } return strings . join ( parts , " " ) } 
func zfillstring ( src string , z int ) string { size : = len ( src ) if size >= z { return src } fill : = strings . repeat ( " " , z - size ) if strings . hasprefix ( src , " " ) { return fmt . sprintf ( " " , fill , src [ 1 : ] ) } return fmt . sprintf ( " " , fill , src ) } 
func zfillint ( src int , z int ) string { if z < 2 { return strconv . itoa ( src ) } return fmt . sprintf ( fmt . sprintf ( " " , z ) , src ) } 
func newinclusiverange ( start , end , step int ) * inclusiverange { if step == 0 { if start <= end { step = 1 } else { step = - 1 } } r : = & inclusiverange { start : start , end : end , step : step , } return r } 
func ( r * inclusiverange ) string ( ) string { var buf strings . builder buf . writestring ( strconv . itoa ( r . start ( ) ) ) if r . end ( ) ! = r . start ( ) { buf . writestring ( ' - ' ) buf . writestring ( strconv . itoa ( r . end ( ) ) ) step : = r . step ( ) if step > 1 | | step < - 1 { buf . writestring ( ' x ' ) buf . writestring ( strconv . itoa ( r . step ( ) ) ) } } return buf . string ( ) } 
func ( r * inclusiverange ) end ( ) int { if r . isendcached { return r . cachedend } r . isendcached = true if r . step == 1 | | r . step == - 1 | | r . start == r . end { r . cachedend = r . end return r . cachedend } if ( r . end < r . start ) && r . step < ( r . end - r . start ) { r . cachedend = r . start return r . cachedend } else if ( r . end > r . start ) && r . step > ( r . end - r . start ) { r . cachedend = r . start return r . cachedend } r . cachedend = r . closestinrange ( r . end , r . start , r . end , r . step ) return r . cachedend } 
func ( r * inclusiverange ) len ( ) int { if r . islencached { return r . cachedlen } diff : = math . abs ( float64 ( r . end - r . start ) ) + 1 r . cachedlen = int ( math . ceil ( diff / math . abs ( float64 ( r . step ) ) ) ) r . islencached = true return r . cachedlen } 
func ( r * inclusiverange ) min ( ) int { start : = r . start ( ) end : = r . end ( ) if start < end { return start } return end } 
func ( r * inclusiverange ) max ( ) int { start : = r . start ( ) end : = r . end ( ) if start > end { return start } return end } 
func ( r * inclusiverange ) contains ( value int ) bool { closest : = r . closestinrange ( value , r . start , r . end ( ) , r . step ) return closest == value } 
func ( * inclusiverange ) closestinrange ( value , start , end , step int ) int { if end >= start { if value < start { return start } else if value > end { return end } } else { if value > start { return start } else if value < end { return end } } if step == 1 | | step == - 1 { return value } return ( ( ( value - start ) / step ) * step ) + start } 
func ( r * inclusiverange ) value ( idx int ) ( int , error ) { if idx < 0 { return 0 , fmt . errorf ( " " , idx ) } start : = r . start ( ) end : = r . end ( ) step : = r . step ( ) val : = start + ( step * idx ) if start <= end && ( val < start | | val > end ) { return 0 , fmt . errorf ( " " , idx , r . len ( ) - 1 ) } else if end < start && ( val > start | | val < end ) { return 0 , fmt . errorf ( " " , idx , r . len ( ) - 1 ) } return val , nil } 
func ( f * inclusiverange ) index ( value int ) int { closest : = f . closestinrange ( value , f . start , f . end ( ) , f . step ) if closest ! = value { return - 1 } idx : = ( value - f . start ) / f . step if idx < 0 { idx * = - 1 } return idx } 
func ( it * inclusiverangeit ) isdone ( ) bool { if it . pos >= it . ptr . len ( ) { return true } return false } 
func ( it * inclusiverangeit ) next ( ) int { val , err : = it . ptr . value ( it . pos ) it . pos ++ if err ! = nil { return it . ptr . end ( ) } return val } 
func ( l * inclusiveranges ) string ( ) string { var buf strings . builder for i , b : = range l . blocks { if i > 0 { buf . writestring ( ' , ' ) } buf . writestring ( b . string ( ) ) } return buf . string ( ) } 
func ( l * inclusiveranges ) len ( ) int { var totallen int for , b : = range l . blocks { totallen += b . len ( ) } return totallen } 
func ( l * inclusiveranges ) start ( ) int { for , b : = range l . blocks { return b . start ( ) } return 0 } 
func ( l * inclusiveranges ) end ( ) int { if l . blocks == nil { return 0 } return l . blocks [ len ( l . blocks ) - 1 ] . end ( ) } 
func ( l * inclusiveranges ) min ( ) int { val : = l . start ( ) for , arange : = range l . blocks { next : = arange . min ( ) if next < val { val = next } } return val } 
func ( l * inclusiveranges ) max ( ) int { val : = l . end ( ) for , arange : = range l . blocks { next : = arange . max ( ) if next > val { val = next } } return val } 
func ( l * inclusiveranges ) numranges ( ) int { if l . blocks == nil { return 0 } return len ( l . blocks ) } 
func ( l * inclusiveranges ) rangeat ( idx int ) * inclusiverange { if idx < 0 | | idx >= l . numranges ( ) { return nil } return l . blocks [ idx ] } 
func ( l * inclusiveranges ) append ( start , end , step int ) { block : = newinclusiverange ( start , end , step ) l . blocks = append ( l . blocks , block ) } 
func ( l * inclusiveranges ) appendunique ( start , end , step int ) { if step == 0 { return } substart : = start subend : = start substep : = step last : = start pending : = 0 var pred func ( ) bool if start <= end { if step < 0 { step * = - 1 } pred = func ( ) bool { return subend <= end } } else { if step > 0 { step * = - 1 } pred = func ( ) bool { return subend >= end } } if len ( l . blocks ) == 0 { l . append ( start , end , step ) return } for ; pred ( ) ; subend += step { if ! l . contains ( subend ) { last = subend if pending == 0 { substart = last } pending ++ continue } if pending == 0 { continue } l . append ( substart , last , substep ) substart = subend + step pending = 0 } if pending > 0 { l . append ( substart , last , substep ) } } 
func ( l * inclusiveranges ) contains ( value int ) bool { for , b : = range l . blocks { if b . contains ( value ) { return true } } return false } 
func ( l * inclusiveranges ) value ( idx int ) ( int , error ) { if idx < 0 { return 0 , fmt . errorf ( " " , idx ) } var err error var val , size , n int for , b : = range l . blocks { size = b . len ( ) if ( idx - n ) < size { if val , err = b . value ( idx - n ) ; err == nil { return val , nil } } n += size } return 0 , fmt . errorf ( " " , idx ) } 
func ( l * inclusiveranges ) index ( value int ) int { var idx , n int for , b : = range l . blocks { if idx = b . index ( value ) ; idx >= 0 { return idx + n } n += b . len ( ) } return - 1 } 
func ( l * inclusiveranges ) normalized ( invert bool ) * inclusiveranges { normalized : = & inclusiveranges { } var ( start int end int step int current int pending int keepvalue bool ) totalrange : = newinclusiverange ( l . min ( ) , l . max ( ) , 1 ) checkvalue : = l . contains if ! invert { checkvalue = func ( value int ) bool { return ! l . contains ( value ) } } for it : = totalrange . itervalues ( ) ; ! it . isdone ( ) ; { current = it . next ( ) keepvalue = checkvalue ( current ) if keepvalue { if pending < 2 { step ++ continue } if ( current + 1 - end ) ! = step { normalized . append ( start , end , step ) step = 1 start = current pending = 0 } continue } if pending >= 2 && current - end ! = step { normalized . append ( start , end , step ) pending = 0 } end = current if pending == 0 { start = end step = 1 } pending ++ continue } if pending > 0 { normalized . append ( start , end , step ) } return normalized } 
func ( it * inclusiverangesit ) isdone ( ) bool { if ! it . init ( ) { return true } return it . current . isdone ( ) } 
func ( it * inclusiverangesit ) next ( ) int { if ! it . init ( ) { return it . ptr . end ( ) } val : = it . current . next ( ) if it . current . isdone ( ) { it . pos ++ it . current = nil } return val } 
func ( s * filesequence ) format ( tpl string ) ( string , error ) { c : = map [ string ] interface { } { " " : s . dirname , " " : s . basename , " " : s . ext , " " : s . start , " " : s . end , " " : s . len , " " : s . padding , " " : s . zfill , " " : s . framerange , " " : s . invertedframerange , } t , err : = template . new ( " " ) . funcs ( c ) . parse ( tpl ) if err ! = nil { return " " , err } var buf bytes . buffer err = t . execute ( & buf , c ) if err ! = nil { return " " , err } return buf . string ( ) , nil } 
func ( s * filesequence ) split ( ) filesequences { if s . frameset == nil { return filesequences { s . copy ( ) } } franges : = strings . split ( s . frameset . framerange ( ) , " " ) if len ( franges ) == 1 { return filesequences { s . copy ( ) } } var buf strings . builder buf . writestring ( s . dir ) buf . writestring ( s . basename ) list : = make ( filesequences , len ( franges ) ) var seq * filesequence for i , frange : = range franges { buf . writestring ( frange ) buf . writestring ( s . padchar ) buf . writestring ( s . ext ) seq , = newfilesequence ( buf . string ( ) ) list [ i ] = seq buf . reset ( ) } return list } 
func ( s * filesequence ) paddingstyle ( ) padstyle { for style , mapper : = range padders { if mapper == s . padmapper { return style } } return padstyledefault } 
func ( s * filesequence ) start ( ) int { if s . frameset == nil { return 0 } return s . frameset . start ( ) } 
func ( s * filesequence ) end ( ) int { if s . frameset == nil { return 0 } return s . frameset . end ( ) } 
func ( s * filesequence ) framerange ( ) string { if s . frameset == nil { return " " } return s . frameset . framerange ( ) } 
func ( s * filesequence ) framerangepadded ( ) string { if s . frameset == nil { return " " } return s . frameset . framerangepadded ( s . zfill ) } 
func ( s * filesequence ) invertedframerange ( ) string { if s . frameset == nil { return " " } return s . frameset . invertedframerange ( 0 ) } 
func ( s * filesequence ) invertedframerangepadded ( ) string { if s . frameset == nil { return " " } return s . frameset . invertedframerange ( s . zfill ) } 
func ( s * filesequence ) frame ( frame interface { } ) ( string , error ) { var zframe string var isint bool if s . frameset ! = nil { switch t : = frame . ( type ) { case int : var i int = t zframe = zfillint ( i , s . zfill ) isint = true case string : zframe = t case [ ] byte : zframe = string ( t ) case fmt . stringer : zframe = t . string ( ) default : return zframe , fmt . errorf ( " " , t ) } if ! isint { if , err : = strconv . atoi ( zframe ) ; err == nil { zframe = zfillstring ( zframe , s . zfill ) } } } var buf strings . builder buf . writestring ( s . dir ) buf . writestring ( s . basename ) buf . writestring ( zframe ) buf . writestring ( s . ext ) return buf . string ( ) , nil } 
func ( s * filesequence ) frameint ( frame int ) string { var zframe string if s . frameset ! = nil { zframe = zfillint ( frame , s . zfill ) } var buf strings . builder buf . writestring ( s . dir ) buf . writestring ( s . basename ) buf . writestring ( zframe ) buf . writestring ( s . ext ) return buf . string ( ) } 
func ( s * filesequence ) index ( idx int ) string { if s . frameset == nil { return s . string ( ) } frame , err : = s . frameset . frame ( idx ) if err ! = nil { return " " } path , err : = s . frame ( frame ) if err ! = nil { return " " } return path } 
func ( s * filesequence ) setdirname ( dir string ) { if ! strings . hassuffix ( dir , string ( filepath . separator ) ) { dir = dir + string ( filepath . separator ) } s . dir = dir } 
func ( s * filesequence ) setpadding ( padchars string ) { s . padchar = padchars s . zfill = s . padmapper . paddingcharssize ( padchars ) } 
func ( s * filesequence ) setpaddingstyle ( style padstyle ) { s . padmapper = padders [ style ] s . setpadding ( s . padmapper . paddingchars ( s . zfill ( ) ) ) } 
func ( s * filesequence ) setext ( ext string ) { if ! strings . hasprefix ( ext , " " ) { ext = " " + ext } s . ext = ext } 
func ( s * filesequence ) setframerange ( framerange string ) error { frameset , err : = newframeset ( framerange ) if err ! = nil { return err } s . frameset = frameset return nil } 
func ( s * filesequence ) len ( ) int { if s . frameset == nil { return 1 } return s . frameset . len ( ) } 
func ( s * filesequence ) string ( ) string { var fs string if s . frameset ! = nil { fs = s . frameset . string ( ) } buf : = bytes . newbufferstring ( s . dir ) buf . writestring ( s . basename ) buf . writestring ( fs ) buf . writestring ( s . padchar ) buf . writestring ( s . ext ) return buf . string ( ) } 
func ( s * filesequence ) copy ( ) * filesequence { seq , : = newfilesequence ( s . string ( ) ) return seq } 
func findsequencesondisk ( path string , opts ... fileoption ) ( filesequences , error ) { return findsequencesondisk ( path , opts ... ) } 
func findsequenceondisk ( pattern string , opts ... fileoption ) ( * filesequence , error ) { return findsequenceondiskpad ( pattern , padstyledefault , opts ... ) } 
func findsequenceondiskpad ( pattern string , padstyle padstyle , opts ... fileoption ) ( * filesequence , error ) { optscopy : = make ( [ ] fileoption , len ( opts ) ) copy ( optscopy , opts ) var strictpadding bool for , opt : = range opts { switch opt { case fileoptpadstylehash1 : padstyle = padstylehash1 optscopy = append ( optscopy , fileoptpadstylehash1 ) case fileoptpadstylehash4 : padstyle = padstylehash4 optscopy = append ( optscopy , fileoptpadstylehash4 ) case strictpadding : strictpadding = true } } fs , err : = newfilesequencepad ( pattern , padstyle ) if err ! = nil { fmt . println ( err . error ( ) ) return nil , nil } seqs , err : = findsequencesondisk ( fs . dirname ( ) , optscopy ... ) if err ! = nil { return nil , fmt . errorf ( " " , pattern , err . error ( ) ) } base : = fs . basename ( ) ext : = fs . ext ( ) pad : = fs . padding ( ) fill : = fs . zfill ( ) for , seq : = range seqs { if seq . basename ( ) ! = base | | seq . ext ( ) ! = ext { continue } seq . setpaddingstyle ( padstyle ) if strictpadding && pad ! = " " && seq . zfill ( ) ! = fill { continue } return seq , nil } return nil , nil } 
func newclient ( url string , tls bool , header interface { } ) * client { return & client { url : url , tls : tls , header : header , } } 
func ( h * header ) unmarshalxml ( d * xml . decoder , start xml . startelement ) error { var ( token xml . token err error ) loop : for { if token , err = d . token ( ) ; err ! = nil { return err } if token == nil { break } switch se : = token . ( type ) { case xml . startelement : if err = d . decodeelement ( h . content , & se ) ; err ! = nil { return err } case xml . endelement : break loop } } return nil } 
func ( b * body ) unmarshalxml ( d * xml . decoder , start xml . startelement ) error { if b . content == nil { return xml . unmarshalerror ( " " ) } var ( token xml . token err error consumed bool ) loop : for { if token , err = d . token ( ) ; err ! = nil { return err } if token == nil { break } envelopenamespace : = " " switch se : = token . ( type ) { case xml . startelement : if consumed { return xml . unmarshalerror ( " " ) } else if se . name . space == envelopenamespace && se . name . local == " " { b . fault = & fault { } b . content = nil err = d . decodeelement ( b . fault , & se ) if err ! = nil { return err } consumed = true } else { if err = d . decodeelement ( b . content , & se ) ; err ! = nil { return err } consumed = true } case xml . endelement : break loop } } return nil } 
func jsondoc ( path string ) ( json . rawmessage , error ) { data , err : = swag . loadfromfileorhttp ( path ) if err ! = nil { return nil , err } return json . rawmessage ( data ) , nil } 
func addloader ( predicate docmatcher , load docloader ) { prev : = loaders loaders = & loader { match : predicate , fn : load , next : prev , } spec . pathloader = loaders . fn } 
func jsonspec ( path string ) ( * document , error ) { data , err : = jsondoc ( path ) if err ! = nil { return nil , err } return analyzed ( data , " " ) } 
func embedded ( orig , flat json . rawmessage ) ( * document , error ) { var origspec , flatspec spec . swagger if err : = json . unmarshal ( orig , & origspec ) ; err ! = nil { return nil , err } if err : = json . unmarshal ( flat , & flatspec ) ; err ! = nil { return nil , err } return & document { raw : orig , origspec : & origspec , spec : & flatspec , } , nil } 
func spec ( path string ) ( * document , error ) { specurl , err : = url . parse ( path ) if err ! = nil { return nil , err } var lasterr error for l : = loaders . next ; l ! = nil ; l = l . next { if loaders . match ( specurl . path ) { b , err2 : = loaders . fn ( path ) if err2 ! = nil { lasterr = err2 continue } doc , err3 : = analyzed ( b , " " ) if err3 ! = nil { return nil , err3 } if doc ! = nil { doc . specfilepath = path } return doc , nil } } if lasterr ! = nil { return nil , lasterr } b , err : = defaultloader . fn ( path ) if err ! = nil { return nil , err } document , err : = analyzed ( b , " " ) if document ! = nil { document . specfilepath = path } return document , err } 
func analyzed ( data json . rawmessage , version string ) ( * document , error ) { if version == " " { version = " " } if version ! = " " { return nil , fmt . errorf ( " " , version ) } raw : = data trimmed : = bytes . trimspace ( data ) if len ( trimmed ) > 0 { if trimmed [ 0 ] ! = ' { ' && trimmed [ 0 ] ! = ' [ ' { yml , err : = swag . bytestoyamldoc ( trimmed ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } d , err : = swag . yamltojson ( yml ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } raw = d } } swspec : = new ( spec . swagger ) if err : = json . unmarshal ( raw , swspec ) ; err ! = nil { return nil , err } origsqspec , err : = clonespec ( swspec ) if err ! = nil { return nil , err } d : = & document { analyzer : analysis . new ( swspec ) , schema : spec . mustloadswagger20schema ( ) , spec : swspec , raw : raw , origspec : origsqspec , } return d , nil } 
func ( d * document ) expanded ( options ... * spec . expandoptions ) ( * document , error ) { swspec : = new ( spec . swagger ) if err : = json . unmarshal ( d . raw , swspec ) ; err ! = nil { return nil , err } var expandoptions * spec . expandoptions if len ( options ) > 0 { expandoptions = options [ 0 ] } else { expandoptions = & spec . expandoptions { relativebase : d . specfilepath , } } if err : = spec . expandspec ( swspec , expandoptions ) ; err ! = nil { return nil , err } dd : = & document { analyzer : analysis . new ( swspec ) , spec : swspec , specfilepath : d . specfilepath , schema : spec . mustloadswagger20schema ( ) , raw : d . raw , origspec : d . origspec , } return dd , nil } 
func ( d * document ) resetdefinitions ( ) * document { defs : = make ( map [ string ] spec . schema , len ( d . origspec . definitions ) ) for k , v : = range d . origspec . definitions { defs [ k ] = v } d . spec . definitions = defs return d } 
func ( d * document ) pristine ( ) * document { dd , : = analyzed ( d . raw ( ) , d . version ( ) ) return dd } 
func opendb ( files [ ] string , flag int ) ( * geoip , error ) { if len ( files ) == 0 { files = [ ] string { " " , " " , " " , " " , " " , } } g : = & geoip { } runtime . setfinalizer ( g , ( * geoip ) . free ) var err error for , file : = range files { if , err : = os . stat ( file ) ; err ! = nil { if os . isexist ( err ) { log . println ( err ) } continue } cbase : = c . cstring ( file ) defer c . free ( unsafe . pointer ( cbase ) ) g . db , err = c . geoip open ( cbase , c . int ( flag ) ) if g . db ! = nil && err ! = nil { break } } if err ! = nil { return nil , fmt . errorf ( " " , files , err ) } if g . db == nil { return nil , fmt . errorf ( " " , files ) } c . geoip set charset ( g . db , c . geoip charset utf8 ) return g , nil } 
func setcustomdirectory ( dir string ) { cdir : = c . cstring ( dir ) c . geoip setup custom directory ( cdir ) } 
func opentypeflag ( dbtype int , flag int ) ( * geoip , error ) { g : = & geoip { } runtime . setfinalizer ( g , ( * geoip ) . free ) var err error g . db , err = c . geoip open type ( c . int ( dbtype ) , c . int ( flag ) ) if err ! = nil { return nil , fmt . errorf ( " " , dbtype , err ) } if g . db == nil { return nil , fmt . errorf ( " " , dbtype ) } c . geoip set charset ( g . db , c . geoip charset utf8 ) return g , nil } 
func ( gi * geoip ) getorg ( ip string ) string { name , : = gi . getname ( ip ) return name } 
func ( gi * geoip ) getregion ( ip string ) ( string , string ) { if gi . db == nil { return " " , " " } cip : = c . cstring ( ip ) defer c . free ( unsafe . pointer ( cip ) ) gi . mu . lock ( ) region : = c . geoip region by addr ( gi . db , cip ) gi . mu . unlock ( ) if region == nil { return " " , " " } countrycode : = c . gostring ( & region . country code [ 0 ] ) regioncode : = c . gostring ( & region . region [ 0 ] ) defer c . free ( unsafe . pointer ( region ) ) return countrycode , regioncode } 
func getregionname ( countrycode , regioncode string ) string { cc : = c . cstring ( countrycode ) defer c . free ( unsafe . pointer ( cc ) ) rc : = c . cstring ( regioncode ) defer c . free ( unsafe . pointer ( rc ) ) region : = c . geoip region name by code ( cc , rc ) if region == nil { return " " } regionname : = c . gostring ( region ) return regionname } 
func ( gi * geoip ) getnamev6 ( ip string ) ( name string , netmask int ) { if gi . db == nil { return } gi . mu . lock ( ) defer gi . mu . unlock ( ) cip : = c . cstring ( ip ) defer c . free ( unsafe . pointer ( cip ) ) cname : = c . geoip name by addr v6 ( gi . db , cip ) if cname ! = nil { name = c . gostring ( cname ) defer c . free ( unsafe . pointer ( cname ) ) netmask = int ( c . geoip last netmask ( gi . db ) ) return } return } 
func ( gi * geoip ) getcountry ( ip string ) ( cc string , netmask int ) { if gi . db == nil { return } gi . mu . lock ( ) defer gi . mu . unlock ( ) cip : = c . cstring ( ip ) defer c . free ( unsafe . pointer ( cip ) ) ccountry : = c . geoip country code by addr ( gi . db , cip ) if ccountry ! = nil { cc = c . gostring ( ccountry ) netmask = int ( c . geoip last netmask ( gi . db ) ) return } return } 
func ( h * filehandler ) write ( b [ ] byte ) ( n int , err error ) { return h . fd . write ( b ) } 
func newrotatingfilehandler ( filename string , maxbytes int , backupcount int ) ( * rotatingfilehandler , error ) { dir : = path . dir ( filename ) os . mkdirall ( dir , 0777 ) h : = new ( rotatingfilehandler ) if maxbytes <= 0 { return nil , fmt . errorf ( " " ) } h . filename = filename h . maxbytes = maxbytes h . backupcount = backupcount var err error h . fd , err = os . openfile ( filename , os . o create | os . o wronly | os . o append , 0666 ) if err ! = nil { return nil , err } f , err : = h . fd . stat ( ) if err ! = nil { return nil , err } h . curbytes = int ( f . size ( ) ) return h , nil } 
func ( h * rotatingfilehandler ) write ( p [ ] byte ) ( n int , err error ) { h . dorollover ( ) n , err = h . fd . write ( p ) h . curbytes += n return } 
func ( h * rotatingfilehandler ) close ( ) error { if h . fd ! = nil { return h . fd . close ( ) } return nil } 
func ( h * timerotatingfilehandler ) write ( b [ ] byte ) ( n int , err error ) { h . dorollover ( ) return h . fd . write ( b ) } 
func fatal ( args ... interface { } ) { logger . output ( 2 , levelfatal , fmt . sprint ( args ... ) ) os . exit ( 1 ) } 
func fatalf ( format string , args ... interface { } ) { logger . output ( 2 , levelfatal , fmt . sprintf ( format , args ... ) ) os . exit ( 1 ) } 
func fatalln ( args ... interface { } ) { logger . output ( 2 , levelfatal , fmt . sprintln ( args ... ) ) os . exit ( 1 ) } 
func panic ( args ... interface { } ) { msg : = fmt . sprint ( args ... ) logger . output ( 2 , levelerror , msg ) panic ( msg ) } 
func panicf ( format string , args ... interface { } ) { msg : = fmt . sprintf ( format , args ... ) logger . output ( 2 , levelerror , msg ) panic ( msg ) } 
func panicln ( args ... interface { } ) { msg : = fmt . sprintln ( args ... ) logger . output ( 2 , levelerror , msg ) panic ( msg ) } 
func printf ( format string , args ... interface { } ) { logger . output ( 2 , leveltrace , fmt . sprintf ( format , args ... ) ) } 
func debugf ( format string , args ... interface { } ) { logger . output ( 2 , leveldebug , fmt . sprintf ( format , args ... ) ) } 
func errorf ( format string , args ... interface { } ) { logger . output ( 2 , levelerror , fmt . sprintf ( format , args ... ) ) } 
func infof ( format string , args ... interface { } ) { logger . output ( 2 , levelinfo , fmt . sprintf ( format , args ... ) ) } 
func warnf ( format string , args ... interface { } ) { logger . output ( 2 , levelwarn , fmt . sprintf ( format , args ... ) ) } 
func ( l level ) string ( ) string { switch l { case leveltrace : return " " case leveldebug : return " " case levelinfo : return " " case levelwarn : return " " case levelerror : return " " case levelfatal : return " " } return " " } 
func new ( handler handler , flag int ) * logger { var l = new ( logger ) l . level = levelinfo l . handler = handler l . flag = flag l . bufs = sync . pool { new : func ( ) interface { } { return make ( [ ] byte , 0 , 1024 ) } , } return l } 
func ( l * logger ) close ( ) { l . hlock . lock ( ) defer l . hlock . unlock ( ) l . handler . close ( ) } 
func ( l * logger ) setlevelbyname ( name string ) { level : = levelinfo switch strings . tolower ( name ) { case " " : level = leveltrace case " " : level = leveldebug case " " , " " : level = levelwarn case " " : level = levelerror case " " : level = levelfatal default : level = levelinfo } l . setlevel ( level ) } 
func ( l * logger ) outputjson ( calldepth int , level level , body interface { } ) { if l . level > level { return } buf : = l . bufs . get ( ) . ( [ ] byte ) buf = buf [ 0 : 0 ] defer l . bufs . put ( buf ) type jsonlog struct { time string ' json : " log time " ' level string ' json : " log level " ' file string ' json : " log file " ' line string ' json : " log line " ' body interface { } ' json : " log body " ' } var jsonlog jsonlog if l . flag & ltime > 0 { now : = time . now ( ) . format ( timeformat ) jsonlog . time = now } if l . flag & llevel > 0 { jsonlog . level = level . string ( ) } if l . flag & lfile > 0 { , file , line , ok : = runtime . caller ( calldepth ) if ! ok { file = " " line = 0 } else { for i : = len ( file ) - 1 ; i > 0 ; i -- { if file [ i ] == ' / ' { file = file [ i + 1 : ] break } } } jsonlog . file = file jsonlog . line = string ( strconv . appendint ( buf , int64 ( line ) , 10 ) ) } jsonlog . body = body msg , : = json . marshal ( jsonlog ) msg = append ( msg , ' \n ' ) l . hlock . lock ( ) l . handler . write ( msg ) l . hlock . unlock ( ) } 
func ( l * logger ) fatal ( args ... interface { } ) { l . output ( 2 , levelfatal , fmt . sprint ( args ... ) ) os . exit ( 1 ) } 
func ( l * logger ) fatalf ( format string , args ... interface { } ) { l . output ( 2 , levelfatal , fmt . sprintf ( format , args ... ) ) os . exit ( 1 ) } 
func ( l * logger ) fatalln ( args ... interface { } ) { l . output ( 2 , levelfatal , fmt . sprintln ( args ... ) ) os . exit ( 1 ) } 
func ( l * logger ) panic ( args ... interface { } ) { msg : = fmt . sprint ( args ... ) l . output ( 2 , levelerror , msg ) panic ( msg ) } 
func ( l * logger ) panicf ( format string , args ... interface { } ) { msg : = fmt . sprintf ( format , args ... ) l . output ( 2 , levelerror , msg ) panic ( msg ) } 
func ( l * logger ) panicln ( args ... interface { } ) { msg : = fmt . sprintln ( args ... ) l . output ( 2 , levelerror , msg ) panic ( msg ) } 
func ( l * logger ) print ( args ... interface { } ) { l . output ( 2 , leveltrace , fmt . sprint ( args ... ) ) } 
func ( l * logger ) printf ( format string , args ... interface { } ) { l . output ( 2 , leveltrace , fmt . sprintf ( format , args ... ) ) } 
func ( l * logger ) println ( args ... interface { } ) { l . output ( 2 , leveltrace , fmt . sprintln ( args ... ) ) } 
func ( l * logger ) debug ( args ... interface { } ) { l . output ( 2 , leveldebug , fmt . sprint ( args ... ) ) } 
func ( l * logger ) debugf ( format string , args ... interface { } ) { l . output ( 2 , leveldebug , fmt . sprintf ( format , args ... ) ) } 
func ( l * logger ) debugln ( args ... interface { } ) { l . output ( 2 , leveldebug , fmt . sprintln ( args ... ) ) } 
func ( l * logger ) error ( args ... interface { } ) { l . output ( 2 , levelerror , fmt . sprint ( args ... ) ) } 
func ( l * logger ) errorf ( format string , args ... interface { } ) { l . output ( 2 , levelerror , fmt . sprintf ( format , args ... ) ) } 
func ( l * logger ) errorln ( args ... interface { } ) { l . output ( 2 , levelerror , fmt . sprintln ( args ... ) ) } 
func ( l * logger ) info ( args ... interface { } ) { l . output ( 2 , levelinfo , fmt . sprint ( args ... ) ) } 
func ( l * logger ) infof ( format string , args ... interface { } ) { l . output ( 2 , levelinfo , fmt . sprintf ( format , args ... ) ) } 
func ( l * logger ) infoln ( args ... interface { } ) { l . output ( 2 , levelinfo , fmt . sprintln ( args ... ) ) } 
func ( l * logger ) warn ( args ... interface { } ) { l . output ( 2 , levelwarn , fmt . sprint ( args ... ) ) } 
func ( l * logger ) warnf ( format string , args ... interface { } ) { l . output ( 2 , levelwarn , fmt . sprintf ( format , args ... ) ) } 
func ( l * logger ) warnln ( args ... interface { } ) { l . output ( 2 , levelwarn , fmt . sprintln ( args ... ) ) } 
func newstreamhandler ( w io . writer ) ( * streamhandler , error ) { h : = new ( streamhandler ) h . w = w return h , nil } 
func ( h * streamhandler ) write ( b [ ] byte ) ( n int , err error ) { return h . w . write ( b ) } 
func ( h * nullhandler ) write ( b [ ] byte ) ( n int , err error ) { return len ( b ) , nil } 
func left ( str string , length int , pad string ) string { return times ( pad , length - len ( str ) ) + str } 
func right ( str string , length int , pad string ) string { return str + times ( pad , length - len ( str ) ) } 
func left ( str string , len int , pad string ) string { return times ( pad , len - utf8 . runecountinstring ( str ) ) + str } 
func new ( h string , a rsapi . authenticator ) * api { api : = rsapi . new ( h , a ) api . metadata = genmetadata return & api { api : api } } 
func removeprefixes ( r * regexp . regexp , num int ) ( result * regexp . regexp ) { path : = strings . trimleft ( r . string ( ) , " " ) paths : = strings . split ( path , " " ) result = regexp . mustcompile ( " " + strings . join ( paths [ num : ] , " " ) ) return } 
func setupmetadata ( ) ( result map [ string ] * metadata . resource ) { result = make ( map [ string ] * metadata . resource ) for n , r : = range ssd . genmetadata { result [ n ] = r for , a : = range r . actions { for , p : = range a . pathpatterns { p . regexp = removeprefixes ( p . regexp , 2 ) } } } for n , r : = range ssc . genmetadata { result [ n ] = r for , a : = range r . actions { for , p : = range a . pathpatterns { p . regexp = removeprefixes ( p . regexp , 2 ) } } } for n , r : = range ssm . genmetadata { result [ n ] = r for , a : = range r . actions { for , p : = range a . pathpatterns { p . regexp = removeprefixes ( p . regexp , 2 ) } } } return } 
func ( p * paramanalyzer ) recordtypes ( root gen . datatype ) { if o , ok : = root . ( * gen . objectdatatype ) ; ok { if , found : = p . paramtypes [ o . typename ] ; ! found { p . paramtypes [ o . typename ] = o for , f : = range o . fields { p . recordtypes ( f . type ) } } } else if a , ok : = root . ( * gen . arraydatatype ) ; ok { p . recordtypes ( a . elemtype . type ) } } 
func appendsorted ( params [ ] * gen . actionparam , param * gen . actionparam ) [ ] * gen . actionparam { params = append ( params , param ) sort . sort ( gen . byname ( params ) ) return params } 
func ( p * paramanalyzer ) parsedatatype ( path string , child * gen . actionparam ) gen . datatype { param : = p . rawparams [ path ] . ( map [ string ] interface { } ) class : = " " if c , ok : = param [ " " ] . ( string ) ; ok { class = c } var res gen . datatype switch class { case " " : i : = gen . basicdatatype ( " " ) res = & i case " " : s : = gen . basicdatatype ( " " ) res = & s case " " : if child ! = nil { res = & gen . arraydatatype { child } } else { s : = gen . basicdatatype ( " " ) p : = p . newparam ( fmt . sprintf ( " " , path ) , map [ string ] interface { } { } , & s ) res = & gen . arraydatatype { p } } case " " : res = new ( gen . sourceuploaddatatype ) case " " , " " : res = & gen . uploaddatatype { typename : " " } case " " : res = new ( gen . enumerabledatatype ) case " " : if current , ok : = p . parsed [ path ] ; ok { res = current . type o : = res . ( * gen . objectdatatype ) o . fields = appendsorted ( o . fields , child ) } else { oname : = p . typename ( path ) res = & gen . objectdatatype { oname , [ ] * gen . actionparam { child } } } } return res } 
func ( p * paramanalyzer ) parseparam ( path string , param map [ string ] interface { } , child * gen . actionparam ) * gen . actionparam { dtype : = p . parsedatatype ( path , child ) return p . newparam ( path , param , dtype ) } 
func nativenamefrompath ( path string ) string { native : = path matches : = childpathregexp . findstringsubmatch ( path ) if matches ! = nil { native = matches [ 1 ] } return native } 
func parseparamname ( name string ) string { if name == " " { return " " } if name == " " { return " " } if name == " " { return " " } p : = partsregexp . replaceallstring ( name , " " ) return inflect . camelizedownfirst ( p ) } 
func togoreturntypename ( name string , slice bool ) string { sliceprefix : = " " if slice { sliceprefix = " " } return fmt . sprintf ( " " , sliceprefix , togotypename ( name ) ) } 
func togotypename ( name string ) string { switch name { case " " , " " : return " " case " " : return " " case " " : return " " case " " , " " : panic ( " " + name + " " ) default : if strings . contains ( name , " " ) { elems : = strings . split ( name , " " ) return strings . join ( elems [ 2 : len ( elems ) ] , " " ) } return name } } 
func prettify ( o interface { } ) string { s , err : = json . marshalindent ( o , " " , " " ) if err ! = nil { return fmt . sprintf ( " " , o ) } return string ( s ) } 
func isbuiltintype ( name string ) bool { for , n : = range builtintypes { if name == n { return true } } return false } 
func ( a * action ) matchhref ( href string ) bool { hrefs : = [ ] string { href , href + " " } for , pattern : = range a . pathpatterns { for , href : = range hrefs { indices : = pattern . regexp . findstringindex ( href ) if indices ! = nil && indices [ 0 ] == 0 && indices [ 1 ] == len ( href ) { return true } } } return false } 
func ( a * action ) paramsbylocation ( loc location ) [ ] string { var res [ ] string for , p : = range a . apiparams { if p . location == loc { res = append ( res , p . name ) } } sort . strings ( res ) return res } 
func ( a * action ) url ( vars [ ] * pathvariable ) ( * actionpath , error ) { candidates : = make ( [ ] * actionpath , len ( a . pathpatterns ) ) allmissing : = [ ] string { } j : = 0 for , p : = range a . pathpatterns { path , names : = p . substitute ( vars ) if path == " " { allmissing = append ( allmissing , names ... ) } else { candidates [ j ] = & actionpath { path , p . httpmethod , len ( names ) } j ++ } } if j == 0 { return nil , fmt . errorf ( " " , strings . join ( allmissing , " " ) ) } candidates = candidates [ : j ] sort . sort ( byweight ( candidates ) ) return candidates [ 0 ] , nil } 
func ( p * pathpattern ) substitute ( vars [ ] * pathvariable ) ( string , [ ] string ) { values : = make ( [ ] interface { } , len ( p . variables ) ) var missing [ ] string var used [ ] string for i , n : = range p . variables { for , v : = range vars { if v . name == n { values [ i ] = v . value used = append ( used , n ) break } } if values [ i ] == nil { missing = append ( missing , n ) } } if len ( missing ) > 0 { return " " , missing } return fmt . sprintf ( p . pattern , values ... ) , used } 
func ( f * fileupload ) marshaljson ( ) ( [ ] byte , error ) { b , err : = ioutil . readall ( f . reader ) if err ! = nil { return nil , err } return json . marshal ( string ( b ) ) } 
func extractuploads ( payload * apiparams ) ( uploads [ ] * fileupload ) { for k , v : = range * payload { if mpart , ok : = v . ( * fileupload ) ; ok { uploads = append ( uploads , mpart ) delete ( * payload , k ) } else if child params , ok : = v . ( apiparams ) ; ok { child uploads : = extractuploads ( & child params ) uploads = append ( uploads , child uploads ... ) } } return uploads } 
func writemultipartparams ( w * multipart . writer , payload apiparams , prefix string ) error { for k , v : = range payload { fieldname : = k if prefix ! = " " { fieldname = fmt . sprintf ( " " , prefix , k ) } switch v . ( type ) { case string : err : = w . writefield ( fieldname , v . ( string ) ) if err ! = nil { return err } case apiparams : err : = writemultipartparams ( w , v . ( apiparams ) , fieldname ) if err ! = nil { return err } default : return fmt . errorf ( " " , fieldname , v ) } } return nil } 
func ( a * api ) performrequest ( req * http . request ) ( * http . response , error ) { if a . auth ! = nil { if err : = a . auth . sign ( req ) ; err ! = nil { return nil , err } } resp , err : = a . client . do ( req ) if err ! = nil { return nil , err } return resp , err } 
func ( a * api ) performrequestwithcontext ( ctx context . context , req * http . request ) ( * http . response , error ) { if a . auth ! = nil { if err : = a . auth . sign ( req ) ; err ! = nil { return nil , err } } resp , err : = a . client . dowithcontext ( ctx , req ) if err ! = nil { return nil , err } return resp , err } 
func identifyparams ( a * metadata . action , params apiparams ) ( payloadparams apiparams , queryparams apiparams ) { payloadparamnames : = a . payloadparamnames ( ) payloadparams = make ( apiparams ) for , n : = range payloadparamnames { if p , ok : = params [ n ] ; ok { payloadparams [ n ] = p } } queryparamnames : = a . queryparamnames ( ) queryparams = make ( apiparams ) for , n : = range queryparamnames { if p , ok : = params [ n ] ; ok { queryparams [ n ] = p } } return payloadparams , queryparams } 
func ( a * api ) loadresponse ( resp * http . response ) ( interface { } , error ) { defer resp . body . close ( ) var respbody interface { } jsonresp , err : = ioutil . readall ( resp . body ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if len ( jsonresp ) > 0 { err = json . unmarshal ( jsonresp , & respbody ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } } loc : = resp . header . get ( " " ) if len ( loc ) > 0 { var bodymap = make ( map [ string ] interface { } ) bodymap [ " " ] = loc respbody = interface { } ( bodymap ) } return respbody , err } 
func ( r * href ) actionpath ( rname , aname string ) ( * metadata . actionpath , error ) { res , ok : = genmetadata [ rname ] if ! ok { return nil , fmt . errorf ( " " , rname ) } var action * metadata . action for , a : = range res . actions { if a . name == aname { action = a break } } if action == nil { return nil , fmt . errorf ( " " , aname , rname ) } vars , err : = res . extractvariables ( string ( * r ) ) if err ! = nil { return nil , err } return action . url ( vars ) } 
func ( r * schedule ) locator ( api * api ) * schedulelocator { return api . schedulelocator ( r . href ) } 
func ( api * api ) schedulelocator ( href string ) * schedulelocator { return & schedulelocator { href ( href ) , api } } 
func ( r * template ) locator ( api * api ) * templatelocator { return api . templatelocator ( r . href ) } 
func ( api * api ) templatelocator ( href string ) * templatelocator { return & templatelocator { href ( href ) , api } } 
func fetchdetails ( client * cm15 . api , envname string , envdetail environmentdetail , sshconfig * [ ] sshconfig ) { for nickname , name : = range envdetail . serverarrays { instances : = serverarray ( client , name ) for , instance : = range instances { ipaddress : = instance . publicipaddresses [ 0 ] number : = getinstancenumber ( instance . name ) * sshconfig = append ( * sshconfig , sshconfig { name : envname + " " + nickname + number , ipaddress : ipaddress } ) } } for nickname , name : = range envdetail . servers { instance : = server ( client , name ) ipaddress : = instance . publicipaddresses [ 0 ] * sshconfig = append ( * sshconfig , sshconfig { name : envname + " " + nickname , ipaddress : ipaddress } ) } } 
func getinstancenumber ( name string ) string { re , : = regexp . compile ( ) matches : = re . findstringsubmatch ( name ) if len ( matches ) == 0 { return " " } return matches [ len ( matches ) - 1 ] } 
func buildaliases ( sshconfig [ ] sshconfig , sshoptions , sshuser string ) string { var aliases string for , conf : = range sshconfig { aliases = aliases + fmt . sprintf ( " \n " , conf . name , sshoptions , sshuser , conf . ipaddress ) } return aliases } 
func serverarray ( client * cm15 . api , name string ) [ ] * cm15 . instance { serverarraylocator : = client . serverarraylocator ( " " ) serverarrays , err : = serverarraylocator . index ( rsapi . apiparams { " " : " " , " " : [ ] string { " " + name } } ) if err ! = nil { fail ( " \n " , err . error ( ) ) } if len ( serverarrays ) == 0 { fail ( " \n " , name ) } else if len ( serverarrays ) ! = 1 { fail ( " \n " , name ) } array : = serverarrays [ 0 ] var instanceshref string for , l : = range array . links { if l [ " " ] == " " { instanceshref = l [ " " ] break } } instancelocator : = client . instancelocator ( instanceshref ) instances , err : = instancelocator . index ( rsapi . apiparams { } ) if err ! = nil { fail ( " \n " , err . error ( ) ) } if len ( instances ) == 0 { fail ( " \n " , name ) } return instances } 
func server ( client * cm15 . api , name string ) * cm15 . instance { serverlocator : = client . serverlocator ( " " ) servers , err : = serverlocator . index ( rsapi . apiparams { " " : " " , " " : [ ] string { " " + name } } ) if err ! = nil { fail ( " \n " , err . error ( ) ) } if len ( servers ) == 0 { fail ( " \n " , name ) } else if len ( servers ) ! = 1 { fail ( " \n " , name ) } return servers [ 0 ] . currentinstance } 
func unmarshal ( path string , target * map [ string ] interface { } ) error { content , err : = loadfile ( path ) if err ! = nil { return fmt . errorf ( " " , path , err ) } err = json . unmarshal ( content , target ) if err ! = nil { return fmt . errorf ( " " , path , err ) } return nil } 
func topackagename ( version string ) string { if version == " " { return " " } parts : = strings . split ( version , " " ) i : = 1 p : = parts [ len ( parts ) - i ] for p == " " && i <= len ( parts ) { i ++ p = parts [ len ( parts ) - i ] } version = strings . join ( parts , " " ) return fmt . sprintf ( " " , version ) } 
func loadfile ( file string ) ( [ ] byte , error ) { if , err : = os . stat ( file ) ; err ! = nil { return nil , fmt . errorf ( " " , file ) } js , err : = ioutil . readfile ( file ) if err ! = nil { return nil , fmt . errorf ( " " , file , err ) } return js , nil } 
func runcommand ( client cmd . commandclient , cmdline * cmd . commandline ) ( resp * http . response , err error ) { cmds : = strings . split ( cmdline . command , " " ) if cmdline . showhelp { err = client . showcommandhelp ( cmdline . command ) } else if len ( cmds ) > 1 && cmds [ 1 ] == " " { err = client . showapiactions ( cmdline . command ) } else { resp , err = client . runcommand ( cmdline . command ) } return } 
func ( r * account ) locator ( api * api ) * accountlocator { for , l : = range r . links { if l [ " " ] == " " { return api . accountlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) accountlocator ( href string ) * accountlocator { return & accountlocator { href ( href ) , api } } 
func ( r * accountgroup ) locator ( api * api ) * accountgrouplocator { for , l : = range r . links { if l [ " " ] == " " { return api . accountgrouplocator ( l [ " " ] ) } } return nil } 
func ( api * api ) accountgrouplocator ( href string ) * accountgrouplocator { return & accountgrouplocator { href ( href ) , api } } 
func ( r * alert ) locator ( api * api ) * alertlocator { for , l : = range r . links { if l [ " " ] == " " { return api . alertlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) alertlocator ( href string ) * alertlocator { return & alertlocator { href ( href ) , api } } 
func ( r * alertspec ) locator ( api * api ) * alertspeclocator { for , l : = range r . links { if l [ " " ] == " " { return api . alertspeclocator ( l [ " " ] ) } } return nil } 
func ( api * api ) alertspeclocator ( href string ) * alertspeclocator { return & alertspeclocator { href ( href ) , api } } 
func ( r * auditentry ) locator ( api * api ) * auditentrylocator { for , l : = range r . links { if l [ " " ] == " " { return api . auditentrylocator ( l [ " " ] ) } } return nil } 
func ( api * api ) auditentrylocator ( href string ) * auditentrylocator { return & auditentrylocator { href ( href ) , api } } 
func ( r * backup ) locator ( api * api ) * backuplocator { for , l : = range r . links { if l [ " " ] == " " { return api . backuplocator ( l [ " " ] ) } } return nil } 
func ( api * api ) backuplocator ( href string ) * backuplocator { return & backuplocator { href ( href ) , api } } 
func ( api * api ) childaccountlocator ( href string ) * childaccountlocator { return & childaccountlocator { href ( href ) , api } } 
func ( r * cloud ) locator ( api * api ) * cloudlocator { for , l : = range r . links { if l [ " " ] == " " { return api . cloudlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) cloudlocator ( href string ) * cloudlocator { return & cloudlocator { href ( href ) , api } } 
func ( r * cloudaccount ) locator ( api * api ) * cloudaccountlocator { for , l : = range r . links { if l [ " " ] == " " { return api . cloudaccountlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) cloudaccountlocator ( href string ) * cloudaccountlocator { return & cloudaccountlocator { href ( href ) , api } } 
func ( r * cookbook ) locator ( api * api ) * cookbooklocator { for , l : = range r . links { if l [ " " ] == " " { return api . cookbooklocator ( l [ " " ] ) } } return nil } 
func ( api * api ) cookbooklocator ( href string ) * cookbooklocator { return & cookbooklocator { href ( href ) , api } } 
func ( r * cookbookattachment ) locator ( api * api ) * cookbookattachmentlocator { for , l : = range r . links { if l [ " " ] == " " { return api . cookbookattachmentlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) cookbookattachmentlocator ( href string ) * cookbookattachmentlocator { return & cookbookattachmentlocator { href ( href ) , api } } 
func ( r * credential ) locator ( api * api ) * credentiallocator { for , l : = range r . links { if l [ " " ] == " " { return api . credentiallocator ( l [ " " ] ) } } return nil } 
func ( api * api ) credentiallocator ( href string ) * credentiallocator { return & credentiallocator { href ( href ) , api } } 
func ( r * datacenter ) locator ( api * api ) * datacenterlocator { for , l : = range r . links { if l [ " " ] == " " { return api . datacenterlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) datacenterlocator ( href string ) * datacenterlocator { return & datacenterlocator { href ( href ) , api } } 
func ( r * deployment ) locator ( api * api ) * deploymentlocator { for , l : = range r . links { if l [ " " ] == " " { return api . deploymentlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) deploymentlocator ( href string ) * deploymentlocator { return & deploymentlocator { href ( href ) , api } } 
func ( api * api ) healthchecklocator ( href string ) * healthchecklocator { return & healthchecklocator { href ( href ) , api } } 
func ( r * identityprovider ) locator ( api * api ) * identityproviderlocator { for , l : = range r . links { if l [ " " ] == " " { return api . identityproviderlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) identityproviderlocator ( href string ) * identityproviderlocator { return & identityproviderlocator { href ( href ) , api } } 
func ( r * image ) locator ( api * api ) * imagelocator { for , l : = range r . links { if l [ " " ] == " " { return api . imagelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) imagelocator ( href string ) * imagelocator { return & imagelocator { href ( href ) , api } } 
func ( api * api ) inputlocator ( href string ) * inputlocator { return & inputlocator { href ( href ) , api } } 
func ( r * instance ) locator ( api * api ) * instancelocator { for , l : = range r . links { if l [ " " ] == " " { return api . instancelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) instancelocator ( href string ) * instancelocator { return & instancelocator { href ( href ) , api } } 
func ( r * instancetype ) locator ( api * api ) * instancetypelocator { for , l : = range r . links { if l [ " " ] == " " { return api . instancetypelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) instancetypelocator ( href string ) * instancetypelocator { return & instancetypelocator { href ( href ) , api } } 
func ( r * ipaddress ) locator ( api * api ) * ipaddresslocator { for , l : = range r . links { if l [ " " ] == " " { return api . ipaddresslocator ( l [ " " ] ) } } return nil } 
func ( api * api ) ipaddresslocator ( href string ) * ipaddresslocator { return & ipaddresslocator { href ( href ) , api } } 
func ( r * ipaddressbinding ) locator ( api * api ) * ipaddressbindinglocator { for , l : = range r . links { if l [ " " ] == " " { return api . ipaddressbindinglocator ( l [ " " ] ) } } return nil } 
func ( api * api ) ipaddressbindinglocator ( href string ) * ipaddressbindinglocator { return & ipaddressbindinglocator { href ( href ) , api } } 
func ( r * monitoringmetric ) locator ( api * api ) * monitoringmetriclocator { for , l : = range r . links { if l [ " " ] == " " { return api . monitoringmetriclocator ( l [ " " ] ) } } return nil } 
func ( api * api ) monitoringmetriclocator ( href string ) * monitoringmetriclocator { return & monitoringmetriclocator { href ( href ) , api } } 
func ( r * multicloudimage ) locator ( api * api ) * multicloudimagelocator { for , l : = range r . links { if l [ " " ] == " " { return api . multicloudimagelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) multicloudimagelocator ( href string ) * multicloudimagelocator { return & multicloudimagelocator { href ( href ) , api } } 
func ( r * multicloudimagematcher ) locator ( api * api ) * multicloudimagematcherlocator { for , l : = range r . links { if l [ " " ] == " " { return api . multicloudimagematcherlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) multicloudimagematcherlocator ( href string ) * multicloudimagematcherlocator { return & multicloudimagematcherlocator { href ( href ) , api } } 
func ( r * multicloudimagesetting ) locator ( api * api ) * multicloudimagesettinglocator { for , l : = range r . links { if l [ " " ] == " " { return api . multicloudimagesettinglocator ( l [ " " ] ) } } return nil } 
func ( api * api ) multicloudimagesettinglocator ( href string ) * multicloudimagesettinglocator { return & multicloudimagesettinglocator { href ( href ) , api } } 
func ( r * network ) locator ( api * api ) * networklocator { for , l : = range r . links { if l [ " " ] == " " { return api . networklocator ( l [ " " ] ) } } return nil } 
func ( api * api ) networklocator ( href string ) * networklocator { return & networklocator { href ( href ) , api } } 
func ( r * networkgateway ) locator ( api * api ) * networkgatewaylocator { for , l : = range r . links { if l [ " " ] == " " { return api . networkgatewaylocator ( l [ " " ] ) } } return nil } 
func ( api * api ) networkgatewaylocator ( href string ) * networkgatewaylocator { return & networkgatewaylocator { href ( href ) , api } } 
func ( r * networkoptiongroup ) locator ( api * api ) * networkoptiongrouplocator { for , l : = range r . links { if l [ " " ] == " " { return api . networkoptiongrouplocator ( l [ " " ] ) } } return nil } 
func ( api * api ) networkoptiongrouplocator ( href string ) * networkoptiongrouplocator { return & networkoptiongrouplocator { href ( href ) , api } } 
func ( r * networkoptiongroupattachment ) locator ( api * api ) * networkoptiongroupattachmentlocator { for , l : = range r . links { if l [ " " ] == " " { return api . networkoptiongroupattachmentlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) networkoptiongroupattachmentlocator ( href string ) * networkoptiongroupattachmentlocator { return & networkoptiongroupattachmentlocator { href ( href ) , api } } 
func ( api * api ) oauth2locator ( href string ) * oauth2locator { return & oauth2locator { href ( href ) , api } } 
func ( r * permission ) locator ( api * api ) * permissionlocator { for , l : = range r . links { if l [ " " ] == " " { return api . permissionlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) permissionlocator ( href string ) * permissionlocator { return & permissionlocator { href ( href ) , api } } 
func ( r * placementgroup ) locator ( api * api ) * placementgrouplocator { for , l : = range r . links { if l [ " " ] == " " { return api . placementgrouplocator ( l [ " " ] ) } } return nil } 
func ( api * api ) placementgrouplocator ( href string ) * placementgrouplocator { return & placementgrouplocator { href ( href ) , api } } 
func ( r * preference ) locator ( api * api ) * preferencelocator { for , l : = range r . links { if l [ " " ] == " " { return api . preferencelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) preferencelocator ( href string ) * preferencelocator { return & preferencelocator { href ( href ) , api } } 
func ( r * publication ) locator ( api * api ) * publicationlocator { for , l : = range r . links { if l [ " " ] == " " { return api . publicationlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) publicationlocator ( href string ) * publicationlocator { return & publicationlocator { href ( href ) , api } } 
func ( r * publicationlineage ) locator ( api * api ) * publicationlineagelocator { for , l : = range r . links { if l [ " " ] == " " { return api . publicationlineagelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) publicationlineagelocator ( href string ) * publicationlineagelocator { return & publicationlineagelocator { href ( href ) , api } } 
func ( r * recurringvolumeattachment ) locator ( api * api ) * recurringvolumeattachmentlocator { for , l : = range r . links { if l [ " " ] == " " { return api . recurringvolumeattachmentlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) recurringvolumeattachmentlocator ( href string ) * recurringvolumeattachmentlocator { return & recurringvolumeattachmentlocator { href ( href ) , api } } 
func ( r * repository ) locator ( api * api ) * repositorylocator { for , l : = range r . links { if l [ " " ] == " " { return api . repositorylocator ( l [ " " ] ) } } return nil } 
func ( api * api ) repositorylocator ( href string ) * repositorylocator { return & repositorylocator { href ( href ) , api } } 
func ( loc * repositorylocator ) cookbookimport ( assethrefs [ ] string , options rsapi . apiparams ) error { if len ( assethrefs ) == 0 { return fmt . errorf ( " " ) } var params rsapi . apiparams var p rsapi . apiparams p = rsapi . apiparams { " " : assethrefs , } var followopt = options [ " " ] if followopt ! = nil { p [ " " ] = followopt } var namespaceopt = options [ " " ] if namespaceopt ! = nil { p [ " " ] = namespaceopt } var repositorycommitreferenceopt = options [ " " ] if repositorycommitreferenceopt ! = nil { p [ " " ] = repositorycommitreferenceopt } var withdependenciesopt = options [ " " ] if withdependenciesopt ! = nil { p [ " " ] = withdependenciesopt } uri , err : = loc . actionpath ( " " , " " ) if err ! = nil { return err } req , err : = loc . api . buildhttprequest ( uri . httpmethod , uri . path , apiversion , params , p ) if err ! = nil { return err } resp , err : = loc . api . performrequest ( req ) if err ! = nil { return err } defer resp . body . close ( ) if resp . statuscode < 200 | | resp . statuscode > 299 { respbody , : = ioutil . readall ( resp . body ) sr : = string ( respbody ) if sr ! = " " { sr = " " + sr } return fmt . errorf ( " " , resp . status , sr ) } return nil } 
func ( r * repositoryasset ) locator ( api * api ) * repositoryassetlocator { for , l : = range r . links { if l [ " " ] == " " { return api . repositoryassetlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) repositoryassetlocator ( href string ) * repositoryassetlocator { return & repositoryassetlocator { href ( href ) , api } } 
func ( r * resourcegroup ) locator ( api * api ) * resourcegrouplocator { for , l : = range r . links { if l [ " " ] == " " { return api . resourcegrouplocator ( l [ " " ] ) } } return nil } 
func ( api * api ) resourcegrouplocator ( href string ) * resourcegrouplocator { return & resourcegrouplocator { href ( href ) , api } } 
func ( r * rightscript ) locator ( api * api ) * rightscriptlocator { for , l : = range r . links { if l [ " " ] == " " { return api . rightscriptlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) rightscriptlocator ( href string ) * rightscriptlocator { return & rightscriptlocator { href ( href ) , api } } 
func ( r * rightscriptattachment ) locator ( api * api ) * rightscriptattachmentlocator { for , l : = range r . links { if l [ " " ] == " " { return api . rightscriptattachmentlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) rightscriptattachmentlocator ( href string ) * rightscriptattachmentlocator { return & rightscriptattachmentlocator { href ( href ) , api } } 
func ( r * route ) locator ( api * api ) * routelocator { for , l : = range r . links { if l [ " " ] == " " { return api . routelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) routelocator ( href string ) * routelocator { return & routelocator { href ( href ) , api } } 
func ( r * routetable ) locator ( api * api ) * routetablelocator { for , l : = range r . links { if l [ " " ] == " " { return api . routetablelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) routetablelocator ( href string ) * routetablelocator { return & routetablelocator { href ( href ) , api } } 
func ( r * runnablebinding ) locator ( api * api ) * runnablebindinglocator { for , l : = range r . links { if l [ " " ] == " " { return api . runnablebindinglocator ( l [ " " ] ) } } return nil } 
func ( api * api ) runnablebindinglocator ( href string ) * runnablebindinglocator { return & runnablebindinglocator { href ( href ) , api } } 
func ( api * api ) schedulerlocator ( href string ) * schedulerlocator { return & schedulerlocator { href ( href ) , api } } 
func ( r * securitygroup ) locator ( api * api ) * securitygrouplocator { for , l : = range r . links { if l [ " " ] == " " { return api . securitygrouplocator ( l [ " " ] ) } } return nil } 
func ( api * api ) securitygrouplocator ( href string ) * securitygrouplocator { return & securitygrouplocator { href ( href ) , api } } 
func ( r * securitygrouprule ) locator ( api * api ) * securitygrouprulelocator { for , l : = range r . links { if l [ " " ] == " " { return api . securitygrouprulelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) securitygrouprulelocator ( href string ) * securitygrouprulelocator { return & securitygrouprulelocator { href ( href ) , api } } 
func ( r * server ) locator ( api * api ) * serverlocator { for , l : = range r . links { if l [ " " ] == " " { return api . serverlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) serverlocator ( href string ) * serverlocator { return & serverlocator { href ( href ) , api } } 
func ( r * serverarray ) locator ( api * api ) * serverarraylocator { for , l : = range r . links { if l [ " " ] == " " { return api . serverarraylocator ( l [ " " ] ) } } return nil } 
func ( api * api ) serverarraylocator ( href string ) * serverarraylocator { return & serverarraylocator { href ( href ) , api } } 
func ( r * servertemplate ) locator ( api * api ) * servertemplatelocator { for , l : = range r . links { if l [ " " ] == " " { return api . servertemplatelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) servertemplatelocator ( href string ) * servertemplatelocator { return & servertemplatelocator { href ( href ) , api } } 
func ( loc * servertemplatelocator ) publish ( accountgrouphrefs [ ] string , descriptions * descriptions , options rsapi . apiparams ) error { if len ( accountgrouphrefs ) == 0 { return fmt . errorf ( " " ) } if descriptions == nil { return fmt . errorf ( " " ) } var params rsapi . apiparams var p rsapi . apiparams p = rsapi . apiparams { " " : accountgrouphrefs , " " : descriptions , } var allowcommentsopt = options [ " " ] if allowcommentsopt ! = nil { p [ " " ] = allowcommentsopt } var categoriesopt = options [ " " ] if categoriesopt ! = nil { p [ " " ] = categoriesopt } var emailcommentsopt = options [ " " ] if emailcommentsopt ! = nil { p [ " " ] = emailcommentsopt } uri , err : = loc . actionpath ( " " , " " ) if err ! = nil { return err } req , err : = loc . api . buildhttprequest ( uri . httpmethod , uri . path , apiversion , params , p ) if err ! = nil { return err } resp , err : = loc . api . performrequest ( req ) if err ! = nil { return err } defer resp . body . close ( ) if resp . statuscode < 200 | | resp . statuscode > 299 { respbody , : = ioutil . readall ( resp . body ) sr : = string ( respbody ) if sr ! = " " { sr = " " + sr } return fmt . errorf ( " " , resp . status , sr ) } return nil } 
func ( r * servertemplatemulticloudimage ) locator ( api * api ) * servertemplatemulticloudimagelocator { for , l : = range r . links { if l [ " " ] == " " { return api . servertemplatemulticloudimagelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) servertemplatemulticloudimagelocator ( href string ) * servertemplatemulticloudimagelocator { return & servertemplatemulticloudimagelocator { href ( href ) , api } } 
func ( r * session ) locator ( api * api ) * sessionlocator { for , l : = range r . links { if l [ " " ] == " " { return api . sessionlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) sessionlocator ( href string ) * sessionlocator { return & sessionlocator { href ( href ) , api } } 
func ( r * sshkey ) locator ( api * api ) * sshkeylocator { for , l : = range r . links { if l [ " " ] == " " { return api . sshkeylocator ( l [ " " ] ) } } return nil } 
func ( api * api ) sshkeylocator ( href string ) * sshkeylocator { return & sshkeylocator { href ( href ) , api } } 
func ( r * subnet ) locator ( api * api ) * subnetlocator { for , l : = range r . links { if l [ " " ] == " " { return api . subnetlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) subnetlocator ( href string ) * subnetlocator { return & subnetlocator { href ( href ) , api } } 
func ( api * api ) taglocator ( href string ) * taglocator { return & taglocator { href ( href ) , api } } 
func ( r * task ) locator ( api * api ) * tasklocator { for , l : = range r . links { if l [ " " ] == " " { return api . tasklocator ( l [ " " ] ) } } return nil } 
func ( api * api ) tasklocator ( href string ) * tasklocator { return & tasklocator { href ( href ) , api } } 
func ( r * user ) locator ( api * api ) * userlocator { for , l : = range r . links { if l [ " " ] == " " { return api . userlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) userlocator ( href string ) * userlocator { return & userlocator { href ( href ) , api } } 
func ( api * api ) userdatalocator ( href string ) * userdatalocator { return & userdatalocator { href ( href ) , api } } 
func ( r * volume ) locator ( api * api ) * volumelocator { for , l : = range r . links { if l [ " " ] == " " { return api . volumelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) volumelocator ( href string ) * volumelocator { return & volumelocator { href ( href ) , api } } 
func ( r * volumeattachment ) locator ( api * api ) * volumeattachmentlocator { for , l : = range r . links { if l [ " " ] == " " { return api . volumeattachmentlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) volumeattachmentlocator ( href string ) * volumeattachmentlocator { return & volumeattachmentlocator { href ( href ) , api } } 
func ( r * volumesnapshot ) locator ( api * api ) * volumesnapshotlocator { for , l : = range r . links { if l [ " " ] == " " { return api . volumesnapshotlocator ( l [ " " ] ) } } return nil } 
func ( api * api ) volumesnapshotlocator ( href string ) * volumesnapshotlocator { return & volumesnapshotlocator { href ( href ) , api } } 
func ( r * volumetype ) locator ( api * api ) * volumetypelocator { for , l : = range r . links { if l [ " " ] == " " { return api . volumetypelocator ( l [ " " ] ) } } return nil } 
func ( api * api ) volumetypelocator ( href string ) * volumetypelocator { return & volumetypelocator { href ( href ) , api } } 
func registercommands ( registrar rsapi . apicommandregistrar ) { commandvalues = rsapi . actioncommands { } registrar . registeractioncommands ( apiname , genmetadata , commandvalues ) } 
func ( a * api ) runcommand ( cmd string ) ( * http . response , error ) { c , err : = a . parsecommand ( cmd , " " , commandvalues ) if err ! = nil { return nil , err } req , err : = a . buildhttprequest ( c . httpmethod , c . uri , " " , c . queryparams , c . payloadparams ) if err ! = nil { return nil , err } return a . performrequest ( req ) } 
func ( a * api ) showcommandhelp ( cmd string ) error { return a . showhelp ( cmd , " " , commandvalues ) } 
func ( a * api ) showapiactions ( cmd string ) error { return a . showactions ( cmd , " " , commandvalues ) } 
func ( a * api ) showhelp ( cmd , hrefprefix string , values actioncommands ) error { target , , err : = a . parsecommandandflags ( cmd , hrefprefix , values ) if err ! = nil { return err } , action , href : = target . resource , target . action , target . href if len ( action . commandflags ) == 0 { fmt . printf ( " \n \n \n " , strings . split ( cmd , " " ) [ 0 ] , action . name , href , action . description ) return nil } flaghelp : = make ( [ ] string , len ( action . commandflags ) ) for i , f : = range action . commandflags { var attrs string if f . mandatory { attrs = " " } else { attrs = " " } if len ( f . validvalues ) > 0 { attrs += " " + strings . join ( f . validvalues , " " ) + " " } if f . regexp ! = nil { attrs += " " + f . regexp . string ( ) + " " } flaghelp [ i ] = fmt . sprintf ( " \n " , f . name , f . type , attrs , f . description ) } fmt . printf ( " \n \n \n \n " , strings . split ( cmd , " " ) [ 0 ] , action . name , href , action . description ) fmt . printf ( " \n \n " , strings . join ( flaghelp , " \n \n " ) ) return nil } 
func ( a * api ) parsecommandandflags ( cmd , hrefprefix string , values actioncommands ) ( * commandtarget , [ ] string , error ) { resource , vars , err : = a . parseresource ( cmd , hrefprefix , values ) if err ! = nil { return nil , nil , err } var action * metadata . action elems : = strings . split ( cmd , " " ) actionname : = elems [ len ( elems ) - 1 ] for , a : = range resource . actions { if a . name == actionname { action = a break } } if action == nil { supported : = make ( [ ] string , len ( resource . actions ) ) for i , a : = range resource . actions { supported [ i ] = a . name } return nil , nil , fmt . errorf ( " " , resource . name , actionname , strings . join ( supported , " " ) ) } path , err : = action . url ( vars ) if err ! = nil { return nil , nil , err } flags : = values [ cmd ] return & commandtarget { resource , action , path , flags . href } , flags . params , nil } 
func ( a * api ) findparamandvalue ( action * metadata . action , flag string ) ( * metadata . actionparam , string , error ) { elems : = strings . splitn ( flag , " " , 2 ) if len ( elems ) ! = 2 { return nil , " " , fmt . errorf ( " " , flag ) } name : = elems [ 0 ] value : = elems [ 1 ] var param * metadata . actionparam for , ap : = range action . commandflags { if ap . name == name { param = ap break } } if param == nil && strings . contains ( name , " " ) { name = name [ : strings . lastindex ( name , " " ) ] for , ap : = range action . commandflags { if ap . name == name { param = ap es : = captureenumregex . findstringsubmatch ( elems [ 0 ] ) if es == nil { return nil , " " , fmt . errorf ( " " , flag ) } value = es [ 1 ] + " " + value break } } } return param , value , nil } 
func validateflagvalue ( value string , param * metadata . actionparam ) error { if param . regexp ! = nil { if ! param . regexp . matchstring ( value ) { return fmt . errorf ( " " , value , param . name , param . regexp . string ( ) ) } } if param . nonblank && value == " " { return fmt . errorf ( " " , param . name ) } if len ( param . validvalues ) > 0 && param . name ! = " " { found : = false for , v : = range param . validvalues { if v == value { found = true break } } if ! found { return fmt . errorf ( " " , param . name , strings . join ( param . validvalues , " " ) , value ) } } return nil } 
func buildquery ( values [ ] apiparams ) ( apiparams , error ) { query : = apiparams { } for , value : = range values { for name , param : = range value { if q , ok : = query [ name ] ; ok { if a , ok : = q . ( [ ] interface { } ) ; ok { query [ name ] = append ( a , param ) } else { query [ name ] = [ ] interface { } { q , param } } } else { query [ name ] = param } } } return query , nil } 
func buildpayload ( values [ ] apiparams ) ( apiparams , error ) { payload : = apiparams { } for , value : = range values { for name , param : = range value { if , err : = normalize ( payload , name , param ) ; err ! = nil { return nil , err } } } return payload , nil } 
func shortenpattern ( res * metadata . resource , pattern , suffix string ) ( string , bool ) { if strings . hassuffix ( pattern , suffix ) { pat : = strings . trimsuffix ( pattern , suffix ) for , action : = range res . actions { for , pattern2 : = range action . pathpatterns { vars : = pattern2 . variables ivars : = make ( [ ] interface { } , len ( vars ) ) for i , v : = range vars { ivars [ i ] = interface { } ( " " + v ) } subpattern : = pattern2 . pattern pat2 : = fmt . sprintf ( subpattern , ivars ... ) if pat == pat2 { return pat , true } } } } return pattern , false } 
func tovarname ( name string ) string { p : = partsregexp . replaceallstring ( name , " " ) return inflect . camelizedownfirst ( p ) } 
func cleandescription ( doc string ) string { docbits : = strings . split ( doc , " " ) doc = docbits [ 0 ] lines : = strings . split ( doc , " \n " ) fulllines : = make ( [ ] string , len ( lines ) ) i : = 0 for , line : = range lines { if len ( line ) > 0 && ! blankregexp . matchstring ( line ) { fulllines [ i ] = line i ++ } } return strings . join ( fulllines [ : i ] , " \n " ) } 
func fileexists ( file string ) bool { , err : = os . stat ( file ) return err == nil } 
func ( api * api ) analysissnapshotlocator ( href string ) * analysissnapshotlocator { return & analysissnapshotlocator { href ( href ) , api } } 
func ( api * api ) budgetalertlocator ( href string ) * budgetalertlocator { return & budgetalertlocator { href ( href ) , api } } 
func ( api * api ) cloudbilllocator ( href string ) * cloudbilllocator { return & cloudbilllocator { href ( href ) , api } } 
func ( api * api ) cloudbillmetriclocator ( href string ) * cloudbillmetriclocator { return & cloudbillmetriclocator { href ( href ) , api } } 
func ( api * api ) currentuserlocator ( href string ) * currentuserlocator { return & currentuserlocator { href ( href ) , api } } 
func ( loc * currentuserlocator ) cloudaccounts ( awsaccesskeyid string , awsaccountnumber string , awssecretaccesskey string , cloudvendorname string ) error { if awsaccesskeyid == " " { return fmt . errorf ( " " ) } if awsaccountnumber == " " { return fmt . errorf ( " " ) } if awssecretaccesskey == " " { return fmt . errorf ( " " ) } if cloudvendorname == " " { return fmt . errorf ( " " ) } var params rsapi . apiparams var p rsapi . apiparams p = rsapi . apiparams { " " : awsaccesskeyid , " " : awsaccountnumber , " " : awssecretaccesskey , " " : cloudvendorname , } uri , err : = loc . actionpath ( " " , " " ) if err ! = nil { return err } req , err : = loc . api . buildhttprequest ( uri . httpmethod , uri . path , apiversion , params , p ) if err ! = nil { return err } resp , err : = loc . api . performrequest ( req ) if err ! = nil { return err } defer resp . body . close ( ) if resp . statuscode < 200 | | resp . statuscode > 299 { respbody , : = ioutil . readall ( resp . body ) sr : = string ( respbody ) if sr ! = " " { sr = " " + sr } return fmt . errorf ( " " , resp . status , sr ) } return nil } 
func ( api * api ) instancecombinationlocator ( href string ) * instancecombinationlocator { return & instancecombinationlocator { href ( href ) , api } } 
func ( api * api ) instancemetriclocator ( href string ) * instancemetriclocator { return & instancemetriclocator { href ( href ) , api } } 
func ( api * api ) instanceusageperiodlocator ( href string ) * instanceusageperiodlocator { return & instanceusageperiodlocator { href ( href ) , api } } 
func ( api * api ) patternlocator ( href string ) * patternlocator { return & patternlocator { href ( href ) , api } } 
func ( api * api ) reservedinstancelocator ( href string ) * reservedinstancelocator { return & reservedinstancelocator { href ( href ) , api } } 
func ( api * api ) reservedinstancepurchaselocator ( href string ) * reservedinstancepurchaselocator { return & reservedinstancepurchaselocator { href ( href ) , api } } 
func ( api * api ) scenariolocator ( href string ) * scenariolocator { return & scenariolocator { href ( href ) , api } } 
func ( api * api ) scheduledreportlocator ( href string ) * scheduledreportlocator { return & scheduledreportlocator { href ( href ) , api } } 
func ( api * api ) tempinstancepricelocator ( href string ) * tempinstancepricelocator { return & tempinstancepricelocator { href ( href ) , api } } 
func ( loc * tempinstancepricelocator ) index ( ) ( string , error ) { var res string var params rsapi . apiparams var p rsapi . apiparams uri , err : = loc . actionpath ( " " , " " ) if err ! = nil { return res , err } req , err : = loc . api . buildhttprequest ( uri . httpmethod , uri . path , apiversion , params , p ) if err ! = nil { return res , err } resp , err : = loc . api . performrequest ( req ) if err ! = nil { return res , err } defer resp . body . close ( ) if resp . statuscode < 200 | | resp . statuscode > 299 { respbody , : = ioutil . readall ( resp . body ) sr : = string ( respbody ) if sr ! = " " { sr = " " + sr } return res , fmt . errorf ( " " , resp . status , sr ) } defer resp . body . close ( ) respbody , err : = ioutil . readall ( resp . body ) if err ! = nil { return res , err } res = string ( respbody ) return res , err } 
func ( api * api ) usersettinglocator ( href string ) * usersettinglocator { return & usersettinglocator { href ( href ) , api } } 
func readallasync ( f io . readcloser ) ( * [ ] byte , chan struct { } ) { done : = make ( chan struct { } , 1 ) var buf [ ] byte go func ( ) { var err error buf , err = ioutil . readall ( f ) if err ! = nil { buf = make ( [ ] byte , 0 ) } f . close ( ) done < - struct { } { } } ( ) return & buf , done } 
func extractarg ( name string , args [ ] string ) ( string , [ ] string ) { var val string var newargs [ ] string var skip bool for i , a : = range args { if skip { skip = false continue } if strings . contains ( a , " " ) { elems : = strings . splitn ( a , " " , 2 ) if elems [ 0 ] == name { val = elems [ 1 ] } else { newargs = append ( newargs , a ) } } else if a == name && len ( args ) > ( i + 1 ) { val = args [ i + 1 ] skip = true } else { newargs = append ( newargs , a ) } } return val , newargs } 
func write ( b [ ] byte ) { f , err : = os . openfile ( output , os . o append | os . o wronly | os . o create , 0644 ) if err ! = nil { fail ( " " ) } f . write ( b ) f . writestring ( " \n " ) f . close ( ) } 
func ( api * api ) appliedpolicylocator ( href string ) * appliedpolicylocator { return & appliedpolicylocator { href ( href ) , api } } 
func ( api * api ) approvallocator ( href string ) * approvallocator { return & approvallocator { href ( href ) , api } } 
func ( api * api ) incidentlocator ( href string ) * incidentlocator { return & incidentlocator { href ( href ) , api } } 
func ( api * api ) policytemplatelocator ( href string ) * policytemplatelocator { return & policytemplatelocator { href ( href ) , api } } 
func ( api * api ) publishedtemplatelocator ( href string ) * publishedtemplatelocator { return & publishedtemplatelocator { href ( href ) , api } } 
func ( api * api ) debugcookbookpathlocator ( href string ) * debugcookbookpathlocator { return & debugcookbookpathlocator { href ( href ) , api } } 
func ( api * api ) dockercontrollocator ( href string ) * dockercontrollocator { return & dockercontrollocator { href ( href ) , api } } 
func ( api * api ) envlocator ( href string ) * envlocator { return & envlocator { href ( href ) , api } } 
func ( api * api ) logincontrollocator ( href string ) * logincontrollocator { return & logincontrollocator { href ( href ) , api } } 
func ( api * api ) proclocator ( href string ) * proclocator { return & proclocator { href ( href ) , api } } 
func ( api * api ) rl10locator ( href string ) * rl10locator { return & rl10locator { href ( href ) , api } } 
func ( api * api ) tsslocator ( href string ) * tsslocator { return & tsslocator { href ( href ) , api } } 
func ( api * api ) tsscontrollocator ( href string ) * tsscontrollocator { return & tsscontrollocator { href ( href ) , api } } 
func ( api * api ) tsspluginlocator ( href string ) * tsspluginlocator { return & tsspluginlocator { href ( href ) , api } } 
func newangularwriter ( ) ( * angularwriter , error ) { funcmap : = template . funcmap { " " : comment , " " : commandline , " " : path , " " : mandatory , } resourcet , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( angulartmpl ) if err ! = nil { return nil , err } return & angularwriter { angulartmpl : resourcet , } , nil } 
func ( c * angularwriter ) writeresource ( resource * gen . resource , w io . writer ) error { return c . angulartmpl . execute ( w , resource ) } 
func path ( a * gen . action ) string { pattern : = a . pathpatterns [ 0 ] vars : = pattern . variables ivars : = make ( [ ] interface { } , len ( vars ) ) for i , v : = range vars { ivars [ i ] = interface { } ( " " + v ) } return fmt . sprintf ( pattern . pattern , ivars ... ) } 
func mandatory ( a gen . action , param string ) bool { for , p : = range a . params { if p . name == param { return p . mandatory } } panic ( " " + param + " " + a . name ) } 
func new ( host string , auth authenticator ) * api { client : = httpclient . new ( ) if strings . hasprefix ( host , " " ) { host = host [ 7 : ] } else if strings . hasprefix ( host , " " ) { host = host [ 8 : ] } a : = & api { auth : auth , host : host , client : client , } if auth ! = nil { auth . sethost ( host ) } return a } 
func newrl10 ( ) ( * api , error ) { client : = httpclient . new ( ) rllconfig , err : = os . open ( rllsecret ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } defer rllconfig . close ( ) var port string var secret string scanner : = bufio . newscanner ( rllconfig ) for scanner . scan ( ) { line : = scanner . text ( ) elems : = strings . split ( line , " " ) if len ( elems ) ! = 2 { return nil , fmt . errorf ( " " , line ) } switch elems [ 0 ] { case " " : port = elems [ 1 ] if , err : = strconv . atoi ( elems [ 1 ] ) ; err ! = nil { return nil , fmt . errorf ( " " , port ) } case " " : secret = elems [ 1 ] } } if err : = scanner . err ( ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } host : = " " + port auth : = newrl10authenticator ( secret ) auth . sethost ( host ) api : = & api { auth : auth , host : host , client : client , } httpclient . insecure = true return api , nil } 
func ( a * api ) canauthenticate ( ) error { res : = a . auth . canauthenticate ( a . host ) return res } 
func encrypt ( text string ) ( string , error ) { bytes : = [ ] byte ( text ) key : = seekret ( ) block , err : = aes . newcipher ( key ) if err ! = nil { return " " , err } b : = encodebase64 ( bytes ) ciphertext : = make ( [ ] byte , aes . blocksize + len ( b ) ) iv : = ciphertext [ : aes . blocksize ] if , err : = io . readfull ( rand . reader , iv ) ; err ! = nil { return " " , err } cfb : = cipher . newcfbencrypter ( block , iv ) cfb . xorkeystream ( ciphertext [ aes . blocksize : ] , b ) return string ( encodebase64 ( ciphertext ) ) , nil } 
func decrypt ( text string ) ( string , error ) { if text == " " { return " " , nil } key : = seekret ( ) bytes : = decodebase64 ( [ ] byte ( text ) ) block , err : = aes . newcipher ( key ) if err ! = nil { return " " , err } if len ( bytes ) < aes . blocksize { return " " , errors . new ( " " ) } iv : = bytes [ : aes . blocksize ] bytes = bytes [ aes . blocksize : ] cfb : = cipher . newcfbdecrypter ( block , iv ) cfb . xorkeystream ( bytes , bytes ) return string ( decodebase64 ( bytes ) ) , nil } 
func ( a * apianalyzer ) analyzedefinition ( ec evalctx , def * definition , refid string ) gen . datatype { switch def . type { case " " : elemt : = a . typeforref ( ec , def . items ) apelem : = & gen . actionparam { location : gen . payloadparam , type : elemt , } return & gen . arraydatatype { elemtype : apelem , } default : name : = a . guesstype ( ec , def , refid ) if name == " " | | name == " " | | name == " " { return basictype ( " " ) } isrequired : = map [ string ] bool { } for , r : = range def . required { isrequired [ r ] = true } obj : = & gen . objectdatatype { typename : name } keys : = [ ] string { } for propname : = range def . properties { keys = append ( keys , propname ) } sort . strings ( keys ) for , propname : = range keys { prop : = def . properties [ propname ] attr : = a . analyzeproperty ( ec . withtrail ( name ) , propname , isrequired [ propname ] , prop ) obj . fields = append ( obj . fields , attr ) } return obj } } 
func ( a * apianalyzer ) typeforref ( ec evalctx , r ref ) gen . datatype { switch r . type ( ) { case " " : fail ( " " ) case " " : def : = a . doc . ref ( r ) if def == nil { fail ( " " , r ) } dt : = a . analyzedefinition ( ec , def , r . id ( ) ) if objdt , ok : = dt . ( * gen . objectdatatype ) ; ok { a . addtype ( ec , objdt , r ) } return dt } return basictype ( r . type ( ) ) } 
func ( a * apianalyzer ) addtype ( ec evalctx , dt * gen . objectdatatype , r ref ) { a . api . needjson = true if a . refbytype [ dt . typename ] == r . id ( ) { return } if other , ok : = a . api . types [ dt . typename ] ; ok { if ! ec . isresult { dt . typename += " " if a . refbytype [ dt . typename ] == r . id ( ) { return } } oldfields : = [ ] string { } newfields : = [ ] string { } for , f : = range other . fields { oldfields = append ( oldfields , f . name ) } for , f : = range dt . fields { newfields = append ( newfields , f . name ) } use : = " " if len ( newfields ) > len ( oldfields ) { use = " " } if strings . join ( oldfields , " " ) ! = strings . join ( newfields , " " ) { warn ( " \n \n \n \n " , dt . typename , r . id ( ) , newfields , a . refbytype [ dt . typename ] , oldfields , use ) } if use == " " { return } } dbg ( " \n " , prettify ( dt ) ) a . refbytype [ dt . typename ] = r . id ( ) a . api . types [ dt . typename ] = dt } 
func newapianalyzer ( version , clientname string , doc * doc , attroverrides , typeoverrides map [ string ] string ) * apianalyzer { return & apianalyzer { doc : doc , version : version , clientname : clientname , attroverrides : attroverrides , typeoverrides : typeoverrides , refbytype : map [ string ] string { } , } } 
func ( a * apianalyzer ) analyze ( ) ( * gen . apidescriptor , error ) { api : = gen . apidescriptor { version : a . version , resources : make ( map [ string ] * gen . resource ) , types : make ( map [ string ] * gen . objectdatatype ) , } a . api = & api sortedverbs : = [ ] string { " " , " " , " " , " " } paths : = [ ] string { } for path : = range a . doc . paths { paths = append ( paths , path ) } sort . strings ( paths ) for , path : = range paths { endpointmap : = a . doc . paths [ path ] for , verb : = range sortedverbs { if ep , ok : = endpointmap [ verb ] ; ok { a . analyzeendpoint ( verb , path , ep ) } } } a . finalize ( ) return & api , nil } 
func newmetadatawriter ( ) ( * metadatawriter , error ) { funcmap : = template . funcmap { " " : comment , " " : strings . join , " " : commandline , " " : tostringarray , " " : flagtype , " " : location , " " : escapebackticks , } headert , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( headermetadatatmpl ) if err ! = nil { return nil , err } resourcet , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( resourcemetadatatmpl ) if err ! = nil { return nil , err } return & metadatawriter { headertmpl : headert , resourcetmpl : resourcet , } , nil } 
func ( c * metadatawriter ) writeheader ( pkg string , w io . writer ) error { return c . headertmpl . execute ( w , pkg ) } 
func ( c * metadatawriter ) writemetadata ( d * gen . apidescriptor , w io . writer ) error { resources : = make ( [ ] * gen . resource , len ( d . resourcenames ) ) for i , n : = range d . resourcenames { resources [ i ] = d . resources [ n ] } return c . resourcetmpl . execute ( w , resources ) } 
func location ( p * gen . actionparam ) string { switch p . location { case gen . pathparam : return " " case gen . queryparam : return " " case gen . payloadparam : return " " default : return " " } } 
func new ( host string , auth rsapi . authenticator ) * api { return fromapi ( rsapi . new ( host , auth ) ) } 
func newrl10 ( ) ( * api , error ) { raw , err : = rsapi . newrl10 ( ) if err ! = nil { return nil , err } return fromapi ( raw ) , nil } 
func fromapi ( api * rsapi . api ) * api { api . metadata = genmetadata return & api { api } } 
func fromcommandline ( cmdline * cmd . commandline ) ( * api , error ) { api , err : = rsapi . fromcommandline ( cmdline ) if err ! = nil { return nil , err } api . host = apihostfromlogin ( cmdline . host ) api . metadata = genmetadata return & api { api } , nil } 
func setupmetadata ( ) ( result map [ string ] * metadata . resource ) { result = make ( map [ string ] * metadata . resource ) for n , r : = range cac . genmetadata { result [ n ] = r } return } 
func newdisplayer ( resp * http . response ) ( * displayer , error ) { defer resp . body . close ( ) js , err : = ioutil . readall ( resp . body ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } disp : = displayer { response : resp , body : string ( js ) } if len ( js ) > 2 { err = json . unmarshal ( js , & disp . rawoutput ) if err ! = nil { disp . rawoutput = string ( js ) } } return & disp , nil } 
func ( d * displayer ) applysingleextract ( extract string ) error { if err : = d . applyextract ( extract , true ) ; err ! = nil { return err } outputs : = d . rawoutput . ( [ ] interface { } ) if len ( outputs ) ! = 1 { d . rawoutput = nil return fmt . errorf ( " " , extract , len ( outputs ) ) } if len ( outputs ) == 0 { d . rawoutput = " " } else { switch v : = outputs [ 0 ] . ( type ) { case nil : d . rawoutput = " " case float64 , bool : d . rawoutput = fmt . sprint ( v ) case string : d . rawoutput = v default : d . rawoutput = v } d . rawoutput = outputs [ 0 ] } return nil } 
func ( d * displayer ) applyextract ( selector string , js bool ) error { parser , err : = jsonselect . createparserfromstring ( d . body ) if err ! = nil { return fmt . errorf ( " \n " , err , d . body ) } outputs , err : = parser . getvalues ( selector ) if ! js { out : = " " for , o : = range outputs { b , : = json . marshal ( o ) out += string ( b ) + " \n " } d . rawoutput = out } else { d . rawoutput = outputs } if err ! = nil { return fmt . errorf ( " \n " , selector , err , d . body ) } return nil } 
func ( d * displayer ) applyheaderextract ( header string ) error { d . rawoutput = d . response . header . get ( header ) if d . rawoutput == " " { return fmt . errorf ( " " , header ) } return nil } 
func ( d * displayer ) output ( ) string { output : = d . rawoutput if output == nil { return " " } if outputstr , ok : = d . rawoutput . ( string ) ; ok { suffix : = " " if d . prettify { suffix = " \n " } return outputstr + suffix } var out string var err error if d . prettify { var b [ ] byte b , err = json . marshalindent ( output , " " , " " ) if err == nil { out = string ( b ) + " \n " } } else { var b [ ] byte b , err = json . marshal ( output ) out = string ( b ) } if err ! = nil { fm : = " " if d . prettify { fm += " \n " } return fmt . sprintf ( fm , output ) } return out } 
func newapianalyzer ( resources map [ string ] interface { } , attributetypes map [ string ] string ) * apianalyzer { return & apianalyzer { rawresources : resources , attributetypes : attributetypes , rawtypes : make ( map [ string ] [ ] * gen . objectdatatype ) , } } 
func ( a * apianalyzer ) analyze ( ) * gen . apidescriptor { a . analyzealiases ( ) var descriptor = & gen . apidescriptor { resources : make ( map [ string ] * gen . resource ) , types : make ( map [ string ] * gen . objectdatatype ) , } var rawresourcenames = make ( [ ] string , len ( a . rawresources ) ) var idx = 0 for n : = range a . rawresources { rawresourcenames [ idx ] = n idx ++ } sort . strings ( rawresourcenames ) for , name : = range rawresourcenames { var resource = a . rawresources [ name ] a . analyzeresource ( name , resource , descriptor ) } descriptor . finalizetypenames ( a . rawtypes ) return descriptor } 
func ( a * apianalyzer ) analyzealiases ( ) { for from , to : = range aliases { splits : = strings . splitn ( from , " " , 2 ) fromresname : = splits [ 0 ] fromactionname : = splits [ 1 ] splits = strings . splitn ( to , " " , 2 ) toresname : = splits [ 0 ] toactionname : = splits [ 1 ] fromres : = a . rawresources [ fromresname ] fromact : = fromres . ( map [ string ] interface { } ) [ " " ] . ( map [ string ] interface { } ) [ fromactionname ] . ( map [ string ] interface { } ) tores : = a . rawresources [ toresname ] toact : = tores . ( map [ string ] interface { } ) [ " " ] . ( map [ string ] interface { } ) [ toactionname ] . ( map [ string ] interface { } ) fromact [ " " ] = toact [ " " ] fromact [ " " ] = toact [ " " ] fromact [ " " ] = toact [ " " ] } } 
func locatorfunc ( attributes [ ] * gen . attribute , name string ) string { haslinks : = false for , a : = range attributes { if a . fieldname == " " { haslinks = true break } } if ! haslinks { return " " } return + name + } 
func isdeprecated ( path string ) bool { return strings . contains ( path , " " ) && ! strings . contains ( path , " " ) } 
func isqueryparam ( a , n string ) bool { return n == " " | | n == " " | | ( a == " " && ( n == " " | | n == " " | | n == " " | | n == " " ) ) } 
func ispathparam ( p string , pathpatterns [ ] * gen . pathpattern ) bool { for , pattern : = range pathpatterns { for , v : = range pattern . variables { if p == v { return true } } } return false } 
func reftype ( resname string ) string { res : = resourcetype ( resname ) if res ! = " " { res = " " + res } return res } 
func resourcetype ( resname string ) string { if resname == " " { return " " } if , ok : = nomediatyperesources [ resname ] ; ok { return " " } return inflect . singularize ( resname ) } 
func fetchauditentries ( client * cm15 . api , filteremail string ) ( [ ] * cm15 . auditentry , error ) { auditlocator : = client . auditentrylocator ( " " ) var apiparams = rsapi . apiparams { " " : [ ] string { " " + filteremail } } auditentries , err : = auditlocator . index ( tomorrow ( ) , " " , yesterday ( ) , apiparams , ) if err ! = nil { return auditentries , err } return auditentries , nil } 
func formattime ( tm time . time ) string { year , month , date : = tm . date ( ) return time . date ( year , month , date , 0 , 0 , 0 , 0 , time . utc ) . format ( " " ) } 
func printaudits ( entries [ ] * cm15 . auditentry ) { for , a : = range entries { fmt . printf ( " \n " , a . updatedat , a . useremail , a . summary ) } } 
func extractunique ( oldentries , newentries [ ] * cm15 . auditentry ) [ ] * cm15 . auditentry { var uniqueentries = make ( [ ] * cm15 . auditentry , 0 ) var oldhrefs = make ( [ ] string , len ( oldentries ) ) for i , e : = range oldentries { oldhrefs [ i ] = gethref ( e ) } for , newentry : = range newentries { if ! stringinslice ( gethref ( newentry ) , oldhrefs ) { uniqueentries = append ( uniqueentries , newentry ) } } return uniqueentries } 
func gethref ( entry * cm15 . auditentry ) string { var href string for , link : = range entry . links { if link [ " " ] == " " { href = link [ " " ] break } } return href } 
func fail ( format string , v ... interface { } ) { if ! strings . hassuffix ( format , " \n " ) { format += " \n " } fmt . println ( fmt . sprintf ( format , v ... ) ) os . exit ( 1 ) } 
func comment ( elems ... string ) string { var lines [ ] string for , e : = range elems { lines = append ( lines , strings . split ( e , " \n " ) ... ) } var trimmed = make ( [ ] string , len ( lines ) ) for i , l : = range lines { trimmed [ i ] = strings . trimleft ( l , " \ t " ) } t : = strings . join ( trimmed , " \n " ) return text . indent ( t , " " ) } 
func parameters ( a * gen . action ) string { var m = a . mandatoryparams ( ) var hasoptional = a . hasoptionalparams ( ) var countparams = len ( m ) if hasoptional { countparams ++ } var params = make ( [ ] string , countparams ) for i , param : = range m { params [ i ] = fmt . sprintf ( " " , fixreserved ( param . varname ) , param . signature ( ) ) } if hasoptional { params [ countparams - 1 ] = " " } return strings . join ( params , " " ) } 
func paramsinitializer ( action * gen . action , location int , varname string ) string { var fields [ ] string var optionals [ ] * gen . actionparam varname = fixreserved ( varname ) for , param : = range action . params { if param . location ! = location { continue } if param . mandatory { name : = param . name if location == 1 { name = param . queryname } fields = append ( fields , fmt . sprintf ( " " " " , name , fixreserved ( param . varname ) ) ) } else { optionals = append ( optionals , param ) } } if len ( fields ) == 0 && len ( optionals ) == 0 { return " " } var paramsdecl = fmt . sprintf ( " \n \n " , strings . join ( fields , " \n \ t " ) ) if len ( optionals ) == 0 { return fmt . sprintf ( " \n " , varname , paramsdecl ) } var inits = make ( [ ] string , len ( optionals ) ) for i , opt : = range optionals { name : = opt . name if location == 1 { name = opt . queryname } inits [ i ] = fmt . sprintf ( " \ t " " \n \ t \n \ t \ t " " \n \ t " , opt . varname , opt . name , opt . varname , varname , name , opt . varname ) } var paramsinits = strings . join ( inits , " \n \ t " ) return fmt . sprintf ( " \n \n " , varname , paramsdecl , paramsinits ) } 
func commandline ( ) string { return fmt . sprintf ( " " , os . args [ 0 ] , strings . join ( os . args [ 1 : ] , " " ) ) } 
func blankcondition ( name string , t gen . datatype ) ( blank string ) { name = fixreserved ( name ) switch actual : = t . ( type ) { case * gen . basicdatatype : if * actual == " " { blank = fmt . sprintf ( " " " " , name ) } case * gen . arraydatatype : blank = fmt . sprintf ( " " , name ) case * gen . objectdatatype : blank = fmt . sprintf ( " " , name ) case * gen . enumerabledatatype : blank = fmt . sprintf ( " " , name ) } return } 
func tostringarray ( a [ ] interface { } ) [ ] string { res : = make ( [ ] string , len ( a ) ) for i , v : = range a { res [ i ] = fmt . sprintf ( " " , v ) } return res } 
func escapebackticks ( d string ) string { elems : = strings . split ( d , " " ) return strings . join ( elems , " " ) } 
func flagtype ( param * gen . actionparam ) string { path : = param . queryname if , ok : = param . type . ( * gen . arraydatatype ) ; ok { return " " } else if , ok : = param . type . ( * gen . enumerabledatatype ) ; ok { return " " } else if , ok : = param . type . ( * gen . sourceuploaddatatype ) ; ok { return " " } else if , ok : = param . type . ( * gen . uploaddatatype ) ; ok { return " " } b , ok : = param . type . ( * gen . basicdatatype ) if ! ok { panic ( " " + path ) } return string ( * b ) } 
func generateclient ( descriptor * gen . apidescriptor , codegen string ) error { f , err : = os . create ( codegen ) if err ! = nil { return err } c , err : = writers . newclientwriter ( ) if err ! = nil { return err } kingpin . fataliferror ( c . writeheader ( " " , " " , false / * needtime * / , true / * needjson * / , f ) , " " ) for , name : = range descriptor . resourcenames { resource : = descriptor . resources [ name ] c . writeresourceheader ( name , f ) kingpin . fataliferror ( c . writeresource ( resource , f ) , " " ) } c . writetypesectionheader ( f ) for , name : = range descriptor . typenames { t : = descriptor . types [ name ] c . writetype ( t , f ) } f . close ( ) o , err : = exec . command ( " " , " " , codegen ) . combinedoutput ( ) if err ! = nil { return fmt . errorf ( " \n " , o ) } return nil } 
func ( r * accountpreference ) locator ( api * api ) * accountpreferencelocator { return api . accountpreferencelocator ( r . href ) } 
func ( api * api ) accountpreferencelocator ( href string ) * accountpreferencelocator { return & accountpreferencelocator { href ( href ) , api } } 
func ( r * application ) locator ( api * api ) * applicationlocator { return api . applicationlocator ( r . href ) } 
func ( api * api ) applicationlocator ( href string ) * applicationlocator { return & applicationlocator { href ( href ) , api } } 
func ( r * enduser ) locator ( api * api ) * enduserlocator { return api . enduserlocator ( r . href ) } 
func ( api * api ) enduserlocator ( href string ) * enduserlocator { return & enduserlocator { href ( href ) , api } } 
func ( r * notificationrule ) locator ( api * api ) * notificationrulelocator { return api . notificationrulelocator ( r . href ) } 
func ( api * api ) notificationrulelocator ( href string ) * notificationrulelocator { return & notificationrulelocator { href ( href ) , api } } 
func ( r * userpreference ) locator ( api * api ) * userpreferencelocator { return api . userpreferencelocator ( r . href ) } 
func ( api * api ) userpreferencelocator ( href string ) * userpreferencelocator { return & userpreferencelocator { href ( href ) , api } } 
func ( r * userpreferenceinfo ) locator ( api * api ) * userpreferenceinfolocator { return api . userpreferenceinfolocator ( r . href ) } 
func ( api * api ) userpreferenceinfolocator ( href string ) * userpreferenceinfolocator { return & userpreferenceinfolocator { href ( href ) , api } } 
func loadconfig ( path string ) ( * clientconfig , error ) { content , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } var config clientconfig err = json . unmarshal ( content , & config ) if err ! = nil { return nil , err } config . password , err = decrypt ( config . password ) if err ! = nil { return nil , err } config . refreshtoken , err = decrypt ( config . refreshtoken ) return & config , err } 
func ( cfg * clientconfig ) save ( path string ) error { encrypted password , err : = encrypt ( cfg . password ) if err ! = nil { return fmt . errorf ( " " , err ) } cfg . password = encrypted password encrypted refresh , err : = encrypt ( cfg . refreshtoken ) if err ! = nil { return fmt . errorf ( " " , err ) } cfg . refreshtoken = encrypted refresh bytes , err : = json . marshal ( cfg ) if err ! = nil { return fmt . errorf ( " " , err ) } err = ioutil . writefile ( path , bytes , 0644 ) if err ! = nil { return fmt . errorf ( " " , err ) } return nil } 
func fromcommandline ( cmdline * cmd . commandline ) ( * api , error ) { raw , err : = rsapi . fromcommandline ( cmdline ) cmdline . host = hostfromlogin ( cmdline . host ) if err ! = nil { return nil , err } return fromapi ( raw ) , nil } 
func fromapi ( api * rsapi . api ) * api { api . fileencoding = rsapi . fileencodingjson api . host = hostfromlogin ( api . host ) api . metadata = genmetadata api . versionheader = " " return & api { api } } 
func hostfromlogin ( host string ) string { urlelems : = strings . split ( host , " " ) hostprefix : = urlelems [ 0 ] elems : = strings . split ( hostprefix , " " ) if len ( elems ) == 1 && elems [ 0 ] == " " { elems [ 0 ] = " " } else if len ( elems ) < 2 { return host } else { elems [ len ( elems ) - 2 ] = " " } policyhostprefix : = strings . join ( elems , " " ) return strings . join ( append ( [ ] string { policyhostprefix } , urlelems [ 1 : ] ... ) , " " ) } 
func ( a * apianalyzer ) analyzeparam ( ec evalctx , p * parameter ) * gen . actionparam { location , ok : = loc [ p . in ] if ! ok { location = - 1 } ap : = & gen . actionparam { name : p . name , queryname : p . name , description : cleandescription ( p . description ) , varname : tovarname ( p . name ) , location : location , mandatory : p . required , nonblank : p . required | | p . pattern ! = " " , regexp : p . pattern , validvalues : p . enum , } if p . schema ! = nil { ap . type = a . typeforref ( ec , p . schema ) } else { ap . type = basictype ( p . type ) } return ap } 
func ( a * apianalyzer ) analyzeattribute ( name , query string , attr map [ string ] interface { } ) ( * gen . actionparam , error ) { param : = gen . actionparam { name : name , queryname : query , varname : tovarname ( name ) } if d , ok : = attr [ " " ] ; ok { param . description = removeblanklines ( d . ( string ) ) } if r , ok : = attr [ " " ] ; ok { if r . ( bool ) { param . mandatory = true } } if options , ok : = attr [ " " ] ; ok { opts , ok : = options . ( map [ string ] interface { } ) if ok { for n , o : = range opts { switch n { case " " : param . max = int ( o . ( float64 ) ) case " " : param . min = int ( o . ( float64 ) ) case " " : param . regexp = o . ( string ) } } } } if values , ok : = attr [ " " ] ; ok { param . validvalues = values . ( [ ] interface { } ) } t : = attr [ " " ] . ( map [ string ] interface { } ) datatype , err : = a . analyzetype ( t , query ) if err ! = nil { return nil , err } param . type = datatype switch datatype . ( type ) { case * gen . arraydatatype : param . queryname += " " } return & param , nil } 
func ( a * apianalyzer ) createtype ( query string , attributes map [ string ] interface { } ) ( * gen . objectdatatype , error ) { name : = inflect . camelize ( bracketregexp . replaceallliteralstring ( query , " " ) + " " ) obj : = a . registry . createinlinetype ( name ) obj . fields = make ( [ ] * gen . actionparam , len ( attributes ) ) for idx , an : = range sortedkeys ( attributes ) { at : = attributes [ an ] var childq string if query == " " { childq = an } else { childq = fmt . sprintf ( " " , query , an ) } att , err : = a . analyzeattribute ( an , childq , at . ( map [ string ] interface { } ) ) if err ! = nil { return nil , fmt . errorf ( " " , an , err ) } obj . fields [ idx ] = att } return obj , nil } 
func ( d * doc ) ref ( r ref ) * definition { if refif , ok : = r [ " " ] ; ok { refkey : = strings . trimprefix ( refif . ( string ) , " " ) return d . definitions [ refkey ] } return nil } 
func ( r ref ) type ( ) string { if , ok : = r [ " " ] ; ok { return " " } if refif , ok : = r [ " " ] ; ok { return refif . ( string ) } return " " } 
func ( r ref ) required ( ) [ ] string { if refif , ok : = r [ " " ] ; ok { return refif . ( [ ] string ) } return [ ] string { } } 
func ( r ref ) id ( ) string { if refif , ok : = r [ " " ] ; ok { return strings . trimprefix ( refif . ( string ) , " " ) } return " " } 
func ( ep * endpoint ) service ( ) string { if len ( ep . tags ) > 0 { return ep . tags [ 0 ] } if len ( ep . operationid ) > 0 { return strings . split ( ep . operationid , " " ) [ 0 ] } return " " } 
func ( ep * endpoint ) method ( ) string { if strings . contains ( ep . operationid , " " ) { return strings . split ( ep . operationid , " " ) [ 1 ] } return " " } 
func newapianalyzer ( version , clientname string , resources , types map [ string ] map [ string ] interface { } ) * apianalyzer { return & apianalyzer { rawresources : resources , rawtypes : types , version : version , clientname : clientname , registry : newtyperegistry ( ) , } } 
func ( a * apianalyzer ) analyze ( ) ( * gen . apidescriptor , error ) { descriptor : = gen . apidescriptor { version : a . version , resources : make ( map [ string ] * gen . resource ) , types : make ( map [ string ] * gen . objectdatatype ) , } a . descriptor = & descriptor rawresourcenames : = make ( [ ] string , len ( a . rawresources ) ) idx : = 0 for name : = range a . rawresources { rawresourcenames [ idx ] = name idx ++ } sort . strings ( rawresourcenames ) for , name : = range rawresourcenames { err : = a . analyzeresource ( name , a . rawresources [ name ] , & descriptor ) if err ! = nil { return nil , err } } a . registry . finalizetypenames ( & descriptor ) return & descriptor , nil } 
func newtyperegistry ( ) * typeregistry { return & typeregistry { namedtypes : make ( map [ string ] * gen . objectdatatype ) , inlinetypes : make ( map [ string ] [ ] * gen . objectdatatype ) , } } 
func ( reg * typeregistry ) getnamedtype ( name string ) * gen . objectdatatype { return reg . namedtypes [ togotypename ( name ) ] } 
func ( reg * typeregistry ) createnamedtype ( name string ) * gen . objectdatatype { goname : = togotypename ( name ) obj : = gen . objectdatatype { typename : goname } if , ok : = reg . namedtypes [ goname ] ; ok { panic ( " " ) } reg . namedtypes [ goname ] = & obj return & obj } 
func ( reg * typeregistry ) createinlinetype ( name string ) * gen . objectdatatype { goname : = togotypename ( name ) obj : = gen . objectdatatype { typename : goname } reg . inlinetypes [ goname ] = append ( reg . inlinetypes [ goname ] , & obj ) return & obj } 
func ( reg * typeregistry ) finalizetypenames ( d * gen . apidescriptor ) { for n , named : = range reg . namedtypes { reg . inlinetypes [ n ] = append ( reg . inlinetypes [ n ] , named ) } d . finalizetypenames ( reg . inlinetypes ) } 
func ( d * apidescriptor ) merge ( other * apidescriptor ) error { if d . version ! = other . version { return fmt . errorf ( " " ) } for , name : = range d . resourcenames { for , othername : = range other . resourcenames { if name == othername { return fmt . errorf ( " " , name ) } } } for , name : = range d . typenames { for i , othername : = range other . typenames { if name == othername { newname : = makeuniq ( othername , append ( d . typenames , other . typenames ... ) ) first : = other . typenames [ : i ] last : = append ( [ ] string { newname } , other . typenames [ i + 1 : ] ... ) other . typenames = append ( first , last ... ) typ : = other . types [ name ] delete ( other . types , name ) typ . typename = newname other . types [ newname ] = typ } } } for name , resource : = range other . resources { d . resources [ name ] = resource } for name , typ : = range other . types { d . types [ name ] = typ } d . resourcenames = append ( d . resourcenames , other . resourcenames ... ) d . typenames = append ( d . typenames , other . typenames ... ) return nil } 
func ( d * apidescriptor ) uniquetypename ( prefix string ) string { u : = fmt . sprintf ( " " , prefix , 2 ) taken : = false for , tn : = range d . typenames { if tn == u { taken = true break } } idx : = 3 for taken { u = fmt . sprintf ( " " , prefix , idx ) taken = false for , tn : = range d . typenames { if tn == u { taken = true break } } if taken { idx ++ } } return u } 
func ( a * action ) mandatoryparams ( ) [ ] * actionparam { m : = make ( [ ] * actionparam , len ( a . params ) ) i : = 0 for , p : = range a . params { if p . mandatory { m [ i ] = p i ++ } } return m [ : i ] } 
func ( a * action ) hasoptionalparams ( ) bool { for , param : = range a . params { if ! param . mandatory { return true } } return false } 
func ( p * actionparam ) signature ( ) ( sig string ) { switch t : = p . type . ( type ) { case * basicdatatype : sig = string ( * t ) case * arraydatatype : cs : = t . elemtype . signature ( ) sig = fmt . sprintf ( " " , cs ) case * objectdatatype : sig = fmt . sprintf ( " " , t . typename ) case * enumerabledatatype : sig = " " case * uploaddatatype : sig = " " case * sourceuploaddatatype : sig = " " } return } 
func ( p * actionparam ) isequivalent ( other * actionparam ) bool { return p . name == other . name && p . type . isequivalent ( other . type ) } 
func ( b * basicdatatype ) isequivalent ( other datatype ) bool { t , ok : = other . ( * basicdatatype ) if ! ok { return false } return * t == * b } 
func ( a * arraydatatype ) isequivalent ( other datatype ) bool { t , ok : = other . ( * arraydatatype ) if ! ok { return false } return a . elemtype . isequivalent ( t . elemtype ) } 
func ( o * objectdatatype ) isequivalent ( other datatype ) bool { a , ok : = other . ( * objectdatatype ) if ! ok { return false } if o . typename ! = a . typename { return false } if len ( o . fields ) ! = len ( a . fields ) { return false } for i , f : = range o . fields { if ! f . isequivalent ( a . fields [ i ] ) { return false } } return true } 
func ( e * enumerabledatatype ) isequivalent ( other datatype ) bool { , ok : = other . ( * enumerabledatatype ) return ok } 
func ( e * sourceuploaddatatype ) isequivalent ( other datatype ) bool { , ok : = other . ( * sourceuploaddatatype ) return ok } 
func ( u * uploaddatatype ) isequivalent ( other datatype ) bool { o , ok : = other . ( * uploaddatatype ) if ! ok { return false } if o . typename ! = u . typename { return false } return true } 
func makeuniq ( base string , taken [ ] string ) string { idx : = 1 uniq : = base inuse : = true for inuse { inuse = false for , gn : = range taken { if gn == uniq { inuse = true break } } if inuse { idx ++ uniq = base + strconv . itoa ( idx ) } } return uniq } 
func newclientwriter ( ) ( * clientwriter , error ) { funcmap : = template . funcmap { " " : comment , " " : commandline , " " : parameters , " " : paramsinitializer , " " : blankcondition , " " : stripstar , } headert , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( headertmpl ) if err ! = nil { return nil , err } resourcet , err : = template . new ( " " ) . funcs ( funcmap ) . parse ( resourcetmpl ) if err ! = nil { return nil , err } return & clientwriter { headertmpl : headert , resourcetmpl : resourcet , } , nil } 
func ( c * clientwriter ) writeheader ( pkg , version string , needtime , needjson bool , w io . writer ) error { ctx : = map [ string ] interface { } { " " : pkg , " " : version , " " : needtime , " " : needjson , } return c . headertmpl . execute ( w , ctx ) } 
func ( c * clientwriter ) writeresourceheader ( name string , w io . writer ) { fmt . fprintf ( w , " \n \n " , name ) } 
func ( c * clientwriter ) writetype ( o * gen . objectdatatype , w io . writer ) { fields : = make ( [ ] string , len ( o . fields ) ) for i , f : = range o . fields { fields [ i ] = fmt . sprintf ( " " " " , strings . title ( f . varname ) , f . signature ( ) , f . name ) } decl : = fmt . sprintf ( " \n \n " , o . typename , strings . join ( fields , " \n \ t " ) ) fmt . fprintf ( w , " \n \n " , decl ) } 
func ( c * clientwriter ) writeresource ( resource * gen . resource , w io . writer ) error { return c . resourcetmpl . execute ( w , resource ) } 
func ( ec evalctx ) withtrail ( t string ) evalctx { newec : = ec trailcopy : = make ( [ ] string , 0 , len ( ec . trail ) + 1 ) for , val : = range ec . trail { trailcopy = append ( trailcopy , val ) } newec . trail = append ( trailcopy , t ) return newec } 
func ( r * account ) locator ( api * api ) * accountlocator { return api . accountlocator ( r . href ) } 
func ( r * cloud ) locator ( api * api ) * cloudlocator { return api . cloudlocator ( r . href ) } 
func ( r * datacenter ) locator ( api * api ) * datacenterlocator { return api . datacenterlocator ( r . href ) } 
func ( r * deployment ) locator ( api * api ) * deploymentlocator { return api . deploymentlocator ( r . href ) } 
func ( r * image ) locator ( api * api ) * imagelocator { return api . imagelocator ( r . href ) } 
func ( r * instance ) locator ( api * api ) * instancelocator { return api . instancelocator ( r . href ) } 
func ( r * instancetype ) locator ( api * api ) * instancetypelocator { return api . instancetypelocator ( r . href ) } 
func ( r * ipaddress ) locator ( api * api ) * ipaddresslocator { return api . ipaddresslocator ( r . href ) } 
func ( r * ipaddressbinding ) locator ( api * api ) * ipaddressbindinglocator { return api . ipaddressbindinglocator ( r . href ) } 
func ( r * multicloudimage ) locator ( api * api ) * multicloudimagelocator { return api . multicloudimagelocator ( r . href ) } 
func ( r * network ) locator ( api * api ) * networklocator { return api . networklocator ( r . href ) } 
func ( r * networkinterface ) locator ( api * api ) * networkinterfacelocator { return api . networkinterfacelocator ( r . href ) } 
func ( api * api ) networkinterfacelocator ( href string ) * networkinterfacelocator { return & networkinterfacelocator { href ( href ) , api } } 
func ( r * networkinterfaceattachment ) locator ( api * api ) * networkinterfaceattachmentlocator { return api . networkinterfaceattachmentlocator ( r . href ) } 
func ( api * api ) networkinterfaceattachmentlocator ( href string ) * networkinterfaceattachmentlocator { return & networkinterfaceattachmentlocator { href ( href ) , api } } 
func ( r * securitygroup ) locator ( api * api ) * securitygrouplocator { return api . securitygrouplocator ( r . href ) } 
func ( r * server ) locator ( api * api ) * serverlocator { return api . serverlocator ( r . href ) } 
func ( r * serverarray ) locator ( api * api ) * serverarraylocator { return api . serverarraylocator ( r . href ) } 
func ( r * servertemplate ) locator ( api * api ) * servertemplatelocator { return api . servertemplatelocator ( r . href ) } 
func ( r * sshkey ) locator ( api * api ) * sshkeylocator { return api . sshkeylocator ( r . href ) } 
func ( r * subnet ) locator ( api * api ) * subnetlocator { return api . subnetlocator ( r . href ) } 
func ( r * rubytime ) unmarshaljson ( b [ ] byte ) ( err error ) { s : = string ( b ) t , err : = time . parse ( " " , s [ 1 : len ( s ) - 1 ] ) if err ! = nil { return err } r . time = t return nil } 
func ( r * execution ) locator ( api * api ) * executionlocator { return api . executionlocator ( r . href ) } 
func ( api * api ) executionlocator ( href string ) * executionlocator { return & executionlocator { href ( href ) , api } } 
func ( r * notification ) locator ( api * api ) * notificationlocator { return api . notificationlocator ( r . href ) } 
func ( api * api ) notificationlocator ( href string ) * notificationlocator { return & notificationlocator { href ( href ) , api } } 
func ( r * operation ) locator ( api * api ) * operationlocator { return api . operationlocator ( r . href ) } 
func ( api * api ) operationlocator ( href string ) * operationlocator { return & operationlocator { href ( href ) , api } } 
func ( r * scheduledaction ) locator ( api * api ) * scheduledactionlocator { return api . scheduledactionlocator ( r . href ) } 
func ( api * api ) scheduledactionlocator ( href string ) * scheduledactionlocator { return & scheduledactionlocator { href ( href ) , api } } 
func newbasicauthenticator ( username , password string , accountid int ) authenticator { builder : = basicloginrequestbuilder { username : username , password : password , accountid : accountid } return newcookiesigner ( & builder , accountid ) } 
func newinstanceauthenticator ( token string , accountid int ) authenticator { builder : = instanceloginrequestbuilder { token : token , accountid : accountid } return newcookiesigner ( & builder , accountid ) } 
func newoauthauthenticator ( token string , accountid int ) authenticator { return & oauthsigner { refreshtoken : token , refreshat : time . now ( ) . add ( - 2 * time . minute ) , client : httpclient . new ( ) , accountid : accountid , } } 
func newtokenauthenticator ( token string , accountid int ) authenticator { return & tokenauthenticator { token : token , accountid : accountid } } 
func newssauthenticator ( auther authenticator , accountid int ) authenticator { if , ok : = auther . ( * ssauthenticator ) ; ok { return auther } return & ssauthenticator { auther : auther , accountid : accountid , refreshat : time . now ( ) . add ( - 2 * time . minute ) , client : httpclient . newnoredirect ( ) , } } 
func newcookiesigner ( builder loginrequestbuilder , accountid int ) authenticator { return & cookiesigner { builder : builder , accountid : accountid , refreshat : time . now ( ) . add ( - 2 * time . minute ) , client : httpclient . newnoredirect ( ) , } } 
func ( s * cookiesigner ) sign ( req * http . request ) error { if time . now ( ) . after ( s . refreshat ) { authreq , autherr : = s . builder . buildloginrequest ( s . host ) if autherr ! = nil { return autherr } resp , err : = s . client . dohidden ( authreq ) if err ! = nil { return err } url , err : = extractredirecturl ( resp ) if err ! = nil { return err } if url ! = nil { authreq , autherr = s . builder . buildloginrequest ( url . host ) if autherr ! = nil { return autherr } s . host = url . host req . host = url . host req . url . host = url . host resp , err = s . client . dohidden ( authreq ) } if err ! = nil { return fmt . errorf ( " " , err ) } if err : = s . refresh ( resp ) ; err ! = nil { return err } } for , c : = range s . cookies { req . addcookie ( c ) } req . header . set ( " " , strconv . itoa ( s . accountid ) ) return nil } 
func ( s * cookiesigner ) canauthenticate ( host string ) error { , instance : = s . builder . ( * instanceloginrequestbuilder ) return testauth ( s , s . client , host , instance ) } 
func ( s * cookiesigner ) refresh ( resp * http . response ) error { if resp . statuscode ! = 204 { return fmt . errorf ( " " , resp . status ) } s . cookies = resp . cookies ( ) s . refreshat = time . now ( ) . add ( time . duration ( 2 ) * time . hour ) return nil } 
func ( s * oauthsigner ) canauthenticate ( host string ) error { return testauth ( s , s . client , host , false ) } 
func ( t * tokenauthenticator ) sign ( r * http . request ) error { r . header . set ( " " , " " + t . token ) if t . accountid ! = 0 { r . header . set ( " " , strconv . itoa ( t . accountid ) ) } return nil } 
func ( t * tokenauthenticator ) canauthenticate ( host string ) error { client : = httpclient . new ( ) return testauth ( t , client , host , false ) } 
func ( a * rl10authenticator ) sign ( r * http . request ) error { r . header . set ( " " , a . secret ) return nil } 
func ( a * rl10authenticator ) canauthenticate ( host string ) error { client : = httpclient . new ( ) return testauth ( a , client , host , true ) } 
func ( a * ssauthenticator ) sign ( r * http . request ) error { if time . now ( ) . after ( a . refreshat ) { u : = buildurl ( a . host , " " ) u += " " + strconv . itoa ( a . accountid ) authreq , err : = http . newrequest ( " " , u , nil ) if err ! = nil { return err } if err : = a . auther . sign ( authreq ) ; err ! = nil { return err } if ca , ok : = a . auther . ( * cookiesigner ) ; ok { a . sethost ( ca . host ) authreq . host = a . host authreq . url . host = a . host } authreq . header . set ( " " , " " ) resp , err : = a . client . dohidden ( authreq ) if err ! = nil { return fmt . errorf ( " " , err ) } if resp . statuscode ! = 303 { body , err : = ioutil . readall ( resp . body ) var msg string if err ! = nil { msg = " " } if len ( body ) > 0 { msg = " " + string ( body ) } return fmt . errorf ( " " , resp . status , msg ) } a . refreshat = time . now ( ) . add ( 2 * time . hour ) } a . auther . sign ( r ) r . header . set ( " " , " " ) r . host = a . host r . url . host = a . host return nil } 
func ( a * ssauthenticator ) sethost ( host string ) { a . auther . sethost ( host ) urlelems : = strings . split ( host , " " ) hostprefix : = urlelems [ 0 ] elems : = strings . split ( hostprefix , " " ) if len ( elems ) == 1 && elems [ 0 ] == " " { elems [ 0 ] = " " } else if len ( elems ) < 2 { a . host = host return } else { elems [ len ( elems ) - 2 ] = " " } ssloginhostprefix : = strings . join ( elems , " " ) a . host = strings . join ( append ( [ ] string { ssloginhostprefix } , urlelems [ 1 : ] ... ) , " " ) } 
func ( a * ssauthenticator ) canauthenticate ( host string ) error { url : = fmt . sprintf ( " " , a . accountid ) req , err : = http . newrequest ( " " , buildurl ( host , url ) , nil ) if err ! = nil { return err } req . header . set ( " " , " " ) if err : = a . sign ( req ) ; err ! = nil { return err } resp , err : = a . client . dohidden ( req ) if err ! = nil { return err } if resp . statuscode ! = 200 { var body string if b , err : = ioutil . readall ( resp . body ) ; err ! = nil { body = " " + string ( b ) } return fmt . errorf ( " " , resp . status , body ) } return nil } 
func ( b * basicloginrequestbuilder ) buildloginrequest ( host string ) ( * http . request , error ) { if host == " " { host = " " } jsonstr : = fmt . sprintf ( ' { " email " : " %s " , " password " : " %s " , " account href " : " / api / accounts / %d " } ' , b . username , b . password , b . accountid ) authreq , err : = http . newrequest ( " " , buildurl ( host , " " ) , bytes . newbufferstring ( jsonstr ) ) if err ! = nil { return authreq , fmt . errorf ( " " , err . error ( ) ) } authreq . header . set ( " " , " " ) authreq . header . set ( " " , " " ) return authreq , nil } 
func ( b * instanceloginrequestbuilder ) buildloginrequest ( host string ) ( * http . request , error ) { if host == " " { host = " " } accounthref : = fmt . sprintf ( " " , b . accountid ) jsonstr : = fmt . sprintf ( ' { " instance token " : " %s " , " account href " : " %s " } ' , b . token , accounthref ) authreq , err : = http . newrequest ( " " , buildurl ( host , " " ) , bytes . newbufferstring ( jsonstr ) ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } authreq . header . set ( " " , " " ) authreq . header . set ( " " , " " ) return authreq , nil } 
func extractredirecturl ( resp * http . response ) ( * url . url , error ) { var u * url . url if resp . statuscode > 299 && resp . statuscode < 399 { loc : = resp . header . get ( " " ) if loc ! = " " { var err error u , err = url . parse ( loc ) if err ! = nil { return nil , fmt . errorf ( " " , loc , err ) } } } return u , nil } 
func buildurl ( host , path string ) string { scheme : = " " if httpclient . insecure { scheme = " " } u : = url . url { scheme : scheme , host : host , path : path , } return u . string ( ) } 
func ( r * resource ) extractvariables ( href string ) ( [ ] * pathvariable , error ) { matches : = r . findmatches ( href ) if len ( matches ) == 0 && ! strings . hasprefix ( href , " " ) { href = " " + href matches = r . findmatches ( href ) } if len ( matches ) == 0 { return nil , fmt . errorf ( " " , href , r . name ) } sort . sort ( bylen ( matches ) ) pattern : = matches [ 0 ] submatches : = pattern . regexp . findallstringsubmatch ( href , - 1 ) if len ( submatches ) == 0 { return [ ] * pathvariable { } , nil } if len ( submatches ) > 1 { return nil , fmt . errorf ( " " , href , r . name ) } submatch : = submatches [ 0 ] variables : = make ( [ ] * pathvariable , len ( submatch ) - 1 ) for i , v : = range submatch [ 1 : ] { variables [ i ] = & pathvariable { name : pattern . variables [ i ] , value : v } } return variables , nil } 
func ( r * resource ) getaction ( name string ) * action { for , a : = range r . actions { if a . name == name { return a } } return nil } 
func ( r * resource ) haslink ( name string ) bool { for n , : = range r . links { if n == name { return true } } return false } 
func ( r * resource ) findmatches ( href string ) [ ] * pathpattern { var matches [ ] * pathpattern for , action : = range r . actions { for , pattern : = range action . pathpatterns { if pattern . regexp . matchstring ( href ) | | pattern . regexp . matchstring ( href + " " ) { matches = append ( matches , pattern ) } } } return matches } 
func newvariabledumpclient ( c * http . client ) httpclient { dc : = & dumpclient { client : c } dc . isinsecure = func ( ) bool { return insecure } dc . dumpformat = func ( ) format { return dumpformat } dc . hiddenheaders = func ( ) map [ string ] bool { return hiddenheaders } return dc } 
func ( d * dumpclient ) dohidden ( req * http . request ) ( * http . response , error ) { return d . doimp ( req , true , nil ) } 
func ( d * dumpclient ) do ( req * http . request ) ( * http . response , error ) { return d . doimp ( req , false , nil ) } 
func ( d * dumpclient ) getclientwithouttimeout ( ) * http . client { client : = * d . client tr , ok : = client . transport . ( * http . transport ) if ok { trcopy : = & http . transport { proxy : tr . proxy , dialcontext : tr . dialcontext , dial : tr . dial , dialtls : tr . dialtls , tlsclientconfig : tr . tlsclientconfig , tlshandshaketimeout : tr . tlshandshaketimeout , disablekeepalives : tr . disablekeepalives , disablecompression : tr . disablecompression , maxidleconns : tr . maxidleconns , maxidleconnsperhost : tr . maxidleconnsperhost , idleconntimeout : tr . idleconntimeout , responseheadertimeout : 0 , expectcontinuetimeout : tr . expectcontinuetimeout , tlsnextproto : tr . tlsnextproto , maxresponseheaderbytes : tr . maxresponseheaderbytes , } tr = trcopy } else { tr = & http . transport { proxy : http . proxyfromenvironment } tr . tlsclientconfig = & tls . config { insecureskipverify : nocertcheck } } client . transport = tr return & client } 
func ( d * dumpclient ) dumprequest ( req * http . request ) [ ] byte { df : = d . dumpformat ( ) if df == nodump { return nil } reqbody , err : = dumpreqbody ( req ) if err ! = nil { log . error ( " " , " " , err . error ( ) ) } if df . isdebug ( ) { var buffer bytes . buffer buffer . writestring ( req . method + " " + req . url . string ( ) + " \n " ) d . writeheaders ( & buffer , req . header ) if reqbody ! = nil { buffer . writestring ( " \n " ) buffer . write ( reqbody ) buffer . writestring ( " \n " ) } fmt . fprint ( osstderr , buffer . string ( ) ) } else if df . isjson ( ) { return reqbody } return nil } 
func filterheaders ( dumpformat format , hiddenheaders map [ string ] bool , headers http . header , iterator headeriterator ) { for k , v : = range headers { if ! dumpformat . isverbose ( ) { if , ok : = hiddenheaders [ k ] ; ok { continue } } iterator ( k , v ) } } 
func copyhiddenheaders ( from map [ string ] bool ) ( to map [ string ] bool ) { to = make ( map [ string ] bool ) for k , v : = range from { to [ k ] = v } return } 
func generateclient ( version string , descriptor * gen . apidescriptor , codegen , pkg string ) error { f , err : = os . create ( codegen ) if err ! = nil { return err } c , err : = newclientwriter ( ) if err ! = nil { return err } kingpin . fataliferror ( c . writeheader ( pkg , version , descriptor . needtime , descriptor . needjson , f ) , " " ) for , name : = range descriptor . resourcenames { resource : = descriptor . resources [ name ] c . writeresourceheader ( name , f ) kingpin . fataliferror ( c . writeresource ( resource , f ) , " " ) } c . writetypesectionheader ( f ) for , name : = range descriptor . typenames { t : = descriptor . types [ name ] c . writetype ( t , f ) } f . close ( ) o , err : = exec . command ( " " , " " , codegen ) . combinedoutput ( ) if err ! = nil { return fmt . errorf ( " \n " , o ) } return nil } 
func generatemetadata ( descriptor * gen . apidescriptor , codegen , pkg string ) error { f , err : = os . create ( codegen ) if err ! = nil { return err } c , err : = newmetadatawriter ( ) if err ! = nil { return err } kingpin . fataliferror ( c . writeheader ( pkg , f ) , " " ) kingpin . fataliferror ( c . writemetadata ( descriptor , f ) , " " ) f . close ( ) o , err : = exec . command ( " " , " " , codegen ) . combinedoutput ( ) if err ! = nil { return fmt . errorf ( " \n " , o ) } return nil } 
func generateangular ( descriptor * gen . apidescriptor , pkgdir string ) ( [ ] string , error ) { var files [ ] string for , name : = range descriptor . resourcenames { res : = descriptor . resources [ name ] codegen : = filepath . join ( pkgdir , inflect . underscore ( name ) + " " ) f , err : = os . create ( codegen ) if err ! = nil { return files , err } c , err : = newangularwriter ( ) if err ! = nil { return files , err } kingpin . fataliferror ( c . writeresource ( res , f ) , " " ) f . close ( ) files = append ( files , codegen ) } return files , nil } 
func validatecommandline ( cmdline * cmd . commandline ) { if cmdline . command == " " | | cmdline . command == " " | | cmdline . command == " " | | cmdline . showhelp | | cmdline . rl10 { return } if cmdline . account == 0 && cmdline . oauthtoken == " " && cmdline . oauthaccesstoken == " " && cmdline . apitoken == " " && ! cmdline . noauth { kingpin . fatalf ( " " ) } if cmdline . host == " " { kingpin . fatalf ( " " ) } if cmdline . password == " " && cmdline . oauthtoken == " " && cmdline . oauthaccesstoken == " " && cmdline . apitoken == " " && ! cmdline . noauth { kingpin . fatalf ( " " ) } } 
func apiclient ( name string , cmdline * cmd . commandline ) ( cmd . commandclient , error ) { switch name { case cm15command : return cm15 . fromcommandline ( cmdline ) case cm16command : return cm16 . fromcommandline ( cmdline ) case sscommand : return ss . fromcommandline ( cmdline ) case rl10command : return rl10 . fromcommandline ( cmdline ) case cacommand : return ca . fromcommandline ( cmdline ) case policycommand : return policy . fromcommandline ( cmdline ) default : return nil , fmt . errorf ( " " , name ) } } 
func registerclientcommands ( app * kingpin . application ) { cm15cmd : = app . command ( cm15command , cm15 . apiname ) registrar : = rsapi . registrar { apicmd : cm15cmd } cm15 . registercommands ( & registrar ) cm16cmd : = app . command ( cm16command , cm16 . apiname ) registrar = rsapi . registrar { apicmd : cm16cmd } cm16 . registercommands ( & registrar ) sscmd : = app . command ( sscommand , ss . apiname ) registrar = rsapi . registrar { apicmd : sscmd } ss . registercommands ( & registrar ) rl10cmd : = app . command ( rl10command , rl10 . apiname ) registrar = rsapi . registrar { apicmd : rl10cmd } rl10 . registercommands ( & registrar ) cacmd : = app . command ( cacommand , ca . apiname ) registrar = rsapi . registrar { apicmd : cacmd } ca . registercommands ( & registrar ) policycmd : = app . command ( policycommand , policy . apiname ) registrar = rsapi . registrar { apicmd : policycmd } policy . registercommands ( & registrar ) } 
func interactive ( ) { logger . sethandler ( log15 . multihandler ( log15 . lvlfilterhandler ( log15 . lvlerror , log15 . stderrhandler ) ) ) } 
func ( a * api ) runcommand ( cmd string ) ( * http . response , error ) { parsed , err : = a . parsecommand ( cmd , " " , commandvalues ) if err ! = nil { return nil , err } href : = parsed . uri if ! strings . hasprefix ( href , " " ) { href = path . join ( " " , href ) } req , err : = a . buildhttprequest ( " " , href , " " , parsed . queryparams , nil ) if err ! = nil { return nil , err } return a . performrequest ( req ) } 
func rawpayload ( typ gen . datatype , p interface { } ) * gen . actionparam { var required bool if req , ok : = p . ( map [ string ] interface { } ) [ " " ] ; ok { required = req . ( bool ) } return & gen . actionparam { name : " " , queryname : " " , varname : " " , type : typ , location : gen . payloadparam , mandatory : required , } } 
func ( a * apianalyzer ) parseurls ( urls interface { } ) ( [ ] * gen . pathpattern , error ) { var patterns [ ] * gen . pathpattern if urlelems , ok : = urls . ( [ ] interface { } ) ; ok { patterns = make ( [ ] * gen . pathpattern , len ( urlelems ) ) for i , elem : = range urlelems { if pair , ok : = elem . ( [ ] interface { } ) ; ok { if len ( pair ) ! = 2 { return nil , fmt . errorf ( " " , pair ) } patterns [ i ] = topattern ( pair [ 0 ] . ( string ) , pair [ 1 ] . ( string ) ) } else if url , ok : = elem . ( map [ string ] interface { } ) ; ok { verb , ok : = url [ " " ] . ( string ) if ! ok { return nil , fmt . errorf ( " " , url ) } path , ok : = url [ " " ] . ( string ) if ! ok { return nil , fmt . errorf ( " " , url ) } patterns [ i ] = topattern ( verb , path ) } else { return nil , fmt . errorf ( " " , elem ) } } } else { return nil , fmt . errorf ( " " " " , prettify ( urls ) ) } return patterns , nil } 
func promptconfirmation ( format string , a ... interface { } ) string { m : = fmt . sprintf ( format , a ... ) fmt . fprintf ( out , m ) var yn string fmt . fscanf ( in , " " , & yn ) return yn } 
func withclientip ( ctx context . context , ip net . ip ) context . context { if ip == nil { return ctx } return context . withvalue ( ctx , clientipkey { } , ip ) } 
func clientip ( ctx context . context ) net . ip { ip , : = ctx . value ( clientipkey { } ) . ( net . ip ) return ip } 
func newproducer ( config producerconfig ) ( p * producer , err error ) { config . defaults ( ) p = & producer { reqs : make ( chan producerrequest , config . maxconcurrency ) , done : make ( chan struct { } ) , address : config . address , topic : config . topic , dialtimeout : config . dialtimeout , readtimeout : config . readtimeout , writetimeout : config . writetimeout , } return } 
func startproducer ( config producerconfig ) ( p * producer , err error ) { p , err = newproducer ( config ) if err ! = nil { return } p . start ( ) return } 
func ( p * producer ) start ( ) { if p . started { panic ( " " ) } concurrency : = cap ( p . reqs ) p . join . add ( concurrency ) for i : = 0 ; i ! = concurrency ; i ++ { go p . run ( ) } p . started = true } 
func ( p * producer ) stop ( ) { p . once . do ( p . stop ) err : = errors . new ( " " ) for req : = range p . reqs { req . complete ( err ) } p . join . wait ( ) } 
func ( p * producer ) publish ( message [ ] byte ) ( err error ) { return p . publishto ( p . topic , message ) } 
func ( p * producer ) publishto ( topic string , message [ ] byte ) ( err error ) { defer func ( ) { if recover ( ) ! = nil { err = errors . new ( " " ) } } ( ) if len ( topic ) == 0 { return errors . new ( " " ) } response : = make ( chan error , 1 ) deadline : = time . now ( ) . add ( p . dialtimeout + p . readtimeout + p . writetimeout ) p . reqs < - producerrequest { topic : topic , message : message , response : response , deadline : deadline , } err = < - response return } 
func newlocalengine ( config localconfig ) * localengine { if config . nodetimeout == 0 { config . nodetimeout = defaultlocalenginenodetimeout } if config . tombstonetimeout == 0 { config . tombstonetimeout = defaultlocalenginetombstonetimeout } e : = & localengine { nodetimeout : config . nodetimeout , tombtimeout : config . tombstonetimeout , done : make ( chan struct { } ) , join : make ( chan struct { } ) , nodes : make ( map [ string ] * localnode ) , } go e . run ( ) return e } 
func ( r response ) write ( w * bufio . writer ) ( err error ) { if err = writeframeheader ( w , frametyperesponse , len ( r ) ) ; err ! = nil { err = errors . withmessage ( err , " " ) } if , err = w . writestring ( string ( r ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( c sub ) write ( w * bufio . writer ) ( err error ) { for , s : = range [ ... ] string { " " , c . topic , " " , c . channel , " \n " , } { if , err = w . writestring ( s ) ; err ! = nil { err = errors . wrap ( err , " " ) return } } return } 
func ( c touch ) write ( w * bufio . writer ) ( err error ) { if , err = w . writestring ( " " ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = c . messageid . writeto ( w ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = w . writebyte ( ' \n ' ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( c * consumerconfig ) validate ( ) error { if len ( c . topic ) == 0 { return errors . new ( " " ) } if len ( c . channel ) == 0 { return errors . new ( " " ) } return nil } 
func ( c * consumerconfig ) defaults ( ) { if c . maxinflight == 0 { c . maxinflight = defaultmaxinflight } if c . dialtimeout == 0 { c . dialtimeout = defaultdialtimeout } if c . readtimeout == 0 { c . readtimeout = defaultreadtimeout } if c . writetimeout == 0 { c . writetimeout = defaultwritetimeout } } 
func newconsumer ( config consumerconfig ) ( c * consumer , err error ) { if err = config . validate ( ) ; err ! = nil { return } config . defaults ( ) c = & consumer { msgs : make ( chan message , config . maxinflight ) , done : make ( chan struct { } ) , topic : config . topic , channel : config . channel , address : config . address , lookup : append ( [ ] string { } , config . lookup ... ) , maxinflight : config . maxinflight , identify : setidentifydefaults ( config . identify ) , dialtimeout : config . dialtimeout , readtimeout : config . readtimeout , writetimeout : config . writetimeout , conns : make ( map [ string ] ( chan < - command ) ) , } return } 
func startconsumer ( config consumerconfig ) ( c * consumer , err error ) { c , err = newconsumer ( config ) if err ! = nil { return } c . start ( ) return } 
func ( c * consumer ) start ( ) { if c . started { panic ( " " ) } go c . run ( ) c . started = true } 
func ratelimit ( limit int , messages < - chan message ) < - chan message { if limit <= 0 { return messages } output : = make ( chan message ) go func ( ) { ticker : = time . newticker ( 1 * time . second ) defer ticker . stop ( ) defer close ( output ) input : = messages count : = 0 for { select { case < - ticker . c : count = 0 input = messages case msg , ok : = < - input : if ! ok { return } output < - msg if count ++ ; count >= limit { input = nil } } } } ( ) return output } 
func ( r rawresponse ) write ( w * bufio . writer ) error { return writeresponse ( w , [ ] byte ( r ) ) } 
func readresponse ( r * bufio . reader ) ( res response , err error ) { var data [ ] byte var size int32 if err = binary . read ( r , binary . bigendian , & size ) ; err ! = nil { return } data = make ( [ ] byte , int ( size ) ) if , err = io . readfull ( r , data ) ; err ! = nil { return } switch { case bytes . equal ( data , [ ] byte ( " " ) ) : res = ok { } case bytes . hasprefix ( data , [ ] byte ( " " ) ) : res = readerror ( data ) default : res = rawresponse ( data ) } return } 
func backoff ( rand * rand . rand , attempt int , min , max time . duration ) time . duration { if attempt <= 0 { panic ( " " ) } if min > max { panic ( " " ) } const coeff = 2 . 0 return jitteredbackoff ( rand , attempt , min , max , coeff ) } 
func ( c mpub ) write ( w * bufio . writer ) ( err error ) { for , s : = range [ ... ] string { " " , c . topic , " \n " , } { if , err = w . writestring ( s ) ; err ! = nil { err = errors . wrap ( err , " " ) return } } var size uint32 for , m : = range c . messages { size += uint32 ( len ( m ) ) } if err = binary . write ( w , binary . bigendian , size ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = binary . write ( w , binary . bigendian , uint32 ( len ( c . messages ) ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } for , m : = range c . messages { if err = binary . write ( w , binary . bigendian , uint32 ( len ( m ) ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = w . write ( m ) ; err ! = nil { err = errors . wrap ( err , " " ) return } } return } 
func ( t frametype ) string ( ) string { switch t { case frametyperesponse : return " " case frametypeerror : return " " case frametypemessage : return " " default : return " " + strconv . itoa ( int ( t ) ) + " " } } 
func readframe ( r * bufio . reader ) ( frame frame , err error ) { var size int32 var ftype int32 if err = binary . read ( r , binary . bigendian , & size ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = binary . read ( r , binary . bigendian , & ftype ) ; err ! = nil { err = errors . wrap ( err , " " ) return } switch size - = 4 ; frametype ( ftype ) { case frametyperesponse : return readresponse ( int ( size ) , r ) case frametypeerror : return readerror ( int ( size ) , r ) case frametypemessage : return readmessage ( int ( size ) , r ) default : return readunknownframe ( frametype ( ftype ) , int ( size ) , r ) } } 
func ( f unknownframe ) write ( w * bufio . writer ) ( err error ) { if err = writeframeheader ( w , f . type , len ( f . data ) ) ; err ! = nil { err = errors . withmessage ( err , " " ) return } if , err = w . write ( f . data ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( c auth ) write ( w * bufio . writer ) ( err error ) { if , err = w . writestring ( " \n " ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = binary . write ( w , binary . bigendian , uint32 ( len ( c . secret ) ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = w . writestring ( c . secret ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( info nodeinfo ) string ( ) string { if len ( info . hostname ) ! = 0 { return info . hostname } return httpbroadcastaddress ( info ) } 
func ( info nodeinfo2 ) string ( ) string { if len ( info . hostname ) ! = 0 { return info . hostname } return makebroadcastaddress ( info . broadcastaddress , info . httpport ) } 
func ( c nop ) write ( w * bufio . writer ) ( err error ) { if , err = w . writestring ( " \n " ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func newconsulengine ( config consulconfig ) * consulengine { if len ( config . address ) == 0 { config . address = defaultconsuladdress } if len ( config . namespace ) == 0 { config . namespace = defaultconsulnamespace } if config . nodetimeout == 0 { config . nodetimeout = defaultlocalenginenodetimeout } if config . tombstonetimeout == 0 { config . tombstonetimeout = defaultlocalenginetombstonetimeout } if ! strings . contains ( config . address , " " ) { config . address = " " + config . address } return & consulengine { client : http . client { transport : config . transport } , address : config . address , namespace : config . namespace , nodetimeout : config . nodetimeout , tombtimeout : config . tombstonetimeout , } } 
func parsemessageid ( s string ) ( id messageid , err error ) { var v uint64 v , err = strconv . parseuint ( s , 16 , 64 ) id = messageid ( v ) return } 
func ( id messageid ) writeto ( w io . writer ) ( int64 , error ) { a : = [ 16 ] byte { } b : = strconv . appenduint ( a [ : 0 ] , uint64 ( id ) , 16 ) n : = len ( a ) - len ( b ) copy ( a [ n : ] , b ) for i : = 0 ; i ! = n ; i ++ { a [ i ] = ' 0 ' } c , e : = w . write ( a [ : ] ) return int64 ( c ) , e } 
func newmessage ( id messageid , body [ ] byte , cmdchan chan < - command ) * message { return & message { id : id , body : body , cmdchan : cmdchan , } } 
func ( m * message ) finish ( ) { if m . complete ( ) { panic ( " " ) } defer func ( ) { recover ( ) } ( ) m . cmdchan < - fin { messageid : m . id } m . cmdchan = nil } 
func ( m * message ) requeue ( timeout time . duration ) { if m . complete ( ) { panic ( " " ) } defer func ( ) { recover ( ) } ( ) m . cmdchan < - req { messageid : m . id , timeout : timeout } m . cmdchan = nil } 
func ( m message ) write ( w * bufio . writer ) ( err error ) { if err = writeframeheader ( w , frametypemessage , len ( m . body ) + 26 ) ; err ! = nil { err = errors . withmessage ( err , " " ) return } if err = binary . write ( w , binary . bigendian , m . timestamp . unixnano ( ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = binary . write ( w , binary . bigendian , m . attempts ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = m . id . writeto ( w ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = w . write ( m . body ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func readcommand ( r * bufio . reader ) ( cmd command , err error ) { var line string if line , err = r . readstring ( ' \n ' ) ; err ! = nil { return } parts : = strings . split ( strings . trimspace ( line ) , " " ) if len ( parts ) == 0 { err = makeerrinvalid ( " " ) return } switch name , args : = parts [ 0 ] , parts [ 1 : ] ; name { case " " : return readping ( args ... ) case " " : return readidentify ( r , args ... ) case " " : return readregister ( args ... ) case " " : return readunregister ( args ... ) default : err = makeerrinvalid ( " " , name ) return } } 
func ( c identify ) write ( w * bufio . writer ) ( err error ) { var data [ ] byte if data , err = json . marshal ( identifybody { clientid : c . clientid , hostname : c . hostname , useragent : c . useragent , messagetimeout : int ( c . messagetimeout / time . millisecond ) , } ) ; err ! = nil { return } if , err = w . writestring ( " \n " ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = binary . write ( w , binary . bigendian , uint32 ( len ( data ) ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = w . write ( data ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( c rdy ) write ( w * bufio . writer ) ( err error ) { if , err = w . writestring ( " " ) ; err ! = nil { err = errors . wrap ( err , " " ) return } b : = strconv . appenduint ( make ( [ ] byte , 0 , 64 ) , uint64 ( c . count ) , 10 ) b = append ( b , ' \n ' ) if , err = w . write ( b ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( c pub ) write ( w * bufio . writer ) ( err error ) { for , s : = range [ ... ] string { " " , c . topic , " \n " , } { if , err = w . writestring ( s ) ; err ! = nil { err = errors . wrap ( err , " " ) return } } if err = binary . write ( w , binary . bigendian , uint32 ( len ( c . message ) ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = w . write ( c . message ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( e error ) write ( w * bufio . writer ) ( err error ) { if err = writeframeheader ( w , frametypeerror , len ( e ) ) ; err ! = nil { err = errors . withmessage ( err , " " ) return } if , err = w . writestring ( string ( e ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( c req ) write ( w * bufio . writer ) ( err error ) { if , err = w . writestring ( " " ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = c . messageid . writeto ( w ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = w . writebyte ( ' ' ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if , err = w . writestring ( strconv . formatuint ( uint64 ( c . timeout / time . millisecond ) , 10 ) ) ; err ! = nil { err = errors . wrap ( err , " " ) return } if err = w . writebyte ( ' \n ' ) ; err ! = nil { err = errors . wrap ( err , " " ) return } return } 
func ( tmpl * template ) funcmapmaker ( req * http . request , writer http . responsewriter ) template . funcmap { var funcmap = template . funcmap { } for key , fc : = range tmpl . render . funcmaps { funcmap [ key ] = fc } if tmpl . render . config . funcmapmaker ! = nil { for key , fc : = range tmpl . render . config . funcmapmaker ( tmpl . render , req , writer ) { funcmap [ key ] = fc } } for key , fc : = range tmpl . funcmap { funcmap [ key ] = fc } return funcmap } 
func ( tmpl * template ) funcs ( funcmap template . funcmap ) * template { tmpl . funcmap = funcmap return tmpl } 
func ( tmpl * template ) execute ( templatename string , obj interface { } , req * http . request , w http . responsewriter ) error { result , err : = tmpl . render ( templatename , obj , req , w ) if err == nil { if w . header ( ) . get ( " " ) == " " { w . header ( ) . set ( " " , " " ) } , err = w . write ( [ ] byte ( result ) ) } return err } 
func ( fs * assetfilesystem ) registerpath ( pth string ) error { if , err : = os . stat ( pth ) ; ! os . isnotexist ( err ) { var existing bool for , p : = range fs . paths { if p == pth { existing = true break } } if ! existing { fs . paths = append ( fs . paths , pth ) } return nil } return errors . new ( " " ) } 
func ( fs * assetfilesystem ) asset ( name string ) ( [ ] byte , error ) { for , pth : = range fs . paths { if , err : = os . stat ( filepath . join ( pth , name ) ) ; err == nil { return ioutil . readfile ( filepath . join ( pth , name ) ) } } return [ ] byte { } , fmt . errorf ( " " , name ) } 
func ( fs * assetfilesystem ) glob ( pattern string ) ( matches [ ] string , err error ) { for , pth : = range fs . paths { if results , err : = filepath . glob ( filepath . join ( pth , pattern ) ) ; err == nil { for , result : = range results { matches = append ( matches , strings . trimprefix ( result , pth ) ) } } } return } 
func ( fs * assetfilesystem ) namespace ( namespace string ) interface { if fs . namespacedfs == nil { fs . namespacedfs = map [ string ] interface { } } fs . namespacedfs [ namespace ] = & assetfilesystem { } return fs . namespacedfs [ namespace ] } 
func new ( config * config , viewpaths ... string ) * render { if config == nil { config = & config { } } if config . defaultlayout == " " { config . defaultlayout = defaultlayout } if config . assetfilesystem == nil { config . assetfilesystem = assetfs . assetfs ( ) . namespace ( " " ) } config . viewpaths = append ( append ( config . viewpaths , viewpaths ... ) , defaultviewpath ) render : = & render { funcmaps : map [ string ] interface { } { } , config : config } for , viewpath : = range config . viewpaths { render . registerviewpath ( viewpath ) } return render } 
func ( render * render ) registerviewpath ( paths ... string ) { for , pth : = range paths { if filepath . isabs ( pth ) { render . viewpaths = append ( render . viewpaths , pth ) render . assetfilesystem . registerpath ( pth ) } else { if abspath , err : = filepath . abs ( pth ) ; err == nil && isexistingdir ( abspath ) { render . viewpaths = append ( render . viewpaths , abspath ) render . assetfilesystem . registerpath ( abspath ) } else if isexistingdir ( filepath . join ( utils . approot , " " , pth ) ) { render . assetfilesystem . registerpath ( filepath . join ( utils . approot , " " , pth ) ) } else { for , gopath : = range utils . gopath ( ) { if p : = filepath . join ( gopath , " " , pth ) ; isexistingdir ( p ) { render . viewpaths = append ( render . viewpaths , p ) render . assetfilesystem . registerpath ( p ) } } } } } } 
func ( render * render ) setassetfs ( assetfs assetfs . interface ) { for , viewpath : = range render . viewpaths { assetfs . registerpath ( viewpath ) } render . assetfilesystem = assetfs } 
func ( render * render ) layout ( name string ) * template { return & template { render : render , layout : name } } 
func ( render * render ) funcs ( funcmap template . funcmap ) * template { tmpl : = & template { render : render , usingdefaultlayout : true } return tmpl . funcs ( funcmap ) } 
func ( render * render ) execute ( name string , context interface { } , request * http . request , writer http . responsewriter ) error { tmpl : = & template { render : render , usingdefaultlayout : true } return tmpl . execute ( name , context , request , writer ) } 
func ( render * render ) registerfuncmap ( name string , fc interface { } ) { if render . funcmaps == nil { render . funcmaps = template . funcmap { } } render . funcmaps [ name ] = fc } 
func ( render * render ) asset ( name string ) ( [ ] byte , error ) { return render . assetfilesystem . asset ( name ) } 
func newplainclient ( identity , username , password string ) client { return & plainclient { identity , username , password } } 
func create ( url string , h http . header , c * config ) ( io . writecloser , error ) { if c == nil { c = defaultconfig } return newuploader ( url , h , c ) } 
func ( u * uploader ) retryuploadpart ( p * part ) { defer u . wg . done ( ) defer func ( ) { p . r = nil } ( ) var err error for i : = 0 ; i < ntry ; i ++ { p . r . seek ( 0 , 0 ) err = u . putpart ( p ) if err == nil { return } } u . err = err } 
func open ( url string , c * config ) ( io . readcloser , error ) { if c == nil { c = defaultconfig } r , : = http . newrequest ( " " , url , nil ) r . header . set ( " " , time . now ( ) . utc ( ) . format ( http . timeformat ) ) c . sign ( r , * c . keys ) client : = c . client if client == nil { client = http . defaultclient } resp , err : = client . do ( r ) if err ! = nil { return nil , err } if resp . statuscode ! = 200 { return nil , newresperror ( resp ) } return resp . body , nil } 
func amazonbucket ( subdomain string ) string { if i : = strings . lastindex ( subdomain , " " ) ; i ! = - 1 { return subdomain [ : i ] } return " " } 
func ( f * file ) readdir ( n int ) ( [ ] os . fileinfo , error ) { if f . result ! = nil && ! f . result . istruncated { return make ( [ ] os . fileinfo , 0 ) , io . eof } reader , err : = f . sendrequest ( n ) if err ! = nil { return nil , err } defer reader . close ( ) return f . parseresponse ( reader ) } 
func find ( x tree . node , p pathexpr . pathexpr ) [ ] tree . node { ret : = [ ] tree . node { } if p . axis == " " { findchild ( x , & p , & ret ) return ret } f : = findmap [ p . axis ] f ( x , & p , & ret ) return ret } 
func lex ( xpath string ) chan xitem { l : = & lexer { input : xpath , items : make ( chan xitem ) , } go l . run ( ) return l . items } 
func mustparsexml ( r io . reader , op ... parsesettings ) tree . node { ret , err : = parsexml ( r , op ... ) if err ! = nil { panic ( err ) } return ret } 
func ( w wrap ) call ( c ctx , args ... result ) ( result , error ) { switch w . lastargopt { case optional : if len ( args ) == w . nargs | | len ( args ) == w . nargs - 1 { return w . fn ( c , args ... ) } case variadic : if len ( args ) >= w . nargs - 1 { return w . fn ( c , args ... ) } default : if len ( args ) == w . nargs { return w . fn ( c , args ... ) } } return nil , fmt . errorf ( " " ) } 
func parse ( xp string ) ( xpathexec , error ) { n , err : = parser . parse ( xp ) return xpathexec { n : n } , err } 
func mustparse ( xp string ) xpathexec { ret , err : = parse ( xp ) if err ! = nil { panic ( err ) } return ret } 
func ( xp xpathexec ) exec ( t tree . node , opts ... funcopts ) ( tree . result , error ) { o : = & opts { ns : make ( map [ string ] string ) , funcs : make ( map [ xml . name ] tree . wrap ) , vars : make ( map [ string ] tree . result ) , } for , i : = range opts { i ( o ) } return execxp . exec ( xp . n , t , o . ns , o . funcs , o . vars ) } 
func ( xp xpathexec ) execbool ( t tree . node , opts ... funcopts ) ( bool , error ) { res , err : = xp . exec ( t , opts ... ) if err ! = nil { return false , err } b , ok : = res . ( tree . isbool ) if ! ok { return false , fmt . errorf ( " " ) } return bool ( b . bool ( ) ) , nil } 
func ( xp xpathexec ) execnum ( t tree . node , opts ... funcopts ) ( float64 , error ) { res , err : = xp . exec ( t , opts ... ) if err ! = nil { return 0 , err } n , ok : = res . ( tree . isnum ) if ! ok { return 0 , fmt . errorf ( " " ) } return float64 ( n . num ( ) ) , nil } 
func ( xp xpathexec ) execnode ( t tree . node , opts ... funcopts ) ( tree . nodeset , error ) { res , err : = xp . exec ( t , opts ... ) if err ! = nil { return nil , err } n , ok : = res . ( tree . nodeset ) if ! ok { return nil , fmt . errorf ( " " ) } return n , nil } 
func ( xp xpathexec ) mustexec ( t tree . node , opts ... funcopts ) tree . result { res , err : = xp . exec ( t , opts ... ) if err ! = nil { panic ( err ) } return res } 
func parseexec ( xpstr string , t tree . node , opts ... funcopts ) ( tree . result , error ) { xp , err : = parse ( xpstr ) if err ! = nil { return nil , err } return xp . exec ( t , opts ... ) } 
func ( x * xmlele ) createnode ( opts * xmlbuilder . builderopts ) xmlbuilder . xmlbuilder { if opts . nodetype == tree . ntelem { ele : = & xmlele { startelement : opts . tok . ( xml . startelement ) , nsbuilder : tree . nsbuilder { ns : opts . ns } , attrs : make ( [ ] tree . node , len ( opts . attrs ) ) , parent : x , nodepos : tree . nodepos ( opts . nodepos ) , nodetype : opts . nodetype , } for i : = range opts . attrs { ele . attrs [ i ] = xmlnode . xmlnode { token : opts . attrs [ i ] , nodepos : tree . nodepos ( opts . attrstartpos + i ) , nodetype : tree . ntattr , parent : ele , } } x . children = append ( x . children , ele ) return ele } node : = xmlnode . xmlnode { token : opts . tok , nodepos : tree . nodepos ( opts . nodepos ) , nodetype : opts . nodetype , parent : x , } x . children = append ( x . children , node ) return x } 
func ( x * xmlele ) getchildren ( ) [ ] tree . node { ret : = make ( [ ] tree . node , len ( x . children ) ) for i : = range x . children { ret [ i ] = x . children [ i ] } return ret } 
func ( x * xmlele ) getattrs ( ) [ ] tree . node { ret : = make ( [ ] tree . node , len ( x . attrs ) ) for i : = range x . attrs { ret [ i ] = x . attrs [ i ] } return ret } 
func ( x * xmlele ) resvalue ( ) string { ret : = " " for i : = range x . children { switch x . children [ i ] . getnodetype ( ) { case tree . ntchd , tree . ntelem , tree . ntroot : ret += x . children [ i ] . resvalue ( ) } } return ret } 
func parse ( xp string ) ( * node , error ) { var err error c : = lexer . lex ( xp ) n : = & node { } p : = & parsestack { cur : n } for next : = range c { if next . typ ! = lexer . xitemerror { parsemap [ next . typ ] ( p , next ) } else if err == nil { err = fmt . errorf ( next . val ) } } return n , err } 
func ( a xmlnode ) gettoken ( ) xml . token { if a . nodetype == tree . ntattr { ret : = a . token . ( * xml . attr ) return * ret } return a . token } 
func ( a xmlnode ) resvalue ( ) string { switch a . nodetype { case tree . ntattr : return a . token . ( * xml . attr ) . value case tree . ntchd : return string ( a . token . ( xml . chardata ) ) case tree . ntcomm : return string ( a . token . ( xml . comment ) ) } return string ( a . token . ( xml . procinst ) . inst ) } 
func exec ( n * parser . node , t tree . node , ns map [ string ] string , fns map [ xml . name ] tree . wrap , v map [ string ] tree . result ) ( tree . result , error ) { f : = xpfilt { t : t , ns : ns , ctx : tree . nodeset { t } , fns : fns , variables : v , } return exec ( & f , n ) } 
func ( n num ) string ( ) string { if math . isinf ( float64 ( n ) , 0 ) { if math . isinf ( float64 ( n ) , 1 ) { return " " } return " " } return fmt . sprintf ( " " , float64 ( n ) ) } 
func ( s string ) num ( ) num { num , err : = strconv . parsefloat ( strings . trimspace ( string ( s ) ) , 64 ) if err ! = nil { return num ( math . nan ( ) ) } return num ( num ) } 
func buildns ( t elem ) ( ret [ ] ns ) { vals : = make ( map [ xml . name ] string ) if nselem , ok : = t . ( nselem ) ; ok { buildns ( nselem , vals ) ret = make ( [ ] ns , 0 , len ( vals ) ) i : = 1 for k , v : = range vals { if ! ( k . local == " " && k . space == " " && v == " " ) { ret = append ( ret , ns { attr : xml . attr { name : k , value : v } , parent : t , nodetype : ntns , } ) i ++ } } sort . sort ( nsvaluesort ( ret ) ) for i : = range ret { ret [ i ] . nodepos = nodepos ( t . pos ( ) + i + 1 ) } } return ret } 
func getattribute ( n elem , local , space string ) ( xml . attr , bool ) { attrs : = n . getattrs ( ) for , i : = range attrs { attr : = i . gettoken ( ) . ( xml . attr ) if local == attr . name . local && space == attr . name . space { return attr , true } } return xml . attr { } , false } 
func getattributeval ( n elem , local , space string ) ( string , bool ) { attr , ok : = getattribute ( n , local , space ) return attr . value , ok } 
func getattrvalorempty ( n elem , local , space string ) string { val , ok : = getattributeval ( n , local , space ) if ! ok { return " " } return val } 
func findnodebypos ( n node , pos int ) node { if n . pos ( ) == pos { return n } if elem , ok : = n . ( elem ) ; ok { chldrn : = elem . getchildren ( ) for i : = 1 ; i < len ( chldrn ) ; i ++ { if chldrn [ i - 1 ] . pos ( ) <= pos && chldrn [ i ] . pos ( ) > pos { return findnodebypos ( chldrn [ i - 1 ] , pos ) } } if len ( chldrn ) > 0 { if chldrn [ len ( chldrn ) - 1 ] . pos ( ) <= pos { return findnodebypos ( chldrn [ len ( chldrn ) - 1 ] , pos ) } } attrs : = elem . getattrs ( ) for , i : = range attrs { if i . pos ( ) == pos { return i } } ns : = buildns ( elem ) for , i : = range ns { if i . pos ( ) == pos { return i } } } return nil } 
func marshal ( n tree . node , w io . writer ) error { return marshal ( n , w ) } 
func marshalstr ( n tree . node ) ( string , error ) { ret : = bytes . newbufferstring ( " " ) err : = marshal ( n , ret ) return ret . string ( ) , err } 
func newlexer ( r io . reader , posix , whitespacesplit bool ) * lexer { return & lexer { reader : bufio . newreader ( r ) , tokenizer : & defaulttokenizer { } , posix : posix , whitespacesplit : whitespacesplit , } } 
func newlexerstring ( s string , posix , whitespacesplit bool ) * lexer { return newlexer ( strings . newreader ( s ) , posix , whitespacesplit ) } 
func split ( s string , posix bool ) ( [ ] string , error ) { return newlexerstring ( s , posix , true ) . split ( ) } 
func ( r * registry ) register ( err * errdescriptor ) { r . lock ( ) defer r . unlock ( ) if err . code == nocode { panic ( fmt . errorf ( " " , err . messageformat ) ) } if r . bycode [ err . code ] ! = nil { panic ( fmt . errorf ( " " , err . code ) ) } err . registered = true r . bycode [ err . code ] = err } 
func ( r * registry ) get ( code code ) * errdescriptor { r . rlock ( ) defer r . runlock ( ) return r . bycode [ code ] } 
func ( r * registry ) getall ( ) [ ] * errdescriptor { r . rlock ( ) defer r . runlock ( ) res : = make ( [ ] * errdescriptor , 0 , len ( r . bycode ) ) for , d : = range r . bycode { res = append ( res , d ) } return res } 
func from ( in error ) error { if err , ok : = in . ( error ) ; ok { return err } return fromgrpc ( in ) } 
func descriptor ( in error ) ( desc * errdescriptor ) { err : = from ( in ) descriptor : = get ( err . code ( ) ) if descriptor ! = nil { return descriptor } return & errdescriptor { messageformat : err . error ( ) , type : err . type ( ) , code : err . code ( ) , } } 
func getattributes ( err error ) attributes { e , ok : = err . ( error ) if ok { return e . attributes ( ) } return attributes { } } 
func toimpl ( err error ) * impl { if i , ok : = err . ( * impl ) ; ok { return i } return & impl { message : err . error ( ) , code : err . code ( ) , typ : err . type ( ) , attributes : err . attributes ( ) , } } 
func metadatafromincomingcontext ( ctx context . context ) metadata . md { md , : = metadata . fromincomingcontext ( ctx ) return md } 
func metadatafromoutgoingcontext ( ctx context . context ) metadata . md { md , : = metadata . fromoutgoingcontext ( ctx ) return md } 
func tokenfrommetadata ( md metadata . md ) ( string , error ) { token , ok : = md [ " " ] if ! ok | | len ( token ) == 0 { return " " , errnotoken } return token [ 0 ] , nil } 
func tokenfromincomingcontext ( ctx context . context ) ( string , error ) { md : = metadatafromincomingcontext ( ctx ) return tokenfrommetadata ( md ) } 
func outgoingcontextwithtoken ( ctx context . context , token string ) context . context { return outgoingcontextwithmergedmetadata ( ctx , " " , token ) } 
func keyfrommetadata ( md metadata . md ) ( string , error ) { key , ok : = md [ " " ] if ! ok | | len ( key ) == 0 { return " " , errnokey } return key [ 0 ] , nil } 
func keyfromincomingcontext ( ctx context . context ) ( string , error ) { md : = metadatafromincomingcontext ( ctx ) return keyfrommetadata ( md ) } 
func outgoingcontextwithkey ( ctx context . context , key string ) context . context { return outgoingcontextwithmergedmetadata ( ctx , " " , key ) } 
func idfrommetadata ( md metadata . md ) ( string , error ) { id , ok : = md [ " " ] if ! ok | | len ( id ) == 0 { return " " , errnoid } return id [ 0 ] , nil } 
func idfromincomingcontext ( ctx context . context ) ( string , error ) { md : = metadatafromincomingcontext ( ctx ) return idfrommetadata ( md ) } 
func outgoingcontextwithid ( ctx context . context , id string ) context . context { return outgoingcontextwithmergedmetadata ( ctx , " " , id ) } 
func serviceinfofrommetadata ( md metadata . md ) ( servicename , serviceversion , netaddress string , err error ) { servicenamel , ok : = md [ " " ] if ok && len ( servicenamel ) > 0 { servicename = servicenamel [ 0 ] } serviceversionl , ok : = md [ " " ] if ok && len ( serviceversionl ) > 0 { serviceversion = serviceversionl [ 0 ] } netaddressl , ok : = md [ " " ] if ok && len ( netaddressl ) > 0 { netaddress = netaddressl [ 0 ] } return } 
func serviceinfofromincomingcontext ( ctx context . context ) ( servicename , serviceversion , netaddress string , err error ) { md : = metadatafromincomingcontext ( ctx ) return serviceinfofrommetadata ( md ) } 
func outgoingcontextwithserviceinfo ( ctx context . context , servicename , serviceversion , netaddress string ) context . context { return outgoingcontextwithmergedmetadata ( ctx , " " , servicename , " " , serviceversion , " " , netaddress ) } 
func limitfrommetadata ( md metadata . md ) ( uint64 , error ) { limit , ok : = md [ " " ] if ! ok | | len ( limit ) == 0 { return 0 , nil } return strconv . parseuint ( limit [ 0 ] , 10 , 64 ) } 
func offsetfrommetadata ( md metadata . md ) ( uint64 , error ) { offset , ok : = md [ " " ] if ! ok | | len ( offset ) == 0 { return 0 , nil } return strconv . parseuint ( offset [ 0 ] , 10 , 64 ) } 
func limitandoffsetfromincomingcontext ( ctx context . context ) ( limit , offset uint64 , err error ) { md : = metadatafromincomingcontext ( ctx ) limit , err = limitfrommetadata ( md ) if err ! = nil { return 0 , 0 , err } offset , err = offsetfrommetadata ( md ) if err ! = nil { return 0 , 0 , err } return limit , offset , nil } 
func outgoingcontextwithlimitandoffset ( ctx context . context , limit , offset uint64 ) context . context { var pairs [ ] string if limit ! = 0 { pairs = append ( pairs , " " , strconv . formatuint ( limit , 10 ) ) } if offset ! = 0 { pairs = append ( pairs , " " , strconv . formatuint ( offset , 10 ) ) } if len ( pairs ) == 0 { return ctx } return outgoingcontextwithmergedmetadata ( ctx , pairs ... ) } 
func before ( i , j scheduleitem ) bool { iend : = i . time ( ) . unixnano ( ) + i . duration ( ) . nanoseconds ( ) jstart : = j . time ( ) . unixnano ( ) if i , ok : = i . ( scheduleitemwithtimestamp ) ; ok { if j , ok : = j . ( scheduleitemwithtimestamp ) ; ok { iend = i . timestamp ( ) + i . duration ( ) . nanoseconds ( ) jstart = j . timestamp ( ) } } return iend < jstart } 
func ( err * errdescriptor ) new ( attributes attributes ) error { if err . code ! = nocode && ! err . registered { panic ( fmt . errorf ( " " , err . code ) ) } return & impl { message : format ( err . messageformat , attributes ) , code : err . code , typ : err . type , attributes : attributes , } } 
func withnamespace ( namespace string , ctx log . interface ) log . interface { return ctx . withfield ( namespacekey , namespace ) } 
func wrap ( ctx log . interface , namespaces ... string ) * namespaced { return & namespaced { interface : ctx , namespaces : & ns { namespaces : namespaces , } , } } 
func ( n * namespaced ) withfield ( k string , v interface { } ) log . interface { if k == namespacekey { if str , ok : = v . ( string ) ; ok { return & namespaced { interface : n . interface , namespaces : n . namespaces , namespace : str , } } } return & namespaced { interface : n . interface . withfield ( k , v ) , namespaces : n . namespaces , namespace : n . namespace , } } 
func ( n * namespaced ) withfields ( fields log . fields ) log . interface { return & namespaced { interface : n . interface . withfields ( fields ) , namespaces : n . namespaces , namespace : n . namespace , } } 
func format ( format string , values attributes ) string { formatter , err : = messageformat . new ( ) if err ! = nil { return format } fm , err : = formatter . parse ( format ) if err ! = nil { return format } fixed : = make ( map [ string ] interface { } , len ( values ) ) for k , v : = range values { fixed [ k ] = fix ( v ) } res , err : = fm . formatmap ( fixed ) if err ! = nil { fmt . println ( " " , err ) return format } return res } 
func fix ( v interface { } ) interface { } { if v == nil { return " " } switch reflect . typeof ( v ) . kind ( ) { case reflect . bool : case reflect . int : case reflect . int8 : case reflect . int16 : case reflect . int32 : case reflect . int64 : case reflect . uint : case reflect . uint8 : case reflect . uint16 : case reflect . uint32 : case reflect . uint64 : case reflect . uintptr : case reflect . float32 : case reflect . float64 : return v case reflect . ptr : return fix ( reflect . valueof ( v ) . elem ( ) ) } return fmt . sprintf ( " " , v ) } 
func grpccodetotype ( code codes . code ) type { switch code { case codes . invalidargument : return invalidargument case codes . outofrange : return outofrange case codes . notfound : return notfound case codes . alreadyexists : return alreadyexists case codes . unauthenticated : return unauthorized case codes . permissiondenied : return permissiondenied case codes . deadlineexceeded : return timeout case codes . unimplemented : return notimplemented case codes . unavailable : return temporarilyunavailable case codes . failedprecondition : return permanentlyunavailable case codes . canceled : return canceled case codes . resourceexhausted : return resourceexhausted case codes . unknown : return unknown } return unknown } 
func fromgrpc ( in error ) error { out : = & impl { message : grpc . errordesc ( in ) , typ : grpccodetotype ( grpc . code ( in ) ) , code : nocode , } matches : = grpcmessageformat . findstringsubmatch ( in . error ( ) ) if len ( matches ) < 4 { return out } out . message = matches [ 1 ] out . code = parsecode ( matches [ 2 ] ) = json . unmarshal ( [ ] byte ( matches [ 3 ] ) , & out . attributes ) got : = get ( code ( out . code ) ) if got == nil { return out } return got . new ( out . attributes ) } 
func togrpc ( in error ) error { if err , ok : = in . ( error ) ; ok { attrs , : = json . marshal ( err . attributes ( ) ) return grpc . errorf ( err . type ( ) . grpccode ( ) , format , err . error ( ) , err . code ( ) , attrs ) } return grpc . errorf ( codes . unknown , in . error ( ) ) } 
func ( n * ns ) isenabled ( namespace string ) bool { n . rlock ( ) defer n . runlock ( ) if namespace == " " { return true } hasstar : = false included : = false for , ns : = range n . namespaces { if ns == negate ( namespace ) { return false } if ns == namespace { included = true } if ns == " " { hasstar = true } } return hasstar | | included } 
func ( n * ns ) set ( namespaces [ ] string ) { n . lock ( ) defer n . unlock ( ) n . namespaces = namespaces } 
func cause ( err error ) error { attributes : = err . attributes ( ) if attributes == nil { return nil } cause , ok : = attributes [ causekey ] if ! ok { return nil } switch v : = cause . ( type ) { case error : return v case string : return errors . new ( v ) default : return nil } } 
func parsecode ( str string ) code { code , err : = strconv . atoi ( str ) if err ! = nil { return code ( 0 ) } return code ( code ) } 
func range ( start uint32 , end uint32 ) func ( uint32 ) code { if end <= start { panic ( " " ) } return func ( i uint32 ) code { if i >= ( end - start ) { panic ( fmt . sprintf ( " " , i , start , end ) ) } return code ( start + i ) } } 
func unaryserverinterceptor ( fn convertfunc ) grpc . unaryserverinterceptor { return func ( ctx context . context , req interface { } , info * grpc . unaryserverinfo , handler grpc . unaryhandler ) ( resp interface { } , err error ) { resp , err = handler ( ctx , req ) return resp , fn ( err ) } } 
func streamserverinterceptor ( fn convertfunc ) grpc . streamserverinterceptor { return func ( srv interface { } , ss grpc . serverstream , info * grpc . streamserverinfo , handler grpc . streamhandler ) ( err error ) { return fn ( handler ( srv , ss ) ) } } 
func unaryclientinterceptor ( fn convertfunc ) grpc . unaryclientinterceptor { return func ( ctx context . context , method string , req , reply interface { } , cc * grpc . clientconn , invoker grpc . unaryinvoker , opts ... grpc . calloption ) ( err error ) { return fn ( invoker ( ctx , method , req , reply , cc , opts ... ) ) } } 
func streamclientinterceptor ( fn convertfunc ) grpc . streamclientinterceptor { return func ( ctx context . context , desc * grpc . streamdesc , cc * grpc . clientconn , method string , streamer grpc . streamer , opts ... grpc . calloption ) ( stream grpc . clientstream , err error ) { stream , err = streamer ( ctx , desc , cc , method , opts ... ) return stream , fn ( err ) } } 
func interceptor ( settings settings ) grpc . streamclientinterceptor { return func ( ctx context . context , desc * grpc . streamdesc , cc * grpc . clientconn , method string , streamer grpc . streamer , opts ... grpc . calloption ) ( stream grpc . clientstream , err error ) { s : = & restartingstream { log : log . get ( ) . withfield ( " " , method ) , ctx : ctx , desc : desc , cc : cc , method : method , streamer : streamer , opts : opts , retryablecodes : settings . retryablecodes , backoff : settings . backoff , retries : - 1 , } err = s . start ( ) stream = s return } } 
func newcounter ( bucketsize , retention time . duration ) counter { return & counter { bucketsize : bucketsize , retention : retention , buckets : make ( [ ] uint64 , 2 * retention / bucketsize ) , } } 
func newrediscounter ( client * redis . client , key string , bucketsize , retention time . duration ) counter { return & rediscounter { client : client , key : key , bucketsize : bucketsize , retention : retention , } } 
func newlimiter ( counter counter , duration time . duration , limit uint64 ) limiter { return & limiter { counter : counter , duration : duration , limit : limit , } } 
func ( c * tokencredentials ) withinsecure ( ) * tokencredentials { return & tokencredentials { token : c . token , tokenfunc : c . tokenfunc , allowinsecure : true } } 
func withtokenfunc ( k string , tokenfunc func ( v string ) string ) * tokencredentials { return & tokencredentials { tokenfunc : tokenfunc , tokenfunckey : k , } } 
func ( c * tokencredentials ) getrequestmetadata ( ctx context . context , uri ... string ) ( map [ string ] string , error ) { md : = ttnctx . metadatafromoutgoingcontext ( ctx ) token , : = ttnctx . tokenfrommetadata ( md ) if token ! = " " { return map [ string ] string { tokenkey : token } , nil } if c . tokenfunc ! = nil { var k string if v , ok : = md [ c . tokenfunckey ] ; ok && len ( v ) > 0 { k = v [ 0 ] } return map [ string ] string { tokenkey : c . tokenfunc ( k ) } , nil } if c . token ! = " " { return map [ string ] string { tokenkey : c . token } , nil } return map [ string ] string { tokenkey : " " } , nil } 
func fieldsfromincomingcontext ( ctx context . context ) ttnlog . fields { fields : = make ( fieldmap ) if peer , ok : = peer . fromcontext ( ctx ) ; ok { fields . addfrompeer ( peer ) } if md , ok : = metadata . fromincomingcontext ( ctx ) ; ok { fields . addfrommd ( md ) } return fields . logfields ( ) } 
func ( t type ) string ( ) string { switch t { case unknown : return " " case internal : return " " case invalidargument : return " " case outofrange : return " " case notfound : return " " case conflict : return " " case alreadyexists : return " " case unauthorized : return " " case permissiondenied : return " " case timeout : return " " case notimplemented : return " " case temporarilyunavailable : return " " case permanentlyunavailable : return " " case canceled : return " " case resourceexhausted : return " " default : return " " } } 
func ( t * type ) unmarshaltext ( text [ ] byte ) error { e , err : = fromstring ( string ( text ) ) if err ! = nil { return err } * t = e return nil } 
func fromstring ( str string ) ( type , error ) { enum : = strings . tolower ( str ) switch enum { case " " : return unknown , nil case " " : return internal , nil case " " : return invalidargument , nil case " " : return outofrange , nil case " " : return notfound , nil case " " : return conflict , nil case " " : return alreadyexists , nil case " " : return unauthorized , nil case " " : return permissiondenied , nil case " " : return timeout , nil case " " : return notimplemented , nil case " " : return temporarilyunavailable , nil case " " : return permanentlyunavailable , nil case " " : return canceled , nil case " " : return resourceexhausted , nil default : return unknown , fmt . errorf ( " " ) } } 
func start ( ctx log . interface , interval time . duration ) { ctx . withfield ( " " , interval ) . debug ( " " ) go func ( ) { memstats : = new ( runtime . memstats ) for range time . tick ( interval ) { runtime . readmemstats ( memstats ) ctx . withfields ( log . fields { " " : runtime . numgoroutine ( ) , " " : float64 ( memstats . alloc ) / megabyte , } ) . debugf ( " " ) } } ( ) } 
func newsimple ( ) simple { q : = & simplequeue { queue : make ( [ ] interface { } , 0 ) , } q . available = sync . newcond ( & q . mu ) return q } 
func wrap ( logger log . interface , filters ... filter ) * filtered { return & filtered { interface : logger , filters : filters , } } 
func ( f * filtered ) withfilters ( filters ... filter ) * filtered { return & filtered { interface : f . interface , filters : append ( f . filters , filters ... ) , } } 
func ( f * filtered ) withfield ( k string , v interface { } ) log . interface { val : = v for , filter : = range f . filters { val = filter . filter ( k , val ) } return & filtered { interface : f . interface . withfield ( k , val ) , filters : f . filters , } } 
func ( f * filtered ) withfields ( fields log . fields ) log . interface { res : = make ( map [ string ] interface { } , len ( fields ) ) for k , v : = range fields { val : = v for , filter : = range f . filters { val = filter . filter ( k , val ) } res [ k ] = val } return & filtered { interface : f . interface . withfields ( res ) , filters : f . filters , } } 
func filtersensitive ( sensitive [ ] string , elided interface { } ) filter { return filterfunc ( func ( key string , v interface { } ) interface { } { lower : = strings . tolower ( key ) for , s : = range sensitive { if lower == s { return elided } } return v } ) } 
func slicefilter ( filter filter ) filter { return filterfunc ( func ( k string , v interface { } ) interface { } { r : = reflect . valueof ( v ) if r . kind ( ) == reflect . slice { res : = make ( [ ] interface { } , 0 , r . len ( ) ) for i : = 0 ; i < r . len ( ) ; i ++ { el : = r . index ( i ) . interface ( ) res = append ( res , filter . filter ( k , el ) ) } return res } return filter . filter ( k , v ) } ) } 
func mapfilter ( filter filter ) filter { return filterfunc ( func ( k string , v interface { } ) interface { } { r : = reflect . valueof ( v ) if r . kind ( ) == reflect . map { res : = make ( map [ string ] interface { } , r . len ( ) ) for , key : = range r . mapkeys ( ) { str : = key . string ( ) val : = r . mapindex ( key ) . interface ( ) res [ str ] = filter . filter ( str , val ) } return res } return v } ) } 
func restrictfilter ( fieldname string , filter filter ) filter { return filterfunc ( func ( k string , v interface { } ) interface { } { if fieldname == k { return filter . filter ( k , v ) } return v } ) } 
func lowercasefilter ( filter filter ) filter { return filterfunc ( func ( k string , v interface { } ) interface { } { return filter . filter ( strings . tolower ( k ) , v ) } ) } 
func newbatchpoints ( bpconf influxdb . batchpointsconfig ) influxdb . batchpoints { bp , err : = influxdb . newbatchpoints ( bpconf ) if err ! = nil { panic ( fmt . errorf ( " " , err ) ) } return bp } 
func newsinglepointwriter ( log ttnlog . interface , w batchpointswriter ) * singlepointwriter { return & singlepointwriter { log : log , writer : w , } } 
func ( w * singlepointwriter ) write ( bpconf influxdb . batchpointsconfig , p * influxdb . point ) error { bp : = newbatchpoints ( bpconf ) bp . addpoint ( p ) return w . writer . write ( bp ) } 
func ( p * batchpoint ) pusherror ( err error ) { p . errch < - err close ( p . errch ) } 
func withscalinginterval ( v time . duration ) batchingwriteroption { return func ( w * batchingwriter ) { w . scalinginterval = v } } 
func newbatchingwriter ( log ttnlog . interface , w batchpointswriter , opts ... batchingwriteroption ) * batchingwriter { bw : = & batchingwriter { log : log , writer : w , scalinginterval : defaultscalinginterval , limit : defaultinstancelimit , pointchans : make ( map [ influxdb . batchpointsconfig ] chan * batchpoint ) , } for , opt : = range opts { opt ( bw ) } bw . log = bw . log . withfields ( ttnlog . fields { " " : bw . limit , " " : bw . scalinginterval , } ) return bw } 
func ( w * batchingwriter ) write ( bpconf influxdb . batchpointsconfig , p * influxdb . point ) error { log : = w . log . withfield ( " " , bpconf ) w . pointchanmutex . rlock ( ) ch , ok : = w . pointchans [ bpconf ] w . pointchanmutex . runlock ( ) if ! ok { w . pointchanmutex . lock ( ) ch , ok = w . pointchans [ bpconf ] if ! ok { w . mutex . lock ( ) w . active ++ w . limit ++ w . mutex . unlock ( ) ch = make ( chan * batchpoint ) w . pointchans [ bpconf ] = ch go writeinbatches ( log , w . writer , bpconf , w . scalinginterval , ch , true ) } w . pointchanmutex . unlock ( ) } point : = & batchpoint { point : p , errch : make ( chan error , 1 ) , } select { case ch < - point : case < - time . after ( w . scalinginterval ) : w . mutex . lock ( ) if w . active < w . limit { w . active ++ go writeinbatches ( w . log , w . writer , bpconf , w . scalinginterval , ch , false ) } w . mutex . unlock ( ) ch < - point } return < - point . errch } 
func stdout ( ) * apexinterfacewrapper { return wrap ( & apex . logger { level : apex . infolevel , handler : cli . new ( os . stdout ) , } ) } 
func ( w * apexinterfacewrapper ) mustparselevel ( s string ) { level , err : = parselevel ( s ) if err ! = nil { w . witherror ( err ) . withfield ( " " , s ) . fatal ( " " ) } w . level = level } 
func new ( buffersize int , setup func ( ) ( grpc . clientstream , error ) ) * stream { return & stream { setupfunc : setup , sendbuffer : make ( chan interface { } , buffersize ) , log : ttnlog . get ( ) , } } 
func ( s * stream ) setlogger ( log ttnlog . interface ) { s . mu . lock ( ) s . log = log s . mu . unlock ( ) } 
func ( s * stream ) recv ( recv func ( ) interface { } ) < - chan interface { } { s . mu . lock ( ) s . recvfunc = recv buf : = make ( chan interface { } , cap ( s . sendbuffer ) ) s . recvbuffer = buf s . mu . unlock ( ) return buf } 
func ( s * stream ) closerecv ( ) { s . mu . lock ( ) if s . recvbuffer ! = nil { close ( s . recvbuffer ) s . recvbuffer = nil } s . mu . unlock ( ) } 
func ( s * stream ) stats ( ) ( sent , dropped uint64 ) { return atomic . loaduint64 ( & s . sent ) , atomic . loaduint64 ( & s . dropped ) } 
func ( s * stream ) sendmsg ( msg interface { } ) { select { case s . sendbuffer < - msg : default : s . log . debug ( " " ) atomic . adduint64 ( & s . dropped , 1 ) < - s . sendbuffer select { case s . sendbuffer < - msg : default : s . log . debug ( " " ) atomic . adduint64 ( & s . dropped , 1 ) } } } 
func ( s * stream ) recvmsg ( msg interface { } ) { s . mu . rlock ( ) if s . recvbuffer == nil { s . mu . runlock ( ) return } defer s . mu . runlock ( ) select { case s . recvbuffer < - msg : default : s . log . debug ( " " ) atomic . adduint64 ( & s . dropped , 1 ) < - s . recvbuffer select { case s . recvbuffer < - msg : default : atomic . adduint64 ( & s . dropped , 1 ) s . log . debug ( " " ) } } } 
func serveroptions ( log ttnlog . interface ) [ ] grpc . serveroption { return [ ] grpc . serveroption { grpc . unaryinterceptor ( unaryserverinterceptor ( log ) ) , grpc . streaminterceptor ( streamserverinterceptor ( log ) ) , } } 
func clientoptions ( log ttnlog . interface ) [ ] grpc . dialoption { return [ ] grpc . dialoption { grpc . withunaryinterceptor ( unaryclientinterceptor ( log ) ) , grpc . withstreaminterceptor ( streamclientinterceptor ( log ) ) , } } 
func unaryserverinterceptor ( log ttnlog . interface ) grpc . unaryserverinterceptor { return func ( ctx context . context , req interface { } , info * grpc . unaryserverinfo , handler grpc . unaryhandler ) ( resp interface { } , err error ) { log : = getlog ( log ) . withfield ( " " , info . fullmethod ) log = log . withfields ( fieldsfromincomingcontext ( ctx ) ) start : = time . now ( ) resp , err = handler ( ctx , req ) log = log . withfield ( " " , time . since ( start ) ) if err ! = nil { log . witherror ( err ) . debug ( " " ) return } log . debug ( " " ) return } } 
func streamserverinterceptor ( log ttnlog . interface ) grpc . streamserverinterceptor { return func ( srv interface { } , ss grpc . serverstream , info * grpc . streamserverinfo , handler grpc . streamhandler ) ( err error ) { log : = getlog ( log ) . withfield ( " " , info . fullmethod ) log = log . withfields ( fieldsfromincomingcontext ( ss . context ( ) ) ) start : = time . now ( ) log . debug ( " " ) err = handler ( srv , ss ) log = log . withfield ( " " , time . since ( start ) ) if err ! = nil { if err == context . canceled | | grpc . code ( err ) == codes . canceled { log . debug ( " " ) return } log . witherror ( err ) . debug ( " " ) return } log . debug ( " " ) return } } 
func unaryclientinterceptor ( log ttnlog . interface ) grpc . unaryclientinterceptor { return func ( ctx context . context , method string , req , reply interface { } , cc * grpc . clientconn , invoker grpc . unaryinvoker , opts ... grpc . calloption ) ( err error ) { log : = getlog ( log ) . withfield ( " " , method ) log = log . withfields ( fieldsfromoutgoingcontext ( ctx ) ) start : = time . now ( ) err = invoker ( ctx , method , req , reply , cc , opts ... ) log = log . withfield ( " " , time . since ( start ) ) if err ! = nil { log . witherror ( err ) . debug ( " " ) return } log . debug ( " " ) return } } 
func streamclientinterceptor ( log ttnlog . interface ) grpc . streamclientinterceptor { return func ( ctx context . context , desc * grpc . streamdesc , cc * grpc . clientconn , method string , streamer grpc . streamer , opts ... grpc . calloption ) ( stream grpc . clientstream , err error ) { log : = getlog ( log ) . withfield ( " " , method ) log = log . withfields ( fieldsfromoutgoingcontext ( ctx ) ) log . debug ( " " ) stream , err = streamer ( ctx , desc , cc , method , opts ... ) if err ! = nil { if err == context . canceled | | grpc . code ( err ) == codes . canceled { log . debug ( " " ) return } log . witherror ( err ) . debug ( " " ) return } go func ( ) { < - stream . context ( ) . done ( ) if err : = stream . context ( ) . err ( ) ; err ! = nil { log = log . witherror ( err ) } log . debug ( " " ) } ( ) return } } 
func ( c * config ) defaults ( ) { if c . buffersize == 0 { c . buffersize = 100 } if c . prefix == " " { c . prefix = " " } } 
func ( h * handler ) flush ( ) { h . mu . lock ( ) defer h . mu . unlock ( ) if h . batch ! = nil { go h . flush ( h . batch ) h . batch = nil } } 
func ( h * handler ) handlelog ( e * log . entry ) error { color : = colors [ e . level ] level : = strings [ e . level ] var fields [ ] field for k , v : = range e . fields { fields = append ( fields , field { k , v } ) } sort . sort ( byname ( fields ) ) h . mu . lock ( ) defer h . mu . unlock ( ) if h . usecolor { fmt . fprintf ( h . writer , " \ 033 \ 033 " , color , level , e . message ) } else { fmt . fprintf ( h . writer , " " , level , e . message ) } for , f : = range fields { var value interface { } switch t : = f . value . ( type ) { case [ ] byte : value = fmt . sprintf ( " " , t ) case [ 21 ] byte : value = fmt . sprintf ( " " , t [ 0 ] , t [ 1 : 9 ] , t [ 9 : 17 ] , t [ 17 : ] ) default : value = f . value } if h . usecolor { fmt . fprintf ( h . writer , " \ 033 \ 033 " , color , f . name , value ) } else { fmt . fprintf ( h . writer , " " , f . name , value ) } } fmt . fprintln ( h . writer ) return nil } 
func new ( seed int64 ) random . interface { return & ttnrandom { interface : & random . ttnrandom { source : rand . new ( rand . newsource ( seed ) ) , } , } } 
func ( self * uritemplate ) names ( ) [ ] string { names : = make ( [ ] string , 0 , len ( self . parts ) ) for , p : = range self . parts { if len ( p . raw ) > 0 | | len ( p . terms ) == 0 { continue } for , term : = range p . terms { names = append ( names , term . name ) } } return names } 
func newperfdatum ( label string , unit string , value float64 , thresholds ... float64 ) ( * perfdatum , error ) { datum : = new ( perfdatum ) datum . label = label datum . value = value datum . unit = unit if ! validunit ( unit ) { return nil , fmt . errorf ( " " , unit ) } if math . isinf ( value , 0 ) | | math . isnan ( value ) { return nil , fmt . errorf ( " " , value ) } if len ( thresholds ) >= 1 { datum . min = & thresholds [ 0 ] } if len ( thresholds ) >= 2 { datum . max = & thresholds [ 1 ] } if len ( thresholds ) >= 3 { datum . warn = & thresholds [ 2 ] } if len ( thresholds ) >= 4 { datum . crit = & thresholds [ 3 ] } return datum , nil } 
func isthresholdset ( t * float64 ) bool { switch { case t == nil : return false case math . isinf ( * t , 0 ) : return false case math . isnan ( * t ) : return false } return true } 
func ( p perfdatum ) string ( ) string { val : = fmtperffloat ( p . value ) value : = fmt . sprintf ( " " , p . label , val , p . unit ) value += fmt . sprintf ( " " , fmtthreshold ( p . warn ) , fmtthreshold ( p . crit ) ) value += fmt . sprintf ( " " , fmtthreshold ( p . min ) , fmtthreshold ( p . max ) ) return value } 
func renderperfdata ( perfdata [ ] perfdatum ) string { value : = " " if len ( perfdata ) == 0 { return value } value += " " for , datum : = range perfdata { value += fmt . sprintf ( " " , datum ) } return value } 
func exit ( status status , message string ) { fmt . printf ( " \n " , status , message ) os . exit ( int ( status ) ) } 
func newcheckwithoptions ( options checkoptions ) * check { c : = newcheck ( ) if options . statuspolicy ! = nil { c . statuspolicy = options . statuspolicy } return c } 
func ( c * check ) addresult ( status status , message string ) { var result result result . status = status result . message = message c . results = append ( c . results , result ) if ( * c . statuspolicy ) [ result . status ] > ( * c . statuspolicy ) [ c . status ] { c . status = result . status } } 
func ( c * check ) addresultf ( status status , format string , v ... interface { } ) { msg : = fmt . sprintf ( format , v ... ) c . addresult ( status , msg ) } 
func ( c * check ) addperfdatum ( label , unit string , value float64 , thresholds ... float64 ) error { datum , err : = newperfdatum ( label , unit , value , thresholds ... ) if err ! = nil { return err } c . perfdata = append ( c . perfdata , * datum ) return nil } 
func ( c check ) exitinfotext ( ) string { var importantmessages [ ] string for , result : = range c . results { if result . status == c . status { importantmessages = append ( importantmessages , result . message ) } } return strings . join ( importantmessages , messageseparator ) } 
func ( c check ) string ( ) string { value : = fmt . sprintf ( " " , c . status , c . exitinfotext ( ) ) value += renderperfdata ( c . perfdata ) return value } 
func ( c * check ) finish ( ) { if r : = recover ( ) ; r ! = nil { c . exitf ( critical , " " , r ) } if len ( c . results ) == 0 { c . addresult ( unknown , " " ) } fmt . println ( c ) os . exit ( int ( c . status ) ) } 
func ( c * check ) exitf ( status status , format string , v ... interface { } ) { info : = fmt . sprintf ( format , v ... ) c . addresult ( status , info ) c . finish ( ) } 
func ( c * check ) criticalf ( format string , v ... interface { } ) { c . exitf ( critical , format , v ... ) } 
func ( c * check ) unknownf ( format string , v ... interface { } ) { c . exitf ( unknown , format , v ... ) } 
func newdefaultstatuspolicy ( ) * statuspolicy { return & statuspolicy { ok : statusseverity ( ok ) , warning : statusseverity ( warning ) , critical : statusseverity ( critical ) , unknown : statusseverity ( unknown ) , } } 
func newouwcstatuspolicy ( ) * statuspolicy { pol , : = newstatuspolicy ( [ ] status { ok , unknown , warning , critical } ) return pol } 
func newstatuspolicy ( statuses [ ] status ) ( * statuspolicy , error ) { newpol : = make ( statuspolicy ) for i , status : = range statuses { newpol [ status ] = statusseverity ( i ) } defaultpol : = newdefaultstatuspolicy ( ) for status : = range * defaultpol { , ok : = newpol [ status ] if ! ok { return nil , fmt . errorf ( " " , status ) } } return & newpol , nil } 
func ( s status ) string ( ) string { switch s { case ok : return " " case warning : return " " case critical : return " " case unknown : return " " } panic ( " " ) } 
func parserange ( rangestr string ) ( * range , error ) { t : = & range { start : 0 , end : math . inf ( 1 ) , alertoninside : false , } rangestr = strings . trim ( rangestr , " \n " ) if rangestr [ 0 ] == ' @ ' { t . alertoninside = true rangestr = rangestr [ 1 : ] } endpos : = strings . index ( rangestr , " " ) if endpos > - 1 { if rangestr [ 0 ] == ' ~ ' { t . start = math . inf ( - 1 ) } else { min , err : = strconv . parsefloat ( rangestr [ 0 : endpos ] , 64 ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } t . start = min } rangestr = rangestr [ endpos + 1 : ] } if len ( rangestr ) > 0 { max , err : = strconv . parsefloat ( rangestr , 64 ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } t . end = max } if t . end < t . start { return nil , errors . new ( " " ) } return t , nil } 
func ( r * range ) check ( value float64 ) bool { if r . start <= value && value <= r . end { return r . alertoninside } return ! r . alertoninside } 
func ( r * range ) checkint ( val int ) bool { return r . check ( float64 ( val ) ) } 
func ( r * range ) checkuint64 ( val uint64 ) bool { return r . check ( float64 ( val ) ) } 
func newclient ( config * clientconfig ) ( * client , error ) { t : = & http . transport { tlsclientconfig : & tls . config { insecureskipverify : config . allowunverifiedssl , } , } httpclient : = & http . client { transport : t , } apipath , : = url . parse ( " " ) baseurl , err : = url . parse ( config . baseurl ) if err ! = nil { return nil , fmt . errorf ( " " , err . error ( ) ) } apiurl : = baseurl . resolvereference ( apipath ) return & client { httpclient : httpclient , apiurl : apiurl , authtoken : config . authtoken , } , nil } 
func ( c * client ) getkeymeta ( path string ) ( * keymeta , error ) { k : = & keymeta { } err : = c . get ( [ ] string { " " , " " , path } , nil , k ) return k , err } 
func ( c * client ) getkeysindirmeta ( path string ) ( [ ] keymeta , error ) { r : = & keymetalistcontents { } err : = c . get ( [ ] string { " " , " " , path } , nil , r ) if err ! = nil { return nil , err } return r . keys , nil } 
func ( c * client ) getkeycontent ( path string ) ( string , error ) { return c . rawget ( [ ] string { " " , " " , path } , nil , " " ) } 
func ( c * client ) getjobsummariesforproject ( projectname string ) ( [ ] jobsummary , error ) { joblist : = & jobsummarylist { } err : = c . get ( [ ] string { " " , projectname , " " } , nil , joblist ) return joblist . jobs , err } 
func ( c * client ) getjobsforproject ( projectname string ) ( [ ] jobdetail , error ) { joblist : = & jobdetaillist { } err : = c . get ( [ ] string { " " , " " } , map [ string ] string { " " : projectname } , joblist ) if err ! = nil { return nil , err } return joblist . jobs , nil } 
func ( c * client ) getjob ( id string ) ( * jobdetail , error ) { joblist : = & jobdetaillist { } err : = c . get ( [ ] string { " " , id } , nil , joblist ) if err ! = nil { return nil , err } return & joblist . jobs [ 0 ] , nil } 
func ( c * client ) createjob ( job * jobdetail ) ( * jobsummary , error ) { return c . importjob ( job , " " ) } 
func ( c * client ) createorupdatejob ( job * jobdetail ) ( * jobsummary , error ) { return c . importjob ( job , " " ) } 
func ( c * client ) deletejob ( id string ) error { return c . delete ( [ ] string { " " , id } ) } 
func ( r * jobimportresult ) jobsummary ( ) * jobsummary { return & jobsummary { id : r . id , name : r . name , groupname : r . groupname , projectname : r . projectname , } } 
func ( c * client ) getsysteminfo ( ) ( * systeminfo , error ) { sysinfo : = & systeminfo { } err : = c . get ( [ ] string { " " , " " } , nil , sysinfo ) return sysinfo , err } 
func ( ts * systemtimestamp ) datetime ( ) time . time { t , : = time . parse ( time . rfc3339 , ts . datetimestr ) return t } 
func ( c * client ) getallprojects ( ) ( [ ] projectsummary , error ) { p : = & projects { } err : = c . get ( [ ] string { " " } , nil , p ) return p . projects , err } 
func ( c * client ) getproject ( name string ) ( * project , error ) { p : = & project { } err : = c . get ( [ ] string { " " , name } , nil , p ) return p , err } 
func ( c * client ) createproject ( project * project ) ( * project , error ) { p : = & project { } err : = c . post ( [ ] string { " " } , nil , project , p ) return p , err } 
func ( c * client ) deleteproject ( name string ) error { return c . delete ( [ ] string { " " , name } ) } 
func ( c * client ) setprojectconfig ( projectname string , config projectconfig ) error { return c . put ( [ ] string { " " , projectname , " " } , config , nil , ) } 
func newclient ( username , password string ) * client { c : = newpbrestclient ( username , password , " " , " " , true ) return & client { username : c . username , password : c . password , client : c , } } 
func newclientbytoken ( token string ) * client { c : = newpbrestclientbytoken ( token , " " , " " , true ) return & client { token : c . token , client : c , } } 
func ( c * client ) setdepth ( depth int ) { c . client . depth = strconv . itoa ( depth ) } 
func ( c * client ) listdatacenters ( ) ( * datacenters , error ) { url : = dccolpath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & datacenters { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) createdatacenter ( dc datacenter ) ( * datacenter , error ) { url : = dccolpath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & datacenter { } err : = c . client . post ( url , dc , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getdatacenter ( dcid string ) ( * datacenter , error ) { url : = dcpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & datacenter { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) updatedatacenter ( dcid string , obj datacenterproperties ) ( * datacenter , error ) { url : = dcpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & datacenter { } err : = c . client . patch ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deletedatacenter ( dcid string ) ( * http . header , error ) { url : = dcpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } return ret , c . client . delete ( url , ret , http . statusaccepted ) } 
func ( c * client ) waittillprovisioned ( path string ) error { waitcount : = 300 for i : = 0 ; i < waitcount ; i ++ { request , err : = c . getrequeststatus ( path ) if err ! = nil { return err } if request . metadata . status == " " { return nil } time . sleep ( 1 * time . second ) i ++ } return fmt . errorf ( " " ) } 
func ( c * client ) listfirewallrules ( dcid string , serverid string , nicid string ) ( * firewallrules , error ) { url : = fwrulecolpath ( dcid , serverid , nicid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & firewallrules { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getfirewallrule ( dcid string , serverid string , nicid string , fwid string ) ( * firewallrule , error ) { url : = fwrulepath ( dcid , serverid , nicid , fwid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & firewallrule { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) createfirewallrule ( dcid string , serverid string , nicid string , fw firewallrule ) ( * firewallrule , error ) { url : = fwrulecolpath ( dcid , serverid , nicid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & firewallrule { } err : = c . client . post ( url , fw , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) updatefirewallrule ( dcid string , serverid string , nicid string , fwid string , obj firewallruleproperties ) ( * firewallrule , error ) { url : = fwrulepath ( dcid , serverid , nicid , fwid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & firewallrule { } err : = c . client . patch ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deletefirewallrule ( dcid string , serverid string , nicid string , fwid string ) ( * http . header , error ) { url : = fwrulepath ( dcid , serverid , nicid , fwid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func servercommandpath ( dcid , srvid , cmd string ) string { return serverpath ( dcid , srvid ) + slash ( cmd ) } 
func balnicpath ( dcid , lbalid , balnicid string ) string { return balniccolpath ( dcid , lbalid ) + slash ( balnicid ) } 
func servercdrompath ( dcid , srvid , cdid string ) string { return servercdromcolpath ( dcid , srvid ) + slash ( cdid ) } 
func servervolumepath ( dcid , srvid , volid string ) string { return servervolumecolpath ( dcid , srvid ) + slash ( volid ) } 
func nicpath ( dcid , srvid , nicid string ) string { return niccolpath ( dcid , srvid ) + slash ( nicid ) } 
func fwrulecolpath ( dcid , srvid , nicid string ) string { return nicpath ( dcid , srvid , nicid ) + slash ( " " ) } 
func fwrulepath ( dcid , srvid , nicid , fwruleid string ) string { return fwrulecolpath ( dcid , srvid , nicid ) + slash ( fwruleid ) } 
func umgroupsharepath ( grpid string , resourceid string ) string { return um ( ) + slash ( " " ) + slash ( grpid ) + slash ( " " ) + slash ( resourceid ) } 
func umgroupuserspath ( grpid string , usrid string ) string { return um ( ) + slash ( " " ) + slash ( grpid ) + slash ( " " ) + slash ( usrid ) } 
func umresourcestypepath ( restype string , resourceid string ) string { return um ( ) + slash ( " " ) + slash ( restype ) + slash ( resourceid ) } 
func ( c * client ) listloadbalancers ( dcid string ) ( * loadbalancers , error ) { url : = lbalcolpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & loadbalancers { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) createloadbalancer ( dcid string , request loadbalancer ) ( * loadbalancer , error ) { url : = lbalcolpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & loadbalancer { } err : = c . client . post ( url , request , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getloadbalancer ( dcid , lbalid string ) ( * loadbalancer , error ) { url : = lbalpath ( dcid , lbalid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & loadbalancer { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) updateloadbalancer ( dcid string , lbalid string , obj loadbalancerproperties ) ( * loadbalancer , error ) { url : = lbalpath ( dcid , lbalid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & loadbalancer { } err : = c . client . patch ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deleteloadbalancer ( dcid , lbalid string ) ( * http . header , error ) { url : = lbalpath ( dcid , lbalid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listbalancednics ( dcid , lbalid string ) ( * nics , error ) { url : = balniccolpath ( dcid , lbalid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & nics { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) associatenic ( dcid string , lbalid string , nicid string ) ( * nic , error ) { sm : = map [ string ] string { " " : nicid } url : = balniccolpath ( dcid , lbalid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & nic { } err : = c . client . post ( url , sm , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getbalancednic ( dcid , lbalid , balnicid string ) ( * nic , error ) { url : = balnicpath ( dcid , lbalid , balnicid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & nic { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) deletebalancednic ( dcid , lbalid , balnicid string ) ( * http . header , error ) { url : = balnicpath ( dcid , lbalid , balnicid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listlans ( dcid string ) ( * lans , error ) { url : = lancolpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & lans { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) createlan ( dcid string , request lan ) ( * lan , error ) { url : = lancolpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & lan { } err : = c . client . post ( url , request , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getlan ( dcid , lanid string ) ( * lan , error ) { url : = lanpath ( dcid , lanid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & lan { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) updatelan ( dcid string , lanid string , obj lanproperties ) ( * lan , error ) { url : = lanpath ( dcid , lanid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & lan { } err : = c . client . patch ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deletelan ( dcid , lanid string ) ( * http . header , error ) { url : = lanpath ( dcid , lanid ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listnics ( dcid , srvid string ) ( * nics , error ) { url : = niccolpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & nics { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) createnic ( dcid string , srvid string , nic nic ) ( * nic , error ) { url : = niccolpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & nic { } err : = c . client . post ( url , nic , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getnic ( dcid , srvid , nicid string ) ( * nic , error ) { url : = nicpath ( dcid , srvid , nicid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & nic { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) updatenic ( dcid string , srvid string , nicid string , obj nicproperties ) ( * nic , error ) { url : = nicpath ( dcid , srvid , nicid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & nic { } err : = c . client . patch ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deletenic ( dcid , srvid , nicid string ) ( * http . header , error ) { url : = nicpath ( dcid , srvid , nicid ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listsnapshots ( ) ( * snapshots , error ) { url : = snapshotcolpath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & snapshots { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getsnapshot ( snapshotid string ) ( * snapshot , error ) { url : = snapshotcolpath ( ) + slash ( snapshotid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & snapshot { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) deletesnapshot ( snapshotid string ) ( * http . header , error ) { url : = snapshotcolpath ( ) + slash ( snapshotid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) updatesnapshot ( snapshotid string , request snapshotproperties ) ( * snapshot , error ) { url : = snapshotcolpath ( ) + slash ( snapshotid ) ret : = & snapshot { } err : = c . client . patch ( url , request , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listipblocks ( ) ( * ipblocks , error ) { url : = ipblockcolpath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & ipblocks { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) reserveipblock ( request ipblock ) ( * ipblock , error ) { url : = ipblockcolpath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & ipblock { } err : = c . client . post ( url , request , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getipblock ( ipblockid string ) ( * ipblock , error ) { url : = ipblockpath ( ipblockid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & ipblock { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) updateipblock ( ipblockid string , props ipblockproperties ) ( * ipblock , error ) { url : = ipblockpath ( ipblockid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & ipblock { } err : = c . client . patch ( url , props , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) releaseipblock ( ipblockid string ) ( * http . header , error ) { url : = ipblockpath ( ipblockid ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listvolumes ( dcid string ) ( * volumes , error ) { url : = volumecolpath ( dcid ) + ' ?depth= ' + c . client . depth ret : = & volumes { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getvolume ( dcid string , volumeid string ) ( * volume , error ) { url : = volumepath ( dcid , volumeid ) + ' ?depth= ' + c . client . depth ret : = & volume { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) updatevolume ( dcid string , volid string , request volumeproperties ) ( * volume , error ) { url : = volumepath ( dcid , volid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & volume { } err : = c . client . patch ( url , request , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) createvolume ( dcid string , request volume ) ( * volume , error ) { url : = volumecolpath ( dcid ) + ' ?depth= ' + c . client . depth ret : = & volume { } err : = c . client . post ( url , request , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deletevolume ( dcid , volid string ) ( * http . header , error ) { url : = volumepath ( dcid , volid ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) createsnapshot ( dcid string , volid string , name string , description string ) ( * snapshot , error ) { path : = volumepath ( dcid , volid ) + " " data : = url . values { } data . set ( " " , name ) data . add ( " " , description ) ret : = & snapshot { } err : = c . client . post ( path , data , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) restoresnapshot ( dcid string , volid string , snapshotid string ) ( * http . header , error ) { path : = volumepath ( dcid , volid ) + " " data : = url . values { } data . set ( " " , snapshotid ) ret : = & http . header { } err : = c . client . post ( path , data , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listservers ( dcid string ) ( * servers , error ) { url : = servercolpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & servers { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) createserver ( dcid string , server server ) ( * server , error ) { url : = servercolpath ( dcid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & server { } err : = c . client . post ( url , server , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getserver ( dcid , srvid string ) ( * server , error ) { url : = serverpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & server { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) updateserver ( dcid string , srvid string , props serverproperties ) ( * server , error ) { url : = serverpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & server { } err : = c . client . patch ( url , props , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deleteserver ( dcid , srvid string ) ( * http . header , error ) { ret : = & http . header { } err : = c . client . delete ( serverpath ( dcid , srvid ) , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listattachedcdroms ( dcid , srvid string ) ( * images , error ) { url : = servercdromcolpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & images { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) attachcdrom ( dcid string , srvid string , cdid string ) ( * image , error ) { data : = struct { id string ' json : " id , omitempty " ' } { cdid , } url : = servercdromcolpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & image { } err : = c . client . post ( url , data , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getattachedcdrom ( dcid , srvid , cdid string ) ( * image , error ) { url : = servercdrompath ( dcid , srvid , cdid ) ret : = & image { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) detachcdrom ( dcid , srvid , cdid string ) ( * http . header , error ) { url : = servercdrompath ( dcid , srvid , cdid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listattachedvolumes ( dcid , srvid string ) ( * volumes , error ) { url : = servervolumecolpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & volumes { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) attachvolume ( dcid string , srvid string , volid string ) ( * volume , error ) { data : = struct { id string ' json : " id , omitempty " ' } { volid , } url : = servervolumecolpath ( dcid , srvid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & volume { } err : = c . client . post ( url , data , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) getattachedvolume ( dcid , srvid , volid string ) ( * volume , error ) { url : = servervolumepath ( dcid , srvid , volid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & volume { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) detachvolume ( dcid , srvid , volid string ) ( * http . header , error ) { url : = servervolumepath ( dcid , srvid , volid ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) startserver ( dcid , srvid string ) ( * http . header , error ) { url : = serverpath ( dcid , srvid ) + " " ret : = & http . header { } err : = c . client . post ( url , nil , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listlocations ( ) ( * locations , error ) { url : = locationcolpath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & locations { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getregionallocations ( regid string ) ( * locations , error ) { url : = locationregpath ( regid ) + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & locations { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getlocation ( locid string ) ( * location , error ) { url : = locationpath ( locid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & location { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getcontractresources ( ) ( * contractresources , error ) { url : = contractresourcepath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & contractresources { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) listimages ( ) ( * images , error ) { url : = imagecolpath ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & images { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getimage ( imageid string ) ( * image , error ) { url : = imagepath ( imageid ) ret : = & image { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) listgroups ( ) ( * groups , error ) { url : = umgroups ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & groups { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getgroup ( groupid string ) ( * group , error ) { url : = umgrouppath ( groupid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & group { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) creategroup ( grp group ) ( * group , error ) { url : = umgroups ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & group { } err : = c . client . post ( url , grp , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) updategroup ( groupid string , obj group ) ( * group , error ) { url : = umgrouppath ( groupid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & group { } err : = c . client . put ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deletegroup ( groupid string ) ( * http . header , error ) { url : = umgrouppath ( groupid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listshares ( grpid string ) ( * shares , error ) { url : = umgroupshares ( grpid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & shares { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getshare ( groupid string , resourceid string ) ( * share , error ) { url : = umgroupsharepath ( groupid , resourceid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & share { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) addshare ( groupid string , resourceid string , share share ) ( * share , error ) { url : = umgroupsharepath ( groupid , resourceid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & share { } err : = c . client . post ( url , share , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) updateshare ( groupid string , resourceid string , obj share ) ( * share , error ) { url : = umgroupsharepath ( groupid , resourceid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & share { } err : = c . client . put ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deleteshare ( groupid string , resourceid string ) ( * http . header , error ) { url : = umgroupsharepath ( groupid , resourceid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listgroupusers ( groupid string ) ( * users , error ) { url : = umgroupusers ( groupid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & users { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) addusertogroup ( groupid string , userid string ) ( * user , error ) { var usr user usr . id = userid url : = umgroupusers ( groupid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & user { } err : = c . client . post ( url , usr , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deleteuserfromgroup ( groupid string , userid string ) ( * http . header , error ) { url : = umgroupuserspath ( groupid , userid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listusers ( ) ( * users , error ) { url : = umusers ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & users { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getuser ( usrid string ) ( * user , error ) { url : = umuserspath ( usrid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & user { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) createuser ( usr user ) ( * user , error ) { url : = umusers ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & user { } err : = c . client . post ( url , usr , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) updateuser ( userid string , obj user ) ( * user , error ) { url : = umuserspath ( userid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & user { } err : = c . client . put ( url , obj , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) deleteuser ( userid string ) ( * http . header , error ) { url : = umuserspath ( userid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & http . header { } err : = c . client . delete ( url , ret , http . statusaccepted ) return ret , err } 
func ( c * client ) listresources ( ) ( * resources , error ) { url : = umresources ( ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & resources { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getresourcebytype ( resourcetype string , resourceid string ) ( * resource , error ) { url : = umresourcestypepath ( resourcetype , resourceid ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & resource { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) listresourcesbytype ( resourcetype string ) ( * resources , error ) { url : = umresourcestype ( resourcetype ) + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & resources { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) listrequests ( ) ( * requests , error ) { url : = " " + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & requests { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getrequest ( reqid string ) ( * request , error ) { url : = " " + reqid + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & request { } err : = c . client . get ( url , ret , http . statusok ) return ret , err } 
func ( c * client ) getrequeststatus ( path string ) ( * requeststatus , error ) { url : = path + ' ?depth= ' + c . client . depth + ' &pretty= ' + strconv . formatbool ( c . client . pretty ) ret : = & requeststatus { } err : = c . client . getrequeststatus ( url , ret , http . statusok ) return ret , err } 
func open ( path string , mode os . filemode ) ( * writer , error ) { var w writer w . path = path w . mode = mode err : = w . open ( ) return & w , err } 
func ( l * writer ) write ( p [ ] byte ) ( int , error ) { l . mutex . lock ( ) defer l . mutex . unlock ( ) inode , err : = l . checkinode ( ) if os . isnotexist ( err ) | | inode ! = l . inode { err = l . reopen ( ) if err ! = nil { return 0 , err } } return l . file . write ( p ) } 
func ( l * writer ) close ( ) error { l . mutex . lock ( ) defer l . mutex . unlock ( ) return l . file . close ( ) } 
func ( serialize * serializablemeta ) getserializableargument ( serializablemetainterface serializablemetainterface ) interface { } { if serialize . value . originalvalue ! = nil { return serialize . value . originalvalue } if res : = serializablemetainterface . getserializableargumentresource ( ) ; res ! = nil { value : = res . newstruct ( ) json . unmarshal ( [ ] byte ( serialize . value . serializedvalue ) , value ) return value } return nil } 
func boolvar ( p * bool , name string , value bool , usage string ) { environmentflags . boolvar ( p , name , value , usage ) } 
func bool ( name string , value bool , usage string ) * bool { return environmentflags . bool ( name , value , usage ) } 
func intvar ( p * int , name string , value int , usage string ) { environmentflags . intvar ( p , name , value , usage ) } 
func int ( name string , value int , usage string ) * int { return environmentflags . int ( name , value , usage ) } 
func int64var ( p * int64 , name string , value int64 , usage string ) { environmentflags . int64var ( p , name , value , usage ) } 
func int64 ( name string , value int64 , usage string ) * int64 { return environmentflags . int64 ( name , value , usage ) } 
func uintvar ( p * uint , name string , value uint , usage string ) { environmentflags . uintvar ( p , name , value , usage ) } 
func uint ( name string , value uint , usage string ) * uint { return environmentflags . uint ( name , value , usage ) } 
func uint64var ( p * uint64 , name string , value uint64 , usage string ) { environmentflags . uint64var ( p , name , value , usage ) } 
func uint64 ( name string , value uint64 , usage string ) * uint64 { return environmentflags . uint64 ( name , value , usage ) } 
func stringvar ( p * string , name string , value string , usage string ) { environmentflags . stringvar ( p , name , value , usage ) } 
func string ( name string , value string , usage string ) * string { return environmentflags . string ( name , value , usage ) } 
func float64var ( p * float64 , name string , value float64 , usage string ) { environmentflags . float64var ( p , name , value , usage ) } 
func float64 ( name string , value float64 , usage string ) * float64 { return environmentflags . float64 ( name , value , usage ) } 
func durationvar ( p * time . duration , name string , value time . duration , usage string ) { environmentflags . durationvar ( p , name , value , usage ) } 
func duration ( name string , value time . duration , usage string ) * time . duration { return environmentflags . duration ( name , value , usage ) } 
func parse ( ) { env : = os . environ ( ) args : = make ( [ ] string , 0 , len ( env ) ) for , value : = range env { if lookup ( value [ : strings . index ( value , " " ) ] ) == nil { continue } args = append ( args , fmt . sprintf ( " " , value ) ) } environmentflags . parse ( args ) } 
func writestringtofile ( text , path string ) error { f , err : = os . openfile ( path , os . o create | os . o wronly , 0644 ) defer f . close ( ) if err ! = nil { return err } f . writestring ( text ) return nil } 
func readfiletostring ( path string ) ( string , error ) { f , err : = os . open ( path ) if err ! = nil { return " " , err } defer f . close ( ) scanner : = bufio . newscanner ( f ) scanner . scan ( ) return scanner . text ( ) , nil } 
func linereader ( r io . reader ) ( < - chan string , error ) { return linereader ( func ( ) ( io . reader , func ( ) , error ) { return r , nil , nil } ) } 
func linereaderfrom ( path string ) ( < - chan string , error ) { return linereader ( func ( ) ( io . reader , func ( ) , error ) { if ! fileexists ( path ) { return nil , nil , nil } f , err : = os . open ( path ) if err ! = nil { return nil , nil , err } return f , func ( ) { f . close ( ) } , nil } ) } 
func fileexists ( filepath string ) bool { if , err : = os . stat ( filepath ) ; ! os . isnotexist ( err ) { return true } return false } 
func fileexistsinpath ( filename string ) bool { , err : = exec . lookpath ( filename ) return err == nil } 
func getpathparts ( path string ) ( dirpath , filename , abspath string ) { lookup , lookuperr : = exec . lookpath ( path ) if lookuperr == nil { path = lookup } abspath , = filepath . abs ( path ) dirpath = filepath . dir ( abspath ) filename = filepath . base ( abspath ) return } 
func getthispathparts ( ) ( dirpath , filename , abspath string ) { exefile , : = osext . executable ( ) return getpathparts ( exefile ) } 
func randomstring ( length int ) string { src : = rand . newsource ( time . now ( ) . unixnano ( ) ) b : = make ( [ ] byte , length ) for i , cache , remain : = length - 1 , src . int63 ( ) , letterindexmax ; i >= 0 ; { if remain == 0 { cache , remain = src . int63 ( ) , letterindexmax } if idx : = int ( cache & letterindexmask ) ; idx < len ( letterbytes ) { b [ i ] = letterbytes [ idx ] i -- } cache > >= letterindexbits remain -- } return string ( b ) } 
func parseaddress ( addr string ) ( proto string , path string , err error ) { m : = netaddrrx . findstringsubmatch ( addr ) if m == nil { return " " , " " , goof . withfield ( " " , addr , " " ) } return m [ 1 ] , m [ 2 ] , nil } 
func homedir ( ) string { if homedirset { return homedir } if user , err : = user . current ( ) ; err == nil { homedir = user . homedir } homedirset = true return homedir } 
func istcpportavailable ( port int ) bool { if port < mintcpport | | port > maxtcpport { return false } conn , err : = net . listen ( " " , fmt . sprintf ( " " , port ) ) if err ! = nil { return false } conn . close ( ) return true } 
func randomtcpport ( ) int { for i : = maxreservedtcpport ; i < maxtcpport ; i ++ { p : = tcpportrand . intn ( maxrandtcpport ) + maxreservedtcpport + 1 if istcpportavailable ( p ) { return p } } return - 1 } 
func ( c * cache ) collect ( in chan < - prometheus . metric ) { c . hitstotal . collect ( in ) c . refreshtotal . collect ( in ) c . missestotal . collect ( in ) } 
func ( c * cache ) describe ( in chan < - * prometheus . desc ) { c . hitstotal . describe ( in ) c . refreshtotal . describe ( in ) c . missestotal . describe ( in ) } 
func hashstring ( key string , numbuckets int ) int32 { k : = hash ( sum64 ( key ) , numbuckets ) return k } 
func ( sm * sessionmanager ) context ( ctx context . context , req * empty . empty ) ( * mnemosynerpc . contextresponse , error ) { md , ok : = metadata . fromincomingcontext ( ctx ) if ! ok { return nil , status . errorf ( codes . invalidargument , " " ) } if len ( md [ mnemosyne . accesstokenmetadatakey ] ) == 0 { return nil , status . errorf ( codes . invalidargument , " " ) } at : = md [ mnemosyne . accesstokenmetadatakey ] [ 0 ] res , err : = sm . get ( ctx , & mnemosynerpc . getrequest { accesstoken : at } ) if err ! = nil { return nil , err } return & mnemosynerpc . contextresponse { session : res . session , } , nil } 
func ( sm * sessionmanager ) collect ( in chan < - prometheus . metric ) { sm . cleanuperrorstotal . collect ( in ) } 
func ( sm * sessionmanager ) describe ( in chan < - * prometheus . desc ) { sm . cleanuperrorstotal . describe ( in ) } 
func ( s * session ) token ( ) ( * oauth2 . token , error ) { var ( err error expireat time . time ) if s . expireat ! = nil { expireat , err = ptypes . timestamp ( s . expireat ) if err ! = nil { return nil , err } } token : = & oauth2 . token { accesstoken : string ( s . accesstoken ) , expiry : expireat , } if s . bag ! = nil && len ( s . bag ) > 0 { token = token . withextra ( bagtourlvalues ( s . bag ) ) } return token , nil } 
func newdaemon ( opts * daemonopts ) ( * daemon , error ) { d : = & daemon { done : make ( chan struct { } ) , opts : opts , logger : opts . logger , serveroptions : opts . rpcoptions , rpclistener : opts . rpclistener , debuglistener : opts . debuglistener , } if err : = d . setpostgresconnectionparameters ( ) ; err ! = nil { return nil , err } if d . opts . sessionttl == 0 { d . opts . sessionttl = storage . defaultttl } if d . opts . sessionttc == 0 { d . opts . sessionttc = storage . defaultttc } if d . opts . storage == " " { d . opts . storage = storage . enginepostgres } if d . opts . postgrestable == " " { d . opts . postgrestable = " " } if d . opts . postgresschema == " " { d . opts . postgresschema = " " } return d , nil } 
func ( d * daemon ) close ( ) ( err error ) { d . done < - struct { } { } d . server . gracefulstop ( ) if d . postgres ! = nil { if err = d . postgres . close ( ) ; err ! = nil { return } } if d . debuglistener ! = nil { if err = d . debuglistener . close ( ) ; err ! = nil { return } } if d . tracercloser ! = nil { if err = d . tracercloser . close ( ) ; err ! = nil { return } } return nil } 
func newaccesstokencontext ( ctx context . context , at string ) context . context { return context . withvalue ( ctx , accesstokencontextkey , at ) } 
func accesstokenfromcontext ( ctx context . context ) ( string , bool ) { at , ok : = ctx . value ( accesstokencontextkey ) . ( string ) return at , ok } 
func randomaccesstoken ( ) ( string , error ) { buf , err : = generaterandombytes ( 128 ) if err ! = nil { return " " , err } hash : = make ( [ ] byte , 64 ) sha3 . shakesum256 ( hash , buf ) hash2 : = make ( [ ] byte , hex . encodedlen ( len ( hash ) ) ) hex . encode ( hash2 , hash ) return string ( hash2 ) , nil } 
func newoption ( w io . writer , eh flag . errorhandling ) ( o * option ) { o = & option { flagset : flag . newflagset ( commandname , eh ) , } o . flagset . setoutput ( w ) o . flagset . stringvar ( & o . file , " " , " " , " " ) o . flagset . stringvar ( & o . dic , " " , " " , " " ) o . flagset . stringvar ( & o . udic , " " , " " , " " ) o . flagset . stringvar ( & o . sysdic , " " , " " , " " ) o . flagset . stringvar ( & o . mode , " " , " " , " " ) return } 
func ( m * storage ) abandon ( a0 context . context , a1 string ) ( bool , error ) { ret : = m . called ( a0 , a1 ) var r0 bool if rf , ok : = ret . get ( 0 ) . ( func ( context . context , string ) bool ) ; ok { r0 = rf ( a0 , a1 ) } else { r0 = ret . get ( 0 ) . ( bool ) } var r1 error if rf , ok : = ret . get ( 1 ) . ( func ( context . context , string ) error ) ; ok { r1 = rf ( a0 , a1 ) } else { r1 = ret . error ( 1 ) } return r0 , r1 } 
func ( m * storage ) delete ( a0 context . context , a1 string , a2 string , a3 string , a4 * time . time , a5 * time . time ) ( int64 , error ) { ret : = m . called ( a0 , a1 , a2 , a3 , a4 , a5 ) var r0 int64 if rf , ok : = ret . get ( 0 ) . ( func ( context . context , string , string , string , * time . time , * time . time ) int64 ) ; ok { r0 = rf ( a0 , a1 , a2 , a3 , a4 , a5 ) } else { r0 = ret . get ( 0 ) . ( int64 ) } var r1 error if rf , ok : = ret . get ( 1 ) . ( func ( context . context , string , string , string , * time . time , * time . time ) error ) ; ok { r1 = rf ( a0 , a1 , a2 , a3 , a4 , a5 ) } else { r1 = ret . error ( 1 ) } return r0 , r1 } 
func ( m * storage ) setup ( ) error { ret : = m . called ( ) var r0 error if rf , ok : = ret . get ( 0 ) . ( func ( ) error ) ; ok { r0 = rf ( ) } else { r0 = ret . error ( 0 ) } return r0 } 
func ( m * storage ) start ( a0 context . context , a1 string , a2 string , a3 string , a4 string , a5 map [ string ] string ) ( * mnemosynerpc . session , error ) { ret : = m . called ( a0 , a1 , a2 , a3 , a4 , a5 ) var r0 * mnemosynerpc . session if rf , ok : = ret . get ( 0 ) . ( func ( context . context , string , string , string , string , map [ string ] string ) * mnemosynerpc . session ) ; ok { r0 = rf ( a0 , a1 , a2 , a3 , a4 , a5 ) } else { if ret . get ( 0 ) ! = nil { r0 = ret . get ( 0 ) . ( * mnemosynerpc . session ) } } var r1 error if rf , ok : = ret . get ( 1 ) . ( func ( context . context , string , string , string , string , map [ string ] string ) error ) ; ok { r1 = rf ( a0 , a1 , a2 , a3 , a4 , a5 ) } else { r1 = ret . error ( 1 ) } return r0 , r1 } 
func init ( opts opts ) ( logger * zap . logger , err error ) { var ( cfg zap . config options [ ] zap . option lvl zapcore . level ) switch opts . environment { case " " : cfg = zap . newproductionconfig ( ) case " " : cfg = newstackdriverconfig ( ) options = append ( options , zap . fields ( zap . object ( " " , & servicecontext { service : " " , version : opts . version , } ) ) ) case " " : cfg = zap . newdevelopmentconfig ( ) default : cfg = zap . newproductionconfig ( ) } if err = lvl . set ( opts . level ) ; err ! = nil { return nil , err } cfg . level . setlevel ( lvl ) logger , err = cfg . build ( options ... ) if err ! = nil { return nil , err } logger . info ( " " , zap . string ( " " , opts . environment ) ) return logger , nil } 
func newstackdriverconfig ( ) zap . config { return zap . config { level : zap . newatomiclevelat ( zap . infolevel ) , development : false , sampling : & zap . samplingconfig { initial : 100 , thereafter : 100 , } , encoding : encodername , encoderconfig : newstackdriverencoderconfig ( ) , outputpaths : [ ] string { " " } , erroroutputpaths : [ ] string { " " } , } } 
func ( sc servicecontext ) marshallogobject ( enc zapcore . objectencoder ) error { if sc . service == " " { return errors . new ( " " ) } enc . addstring ( " " , sc . service ) enc . addstring ( " " , sc . version ) return nil } 
func ( c context ) marshallogobject ( enc zapcore . objectencoder ) error { if c . httprequest ! = emptyhttprequest { enc . addobject ( " " , c . httprequest ) } if c . user ! = " " { enc . addstring ( " " , c . user ) } if c . reportlocation ! = emptyreportlocation { enc . addobject ( " " , c . reportlocation ) } return nil } 
func ( hr httprequest ) marshallogobject ( enc zapcore . objectencoder ) error { enc . addstring ( " " , hr . method ) enc . addstring ( " " , hr . url ) enc . addstring ( " " , hr . useragent ) enc . addstring ( " " , hr . referrer ) enc . addstring ( " " , hr . responsestatuscode ) enc . addstring ( " " , hr . remoteip ) return nil } 
func ( rl reportlocation ) marshallogobject ( enc zapcore . objectencoder ) error { enc . addstring ( " " , rl . filepath ) enc . addint ( " " , rl . linenumber ) enc . addstring ( " " , rl . functionname ) return nil } 
func load ( path string ) ( d * dic , err error ) { d = new ( dic ) r , err : = zip . openreader ( path ) if err ! = nil { return d , err } defer r . close ( ) for , f : = range r . file { if err = func ( ) error { rc , e : = f . open ( ) if e ! = nil { return e } defer rc . close ( ) switch f . name { case " " : if e = d . loadmorphdicpart ( rc ) ; e ! = nil { return e } case " " : if e = d . loadposdicpart ( rc ) ; e ! = nil { return e } case " " : if e = d . loadcontentdicpart ( rc ) ; e ! = nil { return e } case " " : if e = d . loadindexdicpart ( rc ) ; e ! = nil { return e } case " " : if e = d . loadconnectiondicpart ( rc ) ; e ! = nil { return e } case " " : if e = d . loadchardefdicpart ( rc ) ; e ! = nil { return e } case " " : if e = d . loadunkdicpart ( rc ) ; e ! = nil { return e } } return nil } ( ) ; err ! = nil { return } } return } 
func ( s * storage ) start ( ctx context . context , accesstoken , refreshtoken , sid , sc string , b map [ string ] string ) ( * mnemosynerpc . session , error ) { span , ctx : = opentracing . startspanfromcontext ( ctx , " " ) defer span . finish ( ) ent : = & sessionentity { accesstoken : accesstoken , refreshtoken : refreshtoken , subjectid : sid , subjectclient : sc , bag : model . bag ( b ) , } if err : = s . save ( ctx , ent ) ; err ! = nil { return nil , err } return ent . session ( ) } 
func ( s * storage ) get ( ctx context . context , accesstoken string ) ( * mnemosynerpc . session , error ) { span , ctx : = opentracing . startspanfromcontext ( ctx , " " ) defer span . finish ( ) var entity sessionentity start : = time . now ( ) labels : = prometheus . labels { " " : " " } err : = s . db . queryrowcontext ( ctx , s . queryget , accesstoken ) . scan ( & entity . refreshtoken , & entity . subjectid , & entity . subjectclient , & entity . bag , & entity . expireat , ) s . incqueries ( labels , start ) if err ! = nil { s . incerror ( labels ) if err == sql . errnorows { return nil , storage . errsessionnotfound } return nil , err } expireat , err : = ptypes . timestampproto ( entity . expireat ) if err ! = nil { return nil , err } return & mnemosynerpc . session { accesstoken : accesstoken , refreshtoken : entity . refreshtoken , subjectid : entity . subjectid , subjectclient : entity . subjectclient , bag : entity . bag , expireat : expireat , } , nil } 
func ( s * storage ) exists ( ctx context . context , accesstoken string ) ( exists bool , err error ) { span , ctx : = opentracing . startspanfromcontext ( ctx , " " ) defer span . finish ( ) start : = time . now ( ) labels : = prometheus . labels { " " : " " } err = s . db . queryrowcontext ( ctx , s . queryexists , accesstoken ) . scan ( & exists , ) s . incqueries ( labels , start ) if err ! = nil { s . incerror ( labels ) } return } 
func ( s * storage ) abandon ( ctx context . context , accesstoken string ) ( bool , error ) { span , ctx : = opentracing . startspanfromcontext ( ctx , " " ) defer span . finish ( ) start : = time . now ( ) labels : = prometheus . labels { " " : " " } result , err : = s . db . execcontext ( ctx , s . queryabandon , accesstoken ) s . incqueries ( labels , start ) if err ! = nil { s . incerror ( labels ) return false , err } affected , err : = result . rowsaffected ( ) if err ! = nil { return false , err } if affected == 0 { return false , storage . errsessionnotfound } return true , nil } 
func ( s * storage ) delete ( ctx context . context , subjectid , accesstoken , refreshtoken string , expiredatfrom , expiredatto * time . time ) ( int64 , error ) { span , ctx : = opentracing . startspanfromcontext ( ctx , " " ) defer span . finish ( ) where , args : = s . where ( subjectid , accesstoken , refreshtoken , expiredatfrom , expiredatto ) if where . len ( ) == 0 { return 0 , fmt . errorf ( " " , where . string ( ) ) } query : = " " + s . schema + " " + s . table + " " + where . string ( ) labels : = prometheus . labels { " " : " " } start : = time . now ( ) result , err : = s . db . exec ( query , args ... ) s . incqueries ( labels , start ) if err ! = nil { s . incerror ( labels ) return 0 , err } return result . rowsaffected ( ) } 
func ( s * storage ) setup ( ) error { query : = fmt . sprintf ( , s . schema , s . schema , s . table , int64 ( s . ttl . seconds ( ) ) , s . schema , s . table , s . schema , s . table , s . schema , s . table , ) , err : = s . db . exec ( query ) return err } 
func ( s * storage ) teardown ( ) error { , err : = s . db . exec ( ' drop schema if exists ' + s . schema + ' cascade ' ) return err } 
func ( s * storage ) collect ( in chan < - prometheus . metric ) { s . connections . set ( float64 ( s . db . stats ( ) . openconnections ) ) s . connections . collect ( in ) s . queriestotal . collect ( in ) s . queriesduration . collect ( in ) s . errors . collect ( in ) } 
func ( s * storage ) describe ( in chan < - * prometheus . desc ) { s . connections . describe ( in ) s . queriestotal . describe ( in ) s . queriesduration . describe ( in ) s . errors . describe ( in ) } 
func initjaeger ( service , node , agentaddress string , log * zap . logger ) ( opentracing . tracer , io . closer , error ) { cfg : = & config . configuration { sampler : & config . samplerconfig { type : " " , param : 1 , } , tags : [ ] opentracing . tag { { key : constant . subsystem + " " , value : node , } } , reporter : & config . reporterconfig { logspans : true , localagenthostport : agentaddress , } , } tracer , closer , err : = cfg . new ( service , config . logger ( zapjaeger . newlogger ( log ) ) ) if err ! = nil { return nil , nil , err } return tracer , closer , nil } 
func usage ( ) { fmt . fprintf ( errorwriter , " \n " ) fmt . fprintf ( errorwriter , " \n " , path . base ( os . args [ 0 ] ) ) } 
func build ( keywords [ ] string ) ( doublearray , error ) { s : = len ( keywords ) if s == 0 { return doublearray { } , nil } ids : = make ( [ ] int , s , s ) for i : = range ids { ids [ i ] = i + 1 } return buildwithids ( keywords , ids ) } 
func read ( r io . reader ) ( doublearray , error ) { var sz int64 if e : = binary . read ( r , binary . littleendian , & sz ) ; e ! = nil { return doublearray { } , e } d : = make ( doublearray , sz , sz ) for i : = range d { if e : = binary . read ( r , binary . littleendian , & d [ i ] . base ) ; e ! = nil { return d , e } if e : = binary . read ( r , binary . littleendian , & d [ i ] . check ) ; e ! = nil { return d , e } } return d , nil } 
func ( m * instrumentedstorage ) get ( a0 context . context , a1 string ) ( * mnemosynerpc . session , error ) { ret : = m . called ( a0 , a1 ) var r0 * mnemosynerpc . session if rf , ok : = ret . get ( 0 ) . ( func ( context . context , string ) * mnemosynerpc . session ) ; ok { r0 = rf ( a0 , a1 ) } else { if ret . get ( 0 ) ! = nil { r0 = ret . get ( 0 ) . ( * mnemosynerpc . session ) } } var r1 error if rf , ok : = ret . get ( 1 ) . ( func ( context . context , string ) error ) ; ok { r1 = rf ( a0 , a1 ) } else { r1 = ret . error ( 1 ) } return r0 , r1 } 
func ( m * instrumentedstorage ) list ( a0 context . context , a1 int64 , a2 int64 , a3 * time . time , a4 * time . time ) ( [ ] * mnemosynerpc . session , error ) { ret : = m . called ( a0 , a1 , a2 , a3 , a4 ) var r0 [ ] * mnemosynerpc . session if rf , ok : = ret . get ( 0 ) . ( func ( context . context , int64 , int64 , * time . time , * time . time ) [ ] * mnemosynerpc . session ) ; ok { r0 = rf ( a0 , a1 , a2 , a3 , a4 ) } else { if ret . get ( 0 ) ! = nil { r0 = ret . get ( 0 ) . ( [ ] * mnemosynerpc . session ) } } var r1 error if rf , ok : = ret . get ( 1 ) . ( func ( context . context , int64 , int64 , * time . time , * time . time ) error ) ; ok { r1 = rf ( a0 , a1 , a2 , a3 , a4 ) } else { r1 = ret . error ( 1 ) } return r0 , r1 } 
func ( m * instrumentedstorage ) setvalue ( a0 context . context , a1 string , a2 string , a3 string ) ( map [ string ] string , error ) { ret : = m . called ( a0 , a1 , a2 , a3 ) var r0 map [ string ] string if rf , ok : = ret . get ( 0 ) . ( func ( context . context , string , string , string ) map [ string ] string ) ; ok { r0 = rf ( a0 , a1 , a2 , a3 ) } else { if ret . get ( 0 ) ! = nil { r0 = ret . get ( 0 ) . ( map [ string ] string ) } } var r1 error if rf , ok : = ret . get ( 1 ) . ( func ( context . context , string , string , string ) error ) ; ok { r1 = rf ( a0 , a1 , a2 , a3 ) } else { r1 = ret . error ( 1 ) } return r0 , r1 } 
func ( c * cluster ) get ( k int32 ) ( * node , bool ) { if len ( c . nodes ) == 0 { return nil , false } if len ( c . nodes ) - 1 < int ( k ) { return nil , false } return c . nodes [ k ] , true } 
func ( c * cluster ) externalnodes ( ) ( res [ ] * node ) { for , n : = range c . nodes { if n . addr ! = c . listen { res = append ( res , n ) } } return } 
func ( c * cluster ) getother ( accesstoken string ) ( * node , bool ) { if c == nil { return nil , false } if c . len ( ) == 1 { return nil , false } if node , ok : = c . get ( jump . hashstring ( accesstoken , c . len ( ) ) ) ; ok { if node . addr ! = c . listen { if node . client ! = nil { return node , true } } } return nil , false } 
func ( c * cluster ) gostring ( ) string { buf , : = json . marshal ( map [ string ] interface { } { " " : c . listen , " " : c . nodes , " " : strconv . formatint ( int64 ( c . buckets ) , 10 ) , } ) return string ( buf ) } 
func ( b * bag ) scan ( src interface { } ) ( err error ) { switch t : = src . ( type ) { case [ ] byte : err = gob . newdecoder ( bytes . newreader ( t ) ) . decode ( b ) default : return errors . new ( " " ) } return } 
func ( b bag ) value ( ) ( driver . value , error ) { buf : = bytes . newbuffer ( nil ) err : = gob . newencoder ( buf ) . encode ( b ) if err ! = nil { return nil , err } return buf . bytes ( ) , nil } 
func ( b * bag ) has ( key string ) bool { , ok : = ( * b ) [ key ] return ok } 
func newoption ( w io . writer , eh flag . errorhandling ) ( o * option ) { o = & option { flagset : flag . newflagset ( commandname , eh ) , } o . flagset . stringvar ( & o . http , " " , " " , " " ) o . flagset . stringvar ( & o . udic , " " , " " , " " ) o . flagset . stringvar ( & o . sysdic , " " , " " , " " ) return } 
func ( idx indextable ) writeto ( w io . writer ) ( n int64 , err error ) { n , err = idx . da . writeto ( w ) var b bytes . buffer enc : = gob . newencoder ( & b ) if err = enc . encode ( idx . dup ) ; err ! = nil { return } x , err : = b . writeto ( w ) if err ! = nil { return } n += x return } 
func readindextable ( r io . reader ) ( indextable , error ) { idx : = indextable { } d , err : = da . read ( r ) if err ! = nil { return idx , fmt . errorf ( " " , err ) } idx . da = d dec : = gob . newdecoder ( r ) if e : = dec . decode ( & idx . dup ) ; e ! = nil { return idx , fmt . errorf ( " " , e ) } return idx , nil } 
func new ( admin * admin . admin ) * actionbar { bar : = & actionbar { admin : admin } ctr : = & controller { actionbar : bar } admin . getrouter ( ) . get ( " " , ctr . switchmode ) admin . getrouter ( ) . get ( " " , ctr . inlineedit ) return bar } 
func ( bar * actionbar ) registeraction ( action actioninterface ) { bar . globalactions = append ( bar . globalactions , action ) bar . actions = bar . globalactions } 
func ( bar * actionbar ) actions ( actions ... actioninterface ) * actionbar { newbar : = & actionbar { admin : bar . admin , actions : bar . globalactions } newbar . actions = append ( newbar . actions , actions ... ) return newbar } 
func ( bar * actionbar ) render ( w http . responsewriter , r * http . request ) template . html { var ( actions , inlineactions [ ] actioninterface context = bar . admin . newcontext ( w , r ) ) for , action : = range bar . actions { if action . inlineaction ( ) { inlineactions = append ( inlineactions , action ) } else { actions = append ( actions , action ) } } context . context . currentuser = bar . admin . auth . getcurrentuser ( context ) result : = map [ string ] interface { } { " " : bar . editmode ( w , r ) , " " : bar . admin . auth , " " : context . context . currentuser , " " : actions , " " : inlineactions , " " : bar . admin . getrouter ( ) . prefix , } return context . render ( " " , result ) } 
func ( bar * actionbar ) funcmap ( w http . responsewriter , r * http . request ) template . funcmap { funcmap : = template . funcmap { } funcmap [ " " ] = func ( value interface { } , resources ... * admin . resource ) template . html { return bar . rendereditbuttonwithresource ( w , r , value , resources ... ) } return funcmap } 
func ( bar * actionbar ) editmode ( w http . responsewriter , r * http . request ) bool { return iseditmode ( bar . admin . newcontext ( w , r ) ) } 
func ( controller ) switchmode ( context * admin . context ) { utils . setcookie ( http . cookie { name : " " , value : context . request . url . query ( ) . get ( " " ) } , context . context ) referrer : = context . request . referer ( ) if referrer == " " { referrer = " " } http . redirect ( context . writer , context . request , referrer , http . statusfound ) } 
func ( controller ) inlineedit ( context * admin . context ) { context . writer . write ( [ ] byte ( context . render ( " " ) ) ) } 
func ( e * error ) error ( ) string { return fmt . sprintf ( " " , e . filename , e . linenum , e . msg ) } 
func parsefile ( filename string ) ( [ ] * machine , macros , error ) { fd , err : = os . open ( filename ) if err ! = nil { return nil , nil , err } defer fd . close ( ) return parse ( fd , & filepos { filename , 1 } ) } 
func findmachine ( filename , name string ) ( * machine , error ) { mach , , err : = parsefile ( filename ) if err ! = nil { return nil , err } var def * machine for , m : = range mach { if m . name == name { return m , nil } if m . name == " " { def = m } } if def == nil { return nil , errors . new ( " " ) } return def , nil } 
func new ( initialisms map [ string ] bool ) ( * kace , error ) { ci : = initialisms if ci == nil { ci = map [ string ] bool { } } ci = sanitizeci ( ci ) t , err : = ktrie . newktrie ( ci ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } k : = & kace { t : t , } return k , nil } 
func ( k * kace ) camel ( s string ) string { return camelcase ( k . t , s , false ) } 
func ( k * kace ) pascal ( s string ) string { return camelcase ( k . t , s , true ) } 
func ( k * kace ) snake ( s string ) string { return delimitedcase ( s , snakedelim , false ) } 
func ( k * kace ) snakeupper ( s string ) string { return delimitedcase ( s , snakedelim , true ) } 
func ( k * kace ) kebab ( s string ) string { return delimitedcase ( s , kebabdelim , false ) } 
func ( k * kace ) kebabupper ( s string ) string { return delimitedcase ( s , kebabdelim , true ) } 
func ispathsafe ( s string ) error { u , err : = url . parse ( s ) if err ! = nil { return err } e , err : = url . pathunescape ( u . path ) if err ! = nil { return err } if strings . contains ( e , " " ) { return fmt . errorf ( errormessage ) } if ! whitelistpattern . matchstring ( e ) { return fmt . errorf ( errormessage ) } return nil } 
func ( noptracer ) done ( re * response , err error ) ( * response , error ) { return re , err } 
func ( t * writertracer ) start ( r * http . request ) { t . starttime = time . now ( ) . utc ( ) t . request . url = r . url . string ( ) t . request . method = r . method } 
func ( t * writertracer ) done ( re * response , err error ) ( * response , error ) { t . endtime = time . now ( ) . utc ( ) if err ! = nil { fmt . fprintf ( t , " " , t . endtime . sub ( t . starttime ) , t . request . method , t . request . url , err ) return re , err } fmt . fprintf ( t , " " , t . endtime . sub ( t . starttime ) , t . request . method , t . request . url , re . code ( ) ) return re , err } 
func tracer ( newtracer newtracer ) clientparam { return func ( c * client ) error { c . newtracer = newtracer return nil } } 
func sanitizerenabled ( sanitizerenabled bool ) clientparam { return func ( c * client ) error { c . sanitizerenabled = sanitizerenabled return nil } } 
func ( c * client ) endpoint ( params ... string ) string { if c . v ! = " " { return fmt . sprintf ( " " , c . addr , c . v , strings . join ( params , " " ) ) } return fmt . sprintf ( " " , c . addr , strings . join ( params , " " ) ) } 
func ( c * client ) postjson ( ctx context . context , endpoint string , data interface { } ) ( * response , error ) { if c . sanitizerenabled { err : = ispathsafe ( endpoint ) if err ! = nil { return nil , err } } tracer : = c . newtracer ( ) return tracer . done ( c . roundtrip ( func ( ) ( * http . response , error ) { data , err : = json . marshal ( data ) req , err : = http . newrequest ( http . methodpost , endpoint , bytes . newbuffer ( data ) ) if err ! = nil { return nil , err } req = req . withcontext ( ctx ) req . header . set ( " " , " " ) c . addauth ( req ) tracer . start ( req ) return c . client . do ( req ) } ) ) } 
func ( c * client ) delete ( ctx context . context , endpoint string ) ( * response , error ) { if c . sanitizerenabled { err : = ispathsafe ( endpoint ) if err ! = nil { return nil , err } } tracer : = c . newtracer ( ) return tracer . done ( c . roundtrip ( func ( ) ( * http . response , error ) { req , err : = http . newrequest ( http . methoddelete , endpoint , nil ) if err ! = nil { return nil , err } req = req . withcontext ( ctx ) c . addauth ( req ) tracer . start ( req ) return c . client . do ( req ) } ) ) } 
func ( c * client ) deletewithparams ( ctx context . context , endpoint string , params url . values ) ( * response , error ) { baseurl , err : = url . parse ( endpoint ) if err ! = nil { return nil , err } baseurl . rawquery = params . encode ( ) return c . delete ( ctx , baseurl . string ( ) ) } 
func ( c * client ) get ( ctx context . context , endpoint string , params url . values ) ( * response , error ) { if c . sanitizerenabled { err : = ispathsafe ( endpoint ) if err ! = nil { return nil , err } } baseurl , err : = url . parse ( endpoint ) if err ! = nil { return nil , err } baseurl . rawquery = params . encode ( ) tracer : = c . newtracer ( ) return tracer . done ( c . roundtrip ( func ( ) ( * http . response , error ) { req , err : = http . newrequest ( http . methodget , baseurl . string ( ) , nil ) if err ! = nil { return nil , err } req = req . withcontext ( ctx ) c . addauth ( req ) tracer . start ( req ) return c . client . do ( req ) } ) ) } 
func ( c * client ) getfile ( ctx context . context , endpoint string , params url . values ) ( * fileresponse , error ) { if c . sanitizerenabled { err : = ispathsafe ( endpoint ) if err ! = nil { return nil , err } } baseurl , err : = url . parse ( endpoint ) if err ! = nil { return nil , err } baseurl . rawquery = params . encode ( ) req , err : = http . newrequest ( http . methodget , baseurl . string ( ) , nil ) if err ! = nil { return nil , err } req = req . withcontext ( ctx ) c . addauth ( req ) tracer : = c . newtracer ( ) tracer . start ( req ) re , err : = c . client . do ( req ) if err ! = nil { tracer . done ( nil , err ) return nil , err } tracer . done ( & response { code : re . statuscode } , err ) return & fileresponse { code : re . statuscode , headers : re . header , body : re . body , } , nil } 
func ( c * client ) setauthheader ( h http . header ) { if c . auth ! = nil { h . set ( " " , c . auth . string ( ) ) } } 
func newbuffersfromfiles ( files [ ] file ) [ ] filebuffer { buffers : = make ( [ ] filebuffer , 0 , len ( files ) ) for , file : = range files { buffers = append ( buffers , newfilebuffer ( file ) ) } return buffers } 
func newfilebuffer ( file file ) filebuffer { buf : = & bytes . buffer { } return filebuffer { reader : io . teereader ( file . reader , buf ) , file : file , cache : buf , } } 
func ( r * filebuffer ) rewind ( ) { r . reader = io . multireader ( r . cache , r . file . reader ) } 
func ( o * booloption ) set ( s string ) error { err : = convertstring ( s , & o . value ) if err ! = nil { return err } o . source = " " o . defined = true return nil } 
func ( o * booloption ) writeanswer ( name string , value interface { } ) error { if v , ok : = value . ( bool ) ; ok { o . value = v o . defined = true o . source = " " return nil } return fmt . errorf ( " " , value , o . value , value ) } 
func ( o booloption ) string ( ) string { if stringifyvalue { return fmt . sprintf ( " " , o . value ) } return fmt . sprintf ( " " , o . source , o . defined , o . value ) } 
func ( o * mapbooloption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = booloption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listbooloption ) set ( value string ) error { val : = booloption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapbyteoption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = byteoption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listbyteoption ) set ( value string ) error { val : = byteoption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapcomplex128option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = complex128option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listcomplex128option ) set ( value string ) error { val : = complex128option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapcomplex64option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = complex64option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listcomplex64option ) set ( value string ) error { val : = complex64option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * maperroroption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = erroroption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listerroroption ) set ( value string ) error { val : = erroroption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapfloat32option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = float32option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listfloat32option ) set ( value string ) error { val : = float32option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapfloat64option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = float64option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listfloat64option ) set ( value string ) error { val : = float64option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapintoption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = intoption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listintoption ) set ( value string ) error { val : = intoption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapint16option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = int16option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listint16option ) set ( value string ) error { val : = int16option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapint32option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = int32option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listint32option ) set ( value string ) error { val : = int32option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapint64option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = int64option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listint64option ) set ( value string ) error { val : = int64option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapint8option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = int8option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listint8option ) set ( value string ) error { val : = int8option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapruneoption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = runeoption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listruneoption ) set ( value string ) error { val : = runeoption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapstringoption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = stringoption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * liststringoption ) set ( value string ) error { val : = stringoption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapuintoption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = uintoption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listuintoption ) set ( value string ) error { val : = uintoption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapuint16option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = uint16option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listuint16option ) set ( value string ) error { val : = uint16option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapuint32option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = uint32option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listuint32option ) set ( value string ) error { val : = uint32option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapuint64option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = uint64option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listuint64option ) set ( value string ) error { val : = uint64option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapuint8option ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = uint8option { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listuint8option ) set ( value string ) error { val : = uint8option { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * mapuintptroption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = uintptroption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listuintptroption ) set ( value string ) error { val : = uintptroption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func ( o * maprawtypeoption ) set ( value string ) error { parts : = stringmapregex . split ( value , 2 ) if len ( parts ) ! = 2 { return fmt . errorf ( " " , value ) } val : = rawtypeoption { } val . set ( parts [ 1 ] ) ( * o ) [ parts [ 0 ] ] = val return nil } 
func ( o * listrawtypeoption ) set ( value string ) error { val : = rawtypeoption { } val . set ( value ) * o = append ( * o , val ) return nil } 
func trigger ( description string ) ( incidentkey string , err error ) { return trigger ( description , " " , map [ string ] interface { } { } ) } 
func triggerincidentkey ( description string , key string ) ( incidentkey string , err error ) { return trigger ( description , key , map [ string ] interface { } { } ) } 
func triggerwithdetails ( description string , details map [ string ] interface { } ) ( incidentkey string , err error ) { return trigger ( description , " " , details ) } 
func triggerincidentkeywithdetails ( description string , key string , details map [ string ] interface { } ) ( incidentkey string , err error ) { return trigger ( description , key , details ) } 
func ( p * pager ) trigger ( description string ) ( incidentkey string , err error ) { return p . trigger ( description , " " , map [ string ] interface { } { } ) } 
func merge ( dst , src interface { } ) { m : = newmerger ( ) m . mergestructs ( reflect . valueof ( dst ) , reflect . valueof ( src ) ) } 
func ( m * merger ) setsource ( v reflect . value ) { if v . kind ( ) == reflect . ptr { v = v . elem ( ) } switch v . kind ( ) { case reflect . map : for , key : = range v . mapkeys ( ) { keyval : = v . mapindex ( key ) if keyval . kind ( ) == reflect . struct && keyval . fieldbyname ( " " ) . isvalid ( ) { newval : = reflect . new ( keyval . type ( ) ) newval . elem ( ) . set ( keyval ) m . setsource ( newval ) v . setmapindex ( key , newval . elem ( ) ) } } case reflect . struct : if v . canaddr ( ) { if option , ok : = v . addr ( ) . interface ( ) . ( option ) ; ok { if option . isdefined ( ) { option . setsource ( m . sourcefile ) } return } } for i : = 0 ; i < v . numfield ( ) ; i ++ { structfield : = v . type ( ) . field ( i ) if structfield . pkgpath ! = " " { continue } m . setsource ( v . field ( i ) ) } case reflect . array : fallthrough case reflect . slice : for i : = 0 ; i < v . len ( ) ; i ++ { m . setsource ( v . index ( i ) ) } } } 
func do ( d db , f func ( t tx ) error ) error { t , err : = d . txbegin ( ) if err ! = nil { return err } defer t . txfinish ( ) err = f ( t ) if err ! = nil { return err } return t . txcommit ( ) } 
func newfile ( filename string ) io . writer { if err , : = os . open ( filename ) ; err ! = nil { os . remove ( filename ) } file , : = os . create ( filename ) return file } 
func ( b * bench ) internalrun ( showprogress bool ) results . resultset { starttime : = time . now ( ) endtime : = starttime . add ( b . duration ) sem : = semaphore . newsemaphore ( b . threads , b . rampup ) out : = make ( chan results . result ) resultschan : = make ( chan [ ] results . result ) go handleresult ( showprogress , out , resultschan ) for run : = true ; run ; run = ( time . now ( ) . before ( endtime ) ) { sem . lock ( ) go dorequest ( b . request , b . timeout , sem , out ) } fmt . print ( " \n " ) for i : = sem . length ( ) ; i ! = 0 ; i = sem . length ( ) { time . sleep ( 200 * time . millisecond ) } fmt . println ( " " ) fmt . println ( " " ) close ( out ) return < - resultschan } 
func ( r row ) string ( ) string { rstr : = fmt . sprintf ( " \n " , r . starttime . utc ( ) ) rstr = fmt . sprintf ( " \n " , rstr , r . elapsedtime ) rstr = fmt . sprintf ( " \n " , rstr , r . threads ) rstr = fmt . sprintf ( " \n " , rstr , r . totalrequests ) rstr = fmt . sprintf ( " \n " , rstr , r . avgrequesttime ) rstr = fmt . sprintf ( " \n " , rstr , r . totalsuccess ) rstr = fmt . sprintf ( " \n " , rstr , r . totaltimeouts ) return fmt . sprintf ( " \n " , rstr , r . totalfailures ) } 
func ( t * tabularresults ) tabulate ( results [ ] resultset ) [ ] row { var rows [ ] row starttime : = time . unix ( 0 , 0 ) for , bucket : = range results { if len ( bucket ) > 0 { var elapsedtime time . duration if starttime == time . unix ( 0 , 0 ) { starttime = bucket [ 0 ] . timestamp } elapsedtime = bucket [ 0 ] . timestamp . sub ( starttime ) row : = row { starttime : bucket [ 0 ] . timestamp , elapsedtime : elapsedtime , threads : 0 , totalrequests : 0 , totalfailures : 0 , totalsuccess : 0 , totaltimeouts : 0 , avgrequesttime : 0 , } totalrequesttime : = 0 * time . second maxthreads : = 0 for , r : = range bucket { row . totalrequests ++ if r . error ! = nil { if , ok : = r . error . ( errors . timeout ) ; ok { row . totaltimeouts ++ } row . totalfailures ++ } else { row . totalsuccess ++ totalrequesttime += r . requesttime } if r . threads > maxthreads { maxthreads = r . threads row . threads = maxthreads } } if totalrequesttime ! = 0 && row . totalsuccess ! = 0 { avgtime : = int64 ( totalrequesttime ) / int64 ( row . totalsuccess ) row . avgrequesttime = time . duration ( avgtime ) } rows = append ( rows , row ) } } return rows } 
func amazonrequest ( ) error { resp , err : = http . get ( " " ) defer func ( response * http . response ) { if response ! = nil && response . body ! = nil { response . body . close ( ) } } ( resp ) if err ! = nil | | resp . statuscode ! = 200 { return err } return nil } 
func writetabulardata ( interval time . duration , r results . resultset , w io . writer ) { set : = r . reduce ( interval ) t : = results . tabularresults { } rows : = t . tabulate ( set ) for , row : = range rows { w . write ( [ ] byte ( row . string ( ) ) ) w . write ( [ ] byte ( " \n " ) ) } } 
func ( r resultset ) reduce ( interval time . duration ) [ ] resultset { sort . sort ( r ) start : = r [ 0 ] . timestamp end : = r [ len ( r ) - 1 ] . timestamp bucketcount : = getbucketcount ( start , end , interval ) buckets : = make ( [ ] resultset , bucketcount ) for , result : = range r { currentbucket : = getbucketnumber ( result . timestamp , start , end , interval , bucketcount ) buckets [ currentbucket ] = append ( buckets [ currentbucket ] , result ) } return buckets } 
func newsemaphore ( capacity int , rampup time . duration ) * semaphore { s : = semaphore { lockdone : make ( chan struct { } ) , locklock : make ( chan struct { } ) , rampup : rampup , } if rampup < 1 { s . s = make ( chan struct { } , capacity ) } else { s . s = make ( chan struct { } , 1 ) go s . rampupthreads ( capacity , rampup ) } s . resizeunlock ( ) return & s } 
func ( t * semaphore ) release ( ) { t . waitifresizing ( ) t . readmutex . rlock ( ) defer t . readmutex . runlock ( ) if len ( t . s ) == 0 { return } < - t . s } 
func ( t * semaphore ) resize ( capacity int ) { t . resizemutex . lock ( ) if capacity == cap ( t . s ) { t . resizemutex . unlock ( ) return } t . resizelock ( ) t . readmutex . lock ( ) defer t . resizeunlock ( ) defer t . resizemutex . unlock ( ) defer t . readmutex . unlock ( ) new : = make ( chan struct { } , capacity ) for n : = len ( t . s ) ; n ! = 0 ; n = len ( t . s ) { new < - < - t . s } t . s = new } 
func new ( showprogress bool , threads int , duration time . duration , rampup time . duration , timeout time . duration ) * bench { return & bench { showprogress : showprogress , threads : threads , duration : duration , rampup : rampup , timeout : timeout , } } 
func ( b * bench ) addoutput ( interval time . duration , writer io . writer , output output . outputfunc ) { o : = outputcontainer { interval : interval , writer : writer , function : output , } b . outputs = append ( b . outputs , o ) } 
func ( b * bench ) runbenchmarks ( r requestfunc ) { b . request = r results : = b . internalrun ( b . showprogress ) b . processresults ( results ) } 
func parsebool ( bytes [ ] byte ) ( ret bool , err error ) { if len ( bytes ) ! = 1 { err = asn1 . syntaxerror { msg : " " } return } switch bytes [ 0 ] { case 0 : ret = false case 0xff : ret = true default : err = asn1 . syntaxerror { msg : " " } } return } 
func checkinteger ( bytes [ ] byte ) error { if len ( bytes ) == 0 { return asn1 . structuralerror { msg : " " } } if len ( bytes ) == 1 { return nil } if ( bytes [ 0 ] == 0 && bytes [ 1 ] & 0x80 == 0 ) | | ( bytes [ 0 ] == 0xff && bytes [ 1 ] & 0x80 == 0x80 ) { return asn1 . structuralerror { msg : " " } } return nil } 
func parseint64 ( bytes [ ] byte ) ( ret int64 , err error ) { err = checkinteger ( bytes ) if err ! = nil { return } if len ( bytes ) > 8 { err = asn1 . structuralerror { msg : " " } return } for bytesread : = 0 ; bytesread < len ( bytes ) ; bytesread ++ { ret < <= 8 ret | = int64 ( bytes [ bytesread ] ) } ret < <= 64 - uint8 ( len ( bytes ) ) * 8 ret > >= 64 - uint8 ( len ( bytes ) ) * 8 return } 
func parseint32 ( bytes [ ] byte ) ( int32 , error ) { if err : = checkinteger ( bytes ) ; err ! = nil { return 0 , err } ret64 , err : = parseint64 ( bytes ) if err ! = nil { return 0 , err } if ret64 ! = int64 ( int32 ( ret64 ) ) { return 0 , asn1 . structuralerror { msg : " " } } return int32 ( ret64 ) , nil } 
func parsebigint ( bytes [ ] byte ) ( * big . int , error ) { if err : = checkinteger ( bytes ) ; err ! = nil { return nil , err } ret : = new ( big . int ) if len ( bytes ) > 0 && bytes [ 0 ] & 0x80 == 0x80 { notbytes : = make ( [ ] byte , len ( bytes ) ) for i : = range notbytes { notbytes [ i ] = ^ bytes [ i ] } ret . setbytes ( notbytes ) ret . add ( ret , bigone ) ret . neg ( ret ) return ret , nil } ret . setbytes ( bytes ) return ret , nil } 
func parsebitstring ( bytes [ ] byte ) ( ret asn1 . bitstring , err error ) { if len ( bytes ) == 0 { err = asn1 . syntaxerror { msg : " " } return } paddingbits : = int ( bytes [ 0 ] ) if paddingbits > 7 | | len ( bytes ) == 1 && paddingbits > 0 | | bytes [ len ( bytes ) - 1 ] & ( ( 1 < < bytes [ 0 ] ) - 1 ) ! = 0 { err = asn1 . syntaxerror { msg : " " } return } ret . bitlength = ( len ( bytes ) - 1 ) * 8 - paddingbits ret . bytes = bytes [ 1 : ] return } 
func parseobjectidentifier ( bytes [ ] byte ) ( s [ ] int , err error ) { if len ( bytes ) == 0 { err = asn1 . syntaxerror { msg : " " } return } s = make ( [ ] int , len ( bytes ) + 1 ) v , offset , err : = parsebase128int ( bytes , 0 ) if err ! = nil { return } if v < 80 { s [ 0 ] = v / 40 s [ 1 ] = v % 40 } else { s [ 0 ] = 2 s [ 1 ] = v - 80 } i : = 2 for ; offset < len ( bytes ) ; i ++ { v , offset , err = parsebase128int ( bytes , offset ) if err ! = nil { return } s [ i ] = v } s = s [ 0 : i ] return } 
func parsebase128int ( bytes [ ] byte , initoffset int ) ( ret , offset int , err error ) { ret , offset , err = parsebase128int ( bytes , initoffset ) if offset - initoffset >= 4 { err = asn1 . structuralerror { msg : " " } return } return } 
func parsegeneralizedtime ( bytes [ ] byte ) ( ret time . time , err error ) { const formatstr = " " s : = string ( bytes ) if ret , err = time . parse ( formatstr , s ) ; err ! = nil { return } if serialized : = ret . format ( formatstr ) ; serialized ! = s { err = fmt . errorf ( " " , s , serialized ) } return } 
func parseprintablestring ( bytes [ ] byte ) ( ret string , err error ) { for , b : = range bytes { if ! isprintable ( b ) { err = asn1 . syntaxerror { msg : " " } return } } ret = string ( bytes ) return } 
func isprintable ( b byte ) bool { return ' a ' <= b && b <= ' z ' | | ' a ' <= b && b <= ' z ' | | ' 0 ' <= b && b <= ' 9 ' | | ' \ ' ' <= b && b <= ' ) ' | | ' + ' <= b && b <= ' / ' | | b == ' ' | | b == ' : ' | | b == ' = ' | | b == ' ? ' | | b == ' * ' } 
func parseia5string ( bytes [ ] byte ) ( ret string , err error ) { for , b : = range bytes { if b >= utf8 . runeself { err = asn1 . syntaxerror { msg : " " } return } } ret = string ( bytes ) return } 
func parset61string ( bytes [ ] byte ) ( ret string , err error ) { return string ( bytes ) , nil } 
func parseutf8string ( bytes [ ] byte ) ( ret string , err error ) { if ! utf8 . valid ( bytes ) { return " " , errors . new ( " " ) } return string ( bytes ) , nil } 
func parsetagandlength ( bytes [ ] byte , initoffset int ) ( ret tagandlength , offset int , err error ) { offset = initoffset if offset >= len ( bytes ) { err = errors . new ( " " ) return } b : = bytes [ offset ] offset ++ ret . class = int ( b > > 6 ) ret . iscompound = b & 0x20 == 0x20 ret . tag = int ( b & 0x1f ) if ret . tag == 0x1f { ret . tag , offset , err = parsebase128int ( bytes , offset ) if err ! = nil { return } if ret . tag < 0x1f { err = asn1 . syntaxerror { msg : " " } return } } if offset >= len ( bytes ) { err = asn1 . syntaxerror { msg : " " } return } b = bytes [ offset ] offset ++ if b & 0x80 == 0 { ret . length = int ( b & 0x7f ) } else { numbytes : = int ( b & 0x7f ) if numbytes == 0 { err = asn1 . syntaxerror { msg : " " } return } ret . length = 0 for i : = 0 ; i < numbytes ; i ++ { if offset >= len ( bytes ) { err = asn1 . syntaxerror { msg : " " } return } b = bytes [ offset ] offset ++ if ret . length >= 1 < < 23 { err = asn1 . structuralerror { msg : " " } return } ret . length < <= 8 ret . length | = int ( b ) } } return } 
func parsesequenceof ( bytes [ ] byte , slicetype reflect . type , elemtype reflect . type ) ( ret reflect . value , err error ) { expectedtag , compoundtype , ok : = getuniversaltype ( elemtype ) if ! ok { err = asn1 . structuralerror { msg : " " } return } numelements : = 0 for offset : = 0 ; offset < len ( bytes ) ; { var t tagandlength t , offset , err = parsetagandlength ( bytes , offset ) if err ! = nil { return } switch t . tag { case tagia5string , taggeneralstring , tagt61string , tagutf8string : t . tag = tagprintablestring case taggeneralizedtime , tagutctime : t . tag = tagutctime } if t . class ! = classuniversal | | t . iscompound ! = compoundtype | | t . tag ! = expectedtag { err = asn1 . structuralerror { msg : " " } return } if invalidlength ( offset , t . length , len ( bytes ) ) { err = asn1 . syntaxerror { msg : " " } return } offset += t . length numelements ++ } ret = reflect . makeslice ( slicetype , numelements , numelements ) params : = fieldparameters { } offset : = 0 for i : = 0 ; i < numelements ; i ++ { offset , err = parsefield ( ret . index ( i ) , bytes , offset , params ) if err ! = nil { return } } return } 
func invalidlength ( offset , length , slicelength int ) bool { return offset + length < offset | | offset + length > slicelength } 
func canhavedefaultvalue ( k reflect . kind ) bool { switch k { case reflect . int , reflect . int8 , reflect . int16 , reflect . int32 , reflect . int64 : return true } return false } 
func setdefaultvalue ( v reflect . value , params fieldparameters ) ( ok bool ) { if ! params . optional { return } ok = true if params . defaultvalue == nil { return } if canhavedefaultvalue ( v . kind ( ) ) { v . setint ( * params . defaultvalue ) } return } 
func unmarshal ( b [ ] byte , val interface { } ) ( rest [ ] byte , err error ) { return unmarshalwithparams ( b , val , " " ) } 
func unmarshalwithparams ( b [ ] byte , val interface { } , params string ) ( rest [ ] byte , err error ) { v : = reflect . valueof ( val ) . elem ( ) offset , err : = parsefield ( v , b , 0 , parsefieldparameters ( params ) ) if err ! = nil { return nil , err } return b [ offset : ] , nil } 
func parsefieldparameters ( str string ) ( ret fieldparameters ) { for , part : = range strings . split ( str , " " ) { switch { case part == " " : ret . optional = true case part == " " : ret . explicit = true if ret . tag == nil { ret . tag = new ( int ) } case part == " " : ret . timetype = taggeneralizedtime case part == " " : ret . timetype = tagutctime case part == " " : ret . stringtype = tagia5string case part == " " : ret . stringtype = tagprintablestring case part == " " : ret . stringtype = tagutf8string case strings . hasprefix ( part , " " ) : i , err : = strconv . parseint ( part [ 8 : ] , 10 , 64 ) if err == nil { ret . defaultvalue = new ( int64 ) * ret . defaultvalue = i } case strings . hasprefix ( part , " " ) : i , err : = strconv . atoi ( part [ 4 : ] ) if err == nil { ret . tag = new ( int ) * ret . tag = i } case part == " " : ret . set = true case part == " " : ret . application = true if ret . tag == nil { ret . tag = new ( int ) } case part == " " : ret . omitempty = true } } return } 
func getuniversaltype ( t reflect . type ) ( tagnumber int , iscompound , ok bool ) { switch t { case objectidentifiertype : return tagoid , false , true case bitstringtype : return tagbitstring , false , true case timetype : return tagutctime , false , true case enumeratedtype : return tagenum , false , true case biginttype : return taginteger , false , true } switch t . kind ( ) { case reflect . bool : return tagboolean , false , true case reflect . int , reflect . int8 , reflect . int16 , reflect . int32 , reflect . int64 : return taginteger , false , true case reflect . struct : return tagsequence , true , true case reflect . slice : if t . elem ( ) . kind ( ) == reflect . uint8 { return tagoctetstring , false , true } if strings . hassuffix ( t . name ( ) , " " ) { return tagset , true , true } return tagsequence , true , true case reflect . string : return tagprintablestring , false , true } return 0 , false , false } 
func decodestring ( raw string ) ( [ ] byte , error ) { pad : = 8 - ( len ( raw ) % 8 ) nb : = [ ] byte ( raw ) if pad ! = 8 { nb = make ( [ ] byte , len ( raw ) + pad ) copy ( nb , raw ) for i : = 0 ; i < pad ; i ++ { nb [ len ( raw ) + i ] = ' = ' } } return lowerbase32 . decodestring ( string ( nb ) ) } 
func ( m mongodb ) mailnotifier ( ctxt string ) ( models . mailnotifier , error ) { c : = m . connect ( models . coll name mail notifier ) defer m . close ( c ) var notifier [ ] models . mailnotifier if err : = c . find ( nil ) . all ( & notifier ) ; err ! = nil | | len ( notifier ) == 0 { logger . get ( ) . error ( " " , ctxt , err ) return models . mailnotifier { } , errmissingnotifier } else { return notifier [ 0 ] , nil } } 
func ( m mongodb ) savemailnotifier ( ctxt string , notifier models . mailnotifier ) error { c : = m . connect ( models . coll name mail notifier ) defer m . close ( c ) , err : = c . upsert ( bson . m { } , bson . m { " " : notifier } ) if err ! = nil { logger . get ( ) . error ( " " , ctxt , notifier . mailid , err ) return errors . new ( fmt . sprintf ( " " , notifier . mailid , err ) ) } return nil } 
func registerprovider ( name string , factory providersfactory ) { providersmutex . lock ( ) defer providersmutex . unlock ( ) if , found : = providers [ name ] ; found { logger . get ( ) . critical ( " " , name ) } providers [ name ] = factory } 
func initprovider ( name string , configfilepath string ) ( provisioner , error ) { var provider provisioner if name == " " { logger . get ( ) . info ( " " ) return nil , nil } var err error if configfilepath ! = " " { config , err : = os . open ( configfilepath ) if err ! = nil { logger . get ( ) . critical ( " " , configfilepath , err ) } defer config . close ( ) provider , err = getprovider ( name , config ) } else { provider , err = getprovider ( name , nil ) } if err ! = nil { return nil , fmt . errorf ( " " , name , err ) } if provider == nil { return nil , fmt . errorf ( " " , name ) } return provider , nil } 
func ( m mongodb ) initdb ( ) error { if err : = m . inituser ( ) ; err ! = nil { logger . get ( ) . error ( " " , err ) return err } return nil } 
func until ( f func ( ) , period time . duration , stopch < - chan struct { } ) { for { select { case < - stopch : return default : } func ( ) { defer handlecrash ( ) f ( ) } ( ) time . sleep ( period ) } } 
func logpanic ( r interface { } ) { callers : = " " for i : = 0 ; true ; i ++ { , file , line , ok : = runtime . caller ( i ) if ! ok { break } callers = callers + fmt . sprintf ( " \n " , file , line ) } logger . get ( ) . error ( " \n " , r , r , callers ) } 
func ( tsdbm graphitemanager ) pushtodb ( metrics map [ string ] map [ string ] string , hostname string , port int ) error { data : = make ( [ ] graphite . metric , 1 ) for tablename , valuemap : = range metrics { for timestamp , value : = range valuemap { timeint , err : = strconv . parseint ( timestamp , 10 , 64 ) if err ! = nil { return fmt . errorf ( " " , timestamp , tablename , err . error ( ) ) } data = append ( data , graphite . metric { name : tablename , value : value , timestamp : timeint } ) } } graphite , err : = graphite . newgraphite ( hostname , port ) if err ! = nil { return fmt . errorf ( " " , err ) } graphite . sendmetrics ( data ) if err : = graphite . disconnect ( ) ; err ! = nil { logger . get ( ) . warning ( " " , err ) } return nil } 
func initdbprovider ( name string , configfilepath string ) ( dbinterface , error ) { var dbprovider dbinterface if name == " " { logger . get ( ) . info ( " " ) return nil , nil } var err error if configfilepath ! = " " { config , err : = os . open ( configfilepath ) if err ! = nil { logger . get ( ) . critical ( " " , configfilepath , err ) } defer config . close ( ) dbprovider , err = getdbprovider ( name , config ) } else { dbprovider , err = getdbprovider ( name , nil ) } if err ! = nil { return nil , fmt . errorf ( " " , name , err ) } if dbprovider == nil { return nil , fmt . errorf ( " " , name ) } return dbprovider , nil } 
func ( m mongodb ) user ( username string ) ( user models . user , e error ) { c : = m . connect ( models . coll name user ) defer m . close ( c ) err : = c . find ( bson . m { " " : username } ) . one ( & user ) if err ! = nil { return user , errmissinguser } return user , nil } 
func ( m mongodb ) users ( filter interface { } ) ( us [ ] models . user , e error ) { c : = m . connect ( models . coll name user ) defer m . close ( c ) err : = c . find ( filter ) . all ( & us ) if err ! = nil { logger . get ( ) . error ( " " , err ) return us , mkmgoerror ( err . error ( ) ) } return us , nil } 
func ( m mongodb ) saveuser ( user models . user ) error { c : = m . connect ( models . coll name user ) defer m . close ( c ) , err : = c . upsert ( bson . m { " " : user . username } , bson . m { " " : user } ) if err ! = nil { logger . get ( ) . error ( " " , user . username , err ) return mkmgoerror ( err . error ( ) ) } return nil } 
func ( m mongodb ) deleteuser ( username string ) error { c : = m . connect ( models . coll name user ) defer m . close ( c ) err : = c . remove ( bson . m { " " : username } ) if err ! = nil { logger . get ( ) . error ( " " , username , err ) return mkmgoerror ( err . error ( ) ) } return err } 
func newtlsserver ( config tlsserverconfig ) * http . server { tlsconfig : = newtlsconfig ( config . tlsconfiglevel ) tlsconfig . clientauth = tls . requireandverifyclientcert tlsconfig . clientcas = config . certpool server : = & http . server { readtimeout : 5 * time . second , writetimeout : 10 * time . second , tlsconfig : tlsconfig , addr : fmt . sprintf ( " " , config . bindaddress , config . port ) , handler : config . router , } server . tlsconfig . buildnametocertificate ( ) return server } 
func loadcacertfile ( cert string ) ( * x509 . certpool , error ) { ca , err : = ioutil . readfile ( cert ) if err ! = nil { return nil , fmt . errorf ( " " , err . error ( ) ) } certpool : = x509 . newcertpool ( ) if err : = certpool . appendcertsfrompem ( ca ) ; ! err { return nil , errors . new ( " " ) } return certpool , nil } 
func newauth ( opts ... options ) * auth { o : = options { } if len ( opts ) ! = 0 { o = opts [ 0 ] } h : = defaultautherrorhandler if o . autherrorhandler ! = nil { h = o . autherrorhandler } return & auth { opt : o , autherrhandler : http . handlerfunc ( h ) , } } 
func ( a * auth ) validaterequest ( r * http . request ) error { if r . tls == nil | | r . tls . verifiedchains == nil { return errors . new ( " " ) } if r . tls . peercertificates ! = nil { if ! bytes . equal ( r . tls . peercertificates [ 0 ] . raw , r . tls . verifiedchains [ 0 ] [ 0 ] . raw ) { return errors . new ( " " ) } } return nil } 
func ( a * auth ) process ( w http . responsewriter , r * http . request ) error { if err : = a . validaterequest ( r ) ; err ! = nil { return err } if len ( a . opt . allowedous ) > 0 { err : = a . validateou ( r . tls . verifiedchains [ 0 ] [ 0 ] ) if err ! = nil { a . autherrhandler . servehttp ( w , r ) return err } } if len ( a . opt . allowedcns ) > 0 { err : = a . validatecn ( r . tls . verifiedchains [ 0 ] [ 0 ] ) if err ! = nil { a . autherrhandler . servehttp ( w , r ) return err } } return nil } 
func ( a * auth ) validatecn ( verifiedcert * x509 . certificate ) error { var failed [ ] string for , cn : = range a . opt . allowedcns { if cn == verifiedcert . subject . commonname { return nil } failed = append ( failed , verifiedcert . subject . commonname ) } return fmt . errorf ( " " , failed , a . opt . allowedcns ) } 
func ( a * auth ) validateou ( verifiedcert * x509 . certificate ) error { var failed [ ] string for , ou : = range a . opt . allowedous { for , clientou : = range verifiedcert . subject . organizationalunit { if ou == clientou { return nil } failed = append ( failed , clientou ) } } return fmt . errorf ( " " , failed , a . opt . allowedous ) } 
func keylen ( x uint64 ) int { n : = 1 if x >= 1 < < 32 { x > >= 32 n += 4 } if x >= 1 < < 16 { x > >= 16 n += 2 } if x >= 1 < < 8 { x > >= 8 n += 1 } return n } 
func ( c key ) put ( x uint64 ) { s : = uint ( 8 * ( len ( c ) - 1 ) ) for i : = range c { c [ i ] = byte ( x > > s ) s - = 8 } } 
func defaultconfig ( ) config { newclientconfig : = vaultclient . defaultconfig ( ) newclientconfig . address = " " newvaultclient , err : = vaultclient . newclient ( newclientconfig ) if err ! = nil { panic ( err ) } newconfig : = config { vaultclient : newvaultclient , } return newconfig } 
func new ( config config ) ( spec . certsigner , error ) { newcertsigner : = & certsigner { config : config , } if newcertsigner . vaultclient == nil { return nil , microerror . maskf ( invalidconfigerror , " " ) } return newcertsigner , nil } 
func computerolehash ( organizations string ) string { organizationsslice : = strings . split ( organizations , " " ) sort . strings ( organizationsslice ) organizations = strings . join ( organizationsslice , " " ) h : = sha1 . new ( ) h . write ( [ ] byte ( organizations ) ) bs : = h . sum ( nil ) return fmt . sprintf ( " " , bs ) } 
func new ( config config ) ( spec . vaultfactory , error ) { newvaultfactory : = & vaultfactory { config : config , } if newvaultfactory . address == " " { return nil , microerror . maskf ( invalidconfigerror , " " ) } if newvaultfactory . admintoken == " " { return nil , microerror . maskf ( invalidconfigerror , " " ) } return newvaultfactory , nil } 
func defaultserviceconfig ( ) serviceconfig { newclientconfig : = vaultclient . defaultconfig ( ) newclientconfig . address = " " newvaultclient , err : = vaultclient . newclient ( newclientconfig ) if err ! = nil { panic ( err ) } newconfig : = serviceconfig { vaultclient : newvaultclient , } return newconfig } 
func newservice ( config serviceconfig ) ( service , error ) { if config . vaultclient == nil { return nil , microerror . maskf ( invalidconfigerror , " " ) } newservice : = & service { serviceconfig : config , } return newservice , nil } 
func isnovaulthandlerdefined ( err error ) bool { cause : = microerror . cause ( err ) if cause ! = nil && strings . contains ( cause . error ( ) , " " ) { return true } return false } 
func new ( config config ) ( service , error ) { if config . vaultclient == nil { return nil , microerror . maskf ( invalidconfigerror , " " ) } if config . pkimountpoint == " " { return nil , microerror . maskf ( invalidconfigerror , " " ) } service : = & service { vaultclient : config . vaultclient , pkimountpoint : config . pkimountpoint , } return service , nil } 
func ( s * service ) create ( params createparams ) error { logicalstore : = s . vaultclient . logical ( ) data : = map [ string ] interface { } { " " : params . alloweddomains , " " : params . allowsubdomains , " " : params . ttl , " " : params . allowbaredomains , " " : params . organizations , } , err : = logicalstore . write ( fmt . sprintf ( " " , s . pkimountpoint , params . name ) , data ) if err ! = nil { return microerror . mask ( err ) } return nil } 
func createjob ( ) config { return config { lockprovider : nil , runtimeprocessor : nil , resultprocessor : nil , runtimeprocessingfrequency : 200 * time . millisecond , summarybuffer : 1 , } } 
func ( config * config ) run ( ) { err : = config . ensurelock ( ) if err ! = nil { panic ( err ) } err = config . runworker ( ) if err ! = nil { panic ( err ) } } 
func newwatcher ( dir notify bool , initpaths ... string ) ( w * watcher ) { w = new ( watcher ) w . auto watch = dir notify w . paths = make ( map [ string ] * watchitem , 0 ) var paths [ ] string for , path : = range initpaths { matches , err : = filepath . glob ( path ) if err ! = nil { continue } paths = append ( paths , matches ... ) } if dir notify { w . syncaddpaths ( paths ... ) } else { for , path : = range paths { w . paths [ path ] = watchpath ( path ) } } return } 
func ( w * watcher ) start ( ) < - chan * notification { if w . notify chan ! = nil { return w . notify chan } if w . auto watch { w . add chan = make ( chan * watchitem , notificationbuflen ) go w . watchitemlistener ( ) } w . notify chan = make ( chan * notification , notificationbuflen ) go w . watch ( w . notify chan ) return w . notify chan } 
func ( w * watcher ) stop ( ) { if w . notify chan ! = nil { close ( w . notify chan ) } if w . add chan ! = nil { close ( w . add chan ) } } 
func ( w * watcher ) active ( ) bool { return w . paths ! = nil && len ( w . paths ) > 0 } 
func ( w * watcher ) add ( inpaths ... string ) { var paths [ ] string for , path : = range inpaths { matches , err : = filepath . glob ( path ) if err ! = nil { continue } paths = append ( paths , matches ... ) } if w . auto watch && w . notify chan ! = nil { for , path : = range paths { wi : = watchpath ( path ) w . addpaths ( wi ) } } else if w . auto watch { w . syncaddpaths ( paths ... ) } else { for , path : = range paths { w . paths [ path ] = watchpath ( path ) } } } 
func ( w * watcher ) watch ( sndch chan < - * notification ) { defer func ( ) { recover ( ) } ( ) for { < - time . after ( watchdelay ) for , wi : = range w . paths { if wi . update ( ) && w . shouldnotify ( wi ) { sndch < - wi . notification ( ) } if wi . lastevent == noexist && w . auto watch { delete ( w . paths , wi . path ) } if len ( w . paths ) == 0 { w . stop ( ) } } } } 
func ( w * watcher ) watching ( ) ( paths [ ] string ) { paths = make ( [ ] string , 0 ) for path , : = range w . paths { paths = append ( paths , path ) } return } 
func ( w * watcher ) state ( ) ( state [ ] notification ) { state = make ( [ ] notification , 0 ) if w . paths == nil { return } for , wi : = range w . paths { state = append ( state , * wi . notification ( ) ) } return } 
func store ( r * http . request , err error ) { errptr , ok : = r . context ( ) . value ( errorkey ) . ( * error ) if ! ok { panic ( " " ) } if err ! = nil { * errptr = err } } 
func get ( r * http . request ) error { errptr , ok : = r . context ( ) . value ( errorkey ) . ( * error ) if ! ok { return nil } return * errptr } 
func catch ( h func ( w http . responsewriter , r * http . request , err error ) ) middleware { return func ( next http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { var err error ctx : = context . withvalue ( r . context ( ) , errorkey , & err ) next . servehttp ( w , r . withcontext ( ctx ) ) if err ! = nil { h ( w , r , err ) } } ) } } 
func recover ( ) middleware { return func ( next http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { defer func ( ) { if v : = recover ( ) ; v ! = nil { store ( r , panicerror { value : v , stack : stack ( 1 ) , } ) } } ( ) next . servehttp ( w , r ) } ) } } 
func ( e panicerror ) format ( s fmt . state , verb rune ) { switch verb { case ' s ' : io . writestring ( s , e . error ( ) ) case ' v ' : io . writestring ( s , e . error ( ) ) for , f : = range e . stack { io . writestring ( s , " \n " ) if s . flag ( ' + ' ) { fmt . fprintf ( s , " \n \ t " , f . function ) } fmt . fprintf ( s , " " , f . file , f . line ) } } } 
func main ( ) { req , : = http . newrequest ( " " , " " , nil ) req . header . set ( " " , " " ) resp , err : = http . defaultclient . do ( req ) if err ! = nil { log . fatalf ( " " , err ) } r : = resp . body i : = 0 buff : = make ( [ ] byte , 32 * 1024 ) for { n , err : = r . read ( buff ) if err ! = nil { break } i ++ log . printf ( " " , i , sizestr . tostring ( int64 ( n ) ) ) } r . close ( ) log . printf ( " " ) } 
func synchandler ( gostruct interface { } ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { if conn , err : = sync ( gostruct , w , r ) ; err ! = nil { log . printf ( " " , err ) } else { conn . wait ( ) } } ) } 
func ( c * conn ) connect ( w http . responsewriter , r * http . request ) error { if r . header . get ( " " ) == " " { c . transport = & eventsourcetransport { writetimeout : c . state . writetimeout } } else if r . header . get ( " " ) == " " { c . transport = & websocketstransport { writetimeout : c . state . writetimeout } } else { return fmt . errorf ( " " ) } if err : = c . transport . connect ( w , r ) ; err ! = nil { return err } if err : = c . send ( & update { ping : true } ) ; err ! = nil { return fmt . errorf ( " " ) } c . connected = true c . waiter . add ( 1 ) go func ( ) { for { select { case < - time . after ( c . state . pinginterval ) : if err : = c . send ( & update { ping : true } ) ; err ! = nil { goto disconnected } case < - c . connectedch : goto disconnected } } disconnected : c . connected = false c . close ( ) c . waiter . done ( ) } ( ) go func ( ) { if err : = c . transport . wait ( ) ; err ! = nil { } close ( c . connectedch ) } ( ) return nil } 
func ( c * conn ) send ( upd * update ) error { c . sendingmut . lock ( ) defer c . sendingmut . unlock ( ) return c . transport . send ( upd ) } 
func ( s * state ) numconnections ( ) int { s . connmut . lock ( ) n : = len ( s . conns ) s . connmut . unlock ( ) return n } 
func ( s * state ) push ( ) bool { if atomic . compareandswapuint32 ( & s . push . ing , 0 , 1 ) { go s . gopush ( ) return true } atomic . storeuint32 ( & s . push . queued , 1 ) return false } 
func ( t * intail ) run ( c * context ) { c . inputprocess . add ( 1 ) defer c . inputprocess . done ( ) t . messagech = c . messagech t . monitorch = c . monitorch c . startprocess . done ( ) if t . eventch == nil { err : = t . tailstdin ( c ) if err ! = nil { if , ok : = err . ( signal ) ; ok { log . println ( " " , err ) } else { log . println ( " " , err ) } return } } log . println ( " " , t . filename ) f , err : = t . newtrailfile ( seek tail , c ) if err ! = nil { if , ok : = err . ( signal ) ; ok { log . println ( " " , err ) } else { log . println ( " " , err ) } return } for { for { err : = t . watchfileevent ( f , c ) if err ! = nil { if , ok : = err . ( signal ) ; ok { log . println ( " " , err ) return } else { log . println ( " " , err ) break } } } var err error f , err = t . newtrailfile ( seek head , c ) if err ! = nil { if , ok : = err . ( signal ) ; ok { log . println ( " " , err ) } else { log . println ( " " , err ) } return } } } 
func new ( config config ) ( f * fluent , err error ) { if config . server == " " { config . server = defaultserver } if config . timeout == 0 { config . timeout = defaulttimeout } if config . retrywait == 0 { config . retrywait = defaultretrywait } if config . maxretry == 0 { config . maxretry = defaultmaxretry } f = & fluent { config : config , reconnecting : false , cancelreconnect : make ( chan bool ) , } err = f . connect ( ) return } 
func ( f * fluent ) close ( ) ( err error ) { if f . conn ! = nil { f . mu . lock ( ) defer f . mu . unlock ( ) } else { return } if f . conn ! = nil { f . conn . close ( ) f . conn = nil } return } 
func ( f * fluent ) isreconnecting ( ) bool { f . mu . lock ( ) defer f . mu . unlock ( ) return f . reconnecting } 
func ( f * fluent ) connect ( ) ( err error ) { host , port , err : = net . splithostport ( f . server ) if err ! = nil { return err } addrs , err : = net . lookuphost ( host ) if err ! = nil | | len ( addrs ) == 0 { return err } n : = rand . intn ( len ( addrs ) ) addr : = addrs [ n ] var format string if strings . contains ( addr , " " ) { format = " " } else { format = " " } resolved : = fmt . sprintf ( format , addr , port ) log . printf ( " " , f . server , resolved ) f . conn , err = net . dialtimeout ( " " , resolved , f . config . timeout ) f . recorderror ( err ) return } 
func notification ( title , message string ) gnotifier { config : = & config { title , message , 5000 , " " } n : = & notifier { config : config } return n } 
func nullnotification ( title , message string ) gnotifier { config : = & config { title , message , 5000 , " " } n : = & nullnotifier { config : config } return n } 
func new ( opts ... option ) * identity { c : = & configuration { } for , opt : = range opts { option ( opt ) ( c ) } return c . generate ( ) } 
func ( id * identity ) issue ( opts ... option ) * identity { opts = append ( opts , issuer ( id ) ) return new ( opts ... ) } 
func ( id * identity ) pfx ( password string ) [ ] byte { return topfx ( id . certificate , id . privatekey , password ) } 
func ( id * identity ) chain ( ) [ ] * x509 . certificate { chain : = [ ] * x509 . certificate { } for this : = id ; this ! = nil ; this = this . issuer { chain = append ( chain , this . certificate ) } return chain } 
func ( id * identity ) chainpool ( ) * x509 . certpool { chain : = x509 . newcertpool ( ) for this : = id ; this ! = nil ; this = this . issuer { chain . addcert ( this . certificate ) } return chain } 
func subject ( value pkix . name ) option { return func ( c * configuration ) { c . subject = & value } } 
func privatekey ( value crypto . signer ) option { return func ( c * configuration ) { c . priv = & value } } 
func notbefore ( value time . time ) option { return func ( c * configuration ) { c . notbefore = & value } } 
func notafter ( value time . time ) option { return func ( c * configuration ) { c . notafter = & value } } 
func issuingcertificateurl ( value ... string ) option { return func ( c * configuration ) { c . issuingcertificateurl = append ( c . issuingcertificateurl , value ... ) } } 
func ocspserver ( value ... string ) option { return func ( c * configuration ) { c . ocspserver = append ( c . ocspserver , value ... ) } } 
func new ( apikey string ) ( * telegrambotapi , error ) { toreturn : = telegrambotapi { updates : make ( chan botupdate ) , baseuris : createendpoints ( fmt . sprintf ( apibaseuri , apikey ) ) , closed : make ( chan struct { } ) , c : newclient ( fmt . sprintf ( apibaseuri , apikey ) ) , updatec : newclient ( fmt . sprintf ( apibaseuri , apikey ) ) , } user , err : = toreturn . getme ( ) if err ! = nil { return nil , err } toreturn . id = user . user . id toreturn . name = user . user . firstname toreturn . username = * user . user . username err = toreturn . removewebhook ( ) if err ! = nil { return nil , err } toreturn . wg . add ( 1 ) go toreturn . updateloop ( ) return & toreturn , nil } 
func ( api * telegrambotapi ) close ( ) { select { case < - api . closed : return default : } close ( api . closed ) api . wg . wait ( ) } 
func ( api * telegrambotapi ) getme ( ) ( * userresponse , error ) { resp : = & userresponse { } , err : = api . c . get ( getme , resp ) if err ! = nil { return nil , err } err = check ( & resp . baseresponse ) if err ! = nil { return nil , err } return resp , nil } 
func runbot ( apikey string , bot botfunc , name , description string ) { closing : = make ( chan struct { } ) fmt . printf ( " \n " , name , description ) fmt . println ( " " ) api , err : = tbotapi . new ( apikey ) if err ! = nil { log . fatal ( err ) } fmt . printf ( " \n " , api . id ) fmt . printf ( " \n " , api . name ) fmt . printf ( " \n " , api . username ) closed : = make ( chan struct { } ) wg : = & sync . waitgroup { } wg . add ( 1 ) go func ( ) { defer wg . done ( ) for { select { case < - closed : return case update : = < - api . updates : if update . error ( ) ! = nil { fmt . printf ( " \n " , update . error ( ) ) continue } bot ( update . update ( ) , api ) } } } ( ) shutdown : = make ( chan os . signal ) signal . notify ( shutdown , syscall . sigint , syscall . sigterm ) go func ( ) { < - shutdown close ( closing ) } ( ) fmt . println ( " " ) < - closing fmt . println ( " " ) api . close ( ) close ( closed ) wg . wait ( ) } 
func ( api * telegrambotapi ) newoutgoingmessage ( recipient recipient , text string ) * outgoingmessage { return & outgoingmessage { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , text : text , parsemode : modedefault , } } 
func ( api * telegrambotapi ) newoutgoinglocation ( recipient recipient , latitude , longitude float32 ) * outgoinglocation { return & outgoinglocation { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , latitude : latitude , longitude : longitude , } } 
func ( api * telegrambotapi ) newoutgoingvenue ( recipient recipient , latitude , longitude float32 , title , address string ) * outgoingvenue { return & outgoingvenue { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , latitude : latitude , longitude : longitude , title : title , address : address , } } 
func ( api * telegrambotapi ) newoutgoingvideo ( recipient recipient , filename string , reader io . reader ) * outgoingvideo { return & outgoingvideo { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { filename : filename , r : reader , } , } } 
func ( api * telegrambotapi ) newoutgoingvideoresend ( recipient recipient , fileid string ) * outgoingvideo { return & outgoingvideo { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { fileid : fileid , } , } } 
func ( api * telegrambotapi ) newoutgoingphoto ( recipient recipient , filename string , reader io . reader ) * outgoingphoto { return & outgoingphoto { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { filename : filename , r : reader , } , } } 
func ( api * telegrambotapi ) newoutgoingphotoresend ( recipient recipient , fileid string ) * outgoingphoto { return & outgoingphoto { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { fileid : fileid , } , } } 
func ( api * telegrambotapi ) newoutgoingsticker ( recipient recipient , filename string , reader io . reader ) * outgoingsticker { return & outgoingsticker { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { filename : filename , r : reader , } , } } 
func ( api * telegrambotapi ) newoutgoingstickerresend ( recipient recipient , fileid string ) * outgoingsticker { return & outgoingsticker { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { fileid : fileid , } , } } 
func ( api * telegrambotapi ) newoutgoingaudio ( recipient recipient , filename string , reader io . reader ) * outgoingaudio { return & outgoingaudio { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { filename : filename , r : reader , } , } } 
func ( api * telegrambotapi ) newoutgoingaudioresend ( recipient recipient , fileid string ) * outgoingaudio { return & outgoingaudio { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { fileid : fileid , } , } } 
func ( api * telegrambotapi ) newoutgoingdocument ( recipient recipient , filename string , reader io . reader ) * outgoingdocument { return & outgoingdocument { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { filename : filename , r : reader , } , } } 
func ( api * telegrambotapi ) newoutgoingdocumentresend ( recipient recipient , fileid string ) * outgoingdocument { return & outgoingdocument { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , outgoingfilebase : outgoingfilebase { fileid : fileid , } , } } 
func ( api * telegrambotapi ) newoutgoingforward ( recipient recipient , origin chat , messageid int ) * outgoingforward { return & outgoingforward { outgoingmessagebase : outgoingmessagebase { outgoingbase : outgoingbase { api : api , recipient : recipient , } , } , fromchatid : newrecipientfromchat ( origin ) , messageid : messageid , } } 
func ( api * telegrambotapi ) newoutgoingchataction ( recipient recipient , action chataction ) * outgoingchataction { return & outgoingchataction { outgoingbase : outgoingbase { api : api , recipient : recipient , } , action : action , } } 
func ( api * telegrambotapi ) newoutgoinguserprofilephotosrequest ( userid int ) * outgoinguserprofilephotosrequest { return & outgoinguserprofilephotosrequest { api : api , userid : userid , } } 
func ( api * telegrambotapi ) newoutgoingkickchatmember ( chat recipient , userid int ) * outgoingkickchatmember { return & outgoingkickchatmember { api : api , recipient : chat , userid : userid , } } 
func ( api * telegrambotapi ) newoutgoingunbanchatmember ( chat recipient , userid int ) * outgoingunbanchatmember { return & outgoingunbanchatmember { api : api , recipient : chat , userid : userid , } } 
func ( api * telegrambotapi ) newoutgoingcallbackqueryresponse ( queryid string ) * outgoingcallbackqueryresponse { return & outgoingcallbackqueryresponse { api : api , callbackqueryid : queryid , } } 
func ( api * telegrambotapi ) newinlinequeryanswer ( queryid string , results [ ] inlinequeryresult ) * inlinequeryanswer { return & inlinequeryanswer { api : api , queryid : queryid , results : results , } } 
func ( m * message ) type ( ) messagetype { if m . text ! = nil { return textmessage } else if m . audio ! = nil { return audiomessage } else if m . document ! = nil { return documentmessage } else if m . photo ! = nil { return photomessage } else if m . sticker ! = nil { return stickermessage } else if m . video ! = nil { return videomessage } else if m . voice ! = nil { return voicemessage } else if m . contact ! = nil { return contactmessage } else if m . location ! = nil { return locationmessage } else if m . newchatmember ! = nil { return newchatmember } else if m . leftchatmember ! = nil { return leftchatmember } else if m . newchattitle ! = nil { return newchattitle } else if m . newchatphoto ! = nil { return newchatphoto } else if m . deletechatphoto { return deletedchatphoto } else if m . groupchatcreated { return groupchatcreated } else if m . supergroupchatcreated { return supergroupchatcreated } else if m . channelchatcreated { return channelchatcreated } else if m . migratetochatid ! = nil { return migrationtosupergroup } else if m . migratefromchatid ! = nil { return migrationfromgroup } else if m . venue ! = nil { return venuemessage } else if m . pinnedmessage ! = nil { return pinnedmessage } return unknownmessage } 
func ( u * update ) type ( ) updatetype { if u . message ! = nil { return messageupdate } else if u . inlinequery ! = nil { return inlinequeryupdate } else if u . choseninlineresult ! = nil { return choseninlineresultupdate } return unknownupdate } 
func ( r recipient ) marshaljson ( ) ( [ ] byte , error ) { toreturn : = " " if r . ischannel ( ) { toreturn = fmt . sprintf ( " " " " , * r . channelid ) } else { toreturn = fmt . sprintf ( " " , * r . chatid ) } return [ ] byte ( toreturn ) , nil } 
func ( ow * outgoingsetwebhook ) querystring ( ) querystring { toreturn : = make ( map [ string ] string ) if ow . url ! = " " { toreturn [ " " ] = ow . url } return querystring ( toreturn ) } 
func ( op * outgoingmessagebase ) setreplytomessageid ( to int ) { op . replytomessageid = to op . replytomessageidset = true } 
func ( op * outgoingbase ) getbasequerystring ( ) querystring { toreturn : = map [ string ] string { } if op . recipient . ischannel ( ) { toreturn [ " " ] = fmt . sprint ( * op . recipient . channelid ) } else { toreturn [ " " ] = fmt . sprint ( * op . recipient . chatid ) } return querystring ( toreturn ) } 
func ( op * outgoingmessagebase ) getbasequerystring ( ) querystring { toreturn : = map [ string ] string { } if op . recipient . ischannel ( ) { toreturn [ " " ] = fmt . sprint ( * op . recipient . channelid ) } else { toreturn [ " " ] = fmt . sprint ( * op . recipient . chatid ) } if op . replytomessageidset { toreturn [ " " ] = fmt . sprint ( op . replytomessageid ) } if op . replymarkupset { b , err : = json . marshal ( op . replymarkup ) if err ! = nil { panic ( err ) } toreturn [ " " ] = string ( b ) } if op . disablenotification { toreturn [ " " ] = fmt . sprint ( op . disablenotification ) } return querystring ( toreturn ) } 
func ( oa * outgoingaudio ) setduration ( to int ) * outgoingaudio { oa . duration = to return oa } 
func ( oa * outgoingaudio ) setperformer ( to string ) * outgoingaudio { oa . performer = to return oa } 
func ( oa * outgoingaudio ) settitle ( to string ) * outgoingaudio { oa . title = to return oa } 
func ( oa * outgoingaudio ) querystring ( ) querystring { toreturn : = map [ string ] string ( oa . getbasequerystring ( ) ) if oa . duration ! = 0 { toreturn [ " " ] = fmt . sprint ( oa . duration ) } if oa . performer ! = " " { toreturn [ " " ] = oa . performer } if oa . title ! = " " { toreturn [ " " ] = oa . title } return querystring ( toreturn ) } 
func ( ov * outgoingvenue ) setfoursquareid ( to string ) * outgoingvenue { ov . foursquareid = to return ov } 
func ( om * outgoingmessage ) setmarkdown ( to bool ) * outgoingmessage { if to { om . parsemode = modemarkdown } else { om . parsemode = modedefault } return om } 
func ( om * outgoingmessage ) sethtml ( to bool ) * outgoingmessage { if to { om . parsemode = modehtml } else { om . parsemode = modedefault } return om } 
func ( om * outgoingmessage ) setdisablewebpagepreview ( to bool ) * outgoingmessage { om . disablewebpagepreview = to return om } 
func ( op * outgoingphoto ) setcaption ( to string ) * outgoingphoto { op . caption = to return op } 
func ( op * outgoingphoto ) querystring ( ) querystring { toreturn : = map [ string ] string ( op . getbasequerystring ( ) ) if op . caption ! = " " { toreturn [ " " ] = op . caption } return querystring ( toreturn ) } 
func ( op * outgoinguserprofilephotosrequest ) setoffset ( to int ) * outgoinguserprofilephotosrequest { op . offset = to return op } 
func ( op * outgoinguserprofilephotosrequest ) setlimit ( to int ) * outgoinguserprofilephotosrequest { op . limit = to return op } 
func ( op * outgoinguserprofilephotosrequest ) querystring ( ) querystring { toreturn : = map [ string ] string { } toreturn [ " " ] = fmt . sprint ( op . userid ) if op . offset ! = 0 { toreturn [ " " ] = fmt . sprint ( op . offset ) } if op . limit ! = 0 { toreturn [ " " ] = fmt . sprint ( op . limit ) } return querystring ( toreturn ) } 
func ( ov * outgoingvideo ) setcaption ( to string ) * outgoingvideo { ov . caption = to return ov } 
func ( ov * outgoingvideo ) setduration ( to int ) * outgoingvideo { ov . duration = to return ov } 
func ( ov * outgoingvideo ) querystring ( ) querystring { toreturn : = map [ string ] string ( ov . getbasequerystring ( ) ) if ov . caption ! = " " { toreturn [ " " ] = ov . caption } if ov . duration ! = 0 { toreturn [ " " ] = fmt . sprint ( ov . duration ) } return querystring ( toreturn ) } 
func newinlinequeryresultarticle ( id , title , text string ) * inlinequeryresultarticle { return & inlinequeryresultarticle { inlinequeryresultbase : inlinequeryresultbase { type : articleresult , id : id , } , title : title , text : text , } } 
func newinlinequeryresultphoto ( id , photourl , thumburl string ) * inlinequeryresultphoto { return & inlinequeryresultphoto { inlinequeryresultbase : inlinequeryresultbase { type : photoresult , id : id , } , photourl : photourl , thumburl : thumburl , } } 
func newinlinequeryresultgif ( id , gifurl , thumburl string ) * inlinequeryresultgif { return & inlinequeryresultgif { inlinequeryresultbase : inlinequeryresultbase { type : gifresult , id : id , } , gifurl : gifurl , thumburl : thumburl , } } 
func newinlinequeryresultmpeg4gif ( id , mpeg4url , thumburl string ) * inlinequeryresultmpeg4gif { return & inlinequeryresultmpeg4gif { inlinequeryresultbase : inlinequeryresultbase { type : photoresult , id : id , } , mpeg4url : mpeg4url , thumburl : thumburl , } } 
func newinlinequeryresultvideo ( id , videourl , thumburl , title , text string , mimetype mimetype ) * inlinequeryresultvideo { return & inlinequeryresultvideo { inlinequeryresultbase : inlinequeryresultbase { type : photoresult , id : id , } , videourl : videourl , mimetype : mimetype , thumburl : thumburl , title : title , text : text , } } 
func ( op * outgoinguserprofilephotosrequest ) send ( ) ( * userprofilephotosresponse , error ) { resp : = & userprofilephotosresponse { } , err : = op . api . c . postjson ( getuserprofilephotos , resp , op ) if err ! = nil { return nil , err } err = check ( & resp . baseresponse ) if err ! = nil { return nil , err } return resp , nil } 
func ( oc * outgoingchataction ) send ( ) error { resp : = & baseresponse { } , err : = oc . api . c . postjson ( sendchataction , resp , oc ) if err ! = nil { return err } return check ( resp ) } 
func ( ia * inlinequeryanswer ) send ( ) error { resp : = & baseresponse { } , err : = ia . api . c . postjson ( answerinlinequery , resp , ia ) if err ! = nil { return err } return check ( resp ) } 
func ( kr * outgoingkickchatmember ) send ( ) error { resp : = & baseresponse { } , err : = kr . api . c . postjson ( kickchatmember , resp , kr ) if err ! = nil { return err } return check ( resp ) } 
func ( ub * outgoingunbanchatmember ) send ( ) error { resp : = & baseresponse { } , err : = ub . api . c . postjson ( unbanchatmember , resp , ub ) if err ! = nil { return err } return check ( resp ) } 
func ( cbr * outgoingcallbackqueryresponse ) send ( ) error { resp : = & baseresponse { } , err : = cbr . api . c . postjson ( answercallbackquery , resp , cbr ) if err ! = nil { return err } return check ( resp ) } 
func ( ts * timestamp ) beforeinsert ( ) error { n : = now ( ) ts . createdat = n ts . updatedat = n return nil } 
func tointerfaceslice ( slice [ ] string ) [ ] interface { } { result : = make ( [ ] interface { } , len ( slice ) ) for i , v : = range slice { result [ i ] = v } return result } 
func columnname ( d dialect , tname , cname string ) string { if cname ! = " " { cname = d . quote ( cname ) } if tname == " " { return cname } return fmt . sprintf ( " " , d . quote ( tname ) , cname ) } 
func new ( dialect dialect , dsn string ) ( * db , error ) { db , err : = sql . open ( dialect . name ( ) , dsn ) if err ! = nil { return nil , err } return & db { db : db , dialect : dialect , logger : defaultlogger } , nil } 
func ( db * db ) from ( arg interface { } ) * from { t : = reflect . indirect ( reflect . valueof ( arg ) ) . type ( ) if t . kind ( ) ! = reflect . struct { panic ( fmt . errorf ( " " , t ) ) } return & from { tablename : db . tablename ( t ) } } 
func ( db * db ) where ( cond interface { } , args ... interface { } ) * condition { return newcondition ( db ) . where ( cond , args ... ) } 
func ( db * db ) orderby ( table interface { } , column interface { } , order ... interface { } ) * condition { return newcondition ( db ) . orderby ( table , column , order ... ) } 
func ( db * db ) limit ( lim int ) * condition { return newcondition ( db ) . limit ( lim ) } 
func ( db * db ) offset ( offset int ) * condition { return newcondition ( db ) . offset ( offset ) } 
func ( db * db ) join ( table interface { } ) * joincondition { return ( & joincondition { db : db } ) . join ( table ) } 
func ( db * db ) count ( column ... interface { } ) * function { switch len ( column ) { case 0 , 1 : default : panic ( fmt . errorf ( " " , len ( column ) ) ) } return & function { name : " " , args : column , } } 
func ( db * db ) droptable ( table interface { } ) error { , , tablename , err : = db . tablevalueof ( " " , table ) if err ! = nil { return err } query : = fmt . sprintf ( " " , db . dialect . quote ( tablename ) ) stmt , err : = db . prepare ( query ) if err ! = nil { return err } defer stmt . close ( ) if , err = stmt . exec ( ) ; err ! = nil { return err } return nil } 
func ( db * db ) createindex ( table interface { } , name string , names ... string ) error { return db . createindex ( table , false , name , names ... ) } 
func ( db * db ) createuniqueindex ( table interface { } , name string , names ... string ) error { return db . createindex ( table , true , name , names ... ) } 
func ( db * db ) begin ( ) error { tx , err : = db . db . begin ( ) if err ! = nil { return err } db . m . lock ( ) defer db . m . unlock ( ) db . tx = tx return nil } 
func ( db * db ) commit ( ) error { db . m . lock ( ) defer db . m . unlock ( ) if db . tx == nil { return errtxdone } err : = db . tx . commit ( ) db . tx = nil return err } 
func ( db * db ) quote ( s string ) string { return db . dialect . quote ( s ) } 
func ( db * db ) setlogoutput ( w io . writer ) { if w == nil { db . logger = defaultlogger } else { db . logger = & templatelogger { w : w , t : defaultloggertemplate } } } 
func ( db * db ) setlogformat ( format string ) error { return db . logger . setformat ( format ) } 
func ( db * db ) selecttovalue ( rows * sql . rows , t reflect . type ) ( reflect . value , error ) { ptrn : = 0 for ; t . kind ( ) == reflect . ptr ; ptrn ++ { t = t . elem ( ) } dest : = reflect . new ( t ) . elem ( ) if rows . next ( ) { if err : = rows . scan ( dest . addr ( ) . interface ( ) ) ; err ! = nil { return reflect . value { } , err } } for i : = 0 ; i < ptrn ; i ++ { dest = dest . addr ( ) } return dest , nil } 
func ( db * db ) fieldindexbyname ( t reflect . type , name string , index [ ] int ) [ ] int { for i : = 0 ; i < t . numfield ( ) ; i ++ { field : = t . field ( i ) if candidate : = db . columnfromtag ( field ) ; candidate == name { return append ( index , i ) } if field . anonymous { if idx : = db . fieldindexbyname ( field . type , name , append ( index , i ) ) ; len ( idx ) > 0 { return append ( index , idx ... ) } } } return nil } 
func ( db * db ) columns ( tablename string , columns [ ] interface { } ) string { if len ( columns ) == 0 { return columnname ( db . dialect , tablename , " " ) } names : = make ( [ ] string , len ( columns ) ) for i , col : = range columns { switch c : = col . ( type ) { case raw : names [ i ] = fmt . sprint ( * c ) case string : names [ i ] = columnname ( db . dialect , tablename , c ) case * distinct : names [ i ] = fmt . sprintf ( " " , db . columns ( tablename , tointerfaceslice ( c . columns ) ) ) default : panic ( fmt . errorf ( " " , c ) ) } } return strings . join ( names , " " ) } 
func ( db * db ) tagsfromfield ( field * reflect . structfield ) ( options [ ] string ) { if db . hasskiptag ( field ) { return nil } for , tag : = range strings . split ( field . tag . get ( dbtag ) , " " ) { if t : = strings . tolower ( strings . trimspace ( tag ) ) ; t ! = " " { options = append ( options , t ) } } return options } 
func ( db * db ) hasskiptag ( field * reflect . structfield ) bool { if field . tag . get ( dbtag ) == skiptag { return true } return false } 
func ( db * db ) haspktag ( field * reflect . structfield ) bool { for , tag : = range db . tagsfromfield ( field ) { if tag == " " { return true } } return false } 
func ( db * db ) isautoincrementable ( field * reflect . structfield ) bool { switch field . type . kind ( ) { case reflect . int , reflect . int16 , reflect . int32 , reflect . int64 , reflect . uint , reflect . uint16 , reflect . uint32 , reflect . uint64 : return true } return false } 
func ( db * db ) collectfieldindexes ( typ reflect . type , index [ ] int ) ( indexes [ ] [ ] int ) { for i : = 0 ; i < typ . numfield ( ) ; i ++ { field : = typ . field ( i ) if isunexportedfield ( field ) { continue } if ! ( db . hasskiptag ( & field ) | | ( db . haspktag ( & field ) && db . isautoincrementable ( & field ) ) ) { tmp : = make ( [ ] int , len ( index ) + 1 ) copy ( tmp , index ) tmp [ len ( tmp ) - 1 ] = i if field . anonymous { indexes = append ( indexes , db . collectfieldindexes ( field . type , tmp ) ... ) } else { indexes = append ( indexes , tmp ) } } } return indexes } 
func ( db * db ) findpkindex ( typ reflect . type , index [ ] int ) [ ] int { for i : = 0 ; i < typ . numfield ( ) ; i ++ { field : = typ . field ( i ) if isunexportedfield ( field ) { continue } if field . anonymous { if idx : = db . findpkindex ( field . type , append ( index , i ) ) ; idx ! = nil { return append ( index , idx ... ) } continue } if db . haspktag ( & field ) { return append ( index , i ) } } return nil } 
func ( db * db ) sizefromtag ( field * reflect . structfield ) ( size uint64 , err error ) { if s : = field . tag . get ( dbsizetag ) ; s ! = " " { size , err = strconv . parseuint ( s , 10 , 64 ) } return size , err } 
func ( db * db ) columnfromtag ( field reflect . structfield ) string { col : = field . tag . get ( dbcolumntag ) if col == " " { return stringutil . tosnakecase ( field . name ) } return col } 
func ( db * db ) defaultfromtag ( field * reflect . structfield ) ( string , error ) { def : = field . tag . get ( dbdefaulttag ) if def == " " { return " " , nil } switch field . type . kind ( ) { case reflect . bool : b , err : = strconv . parsebool ( def ) if err ! = nil { return " " , err } return fmt . sprintf ( " " , db . dialect . formatbool ( b ) ) , nil } return fmt . sprintf ( " " , def ) , nil } 
func ( c * condition ) where ( cond interface { } , args ... interface { } ) * condition { return c . appendquerybycondorexpr ( " " , 0 , where , cond , args ... ) } 
func ( c * condition ) and ( cond interface { } , args ... interface { } ) * condition { return c . appendquerybycondorexpr ( " " , 100 , and , cond , args ... ) } 
func ( c * condition ) or ( cond interface { } , args ... interface { } ) * condition { return c . appendquerybycondorexpr ( " " , 100 , or , cond , args ... ) } 
func ( c * condition ) like ( arg string ) * condition { return c . appendquery ( 100 , like , arg ) } 
func ( c * condition ) between ( from , to interface { } ) * condition { return c . appendquery ( 100 , between , & between { from , to } ) } 
func ( c * condition ) orderby ( table , col interface { } , order ... interface { } ) * condition { order = append ( [ ] interface { } { table , col } , order ... ) orderbys : = make ( [ ] orderby , 0 , 1 ) for len ( order ) > 0 { o , rest : = order [ 0 ] , order [ 1 : ] if , ok : = o . ( string ) ; ok { if len ( rest ) < 1 { panic ( fmt . errorf ( " " ) ) } orderbys = append ( orderbys , c . orderby ( nil , o , rest [ 0 ] ) ) order = rest [ 1 : ] continue } if len ( rest ) < 2 { panic ( fmt . errorf ( " " ) ) } orderbys = append ( orderbys , c . orderby ( o , rest [ 0 ] , rest [ 1 ] ) ) order = rest [ 2 : ] } return c . appendquery ( 300 , orderby , orderbys ) } 
func ( c * condition ) limit ( lim int ) * condition { return c . appendquery ( 500 , limit , lim ) } 
func ( c * condition ) offset ( offset int ) * condition { return c . appendquery ( 700 , offset , offset ) } 
func ( jc * joincondition ) on ( larg interface { } , args ... string ) * condition { var lcolumn string switch rv : = reflect . valueof ( larg ) ; rv . kind ( ) { case reflect . string : lcolumn = rv . string ( ) default : for rv . kind ( ) == reflect . ptr { rv = rv . elem ( ) } if rv . kind ( ) ! = reflect . struct { panic ( fmt . errorf ( " " , rv . type ( ) ) ) } jc . lefttablename = jc . db . tablename ( rv . type ( ) ) lcolumn , args = args [ 0 ] , args [ 1 : ] } switch len ( args ) { case 0 : jc . left , jc . op , jc . right = lcolumn , " " , lcolumn case 2 : jc . left , jc . op , jc . right = lcolumn , args [ 0 ] , args [ 1 ] default : panic ( fmt . errorf ( " " , len ( args ) + 1 ) ) } c : = newcondition ( jc . db ) c . parts = append ( c . parts , part { clause : jc . clause , expr : jc , priority : - 100 , } ) return c } 
func newrat ( a , b int64 ) * rat { return & rat { rat : big . newrat ( a , b ) , } } 
func ( rat * rat ) scan ( src interface { } ) ( err error ) { rat . rat = new ( big . rat ) switch t : = src . ( type ) { case string : , err = fmt . sscan ( t , rat . rat ) case [ ] byte : , err = fmt . sscan ( string ( t ) , rat . rat ) case float64 : rat . rat . setfloat64 ( t ) default : , err = fmt . sscan ( fmt . sprint ( t ) , rat . rat ) } return err } 
func ( rat rat ) value ( ) ( driver . value , error ) { return rat . floatstring ( decimalscale ) , nil } 
func ( f * float32 ) scan ( src interface { } ) ( err error ) { switch t : = src . ( type ) { case string : , err = fmt . sscan ( t , f ) case [ ] byte : , err = fmt . sscan ( string ( t ) , f ) case float64 : * f = float32 ( t ) case int64 : * f = float32 ( t ) default : , err = fmt . sscan ( fmt . sprint ( t ) , f ) } return err } 
func ( l * templatelogger ) setformat ( format string ) error { l . m . lock ( ) defer l . m . unlock ( ) t , err : = template . new ( " " ) . parse ( format ) if err ! = nil { return err } l . t = t return nil } 
func ( l * templatelogger ) print ( start time . time , query string , args ... interface { } ) error { if len ( args ) > 0 { values : = make ( [ ] string , len ( args ) ) for i , arg : = range args { values [ i ] = fmt . sprintf ( " " , arg ) } query = fmt . sprintf ( " " , query , strings . join ( values , " " ) ) } else { query = fmt . sprintf ( " " , query ) } data : = map [ string ] interface { } { " " : start , " " : fmt . sprintf ( " " , now ( ) . sub ( start ) . seconds ( ) * float64 ( time . microsecond ) ) , " " : query , } var buf bytes . buffer if err : = l . t . execute ( & buf , data ) ; err ! = nil { return err } l . m . lock ( ) defer l . m . unlock ( ) if , err : = fmt . fprintln ( l . w , strings . trimsuffix ( buf . string ( ) , " \n " ) ) ; err ! = nil { return err } return nil } 
func ( l * nulllogger ) print ( start time . time , query string , args ... interface { } ) error { return nil } 
func ( d * mysqldialect ) quote ( s string ) string { return fmt . sprintf ( " " , strings . replace ( s , " " , " " , - 1 ) ) } 
func new ( file * os . file ) archive { if filepath . ext ( file . name ( ) ) == " " { return zip . new ( file ) } return tar . new ( file ) } 
func ( h * host ) disconnect ( ) { if h . handle == c . vix e cancelled { return } if & h . handle ! = nil && h . handle ! = c . vix invalid handle { c . vixhost disconnect ( h . handle ) h . handle = c . vix invalid handle } } 
func ( h * host ) finditems ( options searchtype ) ( [ ] string , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixhost finditems ( h . handle , c . vixfinditemtype ( options ) , c . vix invalid handle , - 1 , ( * c . vixeventproc ) ( c . find items callback ) , unsafe . pointer ( h ) ) defer func ( ) { h . items = [ ] string { } c . vix releasehandle ( jobhandle ) } ( ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return h . items , nil } 
func ( h * host ) openvm ( vmxfile , password string ) ( * vm , error ) { var jobhandle c . vixhandle = c . vix invalid handle var propertyhandle c . vixhandle = c . vix invalid handle var vmhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok defer c . vix releasehandle ( propertyhandle ) defer c . vix releasehandle ( jobhandle ) if password ! = " " { cpassword : = c . cstring ( password ) defer c . free ( unsafe . pointer ( cpassword ) ) err = c . alloc vm pwd proplist ( h . handle , & propertyhandle , cpassword ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } } cvmxfile : = c . cstring ( vmxfile ) defer c . free ( unsafe . pointer ( cvmxfile ) ) jobhandle = c . vixhost openvm ( h . handle , cvmxfile , c . vix vmopen normal , propertyhandle , nil , nil ) err = c . get vix handle ( jobhandle , c . vix property job result handle , & vmhandle , c . vix property none ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return newvirtualmachine ( vmhandle , vmxfile ) } 
func ( h * host ) registervm ( vmxfile string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok cvmxfile : = c . cstring ( vmxfile ) defer c . free ( unsafe . pointer ( cvmxfile ) ) jobhandle = c . vixhost registervm ( h . handle , cvmxfile , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( h * host ) copyfiletoguest ( src string , guest * guest , dest string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok csrc : = c . cstring ( src ) cdest : = c . cstring ( dest ) defer c . free ( unsafe . pointer ( csrc ) ) defer c . free ( unsafe . pointer ( cdest ) ) jobhandle = c . vixvm copyfilefromhosttoguest ( guest . handle , csrc , cdest , c . int ( 0 ) , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) nextnetworkadapterid ( vmx map [ string ] string ) int { var nextid int prefix : = " " for key : = range vmx { if strings . hasprefix ( key , prefix ) { ethn : = strings . split ( key , " " ) [ 0 ] number , : = strconv . atoi ( strings . split ( ethn , prefix ) [ 1 ] ) if vmx [ ethn + " " ] == " " { return number } if number > nextid { nextid = number } } } nextid ++ return nextid } 
func ( v * vm ) totalnetworkadapters ( vmx map [ string ] string ) int { var total int prefix : = " " for key : = range vmx { if strings . hasprefix ( key , prefix ) { ethn : = strings . split ( key , " " ) [ 0 ] number , : = strconv . atoi ( strings . split ( ethn , prefix ) [ 1 ] ) if number > total { total = number } } } return total } 
func ( v * vm ) removeallnetworkadapters ( ) error { vmxpath , err : = v . vmxpath ( ) if err ! = nil { return err } vmx , err : = readvmx ( vmxpath ) if err ! = nil { return err } for key : = range vmx { if strings . hasprefix ( key , " " ) { delete ( vmx , key ) } } return writevmx ( vmxpath , vmx ) } 
func ( v * vm ) removenetworkadapter ( adapter * networkadapter ) error { isvmrunning , err : = v . isrunning ( ) if err ! = nil { return err } if isvmrunning { return & error { operation : " " , code : 100000 , text : " " , } } vmxpath , err : = v . vmxpath ( ) if err ! = nil { return err } vmx , err : = readvmx ( vmxpath ) if err ! = nil { return err } device : = " " + adapter . id for key : = range vmx { if strings . hasprefix ( key , device ) { delete ( vmx , key ) } } vmx [ device + " " ] = " " err = writevmx ( vmxpath , vmx ) if err ! = nil { return err } return nil } 
func advancetofirstentry ( scanner * bufio . scanner ) error { for scanner . scan ( ) { s : = scanner . text ( ) if s == " " { return nil } } err : = scanner . err ( ) if err == nil { err = errnoentries } return err } 
func newarchive ( path string , password * string ) ( * archive , error ) { err : = detect7zcached ( ) if err ! = nil { return nil , err } cmd : = exec . command ( " " , " " , " " , " " , path ) out , err : = cmd . combinedoutput ( ) if err ! = nil { return nil , err } entries , err : = parse7zlistoutput ( out ) if err ! = nil { return nil , err } return & archive { path : path , entries : entries , password : password , } , nil } 
func ( a * archive ) getfilereader ( name string ) ( io . readcloser , error ) { found : = false for , e : = range a . entries { if e . path == name { found = true break } } if ! found { return nil , errors . new ( " " ) } params : = [ ] string { " " , " " } if a . password ! = nil { params = append ( params , fmt . sprintf ( " " , * a . password ) ) } params = append ( params , a . path , name ) cmd : = exec . command ( " " , params ... ) stdout , err : = cmd . stdoutpipe ( ) rc : = & readcloser { rc : stdout , cmd : cmd , } err = cmd . start ( ) if err ! = nil { stdout . close ( ) return nil , err } return rc , nil } 
func ( a * archive ) extracttowriter ( dst io . writer , name string ) error { r , err : = a . getfilereader ( name ) if err ! = nil { return err } , err = io . copy ( dst , r ) err2 : = r . close ( ) if err ! = nil { return err } return err2 } 
func ( a * archive ) extracttofile ( dstpath string , name string ) error { f , err : = os . create ( dstpath ) if err ! = nil { return err } defer f . close ( ) return a . extracttowriter ( f , name ) } 
func ( g * guest ) sharedfoldersparentdir ( ) ( string , error ) { var err c . vixerror = c . vix ok var path * c . char err = c . get property ( g . handle , c . vix property guest sharedfolders shares path , unsafe . pointer ( & path ) ) defer c . vix freebuffer ( unsafe . pointer ( path ) ) if c . vix ok ! = err { return " " , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return c . gostring ( path ) , nil } 
func ( g * guest ) copyfiletohost ( guestpath , hostpath string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok gpath : = c . cstring ( guestpath ) hpath : = c . cstring ( hostpath ) defer c . free ( unsafe . pointer ( gpath ) ) defer c . free ( unsafe . pointer ( hpath ) ) jobhandle = c . vixvm copyfilefromguesttohost ( g . handle , gpath , hpath , 0 , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( g * guest ) mktemp ( ) ( string , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var tempfilepath * c . char jobhandle = c . vixvm createtempfileinguest ( g . handle , 0 , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . get temp filepath ( jobhandle , tempfilepath ) defer c . vix freebuffer ( unsafe . pointer ( tempfilepath ) ) if c . vix ok ! = err { return " " , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return c . gostring ( tempfilepath ) , nil } 
func ( g * guest ) rmdir ( path string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok cpath : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cpath ) ) jobhandle = c . vixvm deletedirectoryinguest ( g . handle , cpath , 0 , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( g * guest ) rmfile ( filepath string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok fpath : = c . cstring ( filepath ) defer c . free ( unsafe . pointer ( fpath ) ) jobhandle = c . vixvm deletefileinguest ( g . handle , fpath , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( g * guest ) isdir ( path string ) ( bool , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var result c . int cpath : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cpath ) ) jobhandle = c . vixvm directoryexistsinguest ( g . handle , cpath , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . is file or dir ( jobhandle , & result ) if c . vix ok ! = err { return false , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } if int ( result ) == c . false { return false , nil } return true , nil } 
func ( g * guest ) isfile ( filepath string ) ( bool , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var result c . int fpath : = c . cstring ( filepath ) defer c . free ( unsafe . pointer ( fpath ) ) jobhandle = c . vixvm fileexistsinguest ( g . handle , fpath , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . is file or dir ( jobhandle , & result ) if c . vix ok ! = err { return false , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } if int ( result ) == c . false { return false , nil } return true , nil } 
func ( g * guest ) fileinfo ( filepath string ) ( * guestfile , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var fsize * c . int64 var flags * c . int var modtime * c . int64 fpath : = c . cstring ( filepath ) defer c . free ( unsafe . pointer ( fpath ) ) jobhandle = c . vixvm getfileinfoinguest ( g . handle , fpath , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . get file info ( jobhandle , fsize , flags , modtime ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return & guestfile { path : filepath , size : int64 ( * fsize ) , attrs : fileattr ( * flags ) , modtime : int64 ( * modtime ) , } , nil } 
func ( g * guest ) kill ( pid uint64 ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm killprocessinguest ( g . handle , c . uint64 ( pid ) , 0 , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( g * guest ) logout ( ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm logoutfromguest ( g . handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( g * guest ) runprogram ( path , args string , options runprogramoption ) ( uint64 , int , int , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var pid * c . uint64 var elapsedtime * c . int var exitcode * c . int cpath : = c . cstring ( path ) cargs : = c . cstring ( args ) defer c . free ( unsafe . pointer ( cpath ) ) defer c . free ( unsafe . pointer ( cargs ) ) jobhandle = c . vixvm runprograminguest ( g . handle , cpath , cargs , c . vixrunprogramoptions ( options ) , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . get program output ( jobhandle , pid , elapsedtime , exitcode ) if c . vix ok ! = err { return 0 , 0 , 0 , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return uint64 ( * pid ) , int ( * elapsedtime ) , int ( * exitcode ) , nil } 
func ( g * guest ) mv ( path1 , path2 string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok cpath1 : = c . cstring ( path1 ) cpath2 : = c . cstring ( path2 ) defer c . free ( unsafe . pointer ( cpath1 ) ) defer c . free ( unsafe . pointer ( cpath2 ) ) jobhandle = c . vixvm renamefileinguest ( g . handle , cpath1 , cpath2 , 0 , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( s * snapshot ) name ( ) ( string , error ) { var err c . vixerror = c . vix ok var name * c . char err = c . get property ( s . handle , c . vix property snapshot displayname , unsafe . pointer ( & name ) ) defer c . vix freebuffer ( unsafe . pointer ( name ) ) if c . vix ok ! = err { return " " , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return c . gostring ( name ) , nil } 
func ( s * snapshot ) description ( ) ( string , error ) { var err c . vixerror = c . vix ok var desc * c . char err = c . get property ( s . handle , c . vix property snapshot description , unsafe . pointer ( & desc ) ) defer c . vix freebuffer ( unsafe . pointer ( desc ) ) if c . vix ok ! = err { return " " , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return c . gostring ( desc ) , nil } 
func ( s * snapshot ) child ( index int ) ( * snapshot , error ) { var snapshothandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok err = c . vixsnapshot getchild ( s . handle , c . int ( index ) , & snapshothandle ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } snapshot : = & snapshot { handle : snapshothandle , } runtime . setfinalizer ( snapshot , cleanupsnapshot ) return snapshot , nil } 
func ( s * snapshot ) numchildren ( ) ( int , error ) { var err c . vixerror = c . vix ok var numchildren * c . int err = c . vixsnapshot getnumchildren ( s . handle , numchildren ) if c . vix ok ! = err { return 0 , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return int ( * numchildren ) , nil } 
func cleanupsnapshot ( s * snapshot ) { if s . handle ! = c . vix invalid handle { c . vix releasehandle ( s . handle ) s . handle = c . vix invalid handle } } 
func ( v * vm ) attachcddvd ( drive * cddvddrive ) error { if running , : = v . isrunning ( ) ; running { return & error { operation : " " , code : 200000 , text : " " , } } v . vmxfile . read ( ) model : = v . vmxfile . model device : = vmx . device { } if drive . filename ! = " " { device . filename = drive . filename device . type = vmx . cdrom image } else { device . type = vmx . cdrom raw device . autodetect = true } device . present = true device . startconnected = true if drive . bus == " " { drive . bus = vmx . ide } switch drive . bus { case vmx . ide : model . idedevices = append ( model . idedevices , vmx . idedevice { device : device } ) case vmx . scsi : model . scsidevices = append ( model . scsidevices , vmx . scsidevice { device : device } ) case vmx . sata : model . satadevices = append ( model . satadevices , vmx . satadevice { device : device } ) default : return & error { operation : " " , code : 200001 , text : fmt . sprintf ( " \n " , drive . bus ) , } } return v . vmxfile . write ( ) } 
func ( v * vm ) cddvds ( ) ( [ ] * cddvddrive , error ) { err : = v . vmxfile . read ( ) if err ! = nil { return nil , err } model : = v . vmxfile . model var cddvds [ ] * cddvddrive model . walkdevices ( func ( d vmx . device ) { bus : = bustypefromid ( d . vmxid ) if d . type == vmx . cdrom image | | d . type == vmx . cdrom raw { cddvds = append ( cddvds , & cddvddrive { id : d . vmxid , bus : bus , filename : d . filename , } ) } } ) return cddvds , nil } 
func ( v * vm ) removeallcddvddrives ( ) error { drives , err : = v . cddvds ( ) if err ! = nil { return & error { operation : " " , code : 200004 , text : fmt . sprintf ( " \n " , err ) , } } for , d : = range drives { err : = v . detachcddvd ( d ) if err ! = nil { return & error { operation : " " , code : 200004 , text : fmt . sprintf ( " \n " , d , err ) , } } } return nil } 
func bustypefromid ( id string ) vmx . bustype { var bus vmx . bustype switch { case strings . hasprefix ( id , string ( vmx . ide ) ) : bus = vmx . ide case strings . hasprefix ( id , string ( vmx . scsi ) ) : bus = vmx . scsi case strings . hasprefix ( id , string ( vmx . sata ) ) : bus = vmx . sata } return bus } 
func ( v * vm ) cddvd ( id string ) ( * cddvddrive , error ) { err : = v . vmxfile . read ( ) if err ! = nil { return nil , err } model : = v . vmxfile . model bus : = bustypefromid ( id ) var filename string found : = model . finddevice ( func ( d vmx . device ) bool { if id == d . vmxid { filename = d . filename } return id == d . vmxid } , bus ) if ! found { return nil , nil } return & cddvddrive { bus : bus , filename : filename } , nil } 
func ( vmxfile * vmxfile ) read ( ) error { data , err : = ioutil . readfile ( vmxfile . path ) if err ! = nil { return err } model : = new ( vmx . virtualmachine ) err = vmx . unmarshal ( data , model ) if err ! = nil { return err } vmxfile . model = model return nil } 
func ( vmxfile * vmxfile ) write ( ) error { file , err : = os . create ( vmxfile . path ) if err ! = nil { return err } defer file . close ( ) data , err : = vmx . marshal ( vmxfile . model ) if err ! = nil { return err } , err = file . write ( data ) if err ! = nil { return err } return nil } 
func readvmx ( path string ) ( map [ string ] string , error ) { data , err : = ioutil . readfile ( path ) if err ! = nil { return nil , err } vmx : = make ( map [ string ] string ) for , line : = range strings . split ( string ( data ) , " \n " ) { values : = strings . split ( line , " " ) if len ( values ) == 2 { vmx [ strings . trimspace ( values [ 0 ] ) ] = strings . trim ( strings . trimspace ( values [ 1 ] ) , ' " ' ) } } return vmx , nil } 
func writevmx ( path string , vmx map [ string ] string ) error { f , err : = os . create ( path ) if err ! = nil { return err } defer f . close ( ) keys : = make ( [ ] string , len ( vmx ) ) i : = 0 for k : = range vmx { keys [ i ] = k i ++ } sort . strings ( keys ) var buf bytes . buffer for , key : = range keys { buf . writestring ( key + " " + ' " ' + vmx [ key ] + ' " ' ) buf . writestring ( " \n " ) } if , err = io . copy ( f , & buf ) ; err ! = nil { return err } return nil } 
func newvirtualmachine ( handle c . vixhandle , vmxpath string ) ( * vm , error ) { vmxfile : = & vmxfile { path : vmxpath , } err : = vmxfile . read ( ) if err ! = nil { return nil , err } vm : = & vm { handle : handle , vmxfile : vmxfile , } runtime . setfinalizer ( vm , cleanupvm ) return vm , nil } 
func ( v * vm ) vcpus ( ) ( uint8 , error ) { var err c . vixerror = c . vix ok vcpus : = c . vix property none err = c . get property ( v . handle , c . vix property vm num vcpus , unsafe . pointer ( & vcpus ) ) if c . vix ok ! = err { return 0 , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return uint8 ( vcpus ) , nil } 
func ( v * vm ) vmxpath ( ) ( string , error ) { var err c . vixerror = c . vix ok var path * c . char err = c . get property ( v . handle , c . vix property vm vmx pathname , unsafe . pointer ( & path ) ) defer c . vix freebuffer ( unsafe . pointer ( path ) ) if c . vix ok ! = err { return " " , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return c . gostring ( path ) , nil } 
func ( v * vm ) memorysize ( ) ( uint , error ) { var err c . vixerror = c . vix ok memsize : = c . vix property none err = c . get property ( v . handle , c . vix property vm memory size , unsafe . pointer ( & memsize ) ) if c . vix ok ! = err { return 0 , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return uint ( memsize ) , nil } 
func ( v * vm ) readonly ( ) ( bool , error ) { var err c . vixerror = c . vix ok readonly : = c . vix property none err = c . get property ( v . handle , c . vix property vm read only , unsafe . pointer ( & readonly ) ) if c . vix ok ! = err { return false , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } if readonly == 0 { return false , nil } return true , nil } 
func ( v * vm ) invmteam ( ) ( bool , error ) { var err c . vixerror = c . vix ok inteam : = c . vix property none err = c . get property ( v . handle , c . vix property vm in vmteam , unsafe . pointer ( & inteam ) ) if c . vix ok ! = err { return false , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } if inteam == 0 { return false , nil } return true , nil } 
func ( v * vm ) powerstate ( ) ( vmpowerstate , error ) { var err c . vixerror = c . vix ok var state c . vixpowerstate = 0x0 err = c . get property ( v . handle , c . vix property vm power state , unsafe . pointer ( & state ) ) if c . vix ok ! = err { return vmpowerstate ( 0x0 ) , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return vmpowerstate ( state ) , nil } 
func ( v * vm ) toolsstate ( ) ( guesttoolsstate , error ) { var err c . vixerror = c . vix ok state : = c . vix toolsstate unknown err = c . get property ( v . handle , c . vix property vm tools state , unsafe . pointer ( & state ) ) if c . vix ok ! = err { return toolsstate unknown , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return guesttoolsstate ( state ) , nil } 
func ( v * vm ) isrunning ( ) ( bool , error ) { var err c . vixerror = c . vix ok running : = c . vix property none err = c . get property ( v . handle , c . vix property vm is running , unsafe . pointer ( & running ) ) if c . vix ok ! = err { return false , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } if running == 0 { return false , nil } return true , nil } 
func ( v * vm ) guestos ( ) ( string , error ) { var err c . vixerror = c . vix ok var os * c . char err = c . get property ( v . handle , c . vix property vm guestos , unsafe . pointer ( & os ) ) defer c . vix freebuffer ( unsafe . pointer ( os ) ) if c . vix ok ! = err { return " " , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return c . gostring ( os ) , nil } 
func ( v * vm ) enablesharedfolders ( enabled bool ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var share c . bool = c . false if enabled { share = c . true } jobhandle = c . vixvm enablesharedfolders ( v . handle , share , 0 , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) addsharedfolder ( guestpath , hostpath string , flags sharedfolderoption ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok gpath : = c . cstring ( guestpath ) hpath : = c . cstring ( hostpath ) defer c . free ( unsafe . pointer ( gpath ) ) defer c . free ( unsafe . pointer ( hpath ) ) jobhandle = c . vixvm addsharedfolder ( v . handle , gpath , hpath , c . vixmsgsharedfolderoptions ( flags ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) removesharedfolder ( guestpath string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok gpath : = c . cstring ( guestpath ) defer c . free ( unsafe . pointer ( gpath ) ) jobhandle = c . vixvm removesharedfolder ( v . handle , gpath , 0 , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) screenshot ( ) ( [ ] byte , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var bytecount c . int var screenbits c . char jobhandle = c . vixvm capturescreenimage ( v . handle , c . vix capturescreenformat png , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . get screenshot bytes ( jobhandle , & bytecount , & screenbits ) defer c . vix freebuffer ( unsafe . pointer ( & screenbits ) ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return c . gobytes ( unsafe . pointer ( & screenbits ) , bytecount ) , nil } 
func ( v * vm ) clone ( clonetype clonetype , destvmxfile string ) ( * vm , error ) { var jobhandle c . vixhandle = c . vix invalid handle var clonedhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok dstvmxfile : = c . cstring ( destvmxfile ) defer c . free ( unsafe . pointer ( dstvmxfile ) ) jobhandle = c . vixvm clone ( v . handle , c . vix invalid handle , c . vixclonetype ( clonetype ) , dstvmxfile , 0 , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . get vix handle ( jobhandle , c . vix property job result handle , & clonedhandle , c . vix property none ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return newvirtualmachine ( clonedhandle , destvmxfile ) } 
func cleanupvm ( v * vm ) { if v . handle ! = c . vix invalid handle { c . vix releasehandle ( v . handle ) v . handle = c . vix invalid handle } } 
func ( v * vm ) createsnapshot ( name , description string , options createsnapshotoption ) ( * snapshot , error ) { var jobhandle c . vixhandle = c . vix invalid handle var snapshothandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok sname : = c . cstring ( name ) sdesc : = c . cstring ( description ) defer c . free ( unsafe . pointer ( sname ) ) defer c . free ( unsafe . pointer ( sdesc ) ) jobhandle = c . vixvm createsnapshot ( v . handle , sname , sdesc , c . vixcreatesnapshotoptions ( options ) , c . vix invalid handle , nil , nil ) err = c . get vix handle ( jobhandle , c . vix property job result handle , & snapshothandle , c . vix property none ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } snapshot : = & snapshot { handle : snapshothandle , } runtime . setfinalizer ( snapshot , cleanupsnapshot ) return snapshot , nil } 
func ( v * vm ) removesnapshot ( snapshot * snapshot , options removesnapshotoption ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm removesnapshot ( v . handle , snapshot . handle , c . vixremovesnapshotoptions ( options ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) delete ( options vmdeleteoption ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok if ( options & vmdelete force ) ! = 0 { vmxpath , err : = v . vmxpath ( ) if err ! = nil { return err } err = os . removeall ( vmxpath + " " ) if err ! = nil { return err } } jobhandle = c . vixvm delete ( v . handle , c . vixvmdeleteoptions ( options ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } c . vix releasehandle ( v . handle ) return nil } 
func ( v * vm ) snapshotbyname ( name string ) ( * snapshot , error ) { var snapshothandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok sname : = c . cstring ( name ) defer c . free ( unsafe . pointer ( sname ) ) err = c . vixvm getnamedsnapshot ( v . handle , sname , & snapshothandle ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } snapshot : = & snapshot { handle : snapshothandle } runtime . setfinalizer ( snapshot , cleanupsnapshot ) return snapshot , nil } 
func ( v * vm ) totalrootsnapshots ( ) ( int , error ) { var result c . int var err c . vixerror = c . vix ok err = c . vixvm getnumrootsnapshots ( v . handle , & result ) if c . vix ok ! = err { return 0 , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return int ( result ) , nil } 
func ( v * vm ) totalsharedfolders ( ) ( int , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var numsharedfolders c . int jobhandle = c . vixvm getnumsharedfolders ( v . handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . get num shared folders ( jobhandle , & numsharedfolders ) if c . vix ok ! = err { return 0 , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return int ( numsharedfolders ) , nil } 
func ( v * vm ) rootsnapshot ( index int ) ( * snapshot , error ) { var snapshothandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok err = c . vixvm getrootsnapshot ( v . handle , c . int ( index ) , & snapshothandle ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } snapshot : = & snapshot { handle : snapshothandle } runtime . setfinalizer ( snapshot , cleanupsnapshot ) return snapshot , nil } 
func ( v * vm ) setsharedfolderstate ( name , hostpath string , options sharedfolderoption ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok sfname : = c . cstring ( name ) hpath : = c . cstring ( hostpath ) defer c . free ( unsafe . pointer ( sfname ) ) defer c . free ( unsafe . pointer ( hpath ) ) jobhandle = c . vixvm setsharedfolderstate ( v . handle , sfname , hpath , c . vixmsgsharedfolderoptions ( options ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } c . vix releasehandle ( v . handle ) return nil } 
func ( v * vm ) sharedfolderstate ( index int ) ( string , string , int , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var ( foldername , folderhostpath * c . char folderflags * c . int ) jobhandle = c . vixvm getsharedfolderstate ( v . handle , c . int ( index ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . get shared folder ( jobhandle , foldername , folderhostpath , folderflags ) defer c . vix freebuffer ( unsafe . pointer ( foldername ) ) defer c . vix freebuffer ( unsafe . pointer ( folderhostpath ) ) if c . vix ok ! = err { return " " , " " , 0 , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } c . vix releasehandle ( v . handle ) return c . gostring ( foldername ) , c . gostring ( folderhostpath ) , int ( * folderflags ) , nil } 
func ( v * vm ) poweroff ( options vmpoweroption ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm poweroff ( v . handle , c . vixvmpoweropoptions ( options ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) suspend ( ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm suspend ( v . handle , 0 , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) readvariable ( vartype guestvartype , name string ) ( string , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok var readvalue * c . char vname : = c . cstring ( name ) defer c . free ( unsafe . pointer ( vname ) ) jobhandle = c . vixvm readvariable ( v . handle , c . int ( vartype ) , vname , 0 , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . read variable ( jobhandle , & readvalue ) if c . vix ok ! = err { return " " , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } defer c . vix freebuffer ( unsafe . pointer ( readvalue ) ) return c . gostring ( readvalue ) , nil } 
func ( v * vm ) writevariable ( vartype guestvartype , name , value string ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok vname : = c . cstring ( name ) vvalue : = c . cstring ( value ) defer c . free ( unsafe . pointer ( vname ) ) defer c . free ( unsafe . pointer ( vvalue ) ) jobhandle = c . vixvm writevariable ( v . handle , c . int ( vartype ) , vname , vvalue , 0 , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) reverttosnapshot ( snapshot * snapshot , options vmpoweroption ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm reverttosnapshot ( v . handle , snapshot . handle , 0 , c . vix invalid handle , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) logininguest ( username , password string , options guestloginoption ) ( * guest , error ) { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok u : = c . cstring ( username ) p : = c . cstring ( password ) defer c . free ( unsafe . pointer ( u ) ) defer c . free ( unsafe . pointer ( p ) ) jobhandle = c . vixvm logininguest ( v . handle , u , p , c . int ( options ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } guest : = & guest { handle : v . handle , } return guest , nil } 
func ( v * vm ) installtools ( options installtoolsoption ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm installtools ( v . handle , c . int ( options ) , nil , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) waitfortoolsinguest ( timeout time . duration ) error { var jobhandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok jobhandle = c . vixvm waitfortoolsinguest ( v . handle , c . int ( timeout . seconds ( ) ) , nil , nil ) defer c . vix releasehandle ( jobhandle ) err = c . vix job wait ( jobhandle ) if c . vix ok ! = err { return & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } return nil } 
func ( v * vm ) updatevmx ( updatefunc func ( model * vmx . virtualmachine ) error ) error { isvmrunning , err : = v . isrunning ( ) if err ! = nil { return err } if isvmrunning { return & error { operation : " " , code : 100000 , text : " " , } } err = v . vmxfile . read ( ) if err ! = nil { return & error { operation : " " , code : 300001 , text : fmt . sprintf ( " " , err ) , } } err = updatefunc ( v . vmxfile . model ) if err ! = nil { return & error { operation : " " , code : 300002 , text : fmt . sprintf ( " " , err ) , } } err = v . vmxfile . write ( ) if err ! = nil { return & error { operation : " " , code : 300003 , text : fmt . sprintf ( " " , err ) , } } return nil } 
func ( v * vm ) setmemorysize ( size uint ) error { if size == 0 { size = 4 } if size % 4 ! = 0 { size = uint ( math . floor ( float64 ( ( size / 4 ) * 4 ) ) ) } return v . updatevmx ( func ( model * vmx . virtualmachine ) error { model . memsize = size return nil } ) } 
func ( v * vm ) setnumbervcpus ( vcpus uint ) error { if vcpus < 1 { vcpus = 1 } return v . updatevmx ( func ( model * vmx . virtualmachine ) error { model . numvcpus = vcpus return nil } ) } 
func ( v * vm ) setdisplayname ( name string ) error { return v . updatevmx ( func ( model * vmx . virtualmachine ) error { model . displayname = name return nil } ) } 
func ( v * vm ) setannotation ( text string ) error { return v . updatevmx ( func ( model * vmx . virtualmachine ) error { model . annotation = text return nil } ) } 
func ( v * vm ) setvirtualhwversion ( version string ) error { return v . updatevmx ( func ( model * vmx . virtualmachine ) error { version , err : = strconv . parseint ( version , 10 , 32 ) if err ! = nil { return err } model . vhardware . compat = " " model . vhardware . version = int ( version ) return nil } ) } 
func connect ( config connectconfig ) ( * host , error ) { var jobhandle c . vixhandle = c . vix invalid handle var hosthandle c . vixhandle = c . vix invalid handle var err c . vixerror = c . vix ok chostname : = c . cstring ( config . hostname ) cusername : = c . cstring ( config . username ) cpassword : = c . cstring ( config . password ) defer c . free ( unsafe . pointer ( chostname ) ) defer c . free ( unsafe . pointer ( cusername ) ) defer c . free ( unsafe . pointer ( cpassword ) ) jobhandle = c . vixhost connect ( c . vix api version , c . vixserviceprovider ( config . provider ) , chostname , c . int ( config . port ) , cusername , cpassword , c . vixhostoptions ( config . options ) , c . vix invalid handle , nil , nil ) err = c . get vix handle ( jobhandle , c . vix property job result handle , & hosthandle , c . vix property none ) defer c . vix releasehandle ( jobhandle ) if c . vix ok ! = err { return nil , & error { operation : " " , code : int ( err & 0xffff ) , text : c . gostring ( c . vix geterrortext ( err , nil ) ) , } } host : = & host { handle : hosthandle , provider : config . provider , } return host , nil } 
func ( e * error ) error ( ) string { return fmt . sprintf ( " " , e . text , e . code , e . operation ) } 
func errorf ( message string , a ... interface { } ) error { return wrap ( fmt . errorf ( message , a ... ) ) } 
func ( t * traceableerror ) error ( ) string { str : = t . err . error ( ) for , frame : = range t . stack { str += fmt . sprintf ( " \n " , frame . string ( ) ) } return str } 
func ( s * stackframe ) string ( ) string { return fmt . sprintf ( " " , s . function , s . file , s . line ) } 
func newstackframe ( pc uintptr ) * stackframe { fn : = runtime . funcforpc ( pc ) file , line : = fn . fileline ( pc ) packagepath , funcsignature : = parsefuncname ( fn . name ( ) ) , filename : = filepath . split ( file ) return & stackframe { file : filepath . join ( packagepath , filename ) , line : line , function : funcsignature , } } 
func capturestack ( skip , maxdepth int ) [ ] * stackframe { pcs : = make ( [ ] uintptr , maxdepth ) count : = runtime . callers ( skip + 1 , pcs ) frames : = make ( [ ] * stackframe , count ) for i , pc : = range pcs [ 0 : count ] { frames [ i ] = newstackframe ( pc ) } return frames } 
func parsefuncname ( fnname string ) ( packagepath , signature string ) { regex : = regexp . mustcompile ( " \ \ \ \ " ) parts : = regex . findstringsubmatch ( fnname ) packagepath = parts [ 1 ] signature = parts [ 2 ] return } 
func stack ( err interface { } ) { stack : = make ( [ ] byte , 64 < < 10 ) stack = stack [ : runtime . stack ( stack , false ) ] log . printf ( " \n " , err , stack ) } 
func stackwithcaller ( err interface { } ) { stack : = make ( [ ] byte , 64 < < 10 ) stack = stack [ : runtime . stack ( stack , false ) ] if pack , ok : = callerpackage ( ) ; ok { log . printf ( " \n " , pack , err , stack ) } else { log . printf ( " \n " , err , stack ) } } 
func ( w responsewriterbinder ) write ( p [ ] byte ) ( int , error ) { for , f : = range w . before { f ( p ) } return w . writer . write ( p ) } 
func bindresponsewriter ( w io . writer , c * core . context , before ... func ( [ ] byte ) ) { c . responsewriter = responsewriterbinder { w , c . responsewriter , before } } 
func setdetectedcontenttype ( w http . responsewriter , p [ ] byte ) string { ct : = w . header ( ) . get ( " " ) if ct == " " { ct = http . detectcontenttype ( p ) w . header ( ) . set ( " " , ct ) } return ct } 
func ( e * servererror ) new ( message string ) * servererror { e . httpcode = http . statusinternalservererror e . errno = 0 e . message = message return e } 
func ( e * validationerror ) new ( message string ) * validationerror { e . httpcode = http . statusbadrequest e . errno = 0 e . message = message return e } 
func ( e * notfounderror ) new ( message string ) * notfounderror { e . httpcode = http . statusnotfound e . errno = 0 e . message = message return e } 
func ( c * controller ) err ( errno int , message string ) error { return ( & businesserror { } ) . new ( errno , message ) } 
func ( c * controller ) intmin ( fieldname string , p interface { } , n int ) int { if p == nil { p = " " } value , ok : = c . tonumber ( p ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } b : = c . validate . min ( value , n ) if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " o v itoa ( n ) ) ) } return value } 
func ( c * controller ) intmax ( fieldname string , p interface { } , m int ) int { if p == nil { p = " " } value , ok : = c . tonumber ( p ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } b : = c . validate . max ( value , m ) if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " o v itoa ( m ) ) ) } return value } 
func ( c * controller ) intrange ( fieldname string , p interface { } , n int , m int ) int { if p == nil { p = 0 } value , ok : = c . tonumber ( p ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } b : = c . validate . range ( value , n , m ) if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " o ( " + s t r o v ( ) ) } return value } 
func ( c * controller ) int64range ( fieldname string , p interface { } , n int64 , m int64 ) int64 { if p == nil { p = 0 } value , ok : = c . tonumber64 ( p ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } b : = c . validate . range64 ( value , n , m ) if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " r a int ( n , 1 " + st r o v a i t ( m , 10 ) ) ) } return value } 
func ( c * controller ) intrangezoom ( fieldname string , p interface { } , n int , m int , zoom int ) int { if p == nil { p = 0 } value , ok : = c . tonumber ( p ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } b : = c . validate . range ( value , n , m ) if b == false { fn : = fmt . sprintf ( " " , float64 ( n ) / float64 ( zoom ) ) fm : = fmt . sprintf ( " " , float64 ( m ) / float64 ( zoom ) ) panic ( ( & validationerror { } ) . new ( fieldname + " m ) } return value } 
func ( c * controller ) strlength ( fieldname string , p interface { } , n int ) string { if p == nil { p = " " } v , ok : = p . ( string ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " v i oa ( n ) ) ) } b : = c . validate . length ( v , n ) if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " v i oa ( n ) ) ) } return v } 
func ( c * controller ) strlenrange ( fieldname string , p interface { } , n int , m int ) string { if p == nil { p = " " } v , ok : = p . ( string ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } length : = utf8 . runecountinstring ( v ) if length > m | | length < n { panic ( ( & validationerror { } ) . new ( fieldname + " v i oa ( n ) + + s r o i o ( m ) ) ) } return v } 
func ( c * controller ) strlenin ( fieldname string , p interface { } , l ... int ) string { if p == nil { p = " " } v , ok : = p . ( string ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } length : = utf8 . runecountinstring ( v ) b : = false for i : = 0 ; i < len ( l ) ; i ++ { if l [ i ] == length { b = true } } if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " p a e ( strin g s . trim ( f mt . spri n t ( l ) , " [ ] " ) , " " , " " - 1 ) + " ) } return v } 
func ( c * controller ) strin ( fieldname string , p interface { } , l ... string ) string { if p == nil { p = " " } v , ok : = p . ( string ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } b : = false for i : = 0 ; i < len ( l ) ; i ++ { if l [ i ] == v { b = true } } if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " n s replace ( strings . trim ( fm t . spr i nt ( l ) , " [ ] " ) , " , , - 1 " " ) ) } return v } 
func ( c * controller ) getemail ( fieldname string , p interface { } ) string { if p == nil { p = " " } v , ok : = p . ( string ) if ok == false { panic ( ( & validationerror { } ) . new ( fieldname + " } b : = c . validate . email ( v ) if b == false { panic ( ( & validationerror { } ) . new ( fieldname + " } return v } 
func mostspecifictype ( types [ ] string ) ( string , error ) { if len ( types ) == 0 { return " " , errors . new ( " " ) } sorted , err : = sorttypes ( types ) if err ! = nil { return " " , err } return sorted [ len ( sorted ) - 1 ] , nil } 
func fulltypehierarchy ( highestleveltype string ) [ ] string { var typehierarchy [ ] string t : = strings . split ( highestleveltype , " " ) typetocheck : = t [ len ( t ) - 1 ] for { typehierarchy = append ( typehierarchy , typetocheck ) parenttype : = parenttype ( typetocheck ) if parenttype ! = " " { typetocheck = parenttype } else { return typeuris ( typehierarchy ) } } } 
func sorttypes ( types [ ] string ) ( [ ] string , error ) { ts : = & typesorter { types : make ( [ ] string , len ( types ) ) } copy ( ts . types , types ) sort . sort ( ts ) if ts . invalid { return types , errnothierarchy } return ts . types , nil } 
func ( rs * redisstore ) delete ( key string ) error { delete ( rs . values , key ) err : = provider . refresh ( rs ) return err } 
func ( rp * redisprovider ) set ( key string , values map [ string ] string ) ( * redisstore , error ) { rs : = & redisstore { sid : key , values : values } err : = provider . refresh ( rs ) return rs , err } 
func ( rp * redisprovider ) refresh ( rs * redisstore ) error { var err error redispool . exec ( func ( c * redis . client ) { err = c . hmset ( rs . sid , rs . values ) . err ( ) if err ! = nil { return } err = c . expire ( rs . sid , sessexpire ) . err ( ) } ) return nil } 
func ( rp * redisprovider ) get ( sid string ) ( * redisstore , error ) { var rs = & redisstore { } var val map [ string ] string var err error redispool . exec ( func ( c * redis . client ) { val , err = c . hgetall ( sid ) . result ( ) rs . values = val } ) return rs , err } 
func ( rp * redisprovider ) destroy ( sid string ) error { var err error redispool . exec ( func ( c * redis . client ) { err = c . del ( sid ) . err ( ) } ) return err } 
func ( rp * redisprovider ) upexpire ( sid string ) error { var err error redispool . exec ( func ( c * redis . client ) { err = c . expire ( sid , sessexpire ) . err ( ) } ) return err } 
func ( hs * handlersstack ) use ( h routerhandler ) { hs . handlers = append ( hs . handlers , h ) } 
func ( group * routergroup ) use ( middleware ... routerhandler ) iroutes { group . handlers = append ( group . handlers , middleware ... ) return group . returnobj ( ) } 
func ( group * routergroup ) group ( relativepath string , handlers ... routerhandler ) * routergroup { return & routergroup { handlers : group . combinehandlers ( handlers ) , basepath : group . calculateabsolutepath ( relativepath ) , engine : group . engine , } } 
func apiurl ( uuid string , labels [ ] string , env string ) string { base : = " " if env == " " { base = " " } path : = " " mostspecific , err : = mostspecifictype ( labels ) if err == nil { for t : = mostspecific ; t ! = " " && path == " " ; t = parenttype ( t ) { path = apipaths [ t ] } } if path == " " { path = " " } return base + path + " " + uuid } 
func run ( ) { for , f : = range beforerun { f ( ) } if opencommandline { flag . stringvar ( & address , " " , " " , " " ) flag . boolvar ( & production , " " , false , " " ) flag . parse ( ) } log . warnln ( fmt . sprintf ( " " , address , os . getpid ( ) , production ) ) use ( routers . handlers ) srv : = & graceful . server { listenlimit : listenlimit , connstate : func ( conn net . conn , state http . connstate ) { } , server : & http . server { addr : address , handler : defaulthandlersstack , readtimeout : readtimeout , writetimeout : writetimeout , idletimeout : idletimeout , maxheaderbytes : maxheaderbytes , } , } err : = srv . listenandserve ( ) if err ! = nil { log . fatalln ( err ) } log . warnln ( " " ) } 
func create ( ) * engine { engine : = & engine { routergroup : routergroup { handlers : nil , basepath : " " , root : true , } , trees : make ( methodtrees , 0 , 9 ) , } engine . routergroup . engine = engine return engine } 
func ( ctx * context ) redirect ( url string , code int ) { http . redirect ( ctx . responsewriter , ctx . request , url , code ) } 
func ( ctx * context ) fail ( err error ) { if err == nil { log . withfields ( log . fields { " " : ctx . request . url . path } ) . warnln ( " " ) ctx . responsewriter . writeheader ( http . statusinternalservererror ) ctx . responsewriter . write ( nil ) return } if ctx . written == true { log . withfields ( log . fields { " " : ctx . request . url . path } ) . warnln ( " " ) return } errno : = 0 errcore , ok : = err . ( icoreerror ) if ok == true { errno = errcore . geterrno ( ) } ctx . written = true if production == false { log . withfields ( log . fields { " " : ctx . request . url . path } ) . warnln ( err . error ( ) ) } else if , ok : = err . ( * servererror ) ; ok == true { log . withfields ( log . fields { " " : ctx . request . url . path } ) . warnln ( err . error ( ) ) } var json = jsoniter . configcompatiblewithstandardlibrary b , : = json . marshal ( & resformat { ok : false , message : err . error ( ) , errno : errno } ) coreerr , ok : = err . ( icoreerror ) if ok == true { ctx . responsewriter . writeheader ( coreerr . gethttpcode ( ) ) } else { ctx . responsewriter . writeheader ( http . statusinternalservererror ) } ctx . responsewriter . write ( b ) } 
func ( ctx * context ) next ( ) { if ! ctx . written ( ) && ctx . index < len ( ctx . handlersstack . handlers ) - 1 { ctx . index ++ ctx . handlersstack . handlers [ ctx . index ] ( ctx ) } } 
func ( ctx * context ) param ( key string ) string { return ctx . params . byname ( key ) } 
func ( ctx * context ) getsession ( ) istore { store : = ctx . data [ " " ] if store == nil { return nil } st , ok : = store . ( istore ) if ok == false { return nil } return st } 
func ( ctx * context ) getbodyjson ( ) { var reqjson map [ string ] interface { } body , : = ioutil . readall ( ctx . request . body ) defer ctx . request . body . close ( ) ctype : = ctx . request . header . get ( " " ) a : = strings . split ( ctype , " " ) if a [ 0 ] == " " { reqjson = make ( map [ string ] interface { } ) reqstr : = string ( body ) reqarr : = strings . split ( reqstr , " " ) for , v : = range reqarr { param : = strings . split ( v , " " ) reqjson [ param [ 0 ] ] , = url . queryunescape ( param [ 1 ] ) } } else { json . unmarshal ( body , & reqjson ) } ctx . bodyjson = reqjson } 
func ( ctx * context ) setsession ( key string , values map [ string ] string ) error { sid : = ctx . gensid ( key ) values [ " " ] = sid timestamp : = strconv . formatint ( time . now ( ) . unix ( ) , 10 ) token : = ctx . gensid ( key + timestamp ) values [ " " ] = token store , err : = provider . set ( sid , values ) if err ! = nil { return err } cookie : = httpcookie cookie . value = sid ctx . data [ " " ] = store respcookie : = ctx . responsewriter . header ( ) . get ( " " ) if strings . hasprefix ( respcookie , cookie . name ) { ctx . responsewriter . header ( ) . del ( " " ) } http . setcookie ( ctx . responsewriter , & cookie ) return nil } 
func ( ctx * context ) freshsession ( key string ) error { err : = provider . upexpire ( key ) if err ! = nil { return err } return nil } 
func ( ctx * context ) deletesession ( ) error { sid : = ctx . data [ " " ] . ( string ) ctx . data [ " " ] = nil provider . destroy ( sid ) cookie : = httpcookie cookie . maxage = - 1 http . setcookie ( ctx . responsewriter , & cookie ) return nil } 
func ( ctx * context ) recover ( ) { if err : = recover ( ) ; err ! = nil { if e , ok : = err . ( * validationerror ) ; ok == true { ctx . fail ( e ) return } stack : = make ( [ ] byte , 64 < < 10 ) n : = runtime . stack ( stack [ : ] , false ) log . withfields ( log . fields { " " : ctx . request . url . path } ) . errorln ( string ( stack [ : n ] ) ) if ! ctx . written ( ) { ctx . responsewriter . header ( ) . del ( " " ) if ctx . handlersstack . panichandler ! = nil { ctx . data [ " " ] = err ctx . handlersstack . panichandler ( ctx ) } else { ctx . fail ( ( & servererror { } ) . new ( http . statustext ( http . statusinternalservererror ) ) ) } } } } 
func ( w contextwriter ) write ( p [ ] byte ) ( int , error ) { w . context . written = true return w . responsewriter . write ( p ) } 
func ( w contextwriter ) writeheader ( code int ) { w . context . written = true w . responsewriter . writeheader ( code ) } 
func ( m * model ) err ( errno int , message string ) error { return validationerror . new ( message ) } 
func new ( pempath string , options ... func ( * client ) error ) * client { c : = client { pempath : pempath , requesttimeout : defaultrequesttimeout , } c . printdebug = false for , option : = range options { err : = option ( & c ) if err ! = nil { return nil } } return & c } 
func allowlargeresults ( shouldallow bool , temptablename string , flattenresults bool ) func ( * client ) error { return func ( c * client ) error { return c . setallowlargeresults ( shouldallow , temptablename , flattenresults ) } } 
func ( c * client ) setallowlargeresults ( shouldallow bool , temptablename string , flattenresults bool ) error { c . allowlargeresults = shouldallow c . temptablename = temptablename c . flattenresults = flattenresults return nil } 
func ( c * client ) connect ( ) ( * bigquery . service , error ) { if c . token ! = nil { if ! c . token . valid ( ) && c . service ! = nil { return c . service , nil } } pemkeybytes , err : = ioutil . readfile ( c . pempath ) if err ! = nil { panic ( err ) } t , err : = google . jwtconfigfromjson ( pemkeybytes , " " ) client : = t . client ( oauth2 . nocontext ) service , err : = bigquery . new ( client ) if err ! = nil { return nil , err } c . service = service return service , nil } 
func ( c * client ) insertrow ( projectid , datasetid , tableid string , rowdata map [ string ] interface { } ) error { service , err : = c . connect ( ) if err ! = nil { return err } insertrequest : = buildbigqueryinsertrequest ( [ ] map [ string ] interface { } { rowdata } ) result , err : = service . tabledata . insertall ( projectid , datasetid , tableid , insertrequest ) . do ( ) if err ! = nil { c . printdebug ( " " , err ) return err } if len ( result . inserterrors ) > 0 { return errors . new ( " " ) } return nil } 
func ( c * client ) asyncquery ( pagesize int , dataset , project , querystr string , datachan chan data ) { c . pagedquery ( pagesize , dataset , project , querystr , datachan ) } 
func ( c * client ) query ( dataset , project , querystr string ) ( [ ] [ ] interface { } , [ ] string , error ) { return c . pagedquery ( defaultpagesize , dataset , project , querystr , nil ) } 
func ( c * client ) stdpagedquery ( service * bigquery . service , pagesize int , dataset , project , querystr string , datachan chan data ) ( [ ] [ ] interface { } , [ ] string , error ) { c . printdebug ( " " ) datasetref : = & bigquery . datasetreference { datasetid : dataset , projectid : project , } query : = & bigquery . queryrequest { defaultdataset : datasetref , maxresults : int64 ( pagesize ) , kind : " " , query : querystr , } qr , err : = service . jobs . query ( project , query ) . do ( ) headers , rows : = c . headersandrows ( qr . schema , qr . rows ) if err ! = nil { c . printdebug ( " " , err ) if datachan ! = nil { datachan < - data { err : err } } return nil , nil , err } return c . processpagedquery ( qr . jobreference , qr . pagetoken , datachan , headers , rows ) } 
func ( c * client ) pagedquery ( pagesize int , dataset , project , querystr string , datachan chan data ) ( [ ] [ ] interface { } , [ ] string , error ) { service , err : = c . connect ( ) if err ! = nil { if datachan ! = nil { datachan < - data { err : err } } return nil , nil , err } if c . allowlargeresults && len ( c . temptablename ) > 0 { return c . largedatapagedquery ( service , pagesize , dataset , project , querystr , datachan ) } return c . stdpagedquery ( service , pagesize , dataset , project , querystr , datachan ) } 
func ( c * client ) pageoverjob ( rowcount int , jobref * bigquery . jobreference , pagetoken string , resultchan chan [ ] [ ] interface { } , headerschan chan [ ] string ) error { service , err : = c . connect ( ) if err ! = nil { return err } qrc : = service . jobs . getqueryresults ( jobref . projectid , jobref . jobid ) if len ( pagetoken ) > 0 { qrc . pagetoken ( pagetoken ) } qr , err : = qrc . do ( ) if err ! = nil { c . printdebug ( " " , err ) close ( resultchan ) return err } if qr . jobcomplete { c . printdebug ( " " ) headers , rows : = c . headersandrows ( qr . schema , qr . rows ) if headerschan ! = nil { headerschan < - headers close ( headerschan ) } c . printdebug ( " " ) resultchan < - rows rowcount = rowcount + len ( rows ) c . printdebug ( " " , rowcount ) } if qr . totalrows > uint64 ( rowcount ) | | ! qr . jobcomplete { c . printdebug ( " " ) if qr . jobreference == nil { c . pageoverjob ( rowcount , jobref , pagetoken , resultchan , headerschan ) } else { c . pageoverjob ( rowcount , qr . jobreference , qr . pagetoken , resultchan , nil ) } } else { close ( resultchan ) return nil } return nil } 
func ( c * client ) syncquery ( dataset , project , querystr string , maxresults int64 ) ( [ ] [ ] interface { } , error ) { service , err : = c . connect ( ) if err ! = nil { return nil , err } datasetref : = & bigquery . datasetreference { datasetid : dataset , projectid : project , } query : = & bigquery . queryrequest { defaultdataset : datasetref , maxresults : maxresults , kind : " " , query : querystr , } results , err : = service . jobs . query ( project , query ) . do ( ) if err ! = nil { c . printdebug ( " " , err ) return nil , err } numrows : = int ( results . totalrows ) if numrows > int ( maxresults ) { numrows = int ( maxresults ) } , rows : = c . headersandrows ( results . schema , results . rows ) return rows , nil } 
func ( c * client ) count ( dataset , project , datasettable string ) int64 { qstr : = fmt . sprintf ( " " , datasettable ) res , err : = c . syncquery ( dataset , project , qstr , 1 ) if err == nil { if len ( res ) > 0 { val , : = strconv . parseint ( res [ 0 ] [ 0 ] . ( string ) , 10 , 64 ) return val } } return 0 } 
func ( c * client ) insertnewtable ( projectid , datasetid , tablename string , fields map [ string ] string ) error { service , err : = c . connect ( ) if err ! = nil { return err } schema : = & bigquery . tableschema { } for k , v : = range fields { schema . fields = append ( schema . fields , & bigquery . tablefieldschema { name : k , type : v } ) } table : = & bigquery . table { } table . schema = schema tr : = & bigquery . tablereference { } tr . datasetid = datasetid tr . projectid = projectid tr . tableid = tablename table . tablereference = tr , err = service . tables . insert ( projectid , datasetid , table ) . do ( ) if err ! = nil { return err } return nil } 
func work ( args ... interface { } ) interface { } { url : = args [ 0 ] . ( string ) depth : = args [ 1 ] . ( int ) fetcher : = args [ 2 ] . ( fetcher ) if depth <= 0 { return crawlresult { } } body , urls , err : = fetcher . fetch ( url ) return crawlresult { body , urls , err } } 
func ( pool * pool ) subworker ( job * job ) { defer func ( ) { if err : = recover ( ) ; err ! = nil { log . println ( " " , err ) job . result = nil job . err = fmt . errorf ( err . ( string ) ) } } ( ) job . result = job . f ( job . args ... ) } 
func ( pool * pool ) worker ( worker id uint ) { job pipe : = make ( chan * job ) worker loop : for { pool . job wanted pipe < - job pipe job : = < - job pipe if job == nil { time . sleep ( pool . interval * time . millisecond ) } else { job . worker id = worker id pool . subworker ( job ) pool . done pipe < - job } select { case < - pool . worker kill pipe : break worker loop default : } } pool . worker wg . done ( ) } 
func new ( workers int ) ( pool * pool ) { pool = new ( pool ) pool . num workers = workers pool . job wanted pipe = make ( chan chan * job ) pool . done pipe = make ( chan * job ) pool . add pipe = make ( chan * job ) pool . result wanted pipe = make ( chan chan * job ) pool . jobs ready to run = list . new ( ) pool . jobs completed = list . new ( ) pool . working wanted pipe = make ( chan chan bool ) pool . stats wanted pipe = make ( chan chan stats ) pool . worker kill pipe = make ( chan bool ) pool . supervisor kill pipe = make ( chan bool ) pool . interval = 1 pool . next job id = 0 pool . startsupervisor ( ) return } 
func ( pool * pool ) supervisor ( ) { supervisor loop : for { select { case job : = < - pool . add pipe : pool . jobs ready to run . pushback ( job ) pool . num jobs submitted ++ job . added < - true case job pipe : = < - pool . job wanted pipe : element : = pool . jobs ready to run . front ( ) var job * job = nil if element ! = nil { job = element . value . ( * job ) pool . num jobs running ++ pool . jobs ready to run . remove ( element ) } job pipe < - job case job : = < - pool . done pipe : pool . num jobs running -- pool . jobs completed . pushback ( job ) pool . num jobs completed ++ case result pipe : = < - pool . result wanted pipe : close pipe : = false job : = ( * job ) ( nil ) element : = pool . jobs completed . front ( ) if element ! = nil { job = element . value . ( * job ) pool . jobs completed . remove ( element ) } else { if pool . num jobs running == 0 && pool . num jobs completed == pool . num jobs submitted { close pipe = true } } if close pipe { close ( result pipe ) } else { result pipe < - job } case working pipe : = < - pool . working wanted pipe : working : = true if pool . jobs ready to run . len ( ) == 0 && pool . num jobs running == 0 { working = false } working pipe < - working case stats pipe : = < - pool . stats wanted pipe : pool stats : = stats { pool . num jobs submitted , pool . num jobs running , pool . num jobs completed } stats pipe < - pool stats case < - pool . supervisor kill pipe : break supervisor loop } } pool . supervisor wg . done ( ) } 
func ( pool * pool ) run ( ) { if pool . workers started { panic ( " " ) } for i : = uint ( 0 ) ; i < uint ( pool . num workers ) ; i ++ { pool . worker wg . add ( 1 ) go pool . worker ( i ) } pool . workers started = true if ! pool . supervisor started { pool . startsupervisor ( ) } } 
func ( pool * pool ) stop ( ) { if ! pool . workers started { panic ( " " ) } for i : = 0 ; i < pool . num workers ; i ++ { pool . worker kill pipe < - true } pool . worker wg . wait ( ) pool . workers started = false if pool . supervisor started { pool . stopsupervisor ( ) } } 
func ( pool * pool ) add ( f func ( ... interface { } ) interface { } , args ... interface { } ) { job : = & job { f , args , nil , nil , make ( chan bool ) , 0 , pool . getnextjobid ( ) } pool . add pipe < - job < - job . added } 
func ( pool * pool ) wait ( ) { working pipe : = make ( chan bool ) for { pool . working wanted pipe < - working pipe if ! < - working pipe { break } time . sleep ( pool . interval * time . millisecond ) } } 
func ( pool * pool ) results ( ) ( res [ ] * job ) { res = make ( [ ] * job , pool . jobs completed . len ( ) ) i : = 0 for e : = pool . jobs completed . front ( ) ; e ! = nil ; e = e . next ( ) { res [ i ] = e . value . ( * job ) i ++ } pool . jobs completed = list . new ( ) return } 
func ( pool * pool ) waitforjob ( ) * job { result pipe : = make ( chan * job ) var job * job var ok bool for { pool . result wanted pipe < - result pipe job , ok = < - result pipe if ! ok { return nil } if job == ( * job ) ( nil ) { time . sleep ( pool . interval * time . millisecond ) } else { break } } return job } 
func ( pool * pool ) status ( ) stats { stats pipe : = make ( chan stats ) if pool . supervisor started { pool . stats wanted pipe < - stats pipe return < - stats pipe } return stats { } } 
func method ( m map [ string ] handlerfunc ) handlerfunc { f : = func ( ctx * context ) error { h , ok : = m [ ctx . request . method ] if ok { return h ( ctx ) } ctx . response . status = http . statusmethodnotallowed return nil } return f } 
func chain ( h ... handlerfunc ) handlerfunc { f : = func ( ctx * context ) error { for , v : = range h { if err : = v ( ctx ) ; err ! = nil { return err } } return nil } return f } 
func rand ( h ... handlerfunc ) handlerfunc { f : = func ( ctx * context ) error { if err : = h [ rand . intn ( len ( h ) ) ] ( ctx ) ; err ! = nil { return err } return nil } return f } 
func websockethandlerfunc ( f func ( ws * websocket . conn ) ) handlerfunc { h : = websocket . handler ( f ) return wraphttphandlerfunc ( h . servehttp ) } 
func staticfile ( filename string , contenttype string ) staticfile { if contenttype == " " { contenttype = mime . typebyextension ( path . ext ( filename ) ) } header : = make ( http . header ) header . set ( " " , contenttype ) return staticfile { filename , header } } 
func preloadfile ( filename string , contenttype string ) ( preloadfile , error ) { body , err : = ioutil . readfile ( filename ) if err ! = nil { return preloadfile { } , err } if contenttype == " " { contenttype = mime . typebyextension ( path . ext ( filename ) ) } header : = make ( http . header ) header . set ( " " , contenttype ) return preloadfile { body , header } , nil } 
func regex ( path string ) * regex { r , err : = regexp . compile ( path ) if err ! = nil { panic ( err ) } return & regex { r : r , } } 
func wildcard ( path string ) * wildcard { matches : = strings . split ( path , " " ) return & wildcard { matches : matches , } } 
func colon ( path string ) * colon { matches : = strings . split ( path , " " ) return & colon { matches : matches , } } 
func inithtmltemplates ( pattern string ) ( err error ) { htmltemp . template , err = html . parseglob ( pattern ) return } 
func inittexttemplates ( pattern string ) ( err error ) { texttemp . template , err = text . parseglob ( pattern ) return nil } 
func html ( name , contenttype , charset string ) template { if htmltemp . template == nil { panic ( " " ) } if contenttype == " " { contenttype = contenttypehtml } if charset == " " { charset = charsetutf8 } header : = make ( http . header ) header . set ( " " , fmt . sprintf ( " " , contenttype , charset ) ) return template { & htmltemp , name , header } } 
func text ( name , contenttype , charset string ) template { if texttemp . template == nil { panic ( " " ) } if contenttype == " " { contenttype = contenttypeplain } if charset == " " { charset = charsetutf8 } header : = make ( http . header ) header . set ( " " , fmt . sprintf ( " " , contenttype , charset ) ) return template { & texttemp , name , header } } 
func initwatcher ( pattern string , f func ( string ) error , ef func ( error ) ) ( err error ) { if err = f ( pattern ) ; err ! = nil { return } if watcher . watcher == nil { watcher . watcher , err = fsnotify . newwatcher ( ) if err ! = nil { return } watcher . closer = make ( chan bool ) } go func ( ) { atomic . adduint32 ( & watcher . count , 1 ) for { select { case < - watcher . events : if err : = f ( pattern ) ; err ! = nil { ef ( err ) } case err : = < - watcher . errors : if ef ! = nil { ef ( err ) } case < - watcher . closer : break } } } ( ) var matches [ ] string matches , err = filepath . glob ( pattern ) if err ! = nil { return } for , v : = range matches { if err = watcher . add ( v ) ; err ! = nil { return } } return } 
func closewatcher ( ) error { for i : = uint32 ( 0 ) ; i < watcher . count ; i ++ { watcher . closer < - true } return watcher . close ( ) } 
func ( rs * routers ) find ( path string ) ( url . values , handlerfunc , view . view ) { defer rs . runlock ( ) rs . rlock ( ) if s , ok : = rs . s [ path ] ; ok { return nil , s . h , s . v } for e : = rs . l . front ( ) ; e ! = nil ; e = e . next ( ) { s : = e . value . ( struct { r router . router v view . view h handlerfunc } ) if params , ok : = s . r . match ( path ) ; ok { return params , s . h , s . v } } return nil , nil , nil } 
func ( rs * routers ) add ( r router . router , h handlerfunc , v view . view ) { defer rs . unlock ( ) rs . lock ( ) s : = struct { r router . router v view . view h handlerfunc } { r , v , h } if sr , ok : = r . ( * router . base ) ; ok { rs . s [ sr . path ] = s return } rs . l . pushfront ( s ) } 
func newrouters ( ) * routers { return & routers { s : make ( map [ string ] struct { r router . router v view . view h handlerfunc } ) , l : list . new ( ) , } } 
func newservermux ( ) ( mux * servermux ) { nf : = struct { view view . view handler handlerfunc } { view . simple ( view . contenttypeplain , view . charsetutf8 ) , defaultnotfound } return & servermux { newrouters ( ) , nil , nil , nil , nf } } 
func ( mux * servermux ) err ( err error ) { if mux . errorhandle ! = nil { mux . errorhandle ( err ) } } 
func ( mux * servermux ) handlefunc ( r router . router , h handlerfunc , v view . view ) { mux . routers . add ( r , h , v ) } 
func ( mux * servermux ) handleerror ( ctx * context , err error ) bool { if err == nil { return false } if e , ok : = err . ( error ) ; ok { ctx . response . status = e . status ctx . response . data = e return true } if ctx . response . status == http . statusok { ctx . response . status = http . statusinternalservererror } ctx . response . data = err . error ( ) mux . err ( err ) return true } 
func ( ctx * context ) redirect ( code int , url string ) { ctx . response . status = code ctx . response . data = url } 
func brace ( path string ) * brace { matches : = strings . split ( path , " " ) return & brace { matches : matches , } } 
func ( mux * servermux ) initpprof ( prefix string ) { if prefix == " " { prefix = " " } mux . handlefunc ( router . wildcard ( fmt . sprintf ( " " , prefix ) ) , wraphttphandlerfunc ( pprofindex ( prefix ) ) , nil ) mux . handlefunc ( router . simple ( fmt . sprintf ( " " , prefix ) ) , wraphttphandlerfunc ( http . handlerfunc ( pprof . cmdline ) ) , nil ) mux . handlefunc ( router . simple ( fmt . sprintf ( " " , prefix ) ) , wraphttphandlerfunc ( http . handlerfunc ( pprof . profile ) ) , nil ) mux . handlefunc ( router . simple ( fmt . sprintf ( " " , prefix ) ) , wraphttphandlerfunc ( http . handlerfunc ( pprof . symbol ) ) , nil ) } 
func ( ctx * context ) startsession ( f session . factoryfunc ) ( err error ) { ctx . session , err = f ( ctx . response , ctx . request ) return } 
func combinations ( list replacer , select num int , repeatable bool , buf int ) ( c chan replacer ) { c = make ( chan replacer , buf ) index : = make ( [ ] int , list . len ( ) , list . len ( ) ) for i : = 0 ; i < list . len ( ) ; i ++ { index [ i ] = i } var comb generator func ( [ ] int , int , int ) chan [ ] int if repeatable { comb generator = repeated combinations } else { comb generator = combinations } go func ( ) { defer close ( c ) for comb : = range comb generator ( index , select num , buf ) { c < - list . replace ( comb ) } } ( ) return } 
func combinations ( list [ ] int , select num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) switch { case select num == 0 : c < - [ ] int { } case select num == len ( list ) : c < - list case len ( list ) < select num : return default : for i : = 0 ; i < len ( list ) ; i ++ { for sub comb : = range combinations ( list [ i + 1 : ] , select num - 1 , buf ) { c < - append ( [ ] int { list [ i ] } , sub comb ... ) } } } } ( ) return } 
func repeated combinations ( list [ ] int , select num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) if select num == 1 { for v : = range list { c < - [ ] int { v } } return } for i : = 0 ; i < len ( list ) ; i ++ { for sub comb : = range repeated combinations ( list [ i : ] , select num - 1 , buf ) { c < - append ( [ ] int { list [ i ] } , sub comb ... ) } } } ( ) return } 
func permutations ( list replacer , select num int , repeatable bool , buf int ) ( c chan replacer ) { c = make ( chan replacer , buf ) go func ( ) { defer close ( c ) var perm generator func ( [ ] int , int , int ) chan [ ] int if repeatable { perm generator = repeated permutations } else { perm generator = permutations } indices : = make ( [ ] int , list . len ( ) , list . len ( ) ) for i : = 0 ; i < list . len ( ) ; i ++ { indices [ i ] = i } for perm : = range perm generator ( indices , select num , buf ) { c < - list . replace ( perm ) } } ( ) return } 
func permutations ( list [ ] int , select num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) switch select num { case 1 : for , v : = range list { c < - [ ] int { v } } return case 0 : return case len ( list ) : for i : = 0 ; i < len ( list ) ; i ++ { top , sub list : = pop ( list , i ) for perm : = range permutations ( sub list , select num - 1 , buf ) { c < - append ( [ ] int { top } , perm ... ) } } default : for comb : = range combinations ( list , select num , buf ) { for perm : = range permutations ( comb , select num , buf ) { c < - perm } } } } ( ) return } 
func repeated permutations ( list [ ] int , select num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) switch select num { case 1 : for , v : = range list { c < - [ ] int { v } } default : for i : = 0 ; i < len ( list ) ; i ++ { for perm : = range repeated permutations ( list , select num - 1 , buf ) { c < - append ( [ ] int { list [ i ] } , perm ... ) } } } } ( ) return } 
func errorm ( format string , args map [ string ] interface { } ) error { f , a : = gformat ( format , args ) return fmt . errorf ( f , a ... ) } 
func fprintm ( w io . writer , format string , args map [ string ] interface { } ) ( n int , err error ) { f , a : = gformat ( format , args ) return fmt . fprintf ( w , f , a ... ) } 
func printm ( format string , args map [ string ] interface { } ) ( n int , err error ) { f , a : = gformat ( format , args ) return fmt . printf ( f , a ... ) } 
func sprintm ( format string , args map [ string ] interface { } ) string { f , a : = gformat ( format , args ) return fmt . sprintf ( f , a ... ) } 
func ( p * passwordstrengthrequirements ) validate ( password string ) ( bool , string ) { reqs : = makerequirements ( password ) if p . maximumtotallength > 0 && reqs . maximumtotallength > p . maximumtotallength { return false , " " } if reqs . minimumtotallength < p . minimumtotallength { return false , " " } if reqs . digits < p . digits { return false , " " } if reqs . punctuation < p . punctuation { return false , " " } if reqs . uppercase < p . uppercase { return false , " " } return true , " " } 
func makerequirements ( password string ) passwordstrengthrequirements { pwd : = [ ] byte ( password ) reqs : = passwordstrengthrequirements { } reqs . maximumtotallength = len ( password ) reqs . minimumtotallength = len ( password ) for i : = range pwd { switch { case unicode . isdigit ( rune ( pwd [ i ] ) ) : reqs . digits ++ case unicode . isupper ( rune ( pwd [ i ] ) ) : reqs . uppercase ++ case unicode . ispunct ( rune ( pwd [ i ] ) ) : reqs . punctuation ++ } } return reqs } 
func ( p * passwordstrengthrequirements ) sanitycheck ( ) ( bool , string ) { if p . maximumtotallength == 0 { return true , " " } if p . maximumtotallength < p . minimumtotallength { return false , " " } if p . maximumtotallength < p . digits { return false , " " } if p . maximumtotallength < p . punctuation { return false , " " } if p . maximumtotallength < p . uppercase { return false , " " } if p . maximumtotallength < p . digits + p . uppercase + p . punctuation { return false , " " } return true , " " } 
func main ( ) { n : = flag . int ( " " , 8 , " " ) min : = flag . int ( " " , 12 , " " ) max : = flag . int ( " " , 0 , " " ) digits : = flag . int ( " " , 3 , " " ) punctuation : = flag . int ( " " , 1 , " " ) uppercase : = flag . int ( " " , 1 , " " ) flag . parse ( ) reqs : = garbler . passwordstrengthrequirements { minimumtotallength : * min , maximumtotallength : * max , uppercase : * uppercase , digits : * digits , punctuation : * punctuation , } for i : = 0 ; i < * n ; i ++ { pass , err : = garbler . newpassword ( & reqs ) if err ! = nil { fmt . println ( err ) return } fmt . println ( pass ) } } 
func ( g garbler ) password ( req passwordstrengthrequirements ) ( string , error ) { letters : = 0 mustgarble : = 0 switch { case req . maximumtotallength > 0 && req . maximumtotallength > 6 : letters = req . maximumtotallength - req . digits - req . punctuation case req . maximumtotallength > 0 && req . maximumtotallength <= 6 : letters = req . maximumtotallength - req . punctuation mustgarble = req . digits case req . minimumtotallength > req . digits + req . punctuation + 6 : letters = req . minimumtotallength - req . digits - req . punctuation default : letters = req . minimumtotallength } if req . uppercase > letters { letters = req . uppercase } password : = g . garbledsequence ( letters , mustgarble ) password = g . uppercase ( password , req . uppercase ) password = g . addnums ( password , req . digits - mustgarble ) password = g . punctuate ( password , req . punctuation ) return password , nil } 
func newpassword ( reqs * passwordstrengthrequirements ) ( string , error ) { if reqs == nil { reqs = & medium } if ok , problems : = reqs . sanitycheck ( ) ; ! ok { return " " , errors . new ( " " + problems ) } e : = garbler { } return e . password ( * reqs ) } 
func newpasswords ( reqs * passwordstrengthrequirements , n int ) ( [ ] string , error ) { var err error if reqs == nil { reqs = & medium } if ok , problems : = reqs . sanitycheck ( ) ; ! ok { return nil , errors . new ( " " + problems ) } e : = garbler { } passes : = make ( [ ] string , n , n ) for i : = 0 ; i < n ; i ++ { passes [ i ] , err = e . password ( * reqs ) if err ! = nil { return nil , err } } return passes , nil } 
func ( g garbler ) addnums ( p string , numdigits int ) string { if numdigits <= 0 { return p } ret : = p remaining : = numdigits for remaining > 10 { ret += fmt . sprintf ( " " , pow ( 10 , 9 ) + randint ( pow ( 10 , 10 ) - pow ( 10 , 9 ) ) ) remaining - = 10 } ret += fmt . sprintf ( " " , pow ( 10 , remaining - 1 ) + randint ( pow ( 10 , remaining ) - pow ( 10 , remaining - 1 ) ) ) return ret } 
func ( g garbler ) punctuate ( p string , numpunc int ) string { if numpunc <= 0 { return p } ret : = p for i : = 0 ; i < numpunc ; i ++ { if i % 2 == 0 { ret += string ( punctuation [ randint ( len ( punctuation ) ) ] ) } else { ret = string ( punctuation [ randint ( len ( punctuation ) ) ] ) + ret } } return ret } 
func ( g garbler ) garbledsequence ( length int , numgarbled int ) string { if numgarbled > length { panic ( " " ) } var ret string numcangarble : = 0 sequence : = [ ] string { " " , " " , " " , " " , " " } sequenceposition : = 0 for i : = 0 ; i < length ; i ++ { if i % 2 == 0 && numcangarble < numgarbled { if sequence [ sequenceposition ] == " " { ret += string ( consonantgarblers [ randint ( len ( consonantgarblers ) ) ] ) } else { ret += string ( vowelgarblers [ randint ( len ( vowelgarblers ) ) ] ) } numcangarble ++ sequenceposition = ( sequenceposition + 1 ) % len ( sequence ) continue } if sequence [ sequenceposition ] == " " { ret += string ( consonants [ randint ( len ( consonants ) ) ] ) } else { ret += string ( vowels [ randint ( len ( vowels ) ) ] ) } sequenceposition = ( sequenceposition + 1 ) % len ( sequence ) } if numcangarble >= numgarbled { return ret } for i : = 0 ; i < length ; i ++ { if i % 2 == 1 && numcangarble < numgarbled { if sequence [ sequenceposition ] == " " { ret += string ( consonantgarblers [ randint ( len ( consonantgarblers ) ) ] ) } else { ret += string ( vowelgarblers [ randint ( len ( vowelgarblers ) ) ] ) } numcangarble ++ sequenceposition = ( sequenceposition + 1 ) % len ( sequence ) } else if numcangarble >= numgarbled { return ret } } panic ( " " ) } 
func randint ( max int ) int { i , err : = crypto . int ( crypto . reader , big . newint ( int64 ( max ) ) ) if err == nil { return int ( i . int64 ( ) ) } return rand . intn ( max ) } 
func deprecated init ( ) { stat , : = os . stdin . stat ( ) if ( stat . mode ( ) & os . modechardevice ) == 0 { return } for i , argv : = range os . args { if argv == " " { arg : = os . args [ i + 1 ] buf : = bytes . newbufferstring ( arg ) stdin = newparamset ( buf ) return } } if len ( os . args ) > 1 { buf : = bytes . newbufferstring ( os . args [ 1 ] ) stdin = newparamset ( buf ) } } 
func ( p paramset ) param ( name string , value interface { } ) { p . params [ name ] = value } 
func ( p paramset ) parse ( ) error { raw : = map [ string ] json . rawmessage { } err : = json . newdecoder ( p . reader ) . decode ( & raw ) if err ! = nil { return err } for key , val : = range p . params { data , ok : = raw [ key ] if ! ok { continue } err : = json . unmarshal ( data , val ) if err ! = nil { return fmt . errorf ( " " , key , err ) } } return nil } 
func ( p paramset ) unmarshal ( v interface { } ) error { return json . newdecoder ( p . reader ) . decode ( v ) } 
func ( p pushy ) deviceinfo ( deviceid string ) ( * deviceinfo , * error , error ) { url : = fmt . sprintf ( " " , p . apiendpoint , deviceid , p . apitoken ) var errresponse * error var info * deviceinfo err : = get ( p . httpclient , url , & info , & errresponse ) return info , errresponse , err } 
func ( p * pushy ) devicepresence ( deviceid ... string ) ( * devicepresenceresponse , * error , error ) { url : = fmt . sprintf ( " " , p . apiendpoint , p . apitoken ) var devicepresenceresponse * devicepresenceresponse var pushyerr * error err : = post ( p . httpclient , url , devicepresencerequest { tokens : deviceid } , & devicepresenceresponse , & pushyerr ) return devicepresenceresponse , pushyerr , err } 
func ( p * pushy ) notificationstatus ( pushid string ) ( * notificationstatus , * error , error ) { url : = fmt . sprintf ( " " , p . apiendpoint , pushid , p . apitoken ) var errresponse * error var status * notificationstatus err : = get ( p . httpclient , url , & status , & errresponse ) return status , errresponse , err } 
func ( p * pushy ) deletenotification ( pushid string ) ( * simplesuccess , * error , error ) { url : = fmt . sprintf ( " " , p . apiendpoint , pushid , p . apitoken ) var success * simplesuccess var pushyerr * error err : = del ( p . httpclient , url , & success , & pushyerr ) return success , pushyerr , err } 
func ( p * pushy ) subscribetotopic ( deviceid string , topics ... string ) ( * simplesuccess , * error , error ) { url : = fmt . sprintf ( " " , p . apiendpoint , p . apitoken ) request : = devicesubscriptionrequest { token : deviceid , topics : topics , } var success * simplesuccess var pushyerr * error err : = post ( p . httpclient , url , request , & success , & pushyerr ) return success , pushyerr , err } 
func ( p * pushy ) notifydevice ( request sendnotificationrequest ) ( * notificationresponse , * error , error ) { url : = fmt . sprintf ( " " , p . apiendpoint , p . apitoken ) var success * notificationresponse var pushyerr * error err : = post ( p . httpclient , url , request , & success , & pushyerr ) return success , pushyerr , err } 
func assert ( t tester , b bool , message ... interface { } ) { if ! b { pc , file , line , : = runtime . caller ( 1 ) caller func info : = runtime . funcforpc ( pc ) error string : = fmt . sprintf ( " \n \ t \n \ t " , caller func info . name ( ) , pc , file , line ) if len ( message ) > 0 { error string += fmt . sprintf ( " \n \ t " , message ) } t . errorf ( error string ) t . failnow ( ) } } 
func createfile ( filename string , size int64 ) error { buf : = make ( [ ] byte , size ) fp , err : = os . create ( filename ) if err ! = nil { return err } , err = fp . write ( buf ) fp . close ( ) return err } 
func ( f * formerrors ) adderror ( e string ) { f . errors = append ( f . errors , e ) } 
func ( f * formerrors ) addfielderror ( field , e string ) { if f . fielderrors == nil { f . fielderrors = map [ string ] [ ] string { } } if , ok : = f . fielderrors [ field ] ; ! ok { f . fielderrors [ field ] = [ ] string { } } f . fielderrors [ field ] = append ( f . fielderrors [ field ] , e ) } 
func ( f formerrors ) haserrors ( ) bool { if len ( f . errors ) > 0 { return true } for , v : = range f . fielderrors { if len ( v ) > 0 { return true } } return false } 
func newerror ( e string ) formerrors { errors : = formerrors { } errors . adderror ( e ) return errors } 
func newfielderror ( field , e string ) formerrors { errors : = formerrors { } errors . addfielderror ( field , e ) return errors } 
func chainhandlers ( handlers ... func ( http . handler ) http . handler ) ( h http . handler ) { for i : = len ( handlers ) - 1 ; i >= 0 ; i -- { h = handlers [ i ] ( h ) } return } 
func ( s md5hasher ) hash ( reader io . reader ) ( string , error ) { hash : = md5 . new ( ) if , err : = io . copy ( hash , reader ) ; err ! = nil { return " " , err } h : = hash . sum ( nil ) if len ( h ) < s . hashlength { return " " , nil } return strings . trimright ( hex . encodetostring ( h ) [ : s . hashlength ] , " " ) , nil } 
func ( s md5hasher ) ishash ( h string ) bool { if len ( h ) ! = s . hashlength { return false } var found bool for , c : = range h { found = false for , m : = range hexchars { if c == m { found = true break } } if ! found { return false } } return true } 
func withbasedir ( dir string ) option { return func ( o * options ) { o . filefindfunc = func ( f string ) string { return filepath . join ( dir , f ) } } } 
func withfilefindfunc ( fn func ( filename string ) string ) option { return func ( o * options ) { o . filefindfunc = fn } } 
func withtemplatefromfiles ( name string , files ... string ) option { return func ( o * options ) { o . files [ name ] = files } } 
func withtemplatesfromfiles ( ts map [ string ] [ ] string ) option { return func ( o * options ) { for name , files : = range ts { o . files [ name ] = files } } } 
func withtemplatefromstrings ( name string , strings ... string ) option { return func ( o * options ) { o . strings [ name ] = strings } } 
func withtemplatesfromstrings ( ts map [ string ] [ ] string ) option { return func ( o * options ) { for name , strings : = range ts { o . strings [ name ] = strings } } } 
func withfunction ( name string , fn interface { } ) option { return func ( o * options ) { o . functions [ name ] = fn } } 
func withfunctions ( fns template . funcmap ) option { return func ( o * options ) { for name , fn : = range fns { o . functions [ name ] = fn } } } 
func withdelims ( open , close string ) option { return func ( o * options ) { o . delimopen = open o . delimclose = close } } 
func withlogfunc ( logf func ( format string , a ... interface { } ) ) option { return func ( o * options ) { o . logf = logf } } 
func ( t templates ) respondwithstatus ( w http . responsewriter , name string , data interface { } , status int ) { buf : = bytes . buffer { } tpl , ok : = t . templates [ name ] if ! ok { panic ( & error { err : errunknowntemplate , template : name } ) } if err : = tpl . execute ( & buf , data ) ; err ! = nil { panic ( err ) } if t . contenttype ! = " " { w . header ( ) . set ( " " , t . contenttype ) } if status > 0 { w . writeheader ( status ) } if , err : = buf . writeto ( w ) ; err ! = nil { t . logf ( " " , name , err ) } } 
func ( t templates ) respondtemplate ( w http . responsewriter , name , templatename string , data interface { } ) { t . respondtemplatewithstatus ( w , name , templatename , data , 0 ) } 
func ( t templates ) respond ( w http . responsewriter , name string , data interface { } ) { t . respondwithstatus ( w , name , data , 0 ) } 
func ( t templates ) rendertemplate ( name , templatename string , data interface { } ) ( s string , err error ) { buf : = bytes . buffer { } tpl , ok : = t . templates [ name ] if ! ok { return " " , & error { err : errunknowntemplate , template : name } } if err : = tpl . executetemplate ( & buf , templatename , data ) ; err ! = nil { return " " , err } return buf . string ( ) , nil } 
func new ( handler http . handler , opts ... option ) ( s * server ) { o : = & options { } for , opt : = range opts { opt ( o ) } s = & server { server : & h2quic . server { server : & http . server { handler : handler , tlsconfig : o . tlsconfig , } , } , } return } 
func ( s * server ) serveudp ( conn * net . udpconn ) ( err error ) { s . server . server . addr = conn . localaddr ( ) . string ( ) return s . server . serve ( conn ) } 
func ( s * server ) shutdown ( context . context ) ( err error ) { return s . server . close ( ) } 
func ( s * server ) quicheadershandler ( h http . handler ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { s . setquicheaders ( w . header ( ) ) h . servehttp ( w , r ) } ) } 
func getrequestendpoint ( r * http . request ) string { proto : = r . header . get ( " " ) if proto == " " { if r . tls == nil { proto = " " } else { proto = " " } } return proto + " " + r . host } 
func new ( opts ... option ) ( s * servers ) { s = & servers { logger : stdlogger { } , recover : func ( ) { } , } for , opt : = range opts { opt ( s ) } return } 
func ( s * servers ) add ( name , address string , srv server ) { s . mu . lock ( ) s . servers = append ( s . servers , & server { server : srv , name : name , address : address , } ) s . mu . unlock ( ) } 
func ( s * servers ) tcpaddr ( name string ) ( a * net . tcpaddr ) { s . mu . lock ( ) defer s . mu . unlock ( ) for , srv : = range s . servers { if srv . name == name { return srv . tcpaddr } } return nil } 
func ( s * servers ) udpaddr ( name string ) ( a * net . udpaddr ) { s . mu . lock ( ) defer s . mu . unlock ( ) for , srv : = range s . servers { if srv . name == name { return srv . udpaddr } } return nil } 
func ( s * servers ) close ( ) { wg : = & sync . waitgroup { } for , srv : = range s . servers { wg . add ( 1 ) go func ( srv * server ) { defer s . recover ( ) defer wg . done ( ) s . logger . infof ( " " , srv . label ( ) ) if err : = srv . close ( ) ; err ! = nil { s . logger . errorf ( " " , srv . label ( ) , err ) } } ( srv ) } wg . wait ( ) return } 
func ( s * servers ) shutdown ( ctx context . context ) { wg : = & sync . waitgroup { } for , srv : = range s . servers { wg . add ( 1 ) go func ( srv * server ) { defer s . recover ( ) defer wg . done ( ) s . logger . infof ( " " , srv . label ( ) ) if err : = srv . shutdown ( ctx ) ; err ! = nil { s . logger . errorf ( " " , srv . label ( ) , err ) } } ( srv ) } wg . wait ( ) return } 
func ( l tlslistener ) accept ( ) ( net . conn , error ) { c , err : = l . accepttcp ( ) if err ! = nil { return nil , err } c . setkeepalive ( true ) c . setkeepaliveperiod ( 3 * time . minute ) b : = make ( [ ] byte , 1 ) , err = c . read ( b ) if err ! = nil { c . close ( ) if err ! = io . eof { return nil , err } } con : = & conn { conn : c , b : b [ 0 ] , e : err , f : true , } if b [ 0 ] == 22 { return tls . server ( con , l . tlsconfig ) , nil } return con , nil } 
func ( o options ) marshaljson ( ) ( [ ] byte , error ) { return json . marshal ( optionsjson { timeout : marshal . duration ( o . timeout ) , keepalive : marshal . duration ( o . keepalive ) , tlshandshaketimeout : marshal . duration ( o . tlshandshaketimeout ) , tlsskipverify : o . tlsskipverify , retrytimemax : marshal . duration ( o . retrytimemax ) , retrysleepmax : marshal . duration ( o . retrysleepmax ) , retrysleepbase : marshal . duration ( o . retrysleepbase ) , } ) } 
func ( o * options ) unmarshaljson ( data [ ] byte ) error { v : = & optionsjson { } if err : = json . unmarshal ( data , v ) ; err ! = nil { return err } * o = options { timeout : v . timeout . duration ( ) , keepalive : v . keepalive . duration ( ) , tlshandshaketimeout : v . tlshandshaketimeout . duration ( ) , tlsskipverify : v . tlsskipverify , retrytimemax : v . retrytimemax . duration ( ) , retrysleepmax : v . retrysleepmax . duration ( ) , retrysleepbase : v . retrysleepbase . duration ( ) , } return nil } 
func ( o options ) marshalyaml ( ) ( interface { } , error ) { return optionsjson { timeout : marshal . duration ( o . timeout ) , keepalive : marshal . duration ( o . keepalive ) , tlshandshaketimeout : marshal . duration ( o . tlshandshaketimeout ) , tlsskipverify : o . tlsskipverify , retrytimemax : marshal . duration ( o . retrytimemax ) , retrysleepmax : marshal . duration ( o . retrysleepmax ) , retrysleepbase : marshal . duration ( o . retrysleepbase ) , } , nil } 
func ( o * options ) unmarshalyaml ( unmarshal func ( interface { } ) error ) error { v : = & optionsjson { } if err : = unmarshal ( v ) ; err ! = nil { return err } * o = options { timeout : v . timeout . duration ( ) , keepalive : v . keepalive . duration ( ) , tlshandshaketimeout : v . tlshandshaketimeout . duration ( ) , tlsskipverify : v . tlsskipverify , retrytimemax : v . retrytimemax . duration ( ) , retrysleepmax : v . retrysleepmax . duration ( ) , retrysleepbase : v . retrysleepbase . duration ( ) , } return nil } 
func ( f roundtripperfunc ) roundtrip ( r * http . request ) ( * http . response , error ) { return f ( r ) } 
func withlogfunc ( logf func ( format string , a ... interface { } ) ) option { return func ( o * handler ) { o . logf = logf } } 
func new ( handler http . handler , options ... option ) ( h * handler ) { h = & handler { handler : handler , logf : log . printf , } for , option : = range options { option ( h ) } return } 
func ( f notifierfunc ) notify ( subject , body string ) error { return f ( subject , body ) } 
func newcontextfunc ( m map [ string ] interface { } ) func ( string ) interface { } { return func ( key string ) interface { } { if value , ok : = m [ key ] ; ok { return value } return nil } } 
func newmaperrorregistry ( errors map [ int ] error , handlers map [ int ] func ( body [ ] byte ) error ) * maperrorregistry { if errors == nil { errors = map [ int ] error { } } if handlers == nil { handlers = map [ int ] func ( body [ ] byte ) error { } } return & maperrorregistry { errors : errors , handlers : handlers , } } 
func ( r * maperrorregistry ) adderror ( code int , err error ) error { if , ok : = r . errors [ code ] ; ok { return errerroralreadyregistered } if , ok : = r . handlers [ code ] ; ok { return errerroralreadyregistered } r . errors [ code ] = err return nil } 
func ( r * maperrorregistry ) addmessageerror ( code int , message string ) ( * error , error ) { if , ok : = r . errors [ code ] ; ok { return nil , errerroralreadyregistered } if , ok : = r . handlers [ code ] ; ok { return nil , errerroralreadyregistered } err : = & error { message : message , code : code , } r . errors [ code ] = err return err , nil } 
func ( r * maperrorregistry ) mustadderror ( code int , err error ) { if e : = r . adderror ( code , err ) ; e ! = nil { panic ( e ) } } 
func ( r * maperrorregistry ) mustaddmessageerror ( code int , message string ) * error { err , e : = r . addmessageerror ( code , message ) if e ! = nil { panic ( e ) } return err } 
func ( r * maperrorregistry ) addhandler ( code int , handler func ( body [ ] byte ) error ) error { if , ok : = r . errors [ code ] ; ok { return errerroralreadyregistered } if , ok : = r . handlers [ code ] ; ok { return errerroralreadyregistered } r . handlers [ code ] = handler return nil } 
func ( r * maperrorregistry ) mustaddhandler ( code int , handler func ( body [ ] byte ) error ) { if err : = r . addhandler ( code , handler ) ; err ! = nil { panic ( err ) } } 
func ( r maperrorregistry ) handler ( code int ) func ( body [ ] byte ) error { return r . handlers [ code ] } 
func new ( endpoint string , errorregistry errorregistry ) * client { return & client { endpoint : endpoint , errorregistry : errorregistry , keyheader : defaultkeyheader , httpclient : http . defaultclient , } } 
func jsonunmarshal ( data [ ] byte , v interface { } ) error { if err : = json . unmarshal ( data , v ) ; err ! = nil { switch e : = err . ( type ) { case * json . syntaxerror : line , col : = getlinecolfromoffset ( data , e . offset ) return fmt . errorf ( " " , e , line , col ) case * json . unmarshaltypeerror : line , col : = getlinecolfromoffset ( data , e . offset ) return fmt . errorf ( " " , e . type , e . value , line , col ) } return err } return nil } 
func ( s * server ) servetcp ( ln net . listener ) ( err error ) { return s . server . serve ( ln ) } 
func ( s * server ) shutdown ( ctx context . context ) ( err error ) { s . server . gracefulstop ( ) return } 
func new ( root , dir string , options * options ) * server { if options == nil { options = & options { } } return & server { options : * options , root : root , dir : dir , hashes : map [ string ] string { } , mu : & sync . rwmutex { } , } } 
func ( s * server ) hashedpath ( p string ) ( string , error ) { if s . hasher == nil { return path . join ( s . root , p ) , nil } h , cont , err : = s . hash ( p ) if err ! = nil { if cont { h , , err = s . hashfromfilename ( p ) } if err ! = nil { return " " , err } } return path . join ( s . root , s . hashedpath ( p , h ) ) , nil } 
func ( s * memorystore ) status ( ) ( on bool , err error ) { s . mu . lock ( ) on = s . on s . mu . unlock ( ) return } 
func ( s * memorystore ) on ( ) ( changed bool , err error ) { s . mu . lock ( ) defer s . mu . unlock ( ) if s . on { return } s . on = true changed = true return } 
func ( s * memorystore ) off ( ) ( changed bool , err error ) { s . mu . lock ( ) defer s . mu . unlock ( ) if ! s . on { return } s . on = false changed = true return } 
func ( s * filestore ) status ( ) ( on bool , err error ) { , err = os . stat ( s . filename ) if err == nil { return true , nil } if os . isnotexist ( err ) { return false , nil } return false , err } 
func ( s * filestore ) on ( ) ( changed bool , err error ) { if , err = os . stat ( s . filename ) ; err == nil { return } err = os . mkdirall ( filepath . dir ( s . filename ) , 0777 ) if err ! = nil { return } f , err : = os . create ( s . filename ) if err ! = nil { return } f . close ( ) changed = true return } 
func ( s * filestore ) off ( ) ( changed bool , err error ) { , err = os . stat ( s . filename ) if os . isnotexist ( err ) { err = nil return } if err ! = nil { return } if err = os . remove ( s . filename ) ; err ! = nil { return } changed = true return } 
func new ( options ... option ) ( s * service ) { s = & service { logger : stdlogger { } , } for , option : = range options { option ( s ) } if s . store == nil { s . store = newmemorystore ( ) } return } 
func ( s service ) status ( ) ( on bool , err error ) { return s . store . status ( ) } 
func ( this * postircmessagerequest ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( github * github ) ping ( ) error { cd : = tcclient . client ( * github ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( github * github ) builds ( continuationtoken , limit , organization , repository , sha string ) ( * buildsresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } if organization ! = " " { v . add ( " " , organization ) } if repository ! = " " { v . add ( " " , repository ) } if sha ! = " " { v . add ( " " , sha ) } cd : = tcclient . client ( * github ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( buildsresponse ) , v ) return responseobject . ( * buildsresponse ) , err } 
func ( github * github ) repository ( owner , repo string ) ( * repositoryresponse , error ) { cd : = tcclient . client ( * github ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( owner ) + " " + url . queryescape ( repo ) , new ( repositoryresponse ) , nil ) return responseobject . ( * repositoryresponse ) , err } 
func ( github * github ) createstatus ( owner , repo , sha string , payload * createstatusrequest ) error { cd : = tcclient . client ( * github ) , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( owner ) + " " + url . queryescape ( repo ) + " " + url . queryescape ( sha ) , nil , nil ) return err } 
func ( github * github ) createcomment ( owner , repo , number string , payload * createcommentrequest ) error { cd : = tcclient . client ( * github ) , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( owner ) + " " + url . queryescape ( repo ) + " " + url . queryescape ( number ) + " " , nil , nil ) return err } 
func ( this * postartifactrequest ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * postartifactresponse ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( notify * notify ) ping ( ) error { cd : = tcclient . client ( * notify ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( notify * notify ) email ( payload * sendemailrequest ) error { cd : = tcclient . client ( * notify ) , , err : = ( & cd ) . apicall ( payload , " " , " " , nil , nil ) return err } 
func ( notify * notify ) pulse ( payload * postpulsemessagerequest ) error { cd : = tcclient . client ( * notify ) , , err : = ( & cd ) . apicall ( payload , " " , " " , nil , nil ) return err } 
func ( notify * notify ) irc ( payload * postircmessagerequest ) error { cd : = tcclient . client ( * notify ) , , err : = ( & cd ) . apicall ( payload , " " , " " , nil , nil ) return err } 
func ( notify * notify ) adddenylistaddress ( payload * notificationtypeandaddress ) error { cd : = tcclient . client ( * notify ) , , err : = ( & cd ) . apicall ( payload , " " , " " , nil , nil ) return err } 
func ( notify * notify ) listdenylist ( continuationtoken , limit string ) ( * listofnotificationadresses , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * notify ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( listofnotificationadresses ) , v ) return responseobject . ( * listofnotificationadresses ) , err } 
func ( notify * notify ) listdenylist signedurl ( continuationtoken , limit string , duration time . duration ) ( * url . url , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * notify ) return ( & cd ) . signedurl ( " " , v , duration ) } 
func newfromenv ( ) * ec2manager { c : = tcclient . credentialsfromenvvars ( ) return & ec2manager { credentials : c , baseurl : defaultbaseurl , authenticate : c . clientid ! = " " , } } 
func ( ec2manager * ec2manager ) ensurekeypair signedurl ( name string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * ec2manager ) return ( & cd ) . signedurl ( " " + url . queryescape ( name ) , nil , duration ) } 
func ( ec2manager * ec2manager ) regions signedurl ( duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * ec2manager ) return ( & cd ) . signedurl ( " " , nil , duration ) } 
func ( this * hookchangedmessage ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * triggerhookrequest ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * triggerhookresponse ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * triggerhookresponse ) unmarshaljson ( data [ ] byte ) error { if this == nil { return errors . new ( " " ) } * this = append ( ( * this ) [ 0 : 0 ] , data ... ) return nil } 
func newfromenv ( ) * index { c : = tcclient . credentialsfromenvvars ( ) return & index { credentials : c , baseurl : tcclient . baseurl ( tcclient . rooturlfromenvvars ( ) , " " , " " ) , authenticate : c . clientid ! = " " , } } 
func ( index * index ) ping ( ) error { cd : = tcclient . client ( * index ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( index * index ) findtask ( indexpath string ) ( * indexedtaskresponse , error ) { cd : = tcclient . client ( * index ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( indexpath ) , new ( indexedtaskresponse ) , nil ) return responseobject . ( * indexedtaskresponse ) , err } 
func ( index * index ) listnamespaces ( namespace , continuationtoken , limit string ) ( * listnamespacesresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * index ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( namespace ) , new ( listnamespacesresponse ) , v ) return responseobject . ( * listnamespacesresponse ) , err } 
func ( index * index ) inserttask ( namespace string , payload * inserttaskrequest ) ( * indexedtaskresponse , error ) { cd : = tcclient . client ( * index ) responseobject , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( namespace ) , new ( indexedtaskresponse ) , nil ) return responseobject . ( * indexedtaskresponse ) , err } 
func ( index * index ) findartifactfromtask signedurl ( indexpath , name string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * index ) return ( & cd ) . signedurl ( " " + url . queryescape ( indexpath ) + " " + url . queryescape ( name ) , nil , duration ) } 
func ( this * launchinfo ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * var ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * var1 ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * var3 ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( login * login ) ping ( ) error { cd : = tcclient . client ( * login ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( login * login ) oidccredentials ( provider string ) ( * credentialsresponse , error ) { cd : = tcclient . client ( * login ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( provider ) , new ( credentialsresponse ) , nil ) return responseobject . ( * credentialsresponse ) , err } 
func ( purgecache * purgecache ) ping ( ) error { cd : = tcclient . client ( * purgecache ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( purgecache * purgecache ) purgecache ( provisionerid , workertype string , payload * purgecacherequest ) error { cd : = tcclient . client ( * purgecache ) , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( provisionerid ) + " " + url . queryescape ( workertype ) , nil , nil ) return err } 
func ( purgecache * purgecache ) allpurgerequests ( continuationtoken , limit string ) ( * openallpurgerequestslist , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * purgecache ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( openallpurgerequestslist ) , v ) return responseobject . ( * openallpurgerequestslist ) , err } 
func ( purgecache * purgecache ) purgerequests ( provisionerid , workertype , since string ) ( * openpurgerequestlist , error ) { v : = url . values { } if since ! = " " { v . add ( " " , since ) } cd : = tcclient . client ( * purgecache ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( provisionerid ) + " " + url . queryescape ( workertype ) , new ( openpurgerequestlist ) , v ) return responseobject . ( * openpurgerequestlist ) , err } 
func ( hooks * hooks ) ping ( ) error { cd : = tcclient . client ( * hooks ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( hooks * hooks ) listhookgroups ( ) ( * hookgroups , error ) { cd : = tcclient . client ( * hooks ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( hookgroups ) , nil ) return responseobject . ( * hookgroups ) , err } 
func ( hooks * hooks ) listhooks ( hookgroupid string ) ( * hooklist , error ) { cd : = tcclient . client ( * hooks ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( hookgroupid ) , new ( hooklist ) , nil ) return responseobject . ( * hooklist ) , err } 
func ( hooks * hooks ) hook ( hookgroupid , hookid string ) ( * hookdefinition , error ) { cd : = tcclient . client ( * hooks ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( hookgroupid ) + " " + url . queryescape ( hookid ) , new ( hookdefinition ) , nil ) return responseobject . ( * hookdefinition ) , err } 
func ( hooks * hooks ) removehook ( hookgroupid , hookid string ) error { cd : = tcclient . client ( * hooks ) , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( hookgroupid ) + " " + url . queryescape ( hookid ) , nil , nil ) return err } 
func ( hooks * hooks ) gettriggertoken signedurl ( hookgroupid , hookid string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * hooks ) return ( & cd ) . signedurl ( " " + url . queryescape ( hookgroupid ) + " " + url . queryescape ( hookid ) + " " , nil , duration ) } 
func ( hooks * hooks ) triggerhookwithtoken ( hookgroupid , hookid , token string , payload * triggerhookrequest ) ( * triggerhookresponse , error ) { cd : = tcclient . client ( * hooks ) responseobject , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( hookgroupid ) + " " + url . queryescape ( hookid ) + " " + url . queryescape ( token ) , new ( triggerhookresponse ) , nil ) return responseobject . ( * triggerhookresponse ) , err } 
func ( awsprovisioner * awsprovisioner ) workertype signedurl ( workertype string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * awsprovisioner ) return ( & cd ) . signedurl ( " " + url . queryescape ( workertype ) , nil , duration ) } 
func ( t time ) marshaljson ( ) ( [ ] byte , error ) { if y : = time . time ( t ) . year ( ) ; y < 0 | | y >= 10000 { return nil , errors . new ( " " ) } return [ ] byte ( ' " ' + t . string ( ) + ' " ' ) , nil } 
func ( t * time ) unmarshaljson ( data [ ] byte ) ( err error ) { x : = new ( time . time ) * x , err = time . parse ( ' " ' + time . rfc3339 + ' " ' , string ( data ) ) * t = time ( * x ) return } 
func ( secrets * secrets ) ping ( ) error { cd : = tcclient . client ( * secrets ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( secrets * secrets ) set ( name string , payload * secret ) error { cd : = tcclient . client ( * secrets ) , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( name ) , nil , nil ) return err } 
func ( secrets * secrets ) remove ( name string ) error { cd : = tcclient . client ( * secrets ) , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( name ) , nil , nil ) return err } 
func ( secrets * secrets ) get ( name string ) ( * secret , error ) { cd : = tcclient . client ( * secrets ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( name ) , new ( secret ) , nil ) return responseobject . ( * secret ) , err } 
func ( secrets * secrets ) get signedurl ( name string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * secrets ) return ( & cd ) . signedurl ( " " + url . queryescape ( name ) , nil , duration ) } 
func ( secrets * secrets ) list ( continuationtoken , limit string ) ( * secretslist , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * secrets ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( secretslist ) , v ) return responseobject . ( * secretslist ) , err } 
func ( rws * readwriteseeker ) write ( p [ ] byte ) ( n int , err error ) { mincap : = rws . pos + len ( p ) if mincap > cap ( rws . buf ) { buf2 : = make ( [ ] byte , len ( rws . buf ) , mincap + len ( p ) ) copy ( buf2 , rws . buf ) rws . buf = buf2 } if mincap > len ( rws . buf ) { rws . buf = rws . buf [ : mincap ] } copy ( rws . buf [ rws . pos : ] , p ) rws . pos += len ( p ) return len ( p ) , nil } 
func ( rws * readwriteseeker ) seek ( offset int64 , whence int ) ( int64 , error ) { newpos , offs : = 0 , int ( offset ) switch whence { case io . seekstart : newpos = offs case io . seekcurrent : newpos = rws . pos + offs case io . seekend : newpos = len ( rws . buf ) + offs } if newpos < 0 { return 0 , errors . new ( " " ) } rws . pos = newpos return int64 ( newpos ) , nil } 
func ( rws * readwriteseeker ) read ( b [ ] byte ) ( n int , err error ) { if rws . pos >= len ( rws . buf ) { return 0 , io . eof } n = copy ( b , rws . buf [ rws . pos : ] ) rws . pos += n return } 
func ( this * launchspecsresponse ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( this * regionlaunchspec ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func ( gceprovider * gceprovider ) getcredentials ( ) error { cd : = tcclient . client ( * gceprovider ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func publishtask ( queue * tcqueue . queue , taskid string , tdr tcqueue . taskdefinitionrequest , workergroup , workerid string , artifacts [ ] artifactsource ) error { workertype : = tdr . workertype provisionerid : = tdr . provisionerid cwrq : = tcqueue . claimworkrequest { tasks : 1 , workergroup : workergroup , workerid : workerid , } log . printf ( " " , taskid ) , err : = queue . createtask ( taskid , & tdr ) if err ! = nil { return fmt . errorf ( " \n " , taskid , err ) } log . printf ( " " , provisionerid , workertype ) cwrs , err : = queue . claimwork ( provisionerid , workertype , & cwrq ) if err ! = nil { return fmt . errorf ( " \n " , taskid , err ) } taskcreds : = cwrs . tasks [ 0 ] . credentials taskqueue : = tcqueue . new ( & tcclient . credentials { clientid : taskcreds . clientid , accesstoken : taskcreds . accesstoken , certificate : taskcreds . certificate , authorizedscopes : nil , } , " " ) taskqueue . baseurl = queue . baseurl for , as : = range artifacts { err = as . upload ( taskqueue , taskid ) if err ! = nil { return fmt . errorf ( " " , as . name , taskid , err ) } } log . printf ( " " , taskid ) , err = taskqueue . reportcompleted ( taskid , " " ) if err ! = nil { return fmt . errorf ( " " , taskid , err ) } return nil } 
func loadapis ( rooturl string ) apidefinitions { apimanifesturl : = tcurls . apimanifest ( rooturl ) fmt . printf ( " \n " , apimanifesturl ) resp , err : = http . get ( apimanifesturl ) if err ! = nil { fmt . printf ( " \n " , apimanifesturl ) } exitonfail ( err ) apimanifestdecoder : = json . newdecoder ( resp . body ) apiman : = taskclusterservicemanifest { } err = apimanifestdecoder . decode ( & apiman ) exitonfail ( err ) apidefs : = [ ] * apidefinition { } for i : = range apiman . references { var resp * http . response resp , err = http . get ( apiman . references [ i ] ) exitonfail ( err ) defer resp . body . close ( ) apidef : = & apidefinition { url : apiman . references [ i ] , } if apidef . url == tcurls . apireference ( rooturl , " " , " " ) { continue } if apidef . loadjson ( resp . body , rooturl ) { apidefs = append ( apidefs , apidef ) validatejson ( apidef . schemaurl , apidef . url ) } } return apidefinitions ( apidefs ) } 
func ( queue * queue ) ping ( ) error { cd : = tcclient . client ( * queue ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( queue * queue ) listtaskgroup ( taskgroupid , continuationtoken , limit string ) ( * listtaskgroupresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( taskgroupid ) + " " , new ( listtaskgroupresponse ) , v ) return responseobject . ( * listtaskgroupresponse ) , err } 
func ( queue * queue ) createtask ( taskid string , payload * taskdefinitionrequest ) ( * taskstatusresponse , error ) { cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( taskid ) , new ( taskstatusresponse ) , nil ) return responseobject . ( * taskstatusresponse ) , err } 
func ( queue * queue ) claimwork ( provisionerid , workertype string , payload * claimworkrequest ) ( * claimworkresponse , error ) { cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( provisionerid ) + " " + url . queryescape ( workertype ) , new ( claimworkresponse ) , nil ) return responseobject . ( * claimworkresponse ) , err } 
func ( queue * queue ) claimtask ( taskid , runid string , payload * taskclaimrequest ) ( * taskclaimresponse , error ) { cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( taskid ) + " " + url . queryescape ( runid ) + " " , new ( taskclaimresponse ) , nil ) return responseobject . ( * taskclaimresponse ) , err } 
func ( queue * queue ) completeartifact ( taskid , runid , name string , payload * completeartifactrequest ) error { cd : = tcclient . client ( * queue ) , , err : = ( & cd ) . apicall ( payload , " " , " " + url . queryescape ( taskid ) + " " + url . queryescape ( runid ) + " " + url . queryescape ( name ) , nil , nil ) return err } 
func ( queue * queue ) listartifacts ( taskid , runid , continuationtoken , limit string ) ( * listartifactsresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( taskid ) + " " + url . queryescape ( runid ) + " " , new ( listartifactsresponse ) , v ) return responseobject . ( * listartifactsresponse ) , err } 
func ( queue * queue ) listprovisioners ( continuationtoken , limit string ) ( * listprovisionersresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( listprovisionersresponse ) , v ) return responseobject . ( * listprovisionersresponse ) , err } 
func ( queue * queue ) getprovisioner ( provisionerid string ) ( * provisionerresponse , error ) { cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( provisionerid ) , new ( provisionerresponse ) , nil ) return responseobject . ( * provisionerresponse ) , err } 
func ( queue * queue ) listworkertypes ( provisionerid , continuationtoken , limit string ) ( * listworkertypesresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( provisionerid ) + " " , new ( listworkertypesresponse ) , v ) return responseobject . ( * listworkertypesresponse ) , err } 
func ( queue * queue ) getworkertype ( provisionerid , workertype string ) ( * workertyperesponse , error ) { cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( provisionerid ) + " " + url . queryescape ( workertype ) , new ( workertyperesponse ) , nil ) return responseobject . ( * workertyperesponse ) , err } 
func ( queue * queue ) listworkers ( provisionerid , workertype , continuationtoken , limit , quarantined string ) ( * listworkersresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } if quarantined ! = " " { v . add ( " " , quarantined ) } cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( provisionerid ) + " " + url . queryescape ( workertype ) + " " , new ( listworkersresponse ) , v ) return responseobject . ( * listworkersresponse ) , err } 
func ( queue * queue ) getworker ( provisionerid , workertype , workergroup , workerid string ) ( * workerresponse , error ) { cd : = tcclient . client ( * queue ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( provisionerid ) + " " + url . queryescape ( workertype ) + " " + url . queryescape ( workergroup ) + " " + url . queryescape ( workerid ) , new ( workerresponse ) , nil ) return responseobject . ( * workerresponse ) , err } 
func ( auth * auth ) ping ( ) error { cd : = tcclient . client ( * auth ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( auth * auth ) listclients ( continuationtoken , limit , prefix string ) ( * listclientresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } if prefix ! = " " { v . add ( " " , prefix ) } cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( listclientresponse ) , v ) return responseobject . ( * listclientresponse ) , err } 
func ( auth * auth ) client ( clientid string ) ( * getclientresponse , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( clientid ) , new ( getclientresponse ) , nil ) return responseobject . ( * getclientresponse ) , err } 
func ( auth * auth ) listroles ( ) ( * getallrolesnopagination , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( getallrolesnopagination ) , nil ) return responseobject . ( * getallrolesnopagination ) , err } 
func ( auth * auth ) listroleids ( continuationtoken , limit string ) ( * getroleidsresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } if limit ! = " " { v . add ( " " , limit ) } cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( getroleidsresponse ) , v ) return responseobject . ( * getroleidsresponse ) , err } 
func ( auth * auth ) role ( roleid string ) ( * getroleresponse , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( roleid ) , new ( getroleresponse ) , nil ) return responseobject . ( * getroleresponse ) , err } 
func ( auth * auth ) expandscopesget ( payload * setofscopes ) ( * setofscopes , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( payload , " " , " " , new ( setofscopes ) , nil ) return responseobject . ( * setofscopes ) , err } 
func ( auth * auth ) awss3credentials signedurl ( level , bucket , prefix , format string , duration time . duration ) ( * url . url , error ) { v : = url . values { } if format ! = " " { v . add ( " " , format ) } cd : = tcclient . client ( * auth ) return ( & cd ) . signedurl ( " " + url . queryescape ( level ) + " " + url . queryescape ( bucket ) + " " + url . queryescape ( prefix ) , v , duration ) } 
func ( auth * auth ) azureaccounts ( ) ( * azurelistaccountresponse , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " , new ( azurelistaccountresponse ) , nil ) return responseobject . ( * azurelistaccountresponse ) , err } 
func ( auth * auth ) azureaccounts signedurl ( duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * auth ) return ( & cd ) . signedurl ( " " , nil , duration ) } 
func ( auth * auth ) azuretables ( account , continuationtoken string ) ( * azurelisttableresponse , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( account ) + " " , new ( azurelisttableresponse ) , v ) return responseobject . ( * azurelisttableresponse ) , err } 
func ( auth * auth ) azuretables signedurl ( account , continuationtoken string , duration time . duration ) ( * url . url , error ) { v : = url . values { } if continuationtoken ! = " " { v . add ( " " , continuationtoken ) } cd : = tcclient . client ( * auth ) return ( & cd ) . signedurl ( " " + url . queryescape ( account ) + " " , v , duration ) } 
func ( auth * auth ) azuretablesas ( account , table , level string ) ( * azuretablesharedaccesssignature , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( account ) + " " + url . queryescape ( table ) + " " + url . queryescape ( level ) , new ( azuretablesharedaccesssignature ) , nil ) return responseobject . ( * azuretablesharedaccesssignature ) , err } 
func ( auth * auth ) azuretablesas signedurl ( account , table , level string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * auth ) return ( & cd ) . signedurl ( " " + url . queryescape ( account ) + " " + url . queryescape ( table ) + " " + url . queryescape ( level ) , nil , duration ) } 
func ( auth * auth ) azurecontainersas ( account , container , level string ) ( * azureblobsharedaccesssignature , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( account ) + " " + url . queryescape ( container ) + " " + url . queryescape ( level ) , new ( azureblobsharedaccesssignature ) , nil ) return responseobject . ( * azureblobsharedaccesssignature ) , err } 
func ( auth * auth ) sentrydsn ( project string ) ( * sentrydsnresponse , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( nil , " " , " " + url . queryescape ( project ) + " " , new ( sentrydsnresponse ) , nil ) return responseobject . ( * sentrydsnresponse ) , err } 
func ( auth * auth ) sentrydsn signedurl ( project string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * auth ) return ( & cd ) . signedurl ( " " + url . queryescape ( project ) + " " , nil , duration ) } 
func ( auth * auth ) websocktunneltoken signedurl ( wstaudience , wstclient string , duration time . duration ) ( * url . url , error ) { cd : = tcclient . client ( * auth ) return ( & cd ) . signedurl ( " " + url . queryescape ( wstaudience ) + " " + url . queryescape ( wstclient ) , nil , duration ) } 
func ( auth * auth ) authenticatehawk ( payload * hawksignatureauthenticationrequest ) ( * hawksignatureauthenticationresponse , error ) { cd : = tcclient . client ( * auth ) responseobject , , err : = ( & cd ) . apicall ( payload , " " , " " , new ( hawksignatureauthenticationresponse ) , nil ) return responseobject . ( * hawksignatureauthenticationresponse ) , err } 
func ( permacreds * credentials ) createtemporarycredentials ( duration time . duration , scopes ... string ) ( tempcreds * credentials , err error ) { return permacreds . createnamedtemporarycredentials ( " " , duration , scopes ... ) } 
func ( creds * credentials ) cert ( ) ( cert * certificate , err error ) { if creds . certificate == " " { return } cert = new ( certificate ) err = json . unmarshal ( [ ] byte ( creds . certificate ) , cert ) return } 
func credentialsfromenvvars ( ) * credentials { return & credentials { clientid : os . getenv ( " " ) , accesstoken : os . getenv ( " " ) , certificate : os . getenv ( " " ) , } } 
func ( events * events ) ping ( ) error { cd : = tcclient . client ( * events ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , nil ) return err } 
func ( events * events ) connect ( bindings string ) error { v : = url . values { } if bindings ! = " " { v . add ( " " , bindings ) } cd : = tcclient . client ( * events ) , , err : = ( & cd ) . apicall ( nil , " " , " " , nil , v ) return err } 
func seturl ( client * client , route string , query url . values ) ( u * url . url , err error ) { url : = client . baseurl if strings . hassuffix ( url , " " ) { url = url [ : len ( url ) - 1 ] } url += route u , err = url . parse ( url ) if err ! = nil { return nil , fmt . errorf ( " \n \n " , url , client . baseurl , err ) } if query ! = nil { u . rawquery = query . encode ( ) } return } 
func ( c * credentials ) signrequest ( req * http . request ) ( err error ) { credentials : = & hawk . credentials { id : c . clientid , key : c . accesstoken , hash : sha256 . new , } reqauth : = hawk . newrequestauth ( req , credentials , 0 ) reqauth . ext , err = getextheader ( c ) if err ! = nil { return fmt . errorf ( " \n \n " , c , err ) } req . header . set ( " " , reqauth . requestheader ( ) ) return nil } 
func ( client * client ) apicall ( payload interface { } , method , route string , result interface { } , query url . values ) ( interface { } , * callsummary , error ) { rawpayload : = [ ] byte { } var err error if reflect . valueof ( payload ) . isvalid ( ) && ! reflect . valueof ( payload ) . isnil ( ) { rawpayload , err = json . marshal ( payload ) if err ! = nil { cs : = & callsummary { httprequestobject : payload , } return result , cs , & apicallexception { callsummary : cs , rootcause : err , } } } callsummary , err : = client . request ( rawpayload , method , route , query ) callsummary . httprequestobject = payload if err ! = nil { if client . context ! = nil && client . context . err ( ) ! = nil { return result , callsummary , client . context . err ( ) } return result , callsummary , & apicallexception { callsummary : callsummary , rootcause : err , } } if reflect . valueof ( result ) . isvalid ( ) && ! reflect . valueof ( result ) . isnil ( ) { err = json . unmarshal ( [ ] byte ( callsummary . httpresponsebody ) , & result ) } if err ! = nil { return result , callsummary , & apicallexception { callsummary : callsummary , rootcause : err , } } return result , callsummary , nil } 
func ( client * client ) signedurl ( route string , query url . values , duration time . duration ) ( u * url . url , err error ) { u , err = seturl ( client , route , query ) if err ! = nil { return } credentials : = & hawk . credentials { id : client . credentials . clientid , key : client . credentials . accesstoken , hash : sha256 . new , } reqauth , err : = hawk . newurlauth ( u . string ( ) , credentials , duration ) if err ! = nil { return } reqauth . ext , err = getextheader ( client . credentials ) if err ! = nil { return } bewitsignature : = reqauth . bewit ( ) if query == nil { query = url . values { } } query . set ( " " , bewitsignature ) u . rawquery = query . encode ( ) return } 
func ( this * hawksignatureauthenticationresponse ) marshaljson ( ) ( [ ] byte , error ) { x : = json . rawmessage ( * this ) return ( & x ) . marshaljson ( ) } 
func bmw256 ( input [ ] byte ) [ ] byte { b : = new ( ) buf : = make ( [ ] byte , 64 ) copy ( buf , input ) buf [ len ( input ) ] = 0x80 bitlen : = uint64 ( len ( input ) ) < < 3 binary . littleendian . putuint64 ( buf [ 56 : ] , bitlen ) for i : = 0 ; i < 16 ; i ++ { b . m [ i ] = binary . littleendian . uint32 ( buf [ i * 4 : ] ) } b . compress ( b . m ) b . h , b . h2 = b . h2 , b . h copy ( b . h , final ) b . compress ( b . h2 ) output : = make ( [ ] byte , 32 ) outlen : = len ( output ) > > 2 for i : = 0 ; i < outlen ; i ++ { j : = 16 - outlen + i binary . littleendian . putuint32 ( output [ 4 * i : ] , b . h [ j ] ) } return output } 
func newcubehash ( ) * cubehash { c : = & cubehash { } c . x0 = iv [ 0 ] c . x1 = iv [ 1 ] c . x2 = iv [ 2 ] c . x3 = iv [ 3 ] c . x4 = iv [ 4 ] c . x5 = iv [ 5 ] c . x6 = iv [ 6 ] c . x7 = iv [ 7 ] c . x8 = iv [ 8 ] c . x9 = iv [ 9 ] c . xa = iv [ 10 ] c . xb = iv [ 11 ] c . xc = iv [ 12 ] c . xd = iv [ 13 ] c . xe = iv [ 14 ] c . xf = iv [ 15 ] c . xg = iv [ 16 ] c . xh = iv [ 17 ] c . xi = iv [ 18 ] c . xj = iv [ 19 ] c . xk = iv [ 20 ] c . xl = iv [ 21 ] c . xm = iv [ 22 ] c . xn = iv [ 23 ] c . xo = iv [ 24 ] c . xp = iv [ 25 ] c . xq = iv [ 26 ] c . xr = iv [ 27 ] c . xs = iv [ 28 ] c . xt = iv [ 29 ] c . xu = iv [ 30 ] c . xv = iv [ 31 ] return c } 
func cubehash256 ( data [ ] byte ) [ ] byte { c : = newcubehash ( ) buf : = make ( [ ] byte , 32 ) buf [ 0 ] = 0x80 c . inputblock ( data ) c . sixteenrounds ( ) c . inputblock ( buf ) c . sixteenrounds ( ) c . xv ^ = 1 for j : = 0 ; j < 10 ; j ++ { c . sixteenrounds ( ) } out : = make ( [ ] byte , 32 ) binary . littleendian . putuint32 ( out [ 0 : ] , c . x0 ) binary . littleendian . putuint32 ( out [ 4 : ] , c . x1 ) binary . littleendian . putuint32 ( out [ 8 : ] , c . x2 ) binary . littleendian . putuint32 ( out [ 12 : ] , c . x3 ) binary . littleendian . putuint32 ( out [ 16 : ] , c . x4 ) binary . littleendian . putuint32 ( out [ 20 : ] , c . x5 ) binary . littleendian . putuint32 ( out [ 24 : ] , c . x6 ) binary . littleendian . putuint32 ( out [ 28 : ] , c . x7 ) return out } 
func sum ( data [ ] byte ) ( [ ] byte , error ) { blake : = blake256 . new ( ) if , err : = blake . write ( data ) ; err ! = nil { return nil , err } resultblake : = blake . sum ( nil ) keccak : = sha3 . newkeccak256 ( ) if , err : = keccak . write ( resultblake ) ; err ! = nil { return nil , err } resultkeccak : = keccak . sum ( nil ) resultcube : = cubehash256 ( resultkeccak ) lyra2result : = make ( [ ] byte , 32 ) lyra2 ( lyra2result , resultcube , resultcube , 1 , 4 , 4 ) var skeinresult [ 32 ] byte skein . sum256 ( & skeinresult , lyra2result , nil ) resultcube2 : = cubehash256 ( skeinresult [ : ] ) resultbmw : = bmw256 ( resultcube2 ) return resultbmw , nil } 
func rotr64 ( w uint64 , c byte ) uint64 { return ( w > > c ) | ( w < < ( 64 - c ) ) } 
func g ( a , b , c , d uint64 ) ( uint64 , uint64 , uint64 , uint64 ) { a = a + b d = rotr64 ( d ^ a , 32 ) c = c + d b = rotr64 ( b ^ c , 24 ) a = a + b d = rotr64 ( d ^ a , 16 ) c = c + d b = rotr64 ( b ^ c , 63 ) return a , b , c , d } 
func initstate ( ) [ ] uint64 { state : = make ( [ ] uint64 , 16 ) state [ 8 ] = blake2biv [ 0 ] state [ 9 ] = blake2biv [ 1 ] state [ 10 ] = blake2biv [ 2 ] state [ 11 ] = blake2biv [ 3 ] state [ 12 ] = blake2biv [ 4 ] state [ 13 ] = blake2biv [ 5 ] state [ 14 ] = blake2biv [ 6 ] state [ 15 ] = blake2biv [ 7 ] return state } 
func squeeze ( state [ ] uint64 , out [ ] byte ) { tmp : = make ( [ ] byte , blocklenbytes ) for j : = 0 ; j < len ( out ) / blocklenbytes + 1 ; j ++ { for i : = 0 ; i < blocklenint64 ; i ++ { binary . littleendian . putuint64 ( tmp [ i * 8 : ] , state [ i ] ) } copy ( out [ j * blocklenbytes : ] , tmp ) blake2blyra ( state ) } } 
func absorbblock ( state [ ] uint64 , in [ ] uint64 ) { state [ 0 ] ^ = in [ 0 ] state [ 1 ] ^ = in [ 1 ] state [ 2 ] ^ = in [ 2 ] state [ 3 ] ^ = in [ 3 ] state [ 4 ] ^ = in [ 4 ] state [ 5 ] ^ = in [ 5 ] state [ 6 ] ^ = in [ 6 ] state [ 7 ] ^ = in [ 7 ] state [ 8 ] ^ = in [ 8 ] state [ 9 ] ^ = in [ 9 ] state [ 10 ] ^ = in [ 10 ] state [ 11 ] ^ = in [ 11 ] blake2blyra ( state ) } 
func absorbblockblake2safe ( state [ ] uint64 , in [ ] uint64 ) { state [ 0 ] ^ = in [ 0 ] state [ 1 ] ^ = in [ 1 ] state [ 2 ] ^ = in [ 2 ] state [ 3 ] ^ = in [ 3 ] state [ 4 ] ^ = in [ 4 ] state [ 5 ] ^ = in [ 5 ] state [ 6 ] ^ = in [ 6 ] state [ 7 ] ^ = in [ 7 ] blake2blyra ( state ) } 
func reducedsqueezerow0 ( state [ ] uint64 , rowout [ ] uint64 , ncols int ) { ptr : = ( ncols - 1 ) * blocklenint64 for i : = 0 ; i < ncols ; i ++ { ptrword : = rowout [ ptr : ] ptrword [ 0 ] = state [ 0 ] ptrword [ 1 ] = state [ 1 ] ptrword [ 2 ] = state [ 2 ] ptrword [ 3 ] = state [ 3 ] ptrword [ 4 ] = state [ 4 ] ptrword [ 5 ] = state [ 5 ] ptrword [ 6 ] = state [ 6 ] ptrword [ 7 ] = state [ 7 ] ptrword [ 8 ] = state [ 8 ] ptrword [ 9 ] = state [ 9 ] ptrword [ 10 ] = state [ 10 ] ptrword [ 11 ] = state [ 11 ] ptr - = blocklenint64 reducedblake2blyra ( state ) } } 
func newreaderbytecodeloader ( p parser . parser , c compiler . compiler ) * readerbytecodeloader { return & readerbytecodeloader { newflags ( ) , p , c } } 
func ( l * readerbytecodeloader ) loadreader ( name string , rdr io . reader ) ( * vm . bytecode , error ) { ast , err : = l . parser . parsereader ( name , rdr ) if err ! = nil { return nil , err } if l . shoulddumpast ( ) { fmt . fprintf ( os . stderr , " \n \n " , ast ) } bc , err : = l . compiler . compile ( ast ) if err ! = nil { return nil , err } return bc , nil } 
func newv3 ( namespace * uuid , name [ ] byte ) * uuid { uuid : = newbyhash ( md5 . new ( ) , namespace , name ) uuid [ 6 ] = ( uuid [ 6 ] & 0x0f ) | 0x30 return uuid } 
func txliteral ( st * state ) { st . sa = st . currentop ( ) . arg ( ) st . advance ( ) } 
func txfetchsymbol ( st * state ) { key : = st . currentop ( ) . arg ( ) vars : = st . vars ( ) if v , ok : = vars . get ( key ) ; ok { st . sa = v } else { st . sa = nil } st . advance ( ) } 
func txfetchfield ( st * state ) { container : = st . sa if container == nil { st . sa = nil } else { t : = reflect . typeof ( container ) var f reflect . value var v reflect . value name : = st . currentop ( ) . argstring ( ) switch t . kind ( ) { case reflect . ptr , reflect . struct : r , size : = utf8 . decoderuneinstring ( name ) name = string ( unicode . toupper ( r ) ) + name [ size : ] v = reflect . valueof ( container ) if t . kind ( ) == reflect . ptr { v = v . elem ( ) } if v . type ( ) . name ( ) == " " { switch name { case " " : name = " " case " " : name = " " case " " : name = " " case " " : name = " " case " " : name = " " } } f = v . fieldbyname ( name ) case reflect . map : v = reflect . valueof ( container ) f = v . mapindex ( reflect . valueof ( name ) ) default : panic ( fmt . sprintf ( " " , container , t ) ) } st . sa = f . interface ( ) } st . advance ( ) } 
func txunmarkraw ( st * state ) { if reflect . valueof ( st . sa ) . type ( ) == rawstringtype { st . sa = string ( interfacetostring ( st . sa ) ) } st . advance ( ) } 
func txprint ( st * state ) { arg : = st . sa if arg == nil { st . warnf ( " \n " ) } else if reflect . valueof ( st . sa ) . type ( ) ! = rawstringtype { st . appendoutputstring ( html . escapestring ( interfacetostring ( arg ) ) ) } else { st . appendoutputstring ( interfacetostring ( arg ) ) } st . advance ( ) } 
func txprintraw ( st * state ) { arg : = st . sa if arg == nil { st . warnf ( " \n " ) } else { st . appendoutputstring ( interfacetostring ( arg ) ) } st . advance ( ) } 
func newloopvar ( idx int , array reflect . value ) * loopvar { lv : = & loopvar { index : idx , count : idx + 1 , body : array , size : array . len ( ) , maxindex : array . len ( ) - 1 , peeknext : nil , peekprev : nil , isfirst : false , islast : false , } return lv } 
func txfuncall ( st * state ) { mark : = st . currentmark ( ) tip : = st . stack . size ( ) - 1 var args [ ] reflect . value if tip - mark - 1 > 0 { args = make ( [ ] reflect . value , tip - mark - 1 ) for i : = mark + 1 ; tip > i ; i ++ { v , : = st . stack . get ( i ) args [ i - mark ] = reflect . valueof ( v ) } } x : = st . sa st . sa = nil if x == nil { st . advance ( ) return } v : = reflect . valueof ( x ) if v . type ( ) . kind ( ) == reflect . func { fun : = reflect . valueof ( x ) invokefuncsinglereturn ( st , fun , args ) } st . advance ( ) } 
func txrange ( st * state ) { lhs : = interfacetonumeric ( st . sb ) . int ( ) rhs : = interfacetonumeric ( st . sa ) . int ( ) for i : = lhs ; i <= rhs ; i ++ { st . stackpush ( i ) } st . advance ( ) } 
func txmakearray ( st * state ) { start : = st . currentmark ( ) end : = st . stacktip ( ) if end <= start { panic ( fmt . sprintf ( " " , start , end ) ) } list : = make ( [ ] interface { } , end - start + 1 ) for i : = end ; i >= start ; i -- { list [ i - start ] = st . stackpop ( ) } st . sa = list st . advance ( ) } 
func txfuncallomni ( st * state ) { t : = reflect . valueof ( st . sa ) switch t . kind ( ) { case reflect . int : txmacrocall ( st ) case reflect . func : txfuncall ( st ) default : st . warnf ( " \n " , st . sa ) st . sa = nil st . advance ( ) } } 
func ( f * flags ) dumpast ( b bool ) { if b { f . flags | = maskdumpast } else { f . flags &= ^ maskdumpast } } 
func ( f * flags ) dumpbytecode ( b bool ) { if b { f . flags | = maskdumpbytecode } else { f . flags &= ^ maskdumpbytecode } } 
func ( o * naiveoptimizer ) optimize ( bc * vm . bytecode ) error { for i : = 0 ; i < bc . len ( ) ; i ++ { op : = bc . get ( i ) if op == nil { return errors . new ( " " + op . string ( ) + " " ) } switch op . type ( ) { case vm . txopliteral : if i + 1 < bc . len ( ) && bc . get ( i + 1 ) . type ( ) == vm . txopprintraw { bc . oplist [ i ] = vm . newop ( vm . txopprintrawconst , op . argstring ( ) ) bc . oplist [ i + 1 ] = vm . newop ( vm . txopnoop ) i ++ } } } return nil } 
func newfuncdepot ( namespace string ) * funcdepot { return & funcdepot { namespace , make ( map [ string ] reflect . value ) } } 
func ( fc * funcdepot ) get ( key string ) ( reflect . value , bool ) { f , ok : = fc . depot [ key ] return f , ok } 
func ( fc * funcdepot ) set ( key string , v interface { } ) { fc . depot [ key ] = reflect . valueof ( v ) } 
func newfiletemplatefetcher ( paths [ ] string ) ( * filetemplatefetcher , error ) { l : = & filetemplatefetcher { paths : make ( [ ] string , len ( paths ) ) , } for k , v : = range paths { abs , err : = filepath . abs ( v ) if err ! = nil { return nil , err } l . paths [ k ] = abs } return l , nil } 
func ( l * filetemplatefetcher ) fetchtemplate ( path string ) ( templatesource , error ) { if filepath . isabs ( path ) { return nil , errabsolutepathnotallowed } for , dir : = range l . paths { fullpath : = filepath . join ( dir , path ) , err : = os . stat ( fullpath ) if err ! = nil { continue } return newfilesource ( fullpath ) , nil } return nil , errtemplatenotfound } 
func ( s * filesource ) lastmodified ( ) ( time . time , error ) { if time . since ( s . laststat ) < time . second { return s . laststatresult . modtime ( ) , nil } fi , err : = os . stat ( s . path ) if err ! = nil { return time . time { } , err } s . laststat = time . now ( ) s . laststatresult = fi return s . laststatresult . modtime ( ) , nil } 
func ( s * filesource ) reader ( ) ( io . reader , error ) { fh , err : = os . open ( s . path ) if err ! = nil { return nil , err } return fh , nil } 
func ( s * filesource ) bytes ( ) ( [ ] byte , error ) { rdr , err : = s . reader ( ) if err ! = nil { return nil , err } return ioutil . readall ( rdr ) } 
func newstate ( ) * state { st : = & state { opidx : 0 , pc : newbytecode ( ) , stack : stack . new ( 5 ) , markstack : stack . new ( 5 ) , framestack : stack . new ( 5 ) , frames : stack . new ( 5 ) , vars : make ( vars ) , warn : os . stderr , maxloopcount : 1000 , } st . pushmark ( ) st . pushframe ( ) return st } 
func ( st * state ) pushframe ( ) * frame . frame { f : = frame . new ( st . framestack ) st . frames . push ( f ) f . setmark ( st . frames . size ( ) ) return f } 
func ( st * state ) popframe ( ) * frame . frame { x : = st . frames . pop ( ) if x == nil { return nil } f : = x . ( * frame . frame ) for i : = st . framestack . size ( ) ; i > f . mark ( ) ; i -- { st . framestack . pop ( ) } return f } 
func ( st * state ) currentframe ( ) * frame . frame { x , err : = st . frames . top ( ) if err ! = nil { return nil } return x . ( * frame . frame ) } 
func ( st * state ) warnf ( format string , args ... interface { } ) { st . warn . write ( [ ] byte ( fmt . sprintf ( format , args ... ) ) ) } 
func ( st * state ) appendoutputstring ( o string ) { st . output . write ( [ ] byte ( o ) ) } 
func ( st * state ) popmark ( ) int { x : = st . markstack . pop ( ) return x . ( int ) } 
func ( st * state ) currentmark ( ) int { x , err : = st . markstack . top ( ) if err ! = nil { x = 0 } return x . ( int ) } 
func ( st * state ) loadbytecode ( key string ) ( * bytecode , error ) { return st . loader . load ( key ) } 
func ( st * state ) reset ( ) { st . opidx = 0 st . sa = nil st . sb = nil st . stack . reset ( ) st . markstack . reset ( ) st . frames . reset ( ) st . framestack . reset ( ) st . pushmark ( ) st . pushframe ( ) } 
func ( f * frame ) declarevar ( v interface { } ) int { f . stack . push ( v ) return f . stack . size ( ) - 1 } 
func ( f * frame ) getlvar ( i int ) ( interface { } , error ) { v , err : = f . stack . get ( i ) if err ! = nil { return nil , errors . wrap ( err , " " + strconv . itoa ( i + f . mark ) ) } return v , nil } 
func ( f * frame ) setlvar ( i int , v interface { } ) { f . stack . set ( i , v ) } 
func newbytecode ( ) * bytecode { return & bytecode { generatedon : time . now ( ) , name : " " , oplist : nil , version : 1 . 0 , } } 
func ( b * bytecode ) append ( op op ) { b . oplist = append ( b . oplist , op ) } 
func ( b * bytecode ) appendop ( o optype , args ... interface { } ) op { x : = newop ( o , args ... ) b . append ( x ) return x } 
func ( b * bytecode ) string ( ) string { buf : = rbpool . get ( ) defer rbpool . release ( buf ) fmt . fprintf ( buf , " \n \n " , b . name , b . generatedon , ) for k , v : = range b . oplist { fmt . fprintf ( buf , " \n " , k + 1 , v ) } return buf . string ( ) } 
func newcachedbytecodeloader ( cache cache , cachelevel cachestrategy , fetcher templatefetcher , parser parser . parser , compiler compiler . compiler , ) * cachedbytecodeloader { return & cachedbytecodeloader { newstringbytecodeloader ( parser , compiler ) , newreaderbytecodeloader ( parser , compiler ) , fetcher , [ ] cache { memorycache { } , cache } , cachelevel , } } 
func newfilecache ( dir string ) ( * filecache , error ) { f : = & filecache { dir } return f , nil } 
func ( c * filecache ) getcachepath ( key string ) string { key = filepath . clean ( key ) key = strings . trimprefix ( key , " " ) return filepath . join ( c . dir , key ) } 
func ( c * filecache ) get ( key string ) ( * cacheentity , error ) { path : = c . getcachepath ( key ) file , err : = os . open ( path ) if err ! = nil { return nil , errors . wrap ( err , " " + path + " " ) } defer file . close ( ) var entity cacheentity dec : = gob . newdecoder ( file ) if err = dec . decode ( & entity ) ; err ! = nil { return nil , errors . wrap ( err , " " + path + " " ) } return & entity , nil } 
func ( c * filecache ) set ( key string , entity * cacheentity ) error { path : = c . getcachepath ( key ) if err : = os . mkdirall ( filepath . dir ( path ) , 0777 ) ; err ! = nil { return errors . wrap ( err , " " ) } file , err : = os . openfile ( path , os . o wronly | os . o create , 0666 ) if err ! = nil { return errors . wrap ( err , " " ) } defer file . close ( ) f : = bufio . newwriter ( file ) defer f . flush ( ) enc : = gob . newencoder ( f ) if err = enc . encode ( entity ) ; err ! = nil { return errors . wrap ( err , " " ) } return nil } 
func ( c * filecache ) delete ( key string ) error { return errors . wrap ( os . remove ( c . getcachepath ( key ) ) , " " ) } 
func ( c memorycache ) get ( key string ) ( * cacheentity , error ) { bc , ok : = c [ key ] if ! ok { return nil , errors . new ( " " ) } return bc , nil } 
func ( c memorycache ) set ( key string , bc * cacheentity ) error { c [ key ] = bc return nil } 
func ( c memorycache ) delete ( key string ) error { delete ( c , key ) return nil } 
func newstringlexer ( template string ) * parser . lexer { l : = parser . newstringlexer ( template , symbolset ) l . settagstart ( " " ) l . settagend ( " " ) return l } 
func newreaderlexer ( rdr io . reader ) * parser . lexer { l : = parser . newreaderlexer ( rdr , symbolset ) l . settagstart ( " " ) l . settagend ( " " ) return l } 
func ( p * tterse ) parsestring ( name , template string ) ( * parser . ast , error ) { b : = parser . newbuilder ( ) lex : = newstringlexer ( template ) return b . parse ( name , lex ) } 
func newv4 ( ) * uuid { buf : = make ( [ ] byte , 16 ) rand . read ( buf ) buf [ 6 ] = ( buf [ 6 ] & 0x0f ) | 0x40 var uuid uuid copy ( uuid [ : ] , buf [ : ] ) uuid . variantrfc4122 ( ) return & uuid } 
func ( p * kolonish ) parse ( name string , template [ ] byte ) ( * parser . ast , error ) { return p . parsestring ( name , string ( template ) ) } 
func ( p * kolonish ) parsereader ( name string , rdr io . reader ) ( * parser . ast , error ) { b : = parser . newbuilder ( ) lex : = newreaderlexer ( rdr ) return b . parse ( name , lex ) } 
func ( ast * ast ) visit ( ) < - chan node . node { c : = make ( chan node . node ) go func ( ) { defer close ( c ) ast . root . visit ( c ) } ( ) return c } 
func ( ast * ast ) string ( ) string { buf : = rbpool . get ( ) defer rbpool . release ( buf ) c : = ast . visit ( ) k : = 0 for v : = range c { k ++ fmt . fprintf ( buf , " \n " , k , v ) } return buf . string ( ) } 
func ( vm * vm ) run ( bc * bytecode , vars vars , output io . writer ) { if ! vm . issupportedbytecodeversion ( bc ) { panic ( fmt . sprintf ( " " , bc . version , ) ) } st : = vm . st if , ok : = output . ( * bufio . writer ) ; ! ok { output = bufio . newwriter ( output ) defer output . ( * bufio . writer ) . flush ( ) } st . reset ( ) st . pc = bc st . output = output newvars : = vars ( rvpool . get ( ) ) defer rvpool . release ( newvars ) defer newvars . reset ( ) st . vars = newvars if fc : = vm . functions ; fc ! = nil { for k , v : = range vm . functions { st . vars [ k ] = v } } if vars ! = nil { for k , v : = range vars { st . vars [ k ] = v } } st . loader = vm . loader for op : = st . currentop ( ) ; op . type ( ) ! = txopend ; op = st . currentop ( ) { op . call ( st ) } } 
func aligntypesforarithmetic ( left , right interface { } ) ( reflect . value , reflect . value ) { if left == nil { left = 0 } if right == nil { right = 0 } leftv : = interfacetonumeric ( left ) rightv : = interfacetonumeric ( right ) if leftv . kind ( ) == rightv . kind ( ) { return leftv , rightv } var alignto reflect . type if leftv . kind ( ) > rightv . kind ( ) { alignto = leftv . type ( ) } else { alignto = rightv . type ( ) } return leftv . convert ( alignto ) , rightv . convert ( alignto ) } 
func defaultcompiler ( tx * xslate , args args ) error { tx . compiler = compiler . new ( ) return nil } 
func defaultparser ( tx * xslate , args args ) error { syntax , ok : = args . get ( " " ) if ! ok { syntax = " " } switch syntax { case " " : tx . parser = tterse . new ( ) case " " , " " : tx . parser = kolonish . new ( ) default : return errors . new ( " " + syntax . ( string ) + " " ) } return nil } 
func defaultloader ( tx * xslate , args args ) error { var tmp interface { } tmp , ok : = args . get ( " " ) if ! ok { tmp , = ioutil . tempdir ( " " , " " ) } cachedir : = tmp . ( string ) tmp , ok = args . get ( " " ) if ! ok { cwd , : = os . getwd ( ) tmp = [ ] string { cwd } } paths : = tmp . ( [ ] string ) cache , err : = loader . newfilecache ( cachedir ) if err ! = nil { return err } fetcher , err : = loader . newfiletemplatefetcher ( paths ) if err ! = nil { return err } tmp , ok = args . get ( " " ) if ! ok { tmp = 1 } cachelevel : = tmp . ( int ) tx . loader = loader . newcachedbytecodeloader ( cache , loader . cachestrategy ( cachelevel ) , fetcher , tx . parser , tx . compiler ) return nil } 
func defaultvm ( tx * xslate , args args ) error { dvm : = vm . newvm ( ) dvm . loader = tx . loader tx . vm = dvm return nil } 
func ( args args ) get ( key string ) ( interface { } , bool ) { ret , ok : = args [ key ] return ret , ok } 
func ( tx * xslate ) configure ( args configureargs ) error { defaults : = map [ string ] func ( * xslate , args ) error { " " : defaultcompiler , " " : defaultparser , " " : defaultloader , " " : defaultvm , } for , key : = range [ ] string { " " , " " , " " , " " } { configkey : = " " + key configuror , ok : = args . get ( configkey ) if ! ok { configuror = defaults [ key ] } args , ok : = args . get ( key ) if ! ok { args = args { } } err : = tx . configuregeneric ( configuror , args . ( args ) ) if err ! = nil { return err } } if funcs , ok : = args . get ( " " ) ; ok { tx . vm . setfunctions ( vm . vars ( funcs . ( args ) ) ) } if debug { tx . dumpast ( true ) tx . dumpbytecode ( true ) } return nil } 
func new ( args ... args ) ( * xslate , error ) { tx : = & xslate { } if len ( args ) <= 0 { args = [ ] args { args { } } } err : = tx . configure ( args [ 0 ] ) if err ! = nil { return nil , err } return tx , nil } 
func ( tx xslate ) render ( name string , vars vars ) ( string , error ) { buf : = rbpool . get ( ) defer rbpool . release ( buf ) err : = tx . renderinto ( buf , name , vars ) if err ! = nil { return " " , errors . wrap ( err , " " ) } return buf . string ( ) , nil } 
func ( tx * xslate ) renderstring ( template string , vars vars ) ( string , error ) { , file , line , : = runtime . caller ( 1 ) bc , err : = tx . loader . loadstring ( fmt . sprintf ( " " , file , line ) , template ) if err ! = nil { return " " , errors . wrap ( err , " " ) } buf : = rbpool . get ( ) defer rbpool . release ( buf ) tx . vm . run ( bc , vm . vars ( vars ) , buf ) return buf . string ( ) , nil } 
func ( l * httptemplatefetcher ) fetchtemplate ( path string ) ( templatesource , error ) { u , err : = url . parse ( path ) if err ! = nil { return nil , fmt . errorf ( " " , err ) } if u . isabs ( ) { return nil , errabsolutepathnotallowed } for , base : = range l . urls { u : = base + " " + path res , err : = http . get ( u ) if err ! = nil { continue } return newhttpsource ( res ) } return nil , errtemplatenotfound } 
func newstringbytecodeloader ( p parser . parser , c compiler . compiler ) * stringbytecodeloader { return & stringbytecodeloader { newflags ( ) , p , c } } 
func ( l * stringbytecodeloader ) loadstring ( name string , template string ) ( * vm . bytecode , error ) { ast , err : = l . parser . parsestring ( name , template ) if err ! = nil { return nil , err } if l . shoulddumpast ( ) { fmt . fprintf ( os . stderr , " \n \n " , ast ) } bc , err : = l . compiler . compile ( ast ) if err ! = nil { return nil , err } if l . shoulddumpbytecode ( ) { fmt . fprintf ( os . stderr , " \n \n " , bc ) } return bc , nil } 
func ( v vars ) get ( k interface { } ) ( interface { } , bool ) { key , ok : = k . ( string ) if ! ok { key = fmt . sprintf ( " " , k ) } x , ok : = v [ key ] return x , ok } 
func newop ( o optype , args ... interface { } ) op { h : = optypetohandler ( o ) var arg interface { } if len ( args ) > 0 { arg = args [ 0 ] } return & op { optype : o , ophandler : h , uarg : arg , } } 
func ( o op ) argint ( ) int { v : = interfacetonumeric ( o . uarg ) return int ( v . int ( ) ) } 
func ( o op ) argstring ( ) string { if v , ok : = o . uarg . ( string ) ; ok { return v } return interfacetostring ( o . uarg ) } 
func keys ( m map [ interface { } ] interface { } ) [ ] interface { } { l : = make ( [ ] interface { } , len ( m ) ) i : = 0 for k : = range m { l [ i ] = k i ++ } return l } 
func ( ctx * context ) appendop ( o vm . optype , args ... interface { } ) vm . op { return ctx . bytecode . appendop ( o , args ... ) } 
func ( c * basiccompiler ) compile ( ast * parser . ast ) ( * vm . bytecode , error ) { ctx : = & context { bytecode : vm . newbytecode ( ) , } for , n : = range ast . root . nodes { compile ( ctx , n ) } ctx . bytecode . appendop ( vm . txopend ) opt : = & naiveoptimizer { } opt . optimize ( ctx . bytecode ) ctx . bytecode . name = ast . name return ctx . bytecode , nil } 
func newv1 ( ) * uuid { var uuid uuid requests < - true s : = < - answers copy ( uuid [ : 4 ] , s [ 4 : ] ) copy ( uuid [ 4 : 6 ] , s [ 2 : 4 ] ) copy ( uuid [ 6 : 8 ] , s [ : 2 ] ) uuid [ 6 ] = ( uuid [ 6 ] & 0x0f ) | 0x10 copy ( uuid [ 8 : 10 ] , s [ 8 : ] ) copy ( uuid [ 10 : ] , mac ) uuid . variantrfc4122 ( ) return & uuid } 
func newv5 ( namespaceuuid * uuid , name [ ] byte ) * uuid { uuid : = newbyhash ( sha1 . new ( ) , namespaceuuid , name ) uuid [ 6 ] = ( uuid [ 6 ] & 0x0f ) | 0x50 return uuid } 
func ( list lexsymbollist ) sort ( ) lexsymbollist { sorter : = lexsymbolsorter { list : list , } sort . sort ( sorter ) return sorter . list } 
func ( s lexsymbolsorter ) less ( i , j int ) bool { return s . list [ i ] . priority > s . list [ j ] . priority } 
func ( s lexsymbolsorter ) swap ( i , j int ) { s . list [ i ] , s . list [ j ] = s . list [ j ] , s . list [ i ] } 
func ( l * lexsymbolset ) copy ( ) * lexsymbolset { c : = newlexsymbolset ( ) for k , v : = range l . map { c . map [ k ] = lexsymbol { v . name , v . type , v . priority } } return c } 
func ( l * lexsymbolset ) set ( name string , typ lex . itemtype , prio ... float32 ) { var x float32 if len ( prio ) < 1 { x = 1 . 0 } else { x = prio [ 0 ] } l . map [ name ] = lexsymbol { name , typ , x } l . sortedlist = nil } 
func ( l * lexsymbolset ) getsortedlist ( ) lexsymbollist { if l . sortedlist ! = nil { return l . sortedlist } num : = len ( l . map ) list : = make ( lexsymbollist , num ) i : = 0 for , v : = range l . map { list [ i ] = v i ++ } l . sortedlist = list . sort ( ) return l . sortedlist } 
func ( s * stack ) top ( ) ( interface { } , error ) { if len ( * s ) == 0 { return nil , errors . new ( " " ) } return ( * s ) [ len ( * s ) - 1 ] , nil } 
func ( s * stack ) resize ( size int ) { newl : = make ( [ ] interface { } , len ( * s ) , size ) copy ( newl , * s ) * s = newl } 
func ( s * stack ) extend ( extendby int ) { s . resize ( s . size ( ) + extendby ) } 
func ( s * stack ) grow ( min int ) { if min <= s . buffersize ( ) { return } s . resize ( calcnewsize ( min ) ) } 
func ( s * stack ) get ( i int ) ( interface { } , error ) { if i < 0 | | i >= len ( * s ) { return nil , errors . new ( strconv . itoa ( i ) + " " ) } return ( * s ) [ i ] , nil } 
func ( s * stack ) set ( i int , v interface { } ) error { if i < 0 { return errors . new ( " " ) } if i >= s . buffersize ( ) { s . resize ( calcnewsize ( i ) ) } for len ( * s ) < i + 1 { * s = append ( * s , nil ) } ( * s ) [ i ] = v return nil } 
func ( s * stack ) push ( v interface { } ) { if len ( * s ) >= s . buffersize ( ) { s . resize ( calcnewsize ( cap ( * s ) ) ) } * s = append ( * s , v ) } 
func ( s * stack ) pop ( ) interface { } { l : = len ( * s ) if l == 0 { return nil } v : = ( * s ) [ l - 1 ] * s = ( * s ) [ : l - 1 ] return v } 
func ( s * stack ) string ( ) string { buf : = bytes . buffer { } for k , v : = range * s { fmt . fprintf ( & buf , " \n " , k , v ) } return buf . string ( ) } 
func gethostips ( ) ( [ ] net . ip , error ) { ifaces , err : = net . interfaces ( ) if err ! = nil { return nil , err } var ips [ ] net . ip for , iface : = range ifaces { if strings . hasprefix ( iface . name , " " ) { continue } addrs , err : = iface . addrs ( ) if err ! = nil { continue } for , addr : = range addrs { if ipnet , ok : = addr . ( * net . ipnet ) ; ok { ips = append ( ips , ipnet . ip ) } } } return ips , nil } 
func getprivatehostips ( ) ( [ ] net . ip , error ) { ips , err : = gethostips ( ) if err ! = nil { return nil , err } var privateips [ ] net . ip for , ip : = range ips { if ip . isloopback ( ) | | ip . to4 ( ) == nil | | ! isprivate ( ip ) { continue } privateips = append ( privateips , ip ) } return privateips , nil } 
func isprivate ( ip net . ip ) bool { for , ipnet : = range privatenets { if ipnet . contains ( ip ) { return true } } return false } 
func environ ( ) [ ] string { s : = make ( [ ] string , 0 ) flagset . visitall ( func ( f * flag . flag ) { if value , ok : = getenv ( f . name ) ; ok { s = append ( s , flagasenv ( f . name ) + " " + value ) } } ) return s } 
func defaultedflags ( ) [ ] string { m : = make ( map [ string ] bool ) flagset . visitall ( func ( f * flag . flag ) { m [ f . name ] = true } ) flagset . visit ( func ( f * flag . flag ) { delete ( m , f . name ) } ) s : = make ( [ ] string , 0 ) for name , : = range m { s = append ( s , name ) } return s } 
func flagasenv ( name string ) string { name = strings . toupper ( envprefix + name ) name = strings . replace ( name , " " , " " , - 1 ) name = strings . replace ( name , " " , " " , - 1 ) return name } 
func parse ( args [ ] string ) { if ! flagset . parsed ( ) { flagset . parse ( args ) } for , name : = range defaultedflags ( ) { if value , ok : = getenv ( name ) ; ok { flagset . set ( name , value ) } } } 
func newpolicy ( ) policy { p : = policy { minlength : 6 , maxlength : 16 , minlowers : 0 , minuppers : 0 , mindigits : 0 , minspclchars : 0 , lowerpool : " " , upperpool : " " , digitpool : " " , spclcharpool : " " , } return p } 
func createrandom ( bs [ ] byte , length int ) [ ] byte { filled : = make ( [ ] byte , length ) max : = len ( bs ) for i : = 0 ; i < length ; i ++ { shuffle ( bs ) filled [ i ] = bs [ random ( 0 , max ) ] } return filled } 
func shuffle ( bs [ ] byte ) { n : = len ( bs ) for i : = n - 1 ; i > 0 ; i -- { rand . seed ( time . now ( ) . unixnano ( ) ) j : = rand . intn ( i + 1 ) bs [ i ] , bs [ j ] = bs [ j ] , bs [ i ] } } 
func generate ( p policy ) ( string , error ) { if p . minlength < 0 | | p . maxlength < 0 | | p . minuppers < 0 | | p . minlowers < 0 | | p . mindigits < 0 | | p . minspclchars < 0 { return " " , errnegativelengthnotallowed } collectiveminlength : = p . minuppers + p . minlowers + p . mindigits + p . minspclchars if collectiveminlength > p . minlength { p . minlength = collectiveminlength } if p . minlength > p . maxlength { return " " , errmaxlengthexceeded } if p . maxlength == 0 { return " " , nil } capsalpha : = [ ] byte ( p . upperpool ) smallalpha : = [ ] byte ( p . lowerpool ) digits : = [ ] byte ( p . digitpool ) spclchars : = [ ] byte ( p . spclcharpool ) allchars : = [ ] byte ( p . upperpool + p . lowerpool + p . digitpool + p . spclcharpool ) passwd : = createrandom ( capsalpha , p . minuppers ) passwd = append ( passwd , createrandom ( smallalpha , p . minlowers ) ... ) passwd = append ( passwd , createrandom ( digits , p . mindigits ) ... ) passwd = append ( passwd , createrandom ( spclchars , p . minspclchars ) ... ) passlen : = len ( passwd ) if passlen < p . maxlength { randlength : = random ( p . minlength , p . maxlength ) passwd = append ( passwd , createrandom ( allchars , randlength - passlen ) ... ) } shuffle ( passwd ) return string ( passwd ) , nil } 
func executablefolder ( ) ( string , error ) { p , err : = executable ( ) if err ! = nil { return " " , err } folder , : = filepath . split ( p ) return folder , nil } 
func register ( server , shutdown interface { } , ignore ... func ( error ) bool ) option { return func ( s * sentinel ) error { s . lock ( ) defer s . unlock ( ) if s . started { return erralreadystarted } return s . register ( server , shutdown , ignore ... ) } } 
func server ( serverfuncs ... interface { } ) option { return func ( s * sentinel ) error { s . lock ( ) defer s . unlock ( ) if s . started { return erralreadystarted } var err error s . serverfuncs , err = convertandappendcontextfuncs ( s . serverfuncs , serverfuncs ... ) return err } } 
func shutdown ( shutdownfuncs ... interface { } ) option { return func ( s * sentinel ) error { s . lock ( ) defer s . unlock ( ) if s . started { return erralreadystarted } var err error s . shutdownfuncs , err = convertandappendcontextfuncs ( s . shutdownfuncs , shutdownfuncs ... ) return err } } 
func ignore ( ignore ... func ( error ) bool ) option { return func ( s * sentinel ) error { s . lock ( ) defer s . unlock ( ) if s . started { return erralreadystarted } s . ignoreerrors = append ( s . ignoreerrors , ignore ... ) return nil } } 
func sigs ( sigs ... os . signal ) option { return func ( s * sentinel ) error { s . lock ( ) defer s . unlock ( ) if s . started { return erralreadystarted } s . shutdownsigs = sigs return nil } } 
func logf ( f func ( string , ... interface { } ) ) option { return func ( s * sentinel ) error { s . logf = f return nil } } 
func errorf ( f func ( string , ... interface { } ) ) option { return func ( s * sentinel ) error { s . errf = f return nil } } 
func new ( opts ... option ) ( * sentinel , error ) { s : = & sentinel { shutdownduration : defaultshutdownduration , logf : func ( string , ... interface { } ) { } , } var err error for , o : = range opts { if err = o ( s ) ; err ! = nil { return nil , err } } if s . shutdownsigs == nil { s . shutdownsigs = [ ] os . signal { os . interrupt } } if s . errf == nil { s . errf = func ( str string , v ... interface { } ) { s . logf ( " " + str , v ... ) } } return s , nil } 
func ( s * sentinel ) run ( ctxt context . context ) error { s . lock ( ) if s . started { defer s . unlock ( ) return erralreadystarted } s . started = true s . unlock ( ) eg , ctxt : = errgroup . withcontext ( ctxt ) for , f : = range s . serverfuncs { eg . go ( func ( f func ( context . context ) error ) func ( ) error { return func ( ) error { return f ( ctxt ) } } ( f ) ) } eg . go ( func ( ) func ( ) error { s . sig = make ( chan os . signal , 1 ) signal . notify ( s . sig , s . shutdownsigs ... ) return func ( ) error { s . logf ( " " , < - s . sig ) return s . shutdown ( ) } } ( ) ) if err : = eg . wait ( ) ; err ! = nil && ! s . shutdownignore ( err ) { return err } return nil } 
func ( s * sentinel ) shutdown ( ) error { var firsterr error for i , f : = range s . shutdownfuncs { ctxt , cancel : = context . withtimeout ( context . background ( ) , s . shutdownduration ) defer cancel ( ) if err : = f ( ctxt ) ; err ! = nil { s . errf ( " " , i , err ) if firsterr == nil { firsterr = err } } } return firsterr } 
func ( s * sentinel ) shutdownignore ( err error ) bool { if err == nil { return true } for , f : = range s . ignoreerrors { if z : = f ( err ) ; z { return true } } return false } 
func ( s * sentinel ) register ( server , shutdown interface { } , ignore ... func ( error ) bool ) error { var err error s . serverfuncs , err = convertandappendcontextfuncs ( s . serverfuncs , server ) if err ! = nil { return err } s . shutdownfuncs , err = convertandappendcontextfuncs ( s . shutdownfuncs , shutdown ) if err ! = nil { return err } s . ignoreerrors = append ( s . ignoreerrors , ignore ... ) return nil } 
func ( s * sentinel ) mux ( listener net . listener , opts ... netmux . option ) ( * netmux . netmux , error ) { s . lock ( ) defer s . unlock ( ) if s . started { return nil , erralreadystarted } mux , err : = netmux . new ( listener , opts ... ) if err ! = nil { return nil , err } if err = s . register ( mux , mux , ignorelistenerclosed , ignorenetoperror ) ; err ! = nil { return nil , err } return mux , nil } 
func ignoreerror ( err error ) func ( error ) bool { return func ( e error ) bool { return err == e } } 
func ignorenetoperror ( err error ) bool { if operr , ok : = err . ( * net . operror ) ; ok { return operr . err . error ( ) == " " } return false } 
func convertandappendcontextfuncs ( o [ ] func ( context . context ) error , v ... interface { } ) ( [ ] func ( context . context ) error , error ) { for , z : = range v { var t func ( context . context ) error switch f : = z . ( type ) { case func ( context . context ) error : t = f case func ( ) : t = func ( context . context ) error { f ( ) return nil } case func ( ) error : t = func ( context . context ) error { return f ( ) } } if t == nil { return nil , errinvalidtype } o = append ( o , t ) } return o , nil } 
func runserver ( services map [ string ] service , healthhandler func ( http . responsewriter , * http . request ) , port int , servicename string , env string ) { runserverwithconf ( rwconf { enablereqlog : true , services : services , env : env , healthhandler : healthhandler , port : port , servicename : servicename , } ) } 
func outputmetricsifrequired ( graphitetcpaddress string , graphiteprefix string , logmetrics bool ) { if graphitetcpaddress ! = " " { addr , : = net . resolvetcpaddr ( " " , graphitetcpaddress ) go graphite . graphite ( metrics . defaultregistry , 5 * time . second , graphiteprefix , addr ) } if logmetrics { go metrics . log ( metrics . defaultregistry , 60 * time . second , standardlog . new ( os . stdout , " " , standardlog . lmicroseconds ) ) } } 
func buildinfohandler ( w http . responsewriter , req * http . request ) { fmt . fprintf ( w , " " ) } 
func contextwithcookiesecret ( secret string ) martini . handler { return func ( w http . responsewriter , req * http . request , mc martini . context ) { ctx : = & context { req , map [ string ] string { } , secret , w } tm : = time . now ( ) . utc ( ) req . parseform ( ) if len ( req . form ) > 0 { for k , v : = range req . form { ctx . params [ k ] = v [ 0 ] } } ctx . setheader ( " " , webtime ( tm ) , true ) ctx . setheader ( " " , " " , true ) mc . map ( ctx ) } } 
func ( jsonencoder ) encode ( v ... interface { } ) ( [ ] byte , error ) { var data interface { } = v var result interface { } if v == nil { data = [ ] interface { } { } } else if len ( v ) == 1 { data = v [ 0 ] } t : = reflect . typeof ( data ) if t . kind ( ) == reflect . ptr { t = t . elem ( ) } if t . kind ( ) == reflect . struct { result = copystruct ( reflect . valueof ( data ) , t ) . interface ( ) } else { result = data } b , err : = json . marshal ( result ) return b , err } 
func bind ( obj interface { } , ifaceptr ... interface { } ) martini . handler { return func ( context martini . context , req * http . request ) { contenttype : = req . header . get ( " " ) if strings . contains ( contenttype , " " ) { context . invoke ( form ( obj , ifaceptr ... ) ) } else if strings . contains ( contenttype , " " ) { context . invoke ( multipartform ( obj , ifaceptr ... ) ) } else if strings . contains ( contenttype , " " ) { context . invoke ( json ( obj , ifaceptr ... ) ) } else { context . invoke ( json ( obj , ifaceptr ... ) ) if geterrors ( context ) . count ( ) > 0 { context . invoke ( form ( obj , ifaceptr ... ) ) } } context . invoke ( errorhandler ) } } 
func json ( jsonstruct interface { } , ifaceptr ... interface { } ) martini . handler { return func ( context martini . context , req * http . request ) { ensurenotpointer ( jsonstruct ) jsonstruct : = reflect . new ( reflect . typeof ( jsonstruct ) ) errors : = newerrors ( ) if req . body ! = nil { defer req . body . close ( ) } if err : = json . newdecoder ( req . body ) . decode ( jsonstruct . interface ( ) ) ; err ! = nil { errors . overall [ deserializationerror ] = err . error ( ) } validateandmap ( jsonstruct , context , errors , ifaceptr ... ) } } 
func validate ( obj interface { } ) martini . handler { return func ( context martini . context , req * http . request ) { errors : = newerrors ( ) validatestruct ( errors , obj ) if validator , ok : = obj . ( validator ) ; ok { validator . validate ( errors , req ) } context . map ( * errors ) } } 
func errorhandler ( errs errors , resp http . responsewriter ) { if errs . count ( ) > 0 { resp . header ( ) . set ( " " , " " ) if , ok : = errs . overall [ deserializationerror ] ; ok { resp . writeheader ( http . statusbadrequest ) } else { resp . writeheader ( 422 ) } erroutput , : = json . marshal ( errs ) resp . write ( erroutput ) return } } 
func setwithpropertype ( valuekind reflect . kind , val string , structfield reflect . value , nameintag string , errors * errors ) { switch valuekind { case reflect . int , reflect . int8 , reflect . int16 , reflect . int32 , reflect . int64 : if val == " " { val = " " } intval , err : = strconv . atoi ( val ) if err ! = nil { errors . fields [ nameintag ] = integertypeerror } else { structfield . setint ( int64 ( intval ) ) } case reflect . bool : if val == " " { val = " " } boolval , err : = strconv . parsebool ( val ) if err ! = nil { errors . fields [ nameintag ] = booleantypeerror } else { structfield . setbool ( boolval ) } case reflect . float32 : if val == " " { val = " " } floatval , err : = strconv . parsefloat ( val , 32 ) if err ! = nil { errors . fields [ nameintag ] = floattypeerror } else { structfield . setfloat ( floatval ) } case reflect . float64 : if val == " " { val = " " } floatval , err : = strconv . parsefloat ( val , 64 ) if err ! = nil { errors . fields [ nameintag ] = floattypeerror } else { structfield . setfloat ( floatval ) } case reflect . string : structfield . setstring ( val ) } } 
func validateandmap ( obj reflect . value , context martini . context , errors * errors , ifaceptr ... interface { } ) { context . invoke ( validate ( obj . interface ( ) ) ) errors . combine ( geterrors ( context ) ) context . map ( * errors ) context . map ( obj . elem ( ) . interface ( ) ) if len ( ifaceptr ) > 0 { context . mapto ( obj . elem ( ) . interface ( ) , ifaceptr [ 0 ] ) } } 
func ( self errors ) count ( ) int { return len ( self . overall ) + len ( self . fields ) } 
func ( o * options ) header ( origin string ) ( headers map [ string ] string ) { headers = make ( map [ string ] string ) if ! o . allowallorigins && ! o . isoriginallowed ( origin ) { return } if o . allowallorigins { headers [ headeralloworigin ] = " " } else { headers [ headeralloworigin ] = origin } headers [ headerallowcredentials ] = strconv . formatbool ( o . allowcredentials ) if len ( o . allowmethods ) > 0 { headers [ headerallowmethods ] = strings . join ( o . allowmethods , " " ) } if len ( o . allowheaders ) > 0 { headers [ headerallowheaders ] = strings . join ( o . allowheaders , " " ) } if len ( o . exposeheaders ) > 0 { headers [ headerexposeheaders ] = strings . join ( o . exposeheaders , " " ) } if o . maxage > time . duration ( 0 ) { headers [ headermaxage ] = strconv . formatint ( int64 ( o . maxage / time . second ) , 10 ) } return } 
func ( o * options ) preflightheader ( origin , rmethod , rheaders string ) ( headers map [ string ] string ) { headers = make ( map [ string ] string ) if ! o . allowallorigins && ! o . isoriginallowed ( origin ) { return } for , method : = range o . allowmethods { if method == rmethod { headers [ headerallowmethods ] = strings . join ( o . allowmethods , " " ) break } } var allowed [ ] string for , rheader : = range strings . split ( rheaders , " " ) { lookuploop : for , allowedheader : = range o . allowheaders { if rheader == allowedheader { allowed = append ( allowed , rheader ) break lookuploop } } } if len ( allowed ) > 0 { headers [ headerallowheaders ] = strings . join ( allowed , " " ) } if len ( o . exposeheaders ) > 0 { headers [ headerexposeheaders ] = strings . join ( o . exposeheaders , " " ) } if o . maxage > time . duration ( 0 ) { headers [ headermaxage ] = strconv . formatint ( int64 ( o . maxage / time . second ) , 10 ) } return } 
func ( o * options ) isoriginallowed ( origin string ) ( allowed bool ) { for , pattern : = range o . alloworigins { allowed , = regexp . matchstring ( pattern , origin ) if allowed { return } } return } 
func allow ( opts * options ) http . handlerfunc { return func ( res http . responsewriter , req * http . request ) { var ( origin = req . header . get ( headerorigin ) requestedmethod = req . header . get ( headerrequestmethod ) requestedheaders = req . header . get ( headerrequestheaders ) headers map [ string ] string ) if req . method == " " && ( requestedmethod ! = " " | | requestedheaders ! = " " ) { headers = opts . preflightheader ( origin , requestedmethod , requestedheaders ) } else { headers = opts . header ( origin ) } for key , value : = range headers { res . header ( ) . set ( key , value ) } } } 
func renderer ( options ... options ) martini . handler { opt : = prepareoptions ( options ) cs : = preparecharset ( opt . charset ) t : = compile ( opt ) return func ( res http . responsewriter , req * http . request , c martini . context ) { if martini . env == martini . dev { t = compile ( opt ) } tc , : = t . clone ( ) c . mapto ( & renderer { res , req , tc , opt , cs } , ( * render ) ( nil ) ) } } 
func ( al acceptlanguages ) string ( ) string { output : = bytes . newbufferstring ( " " ) for i , language : = range al { output . writestring ( fmt . sprintf ( " " , language . language , language . quality ) ) if i ! = len ( al ) - 1 { output . writestring ( " " ) } } if output . len ( ) == 0 { output . writestring ( " " ) } return output . string ( ) } 
func sessionuser ( newuser func ( ) user ) martini . handler { return func ( s sessions . session , c martini . context , l * log . logger ) { userid : = s . get ( sessionkey ) user : = newuser ( ) if userid ! = nil { err : = user . getbyid ( userid ) if err ! = nil { l . printf ( " \n " , err ) } else { user . login ( ) } } c . mapto ( user , ( * user ) ( nil ) ) } } 
func authenticatesession ( s sessions . session , user user ) error { user . login ( ) return updateuser ( s , user ) } 
func logout ( s sessions . session , user user ) { user . logout ( ) s . delete ( sessionkey ) } 
func loginrequired ( r render . render , user user , req * http . request ) { if user . isauthenticated ( ) == false { path : = fmt . sprintf ( " " , redirecturl , redirectparam , req . url . path ) r . redirect ( path , 302 ) } } 
func updateuser ( s sessions . session , user user ) error { s . set ( sessionkey , user . uniqueid ( ) ) return nil } 
func ( u * myusermodel ) getbyid ( id interface { } ) error { err : = dbmap . selectone ( u , " " , id ) if err ! = nil { return err } return nil } 
func addresstoaccountid ( address string ) ( result xdr . accountid , err error ) { bytes , err : = strkey . decode ( strkey . versionbyteaccountid , address ) if err ! = nil { return } var raw xdr . uint256 copy ( raw [ : ] , bytes ) pk , err : = xdr . newpublickey ( xdr . cryptokeytypekeytypeed25519 , raw ) if err ! = nil { return } result = xdr . accountid ( pk ) return } 
func ( b * changetrustbuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { var err error switch mut : = m . ( type ) { case changetrustmutator : err = mut . mutatechangetrust ( & b . ct ) case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( m asset ) mutatechangetrust ( o * xdr . changetrustop ) ( err error ) { if m . native { return errors . new ( " " ) } o . line , err = m . toxdrobject ( ) return } 
func ( m limit ) mutatechangetrust ( o * xdr . changetrustop ) ( err error ) { o . limit , err = amount . parse ( string ( m ) ) return } 
func trust ( code , issuer string , args ... interface { } ) ( result changetrustbuilder ) { mutators : = [ ] interface { } { creditasset ( code , issuer ) , } limitset : = false for , mut : = range args { mutators = append ( mutators , mut ) , islimit : = mut . ( limit ) if islimit { limitset = true } } if ! limitset { mutators = append ( mutators , maxlimit ) } return changetrust ( mutators ... ) } 
func removetrust ( code , issuer string , args ... interface { } ) ( result changetrustbuilder ) { mutators : = [ ] interface { } { creditasset ( code , issuer ) , limit ( " " ) , } for , mut : = range args { mutators = append ( mutators , mut ) } return changetrust ( mutators ... ) } 
func ( b * paymentbuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { if , ok : = m . ( paywithpath ) ; ok { b . pathpayment = true break } } for , m : = range muts { var err error switch mut : = m . ( type ) { case paymentmutator : if b . pathpayment { err = mut . mutatepayment ( & b . pp ) } else { err = mut . mutatepayment ( & b . p ) } case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( m creditamount ) mutatepayment ( o interface { } ) ( err error ) { switch o : = o . ( type ) { default : err = errors . new ( " " ) case * xdr . paymentop : o . amount , err = amount . parse ( m . amount ) if err ! = nil { return } o . asset , err = createalphanumasset ( m . code , m . issuer ) case * xdr . pathpaymentop : o . destamount , err = amount . parse ( m . amount ) if err ! = nil { return } o . destasset , err = createalphanumasset ( m . code , m . issuer ) } return } 
func ( m destination ) mutatepayment ( o interface { } ) error { switch o : = o . ( type ) { default : return errors . new ( " " ) case * xdr . paymentop : return setaccountid ( m . addressorseed , & o . destination ) case * xdr . pathpaymentop : return setaccountid ( m . addressorseed , & o . destination ) } return nil } 
func ( m nativeamount ) mutatepayment ( o interface { } ) ( err error ) { switch o : = o . ( type ) { default : err = errors . new ( " " ) case * xdr . paymentop : o . amount , err = amount . parse ( m . amount ) if err ! = nil { return } o . asset , err = xdr . newasset ( xdr . assettypeassettypenative , nil ) case * xdr . pathpaymentop : o . destamount , err = amount . parse ( m . amount ) if err ! = nil { return } o . destasset , err = xdr . newasset ( xdr . assettypeassettypenative , nil ) } return } 
func ( m paywithpath ) mutatepayment ( o interface { } ) ( err error ) { var pathpaymentop * xdr . pathpaymentop var ok bool if pathpaymentop , ok = o . ( * xdr . pathpaymentop ) ; ! ok { return errors . new ( " " ) } pathpaymentop . sendmax , err = amount . parse ( m . maxamount ) if err ! = nil { return } var path [ ] xdr . asset var xdrasset xdr . asset for , asset : = range m . path { xdrasset , err = asset . toxdrobject ( ) if err ! = nil { return err } path = append ( path , xdrasset ) } pathpaymentop . path = path pathpaymentop . sendasset , err = m . asset . toxdrobject ( ) return } 
func ( b * accountmergebuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { var err error switch mut : = m . ( type ) { case accountmergemutator : err = mut . mutateaccountmerge ( b ) case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( m destination ) mutateaccountmerge ( o * accountmergebuilder ) error { return setaccountid ( m . addressorseed , & o . destination ) } 
func mustparse ( v string ) xdr . int64 { ret , err : = parse ( v ) if err ! = nil { panic ( err ) } return ret } 
func parse ( v string ) ( xdr . int64 , error ) { var f , o , r big . rat , ok : = f . setstring ( v ) if ! ok { return xdr . int64 ( 0 ) , fmt . errorf ( " " , v ) } o . setint64 ( one ) r . mul ( & f , & o ) is : = r . floatstring ( 0 ) i , err : = strconv . parseint ( is , 10 , 64 ) if err ! = nil { return xdr . int64 ( 0 ) , err } return xdr . int64 ( i ) , nil } 
func string ( v xdr . int64 ) string { var f , o , r big . rat f . setint64 ( int64 ( v ) ) o . setint64 ( one ) r . quo ( & f , & o ) return r . floatstring ( 7 ) } 
func createoffer ( rate rate , amount amount ) ( result manageofferbuilder ) { return manageoffer ( false , rate , amount ) } 
func createpassiveoffer ( rate rate , amount amount ) ( result manageofferbuilder ) { return manageoffer ( true , rate , amount ) } 
func updateoffer ( rate rate , amount amount , offerid offerid ) ( result manageofferbuilder ) { return manageoffer ( false , rate , amount , offerid ) } 
func deleteoffer ( rate rate , offerid offerid ) ( result manageofferbuilder ) { return manageoffer ( false , rate , amount ( " " ) , offerid ) } 
func manageoffer ( passiveoffer bool , muts ... interface { } ) ( result manageofferbuilder ) { result . passiveoffer = passiveoffer result . mutate ( muts ... ) return } 
func ( b * manageofferbuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { var err error switch mut : = m . ( type ) { case manageoffermutator : if b . passiveoffer { err = mut . mutatemanageoffer ( & b . po ) } else { err = mut . mutatemanageoffer ( & b . mo ) } case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( m amount ) mutatemanageoffer ( o interface { } ) ( err error ) { switch o : = o . ( type ) { default : err = errors . new ( " " ) case * xdr . manageofferop : o . amount , err = amount . parse ( string ( m ) ) case * xdr . createpassiveofferop : o . amount , err = amount . parse ( string ( m ) ) } return } 
func ( m offerid ) mutatemanageoffer ( o interface { } ) ( err error ) { switch o : = o . ( type ) { default : err = errors . new ( " " ) case * xdr . manageofferop : o . offerid = xdr . uint64 ( m ) } return } 
func ( m rate ) mutatemanageoffer ( o interface { } ) ( err error ) { switch o : = o . ( type ) { default : err = errors . new ( " " ) case * xdr . manageofferop : o . selling , err = m . selling . toxdrobject ( ) if err ! = nil { return } o . buying , err = m . buying . toxdrobject ( ) if err ! = nil { return } o . price , err = price . parse ( string ( m . price ) ) case * xdr . createpassiveofferop : o . selling , err = m . selling . toxdrobject ( ) if err ! = nil { return } o . buying , err = m . buying . toxdrobject ( ) if err ! = nil { return } o . price , err = price . parse ( string ( m . price ) ) } return } 
func ( m sourceaccount ) mutateoperation ( o * xdr . operation ) error { o . sourceaccount = & xdr . accountid { } return setaccountid ( m . addressorseed , o . sourceaccount ) } 
func ( p * price ) string ( ) string { return big . newrat ( int64 ( p . n ) , int64 ( p . d ) ) . floatstring ( 7 ) } 
func transaction ( muts ... transactionmutator ) ( result * transactionbuilder ) { result = & transactionbuilder { } result . mutate ( muts ... ) result . mutate ( defaults { } ) return } 
func ( b * transactionbuilder ) mutate ( muts ... transactionmutator ) { if b . tx == nil { b . tx = & xdr . transaction { } } for , m : = range muts { err : = m . mutatetransaction ( b ) if err ! = nil { b . err = err return } } } 
func ( b * transactionbuilder ) hash ( ) ( [ 32 ] byte , error ) { var txbytes bytes . buffer , err : = fmt . fprintf ( & txbytes , " " , b . networkid ) if err ! = nil { return [ 32 ] byte { } , err } , err = xdr . marshal ( & txbytes , xdr . envelopetypeenvelopetypetx ) if err ! = nil { return [ 32 ] byte { } , err } , err = xdr . marshal ( & txbytes , b . tx ) if err ! = nil { return [ 32 ] byte { } , err } return hash . hash ( txbytes . bytes ( ) ) , nil } 
func ( b * transactionbuilder ) hashhex ( ) ( string , error ) { hash , err : = b . hash ( ) if err ! = nil { return " " , err } return hex . encodetostring ( hash [ : ] ) , nil } 
func ( b * transactionbuilder ) sign ( signers ... string ) ( result transactionenvelopebuilder ) { result . mutate ( b ) for , s : = range signers { result . mutate ( sign { s } ) } return } 
func ( m allowtrustbuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypeallowtrust , m . at ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } 
func ( m autosequence ) mutatetransaction ( o * transactionbuilder ) error { source : = o . tx . sourceaccount if source == ( xdr . accountid { } ) { return errors . new ( " " ) } seq , err : = m . sequenceforaccount ( source . address ( ) ) if err ! = nil { return err } o . tx . seqnum = seq + 1 return nil } 
func ( m changetrustbuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypechangetrust , m . ct ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } 
func ( m createaccountbuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypecreateaccount , m . ca ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } 
func ( m defaults ) mutatetransaction ( o * transactionbuilder ) error { if o . tx . fee == 0 { o . tx . fee = xdr . uint32 ( 100 * len ( o . tx . operations ) ) } if o . networkid == [ 32 ] byte { } { o . networkid = defaultnetwork . id ( ) } return nil } 
func ( m inflationbuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypeinflation , nil ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } 
func ( m managedatabuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypemanagedata , m . md ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } 
func ( m manageofferbuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } if m . passiveoffer { m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypecreatepassiveoffer , m . po ) o . tx . operations = append ( o . tx . operations , m . o ) } else { m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypemanageoffer , m . mo ) o . tx . operations = append ( o . tx . operations , m . o ) } return m . err } 
func ( m memohash ) mutatetransaction ( o * transactionbuilder ) ( err error ) { o . tx . memo , err = xdr . newmemo ( xdr . memotypememohash , m . value ) return } 
func ( m memoid ) mutatetransaction ( o * transactionbuilder ) ( err error ) { o . tx . memo , err = xdr . newmemo ( xdr . memotypememoid , xdr . uint64 ( m . value ) ) return } 
func ( m memoreturn ) mutatetransaction ( o * transactionbuilder ) ( err error ) { o . tx . memo , err = xdr . newmemo ( xdr . memotypememoreturn , m . value ) return } 
func ( m memotext ) mutatetransaction ( o * transactionbuilder ) ( err error ) { if len ( [ ] byte ( m . value ) ) > memotextmaxlength { err = errors . new ( " " ) return } o . tx . memo , err = xdr . newmemo ( xdr . memotypememotext , m . value ) return } 
func ( m network ) mutatetransaction ( o * transactionbuilder ) error { o . networkid = m . id ( ) return nil } 
func ( m paymentbuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } if m . pathpayment { m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypepathpayment , m . pp ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypepayment , m . p ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } 
func ( m setoptionsbuilder ) mutatetransaction ( o * transactionbuilder ) error { if m . err ! = nil { return m . err } m . o . body , m . err = xdr . newoperationbody ( xdr . operationtypesetoptions , m . so ) o . tx . operations = append ( o . tx . operations , m . o ) return m . err } 
func ( m sequence ) mutatetransaction ( o * transactionbuilder ) error { o . tx . seqnum = xdr . sequencenumber ( m . sequence ) return nil } 
func ( m sourceaccount ) mutatetransaction ( o * transactionbuilder ) error { return setaccountid ( m . addressorseed , & o . tx . sourceaccount ) } 
func ( t * int64 ) scan ( src interface { } ) error { val , ok : = src . ( int64 ) if ! ok { return errors . new ( " " ) } * t = int64 ( val ) return nil } 
func safebase64scan ( src , dest interface { } ) error { var val string switch src : = src . ( type ) { case [ ] byte : val = string ( src ) case string : val = src default : return fmt . errorf ( " " , dest ) } return safeunmarshalbase64 ( val , dest ) } 
func ( entry * ledgerentry ) ledgerkey ( ) ledgerkey { var body interface { } switch entry . data . type { case ledgerentrytypeaccount : account : = entry . data . mustaccount ( ) body = ledgerkeyaccount { accountid : account . accountid , } case ledgerentrytypedata : data : = entry . data . mustdata ( ) body = ledgerkeydata { accountid : data . accountid , dataname : data . dataname , } case ledgerentrytypeoffer : offer : = entry . data . mustoffer ( ) body = ledgerkeyoffer { sellerid : offer . sellerid , offerid : offer . offerid , } case ledgerentrytypetrustline : tline : = entry . data . musttrustline ( ) body = ledgerkeytrustline { accountid : tline . accountid , asset : tline . asset , } default : panic ( fmt . errorf ( " " , entry . data . type ) ) } ret , err : = newledgerkey ( entry . data . type , body ) if err ! = nil { panic ( err ) } return ret } 
func ( b * bundle ) initialstate ( key xdr . ledgerkey ) ( * xdr . ledgerentry , error ) { all : = b . changes ( key ) if len ( all ) == 0 { return nil , errmetanotfound } first : = all [ 0 ] if first . type ! = xdr . ledgerentrychangetypeledgerentrystate { return nil , nil } result : = first . muststate ( ) return & result , nil } 
func ( b * bundle ) changes ( target xdr . ledgerkey ) ( ret [ ] xdr . ledgerentrychange ) { return b . changes ( target , math . maxint32 ) } 
func ( b * bundle ) stateafter ( key xdr . ledgerkey , opidx int ) ( * xdr . ledgerentry , error ) { all : = b . changes ( key , opidx ) if len ( all ) == 0 { return nil , errmetanotfound } change : = all [ len ( all ) - 1 ] switch change . type { case xdr . ledgerentrychangetypeledgerentrycreated : entry : = change . mustcreated ( ) return & entry , nil case xdr . ledgerentrychangetypeledgerentryremoved : return nil , nil case xdr . ledgerentrychangetypeledgerentryupdated : entry : = change . mustupdated ( ) return & entry , nil case xdr . ledgerentrychangetypeledgerentrystate : panic ( fmt . errorf ( " " ) ) default : panic ( fmt . errorf ( " " , change . type ) ) } } 
func ( b * bundle ) changes ( target xdr . ledgerkey , maxop int ) ( ret [ ] xdr . ledgerentrychange ) { for , change : = range b . feemeta { key : = change . ledgerkey ( ) if ! key . equals ( target ) { continue } ret = append ( ret , change ) } for i , op : = range b . transactionmeta . mustoperations ( ) { if i > maxop { break } for , change : = range op . changes { key : = change . ledgerkey ( ) if ! key . equals ( target ) { continue } ret = append ( ret , change ) } } return } 
func decode ( expected versionbyte , src string ) ( [ ] byte , error ) { if err : = checkvalidversionbyte ( expected ) ; err ! = nil { return nil , err } raw , err : = base32 . stdencoding . decodestring ( src ) if err ! = nil { return nil , err } if len ( raw ) < 3 { return nil , fmt . errorf ( " " , len ( raw ) ) } version : = versionbyte ( raw [ 0 ] ) vp : = raw [ 0 : len ( raw ) - 2 ] payload : = raw [ 1 : len ( raw ) - 2 ] checksum : = raw [ len ( raw ) - 2 : ] if version ! = expected { return nil , errinvalidversionbyte } if err : = crc16 . validate ( vp , checksum ) ; err ! = nil { return nil , err } return payload , nil } 
func mustdecode ( expected versionbyte , src string ) [ ] byte { d , err : = decode ( expected , src ) if err ! = nil { panic ( err ) } return d } 
func encode ( version versionbyte , src [ ] byte ) ( string , error ) { if err : = checkvalidversionbyte ( version ) ; err ! = nil { return " " , err } var raw bytes . buffer if err : = binary . write ( & raw , binary . littleendian , version ) ; err ! = nil { return " " , err } if , err : = raw . write ( src ) ; err ! = nil { return " " , err } checksum : = crc16 . checksum ( raw . bytes ( ) ) if , err : = raw . write ( checksum ) ; err ! = nil { return " " , err } result : = base32 . stdencoding . encodetostring ( raw . bytes ( ) ) return result , nil } 
func mustencode ( version versionbyte , src [ ] byte ) string { e , err : = encode ( version , src ) if err ! = nil { panic ( err ) } return e } 
func checkvalidversionbyte ( version versionbyte ) error { if version == versionbyteaccountid { return nil } if version == versionbyteseed { return nil } return errinvalidversionbyte } 
func checksum ( data [ ] byte ) [ ] byte { var crc uint16 var out bytes . buffer for , b : = range data { crc = ( ( crc < < 8 ) & 0xffff ) ^ crc16tab [ ( ( crc > > 8 ) ^ uint16 ( b ) ) & 0x00ff ] } err : = binary . write ( & out , binary . littleendian , crc ) if err ! = nil { panic ( err ) } return out . bytes ( ) } 
func validate ( data [ ] byte , expected [ ] byte ) error { actual : = checksum ( data ) if ! bytes . equal ( actual , expected ) { return errinvalidchecksum } return nil } 
func ( change * ledgerentrychange ) ledgerkey ( ) ledgerkey { switch change . type { case ledgerentrychangetypeledgerentrycreated : change : = change . mustcreated ( ) return change . ledgerkey ( ) case ledgerentrychangetypeledgerentryremoved : return change . mustremoved ( ) case ledgerentrychangetypeledgerentryupdated : change : = change . mustupdated ( ) return change . ledgerkey ( ) case ledgerentrychangetypeledgerentrystate : change : = change . muststate ( ) return change . ledgerkey ( ) default : panic ( fmt . errorf ( " " , change . type ) ) } } 
func checkplausible ( ) { for , r : = range prefix { if ! strings . containsrune ( alphabet , r ) { fmt . printf ( " \n " , strconv . quoterune ( r ) ) os . exit ( 1 ) } } } 
func ( aid * accountid ) address ( ) string { if aid == nil { return " " } switch aid . type { case cryptokeytypekeytypeed25519 : ed : = aid . musted25519 ( ) raw : = make ( [ ] byte , 32 ) copy ( raw , ed [ : ] ) return strkey . mustencode ( strkey . versionbyteaccountid , raw ) default : panic ( fmt . errorf ( " " , aid . type ) ) } } 
func ( aid * accountid ) equals ( other accountid ) bool { if aid . type ! = other . type { return false } switch aid . type { case cryptokeytypekeytypeed25519 : l : = aid . musted25519 ( ) r : = other . musted25519 ( ) return l == r default : panic ( fmt . errorf ( " " , aid . type ) ) } } 
func ( aid * accountid ) ledgerkey ( ) ( ret ledgerkey ) { err : = ret . setaccount ( * aid ) if err ! = nil { panic ( err ) } return } 
func ( aid * accountid ) setaddress ( address string ) error { if aid == nil { return nil } raw , err : = strkey . decode ( strkey . versionbyteaccountid , address ) if err ! = nil { return err } if len ( raw ) ! = 32 { return errors . new ( " " ) } var ui uint256 copy ( ui [ : ] , raw ) * aid , err = newaccountid ( cryptokeytypekeytypeed25519 , ui ) return err } 
func ( a asset ) toxdrobject ( ) ( xdr . asset , error ) { if a . native { return xdr . newasset ( xdr . assettypeassettypenative , nil ) } var issuer xdr . accountid err : = setaccountid ( a . issuer , & issuer ) if err ! = nil { return xdr . asset { } , err } length : = len ( a . code ) switch { case length >= 1 && length <= 4 : var codearray [ 4 ] byte bytearray : = [ ] byte ( a . code ) copy ( codearray [ : ] , bytearray [ 0 : length ] ) asset : = xdr . assetalphanum4 { codearray , issuer } return xdr . newasset ( xdr . assettypeassettypecreditalphanum4 , asset ) case length >= 5 && length <= 12 : var codearray [ 12 ] byte bytearray : = [ ] byte ( a . code ) copy ( codearray [ : ] , bytearray [ 0 : length ] ) asset : = xdr . assetalphanum12 { codearray , issuer } return xdr . newasset ( xdr . assettypeassettypecreditalphanum12 , asset ) default : return xdr . asset { } , errors . new ( " " ) } } 
func ( pathsend paywithpath ) through ( asset asset ) paywithpath { pathsend . path = append ( pathsend . path , asset ) return pathsend } 
func paywith ( sendasset asset , maxamount string ) paywithpath { return paywithpath { asset : sendasset , maxamount : maxamount , } } 
func ( b * transactionenvelopebuilder ) mutate ( muts ... transactionenvelopemutator ) { b . init ( ) for , m : = range muts { err : = m . mutatetransactionenvelope ( b ) if err ! = nil { b . err = err return } } } 
func ( b * transactionenvelopebuilder ) mutatetx ( muts ... transactionmutator ) { b . init ( ) if b . err ! = nil { return } b . child . mutate ( muts ... ) b . err = b . child . err } 
func ( b * transactionenvelopebuilder ) bytes ( ) ( [ ] byte , error ) { if b . err ! = nil { return nil , b . err } var txbytes bytes . buffer , err : = xdr . marshal ( & txbytes , b . e ) if err ! = nil { return nil , err } return txbytes . bytes ( ) , nil } 
func ( b * transactionenvelopebuilder ) base64 ( ) ( string , error ) { bs , err : = b . bytes ( ) return base64 . stdencoding . encodetostring ( bs ) , err } 
func ( m * transactionbuilder ) mutatetransactionenvelope ( txe * transactionenvelopebuilder ) error { if m . err ! = nil { return m . err } txe . e . tx = * m . tx newchild : = * m txe . child = & newchild m . tx = & txe . e . tx return nil } 
func ( b * setoptionsbuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { var err error switch mut : = m . ( type ) { case setoptionsmutator : err = mut . mutatesetoptions ( & b . so ) case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( m homedomain ) mutatesetoptions ( o * xdr . setoptionsop ) ( err error ) { if len ( m ) > 32 { return errors . new ( " " ) } value : = xdr . string32 ( m ) o . homedomain = & value return } 
func ( m inflationdest ) mutatesetoptions ( o * xdr . setoptionsop ) ( err error ) { o . inflationdest = & xdr . accountid { } err = setaccountid ( string ( m ) , o . inflationdest ) return } 
func ( m masterweight ) mutatesetoptions ( o * xdr . setoptionsop ) ( err error ) { val : = xdr . uint32 ( m ) o . masterweight = & val return } 
func ( m signer ) mutatesetoptions ( o * xdr . setoptionsop ) ( err error ) { var signer xdr . signer signer . weight = xdr . uint32 ( m . weight ) err = setaccountid ( m . publickey , & signer . pubkey ) o . signer = & signer return } 
func setthresholds ( low , medium , high uint32 ) thresholds { return thresholds { low : & low , medium : & medium , high : & high , } } 
func ( m thresholds ) mutatesetoptions ( o * xdr . setoptionsop ) ( err error ) { if m . low ! = nil { val : = xdr . uint32 ( * m . low ) o . lowthreshold = & val } if m . medium ! = nil { val : = xdr . uint32 ( * m . medium ) o . medthreshold = & val } if m . high ! = nil { val : = xdr . uint32 ( * m . high ) o . highthreshold = & val } return } 
func ( m setflag ) mutatesetoptions ( o * xdr . setoptionsop ) ( err error ) { if ! isflagvalid ( xdr . accountflags ( m ) ) { return errors . new ( " " ) } var val xdr . uint32 if o . setflags == nil { val = xdr . uint32 ( m ) } else { val = xdr . uint32 ( m ) | * o . setflags } o . setflags = & val return } 
func ( m clearflag ) mutatesetoptions ( o * xdr . setoptionsop ) ( err error ) { if ! isflagvalid ( xdr . accountflags ( m ) ) { return errors . new ( " " ) } var val xdr . uint32 if o . clearflags == nil { val = xdr . uint32 ( m ) } else { val = xdr . uint32 ( m ) | * o . clearflags } o . clearflags = & val return } 
func ( b * createaccountbuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { var err error switch mut : = m . ( type ) { case createaccountmutator : err = mut . mutatecreateaccount ( & b . ca ) case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( m destination ) mutatecreateaccount ( o * xdr . createaccountop ) error { return setaccountid ( m . addressorseed , & o . destination ) } 
func ( m nativeamount ) mutatecreateaccount ( o * xdr . createaccountop ) ( err error ) { o . startingbalance , err = amount . parse ( m . amount ) return } 
func random ( ) ( * full , error ) { var rawseed [ 32 ] byte , err : = io . readfull ( rand . reader , rawseed [ : ] ) if err ! = nil { return nil , err } kp , err : = fromrawseed ( rawseed ) if err ! = nil { return nil , err } return kp , nil } 
func master ( networkpassphrase string ) kp { kp , err : = fromrawseed ( network . id ( networkpassphrase ) ) if err ! = nil { panic ( err ) } return kp } 
func parse ( addressorseed string ) ( kp , error ) { , err : = strkey . decode ( strkey . versionbyteaccountid , addressorseed ) if err == nil { return & fromaddress { addressorseed } , nil } if err ! = strkey . errinvalidversionbyte { return nil , err } , err = strkey . decode ( strkey . versionbyteseed , addressorseed ) if err == nil { return & full { addressorseed } , nil } return nil , err } 
func fromrawseed ( rawseed [ 32 ] byte ) ( * full , error ) { seed , err : = strkey . encode ( strkey . versionbyteseed , rawseed [ : ] ) if err ! = nil { return nil , err } return & full { seed } , nil } 
func mustparse ( addressorseed string ) kp { kp , err : = parse ( addressorseed ) if err ! = nil { panic ( err ) } return kp } 
func cleardata ( name string , muts ... interface { } ) ( result managedatabuilder ) { result . md . dataname = xdr . string64 ( name ) result . md . datavalue = nil result . validatename ( ) result . mutate ( muts ... ) return } 
func setdata ( name string , value [ ] byte , muts ... interface { } ) ( result managedatabuilder ) { result . md . dataname = xdr . string64 ( name ) v : = xdr . datavalue ( value ) result . md . datavalue = & v result . validatename ( ) result . validatevalue ( ) result . mutate ( muts ... ) return } 
func ( b * managedatabuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { var err error switch mut : = m . ( type ) { case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( b * allowtrustbuilder ) mutate ( muts ... interface { } ) { for , m : = range muts { var err error switch mut : = m . ( type ) { case allowtrustmutator : err = mut . mutateallowtrust ( & b . at ) case operationmutator : err = mut . mutateoperation ( & b . o ) default : err = errors . new ( " " ) } if err ! = nil { b . err = err return } } } 
func ( m authorize ) mutateallowtrust ( o * xdr . allowtrustop ) error { o . authorize = m . value return nil } 
func ( m allowtrustasset ) mutateallowtrust ( o * xdr . allowtrustop ) ( err error ) { length : = len ( m . code ) switch { case length >= 1 && length <= 4 : var code [ 4 ] byte bytearray : = [ ] byte ( m . code ) copy ( code [ : ] , bytearray [ 0 : length ] ) o . asset , err = xdr . newallowtrustopasset ( xdr . assettypeassettypecreditalphanum4 , code ) case length >= 5 && length <= 12 : var code [ 12 ] byte bytearray : = [ ] byte ( m . code ) copy ( code [ : ] , bytearray [ 0 : length ] ) o . asset , err = xdr . newallowtrustopasset ( xdr . assettypeassettypecreditalphanum12 , code ) default : err = errors . new ( " " ) } return } 
func ( m trustor ) mutateallowtrust ( o * xdr . allowtrustop ) error { return setaccountid ( m . address , & o . trustor ) } 
func ( a allowtrustopasset ) toasset ( issuer accountid ) ( ret asset ) { var err error switch a . type { case assettypeassettypecreditalphanum4 : ret , err = newasset ( assettypeassettypecreditalphanum4 , assetalphanum4 { assetcode : a . mustassetcode4 ( ) , issuer : issuer , } ) case assettypeassettypecreditalphanum12 : ret , err = newasset ( assettypeassettypecreditalphanum12 , assetalphanum12 { assetcode : a . mustassetcode12 ( ) , issuer : issuer , } ) default : err = fmt . errorf ( " " , a . type ) } if err ! = nil { panic ( err ) } return } 
func ( a * asset ) setcredit ( code string , issuer accountid ) error { length : = len ( code ) var typ assettype var body interface { } switch { case length >= 1 && length <= 4 : newbody : = assetalphanum4 { issuer : issuer } copy ( newbody . assetcode [ : ] , [ ] byte ( code ) [ : length ] ) typ = assettypeassettypecreditalphanum4 body = newbody case length >= 5 && length <= 12 : newbody : = assetalphanum12 { issuer : issuer } copy ( newbody . assetcode [ : ] , [ ] byte ( code ) [ : length ] ) typ = assettypeassettypecreditalphanum4 body = newbody default : return errors . new ( " " ) } newa , err : = newasset ( typ , body ) if err ! = nil { return err } * a = newa return nil } 
func ( a * asset ) setnative ( ) error { newa , err : = newasset ( assettypeassettypenative , nil ) if err ! = nil { return err } * a = newa return nil } 
func ( a asset ) string ( ) string { var t , c , i string a . mustextract ( & t , & c , & i ) if a . type == assettypeassettypenative { return t } return fmt . sprintf ( " " , t , c , i ) } 
func ( a asset ) equals ( other asset ) bool { if a . type ! = other . type { return false } switch a . type { case assettypeassettypenative : return true case assettypeassettypecreditalphanum4 : l : = a . mustalphanum4 ( ) r : = other . mustalphanum4 ( ) return l . assetcode == r . assetcode && l . issuer . equals ( r . issuer ) case assettypeassettypecreditalphanum12 : l : = a . mustalphanum12 ( ) r : = other . mustalphanum12 ( ) return l . assetcode == r . assetcode && l . issuer . equals ( r . issuer ) default : panic ( fmt . errorf ( " " , a . type ) ) } } 
func ( a asset ) extract ( typ interface { } , code interface { } , issuer interface { } ) error { switch typ : = typ . ( type ) { case * assettype : * typ = a . type case * string : switch a . type { case assettypeassettypenative : * typ = " " case assettypeassettypecreditalphanum4 : * typ = " " case assettypeassettypecreditalphanum12 : * typ = " " } default : return errors . new ( " " ) } if code ! = nil { switch code : = code . ( type ) { case * string : switch a . type { case assettypeassettypecreditalphanum4 : an : = a . mustalphanum4 ( ) * code = strings . trimright ( string ( an . assetcode [ : ] ) , " \ x00 " ) case assettypeassettypecreditalphanum12 : an : = a . mustalphanum12 ( ) * code = strings . trimright ( string ( an . assetcode [ : ] ) , " \ x00 " ) } default : return errors . new ( " " ) } } if issuer ! = nil { switch issuer : = issuer . ( type ) { case * string : switch a . type { case assettypeassettypecreditalphanum4 : an : = a . mustalphanum4 ( ) raw : = an . issuer . musted25519 ( ) * issuer = strkey . mustencode ( strkey . versionbyteaccountid , raw [ : ] ) case assettypeassettypecreditalphanum12 : an : = a . mustalphanum12 ( ) raw : = an . issuer . musted25519 ( ) * issuer = strkey . mustencode ( strkey . versionbyteaccountid , raw [ : ] ) } default : return errors . new ( " " ) } } return nil } 
func ( a asset ) mustextract ( typ interface { } , code interface { } , issuer interface { } ) { err : = a . extract ( typ , code , issuer ) if err ! = nil { panic ( err ) } } 
func unmarshal ( r io . reader , v interface { } ) ( int , error ) { return xdr . unmarshal ( r , v ) } 
func marshal ( w io . writer , v interface { } ) ( int , error ) { return xdr . marshal ( w , v ) } 
func ( e cryptokeytype ) validenum ( v int32 ) bool { , ok : = cryptokeytypemap [ v ] return ok } 
func ( e cryptokeytype ) string ( ) string { name , : = cryptokeytypemap [ int32 ( e ) ] return name } 
func ( u publickey ) armforswitch ( sw int32 ) ( string , bool ) { switch cryptokeytype ( sw ) { case cryptokeytypekeytypeed25519 : return " " , true } return " " , false } 
func newpublickey ( atype cryptokeytype , value interface { } ) ( result publickey , err error ) { result . type = atype switch cryptokeytype ( atype ) { case cryptokeytypekeytypeed25519 : tv , ok : = value . ( uint256 ) if ! ok { err = fmt . errorf ( " " ) return } result . ed25519 = & tv } return } 
func ( u publickey ) musted25519 ( ) uint256 { val , ok : = u . geted25519 ( ) if ! ok { panic ( " " ) } return val } 
func ( u publickey ) geted25519 ( ) ( result uint256 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . ed25519 ok = true } return } 
func ( u nodeid ) armforswitch ( sw int32 ) ( string , bool ) { return publickey ( u ) . armforswitch ( sw ) } 
func newnodeid ( atype cryptokeytype , value interface { } ) ( result nodeid , err error ) { u , err : = newpublickey ( atype , value ) result = nodeid ( u ) return } 
func ( u nodeid ) geted25519 ( ) ( result uint256 , ok bool ) { return publickey ( u ) . geted25519 ( ) } 
func ( u accountid ) armforswitch ( sw int32 ) ( string , bool ) { return publickey ( u ) . armforswitch ( sw ) } 
func newaccountid ( atype cryptokeytype , value interface { } ) ( result accountid , err error ) { u , err : = newpublickey ( atype , value ) result = accountid ( u ) return } 
func ( u accountid ) geted25519 ( ) ( result uint256 , ok bool ) { return publickey ( u ) . geted25519 ( ) } 
func ( e assettype ) validenum ( v int32 ) bool { , ok : = assettypemap [ v ] return ok } 
func ( e assettype ) string ( ) string { name , : = assettypemap [ int32 ( e ) ] return name } 
func ( u asset ) armforswitch ( sw int32 ) ( string , bool ) { switch assettype ( sw ) { case assettypeassettypenative : return " " , true case assettypeassettypecreditalphanum4 : return " " , true case assettypeassettypecreditalphanum12 : return " " , true } return " " , false } 
func newasset ( atype assettype , value interface { } ) ( result asset , err error ) { result . type = atype switch assettype ( atype ) { case assettypeassettypenative : case assettypeassettypecreditalphanum4 : tv , ok : = value . ( assetalphanum4 ) if ! ok { err = fmt . errorf ( " " ) return } result . alphanum4 = & tv case assettypeassettypecreditalphanum12 : tv , ok : = value . ( assetalphanum12 ) if ! ok { err = fmt . errorf ( " " ) return } result . alphanum12 = & tv } return } 
func ( u asset ) mustalphanum4 ( ) assetalphanum4 { val , ok : = u . getalphanum4 ( ) if ! ok { panic ( " " ) } return val } 
func ( u asset ) getalphanum4 ( ) ( result assetalphanum4 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . alphanum4 ok = true } return } 
func ( u asset ) mustalphanum12 ( ) assetalphanum12 { val , ok : = u . getalphanum12 ( ) if ! ok { panic ( " " ) } return val } 
func ( u asset ) getalphanum12 ( ) ( result assetalphanum12 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . alphanum12 ok = true } return } 
func ( e thresholdindexes ) validenum ( v int32 ) bool { , ok : = thresholdindexesmap [ v ] return ok } 
func ( e thresholdindexes ) string ( ) string { name , : = thresholdindexesmap [ int32 ( e ) ] return name } 
func ( e ledgerentrytype ) validenum ( v int32 ) bool { , ok : = ledgerentrytypemap [ v ] return ok } 
func ( e ledgerentrytype ) string ( ) string { name , : = ledgerentrytypemap [ int32 ( e ) ] return name } 
func ( e accountflags ) validenum ( v int32 ) bool { , ok : = accountflagsmap [ v ] return ok } 
func ( e accountflags ) string ( ) string { name , : = accountflagsmap [ int32 ( e ) ] return name } 
func newaccountentryext ( v int32 , value interface { } ) ( result accountentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func ( e trustlineflags ) validenum ( v int32 ) bool { , ok : = trustlineflagsmap [ v ] return ok } 
func ( e trustlineflags ) string ( ) string { name , : = trustlineflagsmap [ int32 ( e ) ] return name } 
func newtrustlineentryext ( v int32 , value interface { } ) ( result trustlineentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func ( e offerentryflags ) validenum ( v int32 ) bool { , ok : = offerentryflagsmap [ v ] return ok } 
func ( e offerentryflags ) string ( ) string { name , : = offerentryflagsmap [ int32 ( e ) ] return name } 
func newofferentryext ( v int32 , value interface { } ) ( result offerentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func newdataentryext ( v int32 , value interface { } ) ( result dataentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func newledgerentrydata ( atype ledgerentrytype , value interface { } ) ( result ledgerentrydata , err error ) { result . type = atype switch ledgerentrytype ( atype ) { case ledgerentrytypeaccount : tv , ok : = value . ( accountentry ) if ! ok { err = fmt . errorf ( " " ) return } result . account = & tv case ledgerentrytypetrustline : tv , ok : = value . ( trustlineentry ) if ! ok { err = fmt . errorf ( " " ) return } result . trustline = & tv case ledgerentrytypeoffer : tv , ok : = value . ( offerentry ) if ! ok { err = fmt . errorf ( " " ) return } result . offer = & tv case ledgerentrytypedata : tv , ok : = value . ( dataentry ) if ! ok { err = fmt . errorf ( " " ) return } result . data = & tv } return } 
func ( u ledgerentrydata ) mustaccount ( ) accountentry { val , ok : = u . getaccount ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrydata ) getaccount ( ) ( result accountentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . account ok = true } return } 
func ( u ledgerentrydata ) musttrustline ( ) trustlineentry { val , ok : = u . gettrustline ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrydata ) gettrustline ( ) ( result trustlineentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . trustline ok = true } return } 
func ( u ledgerentrydata ) mustoffer ( ) offerentry { val , ok : = u . getoffer ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrydata ) getoffer ( ) ( result offerentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . offer ok = true } return } 
func ( u ledgerentrydata ) mustdata ( ) dataentry { val , ok : = u . getdata ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrydata ) getdata ( ) ( result dataentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . data ok = true } return } 
func newledgerentryext ( v int32 , value interface { } ) ( result ledgerentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func ( e envelopetype ) validenum ( v int32 ) bool { , ok : = envelopetypemap [ v ] return ok } 
func ( e envelopetype ) string ( ) string { name , : = envelopetypemap [ int32 ( e ) ] return name } 
func ( e operationtype ) validenum ( v int32 ) bool { , ok : = operationtypemap [ v ] return ok } 
func ( e operationtype ) string ( ) string { name , : = operationtypemap [ int32 ( e ) ] return name } 
func ( u allowtrustopasset ) armforswitch ( sw int32 ) ( string , bool ) { switch assettype ( sw ) { case assettypeassettypecreditalphanum4 : return " " , true case assettypeassettypecreditalphanum12 : return " " , true } return " " , false } 
func newallowtrustopasset ( atype assettype , value interface { } ) ( result allowtrustopasset , err error ) { result . type = atype switch assettype ( atype ) { case assettypeassettypecreditalphanum4 : tv , ok : = value . ( [ 4 ] byte ) if ! ok { err = fmt . errorf ( " " ) return } result . assetcode4 = & tv case assettypeassettypecreditalphanum12 : tv , ok : = value . ( [ 12 ] byte ) if ! ok { err = fmt . errorf ( " " ) return } result . assetcode12 = & tv } return } 
func ( u allowtrustopasset ) mustassetcode4 ( ) [ 4 ] byte { val , ok : = u . getassetcode4 ( ) if ! ok { panic ( " " ) } return val } 
func ( u allowtrustopasset ) getassetcode4 ( ) ( result [ 4 ] byte , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . assetcode4 ok = true } return } 
func ( u allowtrustopasset ) mustassetcode12 ( ) [ 12 ] byte { val , ok : = u . getassetcode12 ( ) if ! ok { panic ( " " ) } return val } 
func ( u allowtrustopasset ) getassetcode12 ( ) ( result [ 12 ] byte , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . assetcode12 ok = true } return } 
func ( u operationbody ) mustcreateaccountop ( ) createaccountop { val , ok : = u . getcreateaccountop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getcreateaccountop ( ) ( result createaccountop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . createaccountop ok = true } return } 
func ( u operationbody ) mustpaymentop ( ) paymentop { val , ok : = u . getpaymentop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getpaymentop ( ) ( result paymentop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . paymentop ok = true } return } 
func ( u operationbody ) mustpathpaymentop ( ) pathpaymentop { val , ok : = u . getpathpaymentop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getpathpaymentop ( ) ( result pathpaymentop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . pathpaymentop ok = true } return } 
func ( u operationbody ) mustmanageofferop ( ) manageofferop { val , ok : = u . getmanageofferop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getmanageofferop ( ) ( result manageofferop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . manageofferop ok = true } return } 
func ( u operationbody ) mustcreatepassiveofferop ( ) createpassiveofferop { val , ok : = u . getcreatepassiveofferop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getcreatepassiveofferop ( ) ( result createpassiveofferop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . createpassiveofferop ok = true } return } 
func ( u operationbody ) mustsetoptionsop ( ) setoptionsop { val , ok : = u . getsetoptionsop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getsetoptionsop ( ) ( result setoptionsop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . setoptionsop ok = true } return } 
func ( u operationbody ) mustchangetrustop ( ) changetrustop { val , ok : = u . getchangetrustop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getchangetrustop ( ) ( result changetrustop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . changetrustop ok = true } return } 
func ( u operationbody ) mustallowtrustop ( ) allowtrustop { val , ok : = u . getallowtrustop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getallowtrustop ( ) ( result allowtrustop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . allowtrustop ok = true } return } 
func ( u operationbody ) mustdestination ( ) accountid { val , ok : = u . getdestination ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getdestination ( ) ( result accountid , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . destination ok = true } return } 
func ( u operationbody ) mustmanagedataop ( ) managedataop { val , ok : = u . getmanagedataop ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationbody ) getmanagedataop ( ) ( result managedataop , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . managedataop ok = true } return } 
func ( e memotype ) validenum ( v int32 ) bool { , ok : = memotypemap [ v ] return ok } 
func ( e memotype ) string ( ) string { name , : = memotypemap [ int32 ( e ) ] return name } 
func ( u memo ) armforswitch ( sw int32 ) ( string , bool ) { switch memotype ( sw ) { case memotypememonone : return " " , true case memotypememotext : return " " , true case memotypememoid : return " " , true case memotypememohash : return " " , true case memotypememoreturn : return " " , true } return " " , false } 
func newmemo ( atype memotype , value interface { } ) ( result memo , err error ) { result . type = atype switch memotype ( atype ) { case memotypememonone : case memotypememotext : tv , ok : = value . ( string ) if ! ok { err = fmt . errorf ( " " ) return } result . text = & tv case memotypememoid : tv , ok : = value . ( uint64 ) if ! ok { err = fmt . errorf ( " " ) return } result . id = & tv case memotypememohash : tv , ok : = value . ( hash ) if ! ok { err = fmt . errorf ( " " ) return } result . hash = & tv case memotypememoreturn : tv , ok : = value . ( hash ) if ! ok { err = fmt . errorf ( " " ) return } result . rethash = & tv } return } 
func ( u memo ) musttext ( ) string { val , ok : = u . gettext ( ) if ! ok { panic ( " " ) } return val } 
func ( u memo ) gettext ( ) ( result string , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . text ok = true } return } 
func ( u memo ) mustid ( ) uint64 { val , ok : = u . getid ( ) if ! ok { panic ( " " ) } return val } 
func ( u memo ) getid ( ) ( result uint64 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . id ok = true } return } 
func ( u memo ) musthash ( ) hash { val , ok : = u . gethash ( ) if ! ok { panic ( " " ) } return val } 
func ( u memo ) gethash ( ) ( result hash , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . hash ok = true } return } 
func ( u memo ) mustrethash ( ) hash { val , ok : = u . getrethash ( ) if ! ok { panic ( " " ) } return val } 
func newtransactionext ( v int32 , value interface { } ) ( result transactionext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func ( e createaccountresultcode ) validenum ( v int32 ) bool { , ok : = createaccountresultcodemap [ v ] return ok } 
func ( e createaccountresultcode ) string ( ) string { name , : = createaccountresultcodemap [ int32 ( e ) ] return name } 
func ( u createaccountresult ) armforswitch ( sw int32 ) ( string , bool ) { switch createaccountresultcode ( sw ) { case createaccountresultcodecreateaccountsuccess : return " " , true default : return " " , true } } 
func newcreateaccountresult ( code createaccountresultcode , value interface { } ) ( result createaccountresult , err error ) { result . code = code switch createaccountresultcode ( code ) { case createaccountresultcodecreateaccountsuccess : default : } return } 
func ( e paymentresultcode ) validenum ( v int32 ) bool { , ok : = paymentresultcodemap [ v ] return ok } 
func ( e paymentresultcode ) string ( ) string { name , : = paymentresultcodemap [ int32 ( e ) ] return name } 
func ( u paymentresult ) armforswitch ( sw int32 ) ( string , bool ) { switch paymentresultcode ( sw ) { case paymentresultcodepaymentsuccess : return " " , true default : return " " , true } } 
func newpaymentresult ( code paymentresultcode , value interface { } ) ( result paymentresult , err error ) { result . code = code switch paymentresultcode ( code ) { case paymentresultcodepaymentsuccess : default : } return } 
func ( e pathpaymentresultcode ) validenum ( v int32 ) bool { , ok : = pathpaymentresultcodemap [ v ] return ok } 
func ( e pathpaymentresultcode ) string ( ) string { name , : = pathpaymentresultcodemap [ int32 ( e ) ] return name } 
func ( u pathpaymentresult ) armforswitch ( sw int32 ) ( string , bool ) { switch pathpaymentresultcode ( sw ) { case pathpaymentresultcodepathpaymentsuccess : return " " , true case pathpaymentresultcodepathpaymentnoissuer : return " " , true default : return " " , true } } 
func newpathpaymentresult ( code pathpaymentresultcode , value interface { } ) ( result pathpaymentresult , err error ) { result . code = code switch pathpaymentresultcode ( code ) { case pathpaymentresultcodepathpaymentsuccess : tv , ok : = value . ( pathpaymentresultsuccess ) if ! ok { err = fmt . errorf ( " " ) return } result . success = & tv case pathpaymentresultcodepathpaymentnoissuer : tv , ok : = value . ( asset ) if ! ok { err = fmt . errorf ( " " ) return } result . noissuer = & tv default : } return } 
func ( u pathpaymentresult ) mustsuccess ( ) pathpaymentresultsuccess { val , ok : = u . getsuccess ( ) if ! ok { panic ( " " ) } return val } 
func ( u pathpaymentresult ) getsuccess ( ) ( result pathpaymentresultsuccess , ok bool ) { armname , : = u . armforswitch ( int32 ( u . code ) ) if armname == " " { result = * u . success ok = true } return } 
func ( u pathpaymentresult ) mustnoissuer ( ) asset { val , ok : = u . getnoissuer ( ) if ! ok { panic ( " " ) } return val } 
func ( u pathpaymentresult ) getnoissuer ( ) ( result asset , ok bool ) { armname , : = u . armforswitch ( int32 ( u . code ) ) if armname == " " { result = * u . noissuer ok = true } return } 
func ( e manageofferresultcode ) validenum ( v int32 ) bool { , ok : = manageofferresultcodemap [ v ] return ok } 
func ( e manageofferresultcode ) string ( ) string { name , : = manageofferresultcodemap [ int32 ( e ) ] return name } 
func ( e manageoffereffect ) validenum ( v int32 ) bool { , ok : = manageoffereffectmap [ v ] return ok } 
func ( e manageoffereffect ) string ( ) string { name , : = manageoffereffectmap [ int32 ( e ) ] return name } 
func ( u manageoffersuccessresultoffer ) armforswitch ( sw int32 ) ( string , bool ) { switch manageoffereffect ( sw ) { case manageoffereffectmanageoffercreated : return " " , true case manageoffereffectmanageofferupdated : return " " , true default : return " " , true } } 
func newmanageoffersuccessresultoffer ( effect manageoffereffect , value interface { } ) ( result manageoffersuccessresultoffer , err error ) { result . effect = effect switch manageoffereffect ( effect ) { case manageoffereffectmanageoffercreated : tv , ok : = value . ( offerentry ) if ! ok { err = fmt . errorf ( " " ) return } result . offer = & tv case manageoffereffectmanageofferupdated : tv , ok : = value . ( offerentry ) if ! ok { err = fmt . errorf ( " " ) return } result . offer = & tv default : } return } 
func ( u manageoffersuccessresultoffer ) mustoffer ( ) offerentry { val , ok : = u . getoffer ( ) if ! ok { panic ( " " ) } return val } 
func ( u manageoffersuccessresultoffer ) getoffer ( ) ( result offerentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . effect ) ) if armname == " " { result = * u . offer ok = true } return } 
func ( u manageofferresult ) armforswitch ( sw int32 ) ( string , bool ) { switch manageofferresultcode ( sw ) { case manageofferresultcodemanageoffersuccess : return " " , true default : return " " , true } } 
func newmanageofferresult ( code manageofferresultcode , value interface { } ) ( result manageofferresult , err error ) { result . code = code switch manageofferresultcode ( code ) { case manageofferresultcodemanageoffersuccess : tv , ok : = value . ( manageoffersuccessresult ) if ! ok { err = fmt . errorf ( " " ) return } result . success = & tv default : } return } 
func ( u manageofferresult ) mustsuccess ( ) manageoffersuccessresult { val , ok : = u . getsuccess ( ) if ! ok { panic ( " " ) } return val } 
func ( u manageofferresult ) getsuccess ( ) ( result manageoffersuccessresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . code ) ) if armname == " " { result = * u . success ok = true } return } 
func ( e setoptionsresultcode ) validenum ( v int32 ) bool { , ok : = setoptionsresultcodemap [ v ] return ok } 
func ( e setoptionsresultcode ) string ( ) string { name , : = setoptionsresultcodemap [ int32 ( e ) ] return name } 
func ( u setoptionsresult ) armforswitch ( sw int32 ) ( string , bool ) { switch setoptionsresultcode ( sw ) { case setoptionsresultcodesetoptionssuccess : return " " , true default : return " " , true } } 
func newsetoptionsresult ( code setoptionsresultcode , value interface { } ) ( result setoptionsresult , err error ) { result . code = code switch setoptionsresultcode ( code ) { case setoptionsresultcodesetoptionssuccess : default : } return } 
func ( e changetrustresultcode ) validenum ( v int32 ) bool { , ok : = changetrustresultcodemap [ v ] return ok } 
func ( e changetrustresultcode ) string ( ) string { name , : = changetrustresultcodemap [ int32 ( e ) ] return name } 
func ( u changetrustresult ) armforswitch ( sw int32 ) ( string , bool ) { switch changetrustresultcode ( sw ) { case changetrustresultcodechangetrustsuccess : return " " , true default : return " " , true } } 
func newchangetrustresult ( code changetrustresultcode , value interface { } ) ( result changetrustresult , err error ) { result . code = code switch changetrustresultcode ( code ) { case changetrustresultcodechangetrustsuccess : default : } return } 
func ( e allowtrustresultcode ) validenum ( v int32 ) bool { , ok : = allowtrustresultcodemap [ v ] return ok } 
func ( e allowtrustresultcode ) string ( ) string { name , : = allowtrustresultcodemap [ int32 ( e ) ] return name } 
func ( u allowtrustresult ) armforswitch ( sw int32 ) ( string , bool ) { switch allowtrustresultcode ( sw ) { case allowtrustresultcodeallowtrustsuccess : return " " , true default : return " " , true } } 
func newallowtrustresult ( code allowtrustresultcode , value interface { } ) ( result allowtrustresult , err error ) { result . code = code switch allowtrustresultcode ( code ) { case allowtrustresultcodeallowtrustsuccess : default : } return } 
func ( e accountmergeresultcode ) validenum ( v int32 ) bool { , ok : = accountmergeresultcodemap [ v ] return ok } 
func ( e accountmergeresultcode ) string ( ) string { name , : = accountmergeresultcodemap [ int32 ( e ) ] return name } 
func ( u accountmergeresult ) armforswitch ( sw int32 ) ( string , bool ) { switch accountmergeresultcode ( sw ) { case accountmergeresultcodeaccountmergesuccess : return " " , true default : return " " , true } } 
func newaccountmergeresult ( code accountmergeresultcode , value interface { } ) ( result accountmergeresult , err error ) { result . code = code switch accountmergeresultcode ( code ) { case accountmergeresultcodeaccountmergesuccess : tv , ok : = value . ( int64 ) if ! ok { err = fmt . errorf ( " " ) return } result . sourceaccountbalance = & tv default : } return } 
func ( u accountmergeresult ) mustsourceaccountbalance ( ) int64 { val , ok : = u . getsourceaccountbalance ( ) if ! ok { panic ( " " ) } return val } 
func ( u accountmergeresult ) getsourceaccountbalance ( ) ( result int64 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . code ) ) if armname == " " { result = * u . sourceaccountbalance ok = true } return } 
func ( e inflationresultcode ) validenum ( v int32 ) bool { , ok : = inflationresultcodemap [ v ] return ok } 
func ( e inflationresultcode ) string ( ) string { name , : = inflationresultcodemap [ int32 ( e ) ] return name } 
func ( u inflationresult ) armforswitch ( sw int32 ) ( string , bool ) { switch inflationresultcode ( sw ) { case inflationresultcodeinflationsuccess : return " " , true default : return " " , true } } 
func newinflationresult ( code inflationresultcode , value interface { } ) ( result inflationresult , err error ) { result . code = code switch inflationresultcode ( code ) { case inflationresultcodeinflationsuccess : tv , ok : = value . ( [ ] inflationpayout ) if ! ok { err = fmt . errorf ( " " ) return } result . payouts = & tv default : } return } 
func ( u inflationresult ) mustpayouts ( ) [ ] inflationpayout { val , ok : = u . getpayouts ( ) if ! ok { panic ( " " ) } return val } 
func ( u inflationresult ) getpayouts ( ) ( result [ ] inflationpayout , ok bool ) { armname , : = u . armforswitch ( int32 ( u . code ) ) if armname == " " { result = * u . payouts ok = true } return } 
func ( e managedataresultcode ) validenum ( v int32 ) bool { , ok : = managedataresultcodemap [ v ] return ok } 
func ( e managedataresultcode ) string ( ) string { name , : = managedataresultcodemap [ int32 ( e ) ] return name } 
func ( u managedataresult ) armforswitch ( sw int32 ) ( string , bool ) { switch managedataresultcode ( sw ) { case managedataresultcodemanagedatasuccess : return " " , true default : return " " , true } } 
func newmanagedataresult ( code managedataresultcode , value interface { } ) ( result managedataresult , err error ) { result . code = code switch managedataresultcode ( code ) { case managedataresultcodemanagedatasuccess : default : } return } 
func ( e operationresultcode ) validenum ( v int32 ) bool { , ok : = operationresultcodemap [ v ] return ok } 
func ( e operationresultcode ) string ( ) string { name , : = operationresultcodemap [ int32 ( e ) ] return name } 
func ( u operationresulttr ) armforswitch ( sw int32 ) ( string , bool ) { switch operationtype ( sw ) { case operationtypecreateaccount : return " " , true case operationtypepayment : return " " , true case operationtypepathpayment : return " " , true case operationtypemanageoffer : return " " , true case operationtypecreatepassiveoffer : return " " , true case operationtypesetoptions : return " " , true case operationtypechangetrust : return " " , true case operationtypeallowtrust : return " " , true case operationtypeaccountmerge : return " " , true case operationtypeinflation : return " " , true case operationtypemanagedata : return " " , true } return " " , false } 
func ( u operationresulttr ) mustcreateaccountresult ( ) createaccountresult { val , ok : = u . getcreateaccountresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getcreateaccountresult ( ) ( result createaccountresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . createaccountresult ok = true } return } 
func ( u operationresulttr ) mustpaymentresult ( ) paymentresult { val , ok : = u . getpaymentresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getpaymentresult ( ) ( result paymentresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . paymentresult ok = true } return } 
func ( u operationresulttr ) mustpathpaymentresult ( ) pathpaymentresult { val , ok : = u . getpathpaymentresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getpathpaymentresult ( ) ( result pathpaymentresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . pathpaymentresult ok = true } return } 
func ( u operationresulttr ) mustmanageofferresult ( ) manageofferresult { val , ok : = u . getmanageofferresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getmanageofferresult ( ) ( result manageofferresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . manageofferresult ok = true } return } 
func ( u operationresulttr ) mustcreatepassiveofferresult ( ) manageofferresult { val , ok : = u . getcreatepassiveofferresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) mustsetoptionsresult ( ) setoptionsresult { val , ok : = u . getsetoptionsresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getsetoptionsresult ( ) ( result setoptionsresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . setoptionsresult ok = true } return } 
func ( u operationresulttr ) mustchangetrustresult ( ) changetrustresult { val , ok : = u . getchangetrustresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getchangetrustresult ( ) ( result changetrustresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . changetrustresult ok = true } return } 
func ( u operationresulttr ) mustallowtrustresult ( ) allowtrustresult { val , ok : = u . getallowtrustresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getallowtrustresult ( ) ( result allowtrustresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . allowtrustresult ok = true } return } 
func ( u operationresulttr ) mustaccountmergeresult ( ) accountmergeresult { val , ok : = u . getaccountmergeresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getaccountmergeresult ( ) ( result accountmergeresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . accountmergeresult ok = true } return } 
func ( u operationresulttr ) mustinflationresult ( ) inflationresult { val , ok : = u . getinflationresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getinflationresult ( ) ( result inflationresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . inflationresult ok = true } return } 
func ( u operationresulttr ) mustmanagedataresult ( ) managedataresult { val , ok : = u . getmanagedataresult ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresulttr ) getmanagedataresult ( ) ( result managedataresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . managedataresult ok = true } return } 
func ( u operationresult ) armforswitch ( sw int32 ) ( string , bool ) { switch operationresultcode ( sw ) { case operationresultcodeopinner : return " " , true default : return " " , true } } 
func newoperationresult ( code operationresultcode , value interface { } ) ( result operationresult , err error ) { result . code = code switch operationresultcode ( code ) { case operationresultcodeopinner : tv , ok : = value . ( operationresulttr ) if ! ok { err = fmt . errorf ( " " ) return } result . tr = & tv default : } return } 
func ( u operationresult ) musttr ( ) operationresulttr { val , ok : = u . gettr ( ) if ! ok { panic ( " " ) } return val } 
func ( u operationresult ) gettr ( ) ( result operationresulttr , ok bool ) { armname , : = u . armforswitch ( int32 ( u . code ) ) if armname == " " { result = * u . tr ok = true } return } 
func ( e transactionresultcode ) validenum ( v int32 ) bool { , ok : = transactionresultcodemap [ v ] return ok } 
func ( e transactionresultcode ) string ( ) string { name , : = transactionresultcodemap [ int32 ( e ) ] return name } 
func ( u transactionresultresult ) armforswitch ( sw int32 ) ( string , bool ) { switch transactionresultcode ( sw ) { case transactionresultcodetxsuccess : return " " , true case transactionresultcodetxfailed : return " " , true default : return " " , true } } 
func newtransactionresultresult ( code transactionresultcode , value interface { } ) ( result transactionresultresult , err error ) { result . code = code switch transactionresultcode ( code ) { case transactionresultcodetxsuccess : tv , ok : = value . ( [ ] operationresult ) if ! ok { err = fmt . errorf ( " " ) return } result . results = & tv case transactionresultcodetxfailed : tv , ok : = value . ( [ ] operationresult ) if ! ok { err = fmt . errorf ( " " ) return } result . results = & tv default : } return } 
func ( u transactionresultresult ) mustresults ( ) [ ] operationresult { val , ok : = u . getresults ( ) if ! ok { panic ( " " ) } return val } 
func ( u transactionresultresult ) getresults ( ) ( result [ ] operationresult , ok bool ) { armname , : = u . armforswitch ( int32 ( u . code ) ) if armname == " " { result = * u . results ok = true } return } 
func newtransactionresultext ( v int32 , value interface { } ) ( result transactionresultext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func newstellarvalueext ( v int32 , value interface { } ) ( result stellarvalueext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func newledgerheaderext ( v int32 , value interface { } ) ( result ledgerheaderext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func ( e ledgerupgradetype ) validenum ( v int32 ) bool { , ok : = ledgerupgradetypemap [ v ] return ok } 
func ( e ledgerupgradetype ) string ( ) string { name , : = ledgerupgradetypemap [ int32 ( e ) ] return name } 
func ( u ledgerupgrade ) armforswitch ( sw int32 ) ( string , bool ) { switch ledgerupgradetype ( sw ) { case ledgerupgradetypeledgerupgradeversion : return " " , true case ledgerupgradetypeledgerupgradebasefee : return " " , true case ledgerupgradetypeledgerupgrademaxtxsetsize : return " " , true } return " " , false } 
func newledgerupgrade ( atype ledgerupgradetype , value interface { } ) ( result ledgerupgrade , err error ) { result . type = atype switch ledgerupgradetype ( atype ) { case ledgerupgradetypeledgerupgradeversion : tv , ok : = value . ( uint32 ) if ! ok { err = fmt . errorf ( " " ) return } result . newledgerversion = & tv case ledgerupgradetypeledgerupgradebasefee : tv , ok : = value . ( uint32 ) if ! ok { err = fmt . errorf ( " " ) return } result . newbasefee = & tv case ledgerupgradetypeledgerupgrademaxtxsetsize : tv , ok : = value . ( uint32 ) if ! ok { err = fmt . errorf ( " " ) return } result . newmaxtxsetsize = & tv } return } 
func ( u ledgerupgrade ) mustnewledgerversion ( ) uint32 { val , ok : = u . getnewledgerversion ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerupgrade ) getnewledgerversion ( ) ( result uint32 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . newledgerversion ok = true } return } 
func ( u ledgerupgrade ) mustnewbasefee ( ) uint32 { val , ok : = u . getnewbasefee ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerupgrade ) getnewbasefee ( ) ( result uint32 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . newbasefee ok = true } return } 
func ( u ledgerupgrade ) mustnewmaxtxsetsize ( ) uint32 { val , ok : = u . getnewmaxtxsetsize ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerupgrade ) getnewmaxtxsetsize ( ) ( result uint32 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . newmaxtxsetsize ok = true } return } 
func ( u ledgerkey ) armforswitch ( sw int32 ) ( string , bool ) { switch ledgerentrytype ( sw ) { case ledgerentrytypeaccount : return " " , true case ledgerentrytypetrustline : return " " , true case ledgerentrytypeoffer : return " " , true case ledgerentrytypedata : return " " , true } return " " , false } 
func newledgerkey ( atype ledgerentrytype , value interface { } ) ( result ledgerkey , err error ) { result . type = atype switch ledgerentrytype ( atype ) { case ledgerentrytypeaccount : tv , ok : = value . ( ledgerkeyaccount ) if ! ok { err = fmt . errorf ( " " ) return } result . account = & tv case ledgerentrytypetrustline : tv , ok : = value . ( ledgerkeytrustline ) if ! ok { err = fmt . errorf ( " " ) return } result . trustline = & tv case ledgerentrytypeoffer : tv , ok : = value . ( ledgerkeyoffer ) if ! ok { err = fmt . errorf ( " " ) return } result . offer = & tv case ledgerentrytypedata : tv , ok : = value . ( ledgerkeydata ) if ! ok { err = fmt . errorf ( " " ) return } result . data = & tv } return } 
func ( u ledgerkey ) mustaccount ( ) ledgerkeyaccount { val , ok : = u . getaccount ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerkey ) getaccount ( ) ( result ledgerkeyaccount , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . account ok = true } return } 
func ( u ledgerkey ) musttrustline ( ) ledgerkeytrustline { val , ok : = u . gettrustline ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerkey ) gettrustline ( ) ( result ledgerkeytrustline , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . trustline ok = true } return } 
func ( u ledgerkey ) mustoffer ( ) ledgerkeyoffer { val , ok : = u . getoffer ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerkey ) getoffer ( ) ( result ledgerkeyoffer , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . offer ok = true } return } 
func ( u ledgerkey ) mustdata ( ) ledgerkeydata { val , ok : = u . getdata ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerkey ) getdata ( ) ( result ledgerkeydata , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . data ok = true } return } 
func ( e bucketentrytype ) validenum ( v int32 ) bool { , ok : = bucketentrytypemap [ v ] return ok } 
func ( e bucketentrytype ) string ( ) string { name , : = bucketentrytypemap [ int32 ( e ) ] return name } 
func ( u bucketentry ) armforswitch ( sw int32 ) ( string , bool ) { switch bucketentrytype ( sw ) { case bucketentrytypeliveentry : return " " , true case bucketentrytypedeadentry : return " " , true } return " " , false } 
func newbucketentry ( atype bucketentrytype , value interface { } ) ( result bucketentry , err error ) { result . type = atype switch bucketentrytype ( atype ) { case bucketentrytypeliveentry : tv , ok : = value . ( ledgerentry ) if ! ok { err = fmt . errorf ( " " ) return } result . liveentry = & tv case bucketentrytypedeadentry : tv , ok : = value . ( ledgerkey ) if ! ok { err = fmt . errorf ( " " ) return } result . deadentry = & tv } return } 
func ( u bucketentry ) mustliveentry ( ) ledgerentry { val , ok : = u . getliveentry ( ) if ! ok { panic ( " " ) } return val } 
func ( u bucketentry ) getliveentry ( ) ( result ledgerentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . liveentry ok = true } return } 
func ( u bucketentry ) mustdeadentry ( ) ledgerkey { val , ok : = u . getdeadentry ( ) if ! ok { panic ( " " ) } return val } 
func ( u bucketentry ) getdeadentry ( ) ( result ledgerkey , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . deadentry ok = true } return } 
func newtransactionhistoryentryext ( v int32 , value interface { } ) ( result transactionhistoryentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func ( u transactionhistoryresultentryext ) armforswitch ( sw int32 ) ( string , bool ) { switch int32 ( sw ) { case 0 : return " " , true } return " " , false } 
func newtransactionhistoryresultentryext ( v int32 , value interface { } ) ( result transactionhistoryresultentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func newledgerheaderhistoryentryext ( v int32 , value interface { } ) ( result ledgerheaderhistoryentryext , err error ) { result . v = v switch int32 ( v ) { case 0 : } return } 
func newscphistoryentry ( v int32 , value interface { } ) ( result scphistoryentry , err error ) { result . v = v switch int32 ( v ) { case 0 : tv , ok : = value . ( scphistoryentryv0 ) if ! ok { err = fmt . errorf ( " " ) return } result . v0 = & tv } return } 
func ( u scphistoryentry ) mustv0 ( ) scphistoryentryv0 { val , ok : = u . getv0 ( ) if ! ok { panic ( " " ) } return val } 
func ( u scphistoryentry ) getv0 ( ) ( result scphistoryentryv0 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . v ) ) if armname == " " { result = * u . v0 ok = true } return } 
func ( e ledgerentrychangetype ) validenum ( v int32 ) bool { , ok : = ledgerentrychangetypemap [ v ] return ok } 
func ( e ledgerentrychangetype ) string ( ) string { name , : = ledgerentrychangetypemap [ int32 ( e ) ] return name } 
func ( u ledgerentrychange ) armforswitch ( sw int32 ) ( string , bool ) { switch ledgerentrychangetype ( sw ) { case ledgerentrychangetypeledgerentrycreated : return " " , true case ledgerentrychangetypeledgerentryupdated : return " " , true case ledgerentrychangetypeledgerentryremoved : return " " , true case ledgerentrychangetypeledgerentrystate : return " " , true } return " " , false } 
func newledgerentrychange ( atype ledgerentrychangetype , value interface { } ) ( result ledgerentrychange , err error ) { result . type = atype switch ledgerentrychangetype ( atype ) { case ledgerentrychangetypeledgerentrycreated : tv , ok : = value . ( ledgerentry ) if ! ok { err = fmt . errorf ( " " ) return } result . created = & tv case ledgerentrychangetypeledgerentryupdated : tv , ok : = value . ( ledgerentry ) if ! ok { err = fmt . errorf ( " " ) return } result . updated = & tv case ledgerentrychangetypeledgerentryremoved : tv , ok : = value . ( ledgerkey ) if ! ok { err = fmt . errorf ( " " ) return } result . removed = & tv case ledgerentrychangetypeledgerentrystate : tv , ok : = value . ( ledgerentry ) if ! ok { err = fmt . errorf ( " " ) return } result . state = & tv } return } 
func ( u ledgerentrychange ) mustcreated ( ) ledgerentry { val , ok : = u . getcreated ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrychange ) getcreated ( ) ( result ledgerentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . created ok = true } return } 
func ( u ledgerentrychange ) mustupdated ( ) ledgerentry { val , ok : = u . getupdated ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrychange ) getupdated ( ) ( result ledgerentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . updated ok = true } return } 
func ( u ledgerentrychange ) mustremoved ( ) ledgerkey { val , ok : = u . getremoved ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrychange ) getremoved ( ) ( result ledgerkey , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . removed ok = true } return } 
func ( u ledgerentrychange ) muststate ( ) ledgerentry { val , ok : = u . getstate ( ) if ! ok { panic ( " " ) } return val } 
func ( u ledgerentrychange ) getstate ( ) ( result ledgerentry , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . state ok = true } return } 
func newtransactionmeta ( v int32 , value interface { } ) ( result transactionmeta , err error ) { result . v = v switch int32 ( v ) { case 0 : tv , ok : = value . ( [ ] operationmeta ) if ! ok { err = fmt . errorf ( " " ) return } result . operations = & tv } return } 
func ( u transactionmeta ) mustoperations ( ) [ ] operationmeta { val , ok : = u . getoperations ( ) if ! ok { panic ( " " ) } return val } 
func ( u transactionmeta ) getoperations ( ) ( result [ ] operationmeta , ok bool ) { armname , : = u . armforswitch ( int32 ( u . v ) ) if armname == " " { result = * u . operations ok = true } return } 
func ( e errorcode ) validenum ( v int32 ) bool { , ok : = errorcodemap [ v ] return ok } 
func ( e errorcode ) string ( ) string { name , : = errorcodemap [ int32 ( e ) ] return name } 
func ( e ipaddrtype ) validenum ( v int32 ) bool { , ok : = ipaddrtypemap [ v ] return ok } 
func ( e ipaddrtype ) string ( ) string { name , : = ipaddrtypemap [ int32 ( e ) ] return name } 
func ( u peeraddressip ) armforswitch ( sw int32 ) ( string , bool ) { switch ipaddrtype ( sw ) { case ipaddrtypeipv4 : return " " , true case ipaddrtypeipv6 : return " " , true } return " " , false } 
func newpeeraddressip ( atype ipaddrtype , value interface { } ) ( result peeraddressip , err error ) { result . type = atype switch ipaddrtype ( atype ) { case ipaddrtypeipv4 : tv , ok : = value . ( [ 4 ] byte ) if ! ok { err = fmt . errorf ( " " ) return } result . ipv4 = & tv case ipaddrtypeipv6 : tv , ok : = value . ( [ 16 ] byte ) if ! ok { err = fmt . errorf ( " " ) return } result . ipv6 = & tv } return } 
func ( u peeraddressip ) mustipv4 ( ) [ 4 ] byte { val , ok : = u . getipv4 ( ) if ! ok { panic ( " " ) } return val } 
func ( u peeraddressip ) getipv4 ( ) ( result [ 4 ] byte , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . ipv4 ok = true } return } 
func ( u peeraddressip ) mustipv6 ( ) [ 16 ] byte { val , ok : = u . getipv6 ( ) if ! ok { panic ( " " ) } return val } 
func ( u peeraddressip ) getipv6 ( ) ( result [ 16 ] byte , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . ipv6 ok = true } return } 
func ( e messagetype ) validenum ( v int32 ) bool { , ok : = messagetypemap [ v ] return ok } 
func ( e messagetype ) string ( ) string { name , : = messagetypemap [ int32 ( e ) ] return name } 
func ( u stellarmessage ) armforswitch ( sw int32 ) ( string , bool ) { switch messagetype ( sw ) { case messagetypeerrormsg : return " " , true case messagetypehello : return " " , true case messagetypeauth : return " " , true case messagetypedonthave : return " " , true case messagetypegetpeers : return " " , true case messagetypepeers : return " " , true case messagetypegettxset : return " " , true case messagetypetxset : return " " , true case messagetypetransaction : return " " , true case messagetypegetscpquorumset : return " " , true case messagetypescpquorumset : return " " , true case messagetypescpmessage : return " " , true case messagetypegetscpstate : return " " , true } return " " , false } 
func ( u stellarmessage ) musterror ( ) error { val , ok : = u . geterror ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) geterror ( ) ( result error , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . error ok = true } return } 
func ( u stellarmessage ) musthello ( ) hello { val , ok : = u . gethello ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) gethello ( ) ( result hello , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . hello ok = true } return } 
func ( u stellarmessage ) mustauth ( ) auth { val , ok : = u . getauth ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) getauth ( ) ( result auth , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . auth ok = true } return } 
func ( u stellarmessage ) mustdonthave ( ) donthave { val , ok : = u . getdonthave ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) getdonthave ( ) ( result donthave , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . donthave ok = true } return } 
func ( u stellarmessage ) mustpeers ( ) [ ] peeraddress { val , ok : = u . getpeers ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) getpeers ( ) ( result [ ] peeraddress , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . peers ok = true } return } 
func ( u stellarmessage ) musttxsethash ( ) uint256 { val , ok : = u . gettxsethash ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) gettxsethash ( ) ( result uint256 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . txsethash ok = true } return } 
func ( u stellarmessage ) musttxset ( ) transactionset { val , ok : = u . gettxset ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) gettxset ( ) ( result transactionset , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . txset ok = true } return } 
func ( u stellarmessage ) musttransaction ( ) transactionenvelope { val , ok : = u . gettransaction ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) gettransaction ( ) ( result transactionenvelope , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . transaction ok = true } return } 
func ( u stellarmessage ) mustqsethash ( ) uint256 { val , ok : = u . getqsethash ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) getqsethash ( ) ( result uint256 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . qsethash ok = true } return } 
func ( u stellarmessage ) mustqset ( ) scpquorumset { val , ok : = u . getqset ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) getqset ( ) ( result scpquorumset , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . qset ok = true } return } 
func ( u stellarmessage ) mustenvelope ( ) scpenvelope { val , ok : = u . getenvelope ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) getenvelope ( ) ( result scpenvelope , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . envelope ok = true } return } 
func ( u stellarmessage ) mustgetscpledgerseq ( ) uint32 { val , ok : = u . getgetscpledgerseq ( ) if ! ok { panic ( " " ) } return val } 
func ( u stellarmessage ) getgetscpledgerseq ( ) ( result uint32 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . getscpledgerseq ok = true } return } 
func ( u authenticatedmessage ) armforswitch ( sw int32 ) ( string , bool ) { switch uint32 ( sw ) { case 0 : return " " , true } return " " , false } 
func newauthenticatedmessage ( v uint32 , value interface { } ) ( result authenticatedmessage , err error ) { result . v = v switch uint32 ( v ) { case 0 : tv , ok : = value . ( authenticatedmessagev0 ) if ! ok { err = fmt . errorf ( " " ) return } result . v0 = & tv } return } 
func ( u authenticatedmessage ) mustv0 ( ) authenticatedmessagev0 { val , ok : = u . getv0 ( ) if ! ok { panic ( " " ) } return val } 
func ( u authenticatedmessage ) getv0 ( ) ( result authenticatedmessagev0 , ok bool ) { armname , : = u . armforswitch ( int32 ( u . v ) ) if armname == " " { result = * u . v0 ok = true } return } 
func ( e scpstatementtype ) validenum ( v int32 ) bool { , ok : = scpstatementtypemap [ v ] return ok } 
func ( e scpstatementtype ) string ( ) string { name , : = scpstatementtypemap [ int32 ( e ) ] return name } 
func ( u scpstatementpledges ) armforswitch ( sw int32 ) ( string , bool ) { switch scpstatementtype ( sw ) { case scpstatementtypescpstprepare : return " " , true case scpstatementtypescpstconfirm : return " " , true case scpstatementtypescpstexternalize : return " " , true case scpstatementtypescpstnominate : return " " , true } return " " , false } 
func newscpstatementpledges ( atype scpstatementtype , value interface { } ) ( result scpstatementpledges , err error ) { result . type = atype switch scpstatementtype ( atype ) { case scpstatementtypescpstprepare : tv , ok : = value . ( scpstatementprepare ) if ! ok { err = fmt . errorf ( " " ) return } result . prepare = & tv case scpstatementtypescpstconfirm : tv , ok : = value . ( scpstatementconfirm ) if ! ok { err = fmt . errorf ( " " ) return } result . confirm = & tv case scpstatementtypescpstexternalize : tv , ok : = value . ( scpstatementexternalize ) if ! ok { err = fmt . errorf ( " " ) return } result . externalize = & tv case scpstatementtypescpstnominate : tv , ok : = value . ( scpnomination ) if ! ok { err = fmt . errorf ( " " ) return } result . nominate = & tv } return } 
func ( u scpstatementpledges ) mustprepare ( ) scpstatementprepare { val , ok : = u . getprepare ( ) if ! ok { panic ( " " ) } return val } 
func ( u scpstatementpledges ) getprepare ( ) ( result scpstatementprepare , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . prepare ok = true } return } 
func ( u scpstatementpledges ) mustconfirm ( ) scpstatementconfirm { val , ok : = u . getconfirm ( ) if ! ok { panic ( " " ) } return val } 
func ( u scpstatementpledges ) getconfirm ( ) ( result scpstatementconfirm , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . confirm ok = true } return } 
func ( u scpstatementpledges ) mustexternalize ( ) scpstatementexternalize { val , ok : = u . getexternalize ( ) if ! ok { panic ( " " ) } return val } 
func ( u scpstatementpledges ) getexternalize ( ) ( result scpstatementexternalize , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . externalize ok = true } return } 
func ( u scpstatementpledges ) mustnominate ( ) scpnomination { val , ok : = u . getnominate ( ) if ! ok { panic ( " " ) } return val } 
func ( u scpstatementpledges ) getnominate ( ) ( result scpnomination , ok bool ) { armname , : = u . armforswitch ( int32 ( u . type ) ) if armname == " " { result = * u . nominate ok = true } return } 
func safeunmarshalbase64 ( data string , dest interface { } ) error { count : = & countwriter { } l : = len ( data ) b64 : = io . teereader ( strings . newreader ( data ) , count ) raw : = base64 . newdecoder ( base64 . stdencoding , b64 ) , err : = unmarshal ( raw , dest ) if err ! = nil { return err } if count . count ! = l { return fmt . errorf ( " " , l , count . count ) } return nil } 
func safeunmarshal ( data [ ] byte , dest interface { } ) error { r : = bytes . newreader ( data ) n , err : = unmarshal ( r , dest ) if err ! = nil { return err } if n ! = len ( data ) { return fmt . errorf ( " " , len ( data ) , n ) } return nil } 
func ( pr * pathpaymentresult ) sendamount ( ) int64 { s , ok : = pr . getsuccess ( ) if ! ok { return 0 } if len ( s . offers ) == 0 { return s . last . amount } sa : = s . offers [ 0 ] . assetbought var ret int64 for , o : = range s . offers { if o . assetbought . string ( ) ! = sa . string ( ) { break } ret += o . amountbought } return ret } 
func ( c * client ) loadaccount ( accountid string ) ( account account , err error ) { c . inithttpclient ( ) resp , err : = c . client . get ( c . url + " " + accountid ) if err ! = nil { return } err = decoderesponse ( resp , & account ) return } 
func ( c * client ) sequenceforaccount ( accountid string , ) ( xdr . sequencenumber , error ) { a , err : = c . loadaccount ( accountid ) if err ! = nil { return 0 , err } seq , err : = strconv . parseuint ( a . sequence , 10 , 64 ) if err ! = nil { return 0 , err } return xdr . sequencenumber ( seq ) , nil } 
func ( c * client ) submittransaction ( transactionenvelopexdr string ) ( response transactionsuccess , err error ) { v : = url . values { } v . set ( " " , transactionenvelopexdr ) c . inithttpclient ( ) resp , err : = c . client . postform ( c . url + " " , v ) if err ! = nil { return } err = decoderesponse ( resp , & response ) return } 
func ( key * ledgerkey ) equals ( other ledgerkey ) bool { if key . type ! = other . type { return false } switch key . type { case ledgerentrytypeaccount : l : = key . mustaccount ( ) r : = other . mustaccount ( ) return l . accountid . equals ( r . accountid ) case ledgerentrytypedata : l : = key . mustdata ( ) r : = other . mustdata ( ) return l . accountid . equals ( r . accountid ) && l . dataname == r . dataname case ledgerentrytypeoffer : l : = key . mustoffer ( ) r : = other . mustoffer ( ) return l . sellerid . equals ( r . sellerid ) && l . offerid == r . offerid case ledgerentrytypetrustline : l : = key . musttrustline ( ) r : = other . musttrustline ( ) return l . accountid . equals ( r . accountid ) && l . asset . equals ( r . asset ) default : panic ( fmt . errorf ( " " , key . type ) ) } } 
func ( key * ledgerkey ) setaccount ( account accountid ) error { data : = ledgerkeyaccount { account } nkey , err : = newledgerkey ( ledgerentrytypeaccount , data ) if err ! = nil { return err } * key = nkey return nil } 
func ( key * ledgerkey ) setdata ( account accountid , name string ) error { data : = ledgerkeydata { account , string64 ( name ) } nkey , err : = newledgerkey ( ledgerentrytypedata , data ) if err ! = nil { return err } * key = nkey return nil } 
func ( key * ledgerkey ) setoffer ( account accountid , id uint64 ) error { data : = ledgerkeyoffer { account , uint64 ( id ) } nkey , err : = newledgerkey ( ledgerentrytypeoffer , data ) if err ! = nil { return err } * key = nkey return nil } 
func ( key * ledgerkey ) settrustline ( account accountid , line asset ) error { data : = ledgerkeytrustline { account , line } nkey , err : = newledgerkey ( ledgerentrytypetrustline , data ) if err ! = nil { return err } * key = nkey return nil } 
func createattrlistdefinition ( listname string , atl [ ] attrtuple ) [ ] attrtuple { atlname2atl [ listname ] = atl return atl } 
func createmsgtype ( alist [ ] attrlisttuple , familyid uint16 ) messagetype { if v , exists : = family2mt [ familyid ] ; exists { return * v } var mt messagetype mt . initmessagetype ( alist , familyid ) family2mt [ familyid ] = & mt return mt } 
func ( ipvs * ipvsclient ) addfwmdest ( fwmark uint32 , rip string , vaf uint16 , port uint16 , weight int32 ) error { return ipvs . addfwmdestfwd ( fwmark , rip , vaf , port , weight , ipvs tunneling ) } 
func main ( ) { fmt . println ( " " ) ipvs : = new ( gnl2go . ipvsclient ) ipvs . init ( ) defer ipvs . exit ( ) data , : = ipvs . getallstatsbrief ( ) for k , v : = range data { fmt . println ( k ) stats : = v . getstats ( ) for nk , nv : = range stats { fmt . printf ( " " , nk , nv ) } fmt . printf ( " \n " ) } fmt . println ( " " ) } 
func ( b * chdbuilder ) add ( key [ ] byte , value [ ] byte ) { b . keys = append ( b . keys , key ) b . values = append ( b . values , value ) } 
func tryhash ( hasher * chdhasher , seen map [ uint64 ] bool , keys [ ] [ ] byte , values [ ] [ ] byte , indices [ ] uint16 , bucket * bucket , ri uint16 , r uint64 ) bool { duplicate : = make ( map [ uint64 ] bool ) hashes : = make ( [ ] uint64 , len ( bucket . keys ) ) for i , k : = range bucket . keys { h : = hasher . table ( r , k ) hashes [ i ] = h if seen [ h ] { return false } if duplicate [ h ] { return false } duplicate [ h ] = true } for , h : = range hashes { seen [ h ] = true } indices [ bucket . index ] = ri for i , h : = range hashes { keys [ h ] = bucket . keys [ i ] values [ h ] = bucket . values [ i ] } return true } 
func ( h * chdhasher ) hashindexfromkey ( b [ ] byte ) uint64 { return ( hasher ( b ) ^ h . r [ 0 ] ) % h . buckets } 
func ( h * chdhasher ) table ( r uint64 , b [ ] byte ) uint64 { return ( hasher ( b ) ^ h . r [ 0 ] ^ r ) % h . size } 
func ( c * chdhasher ) add ( r uint64 ) { c . r = append ( c . r , r ) } 
func ( b * slicereader ) readint ( ) uint64 { return uint64 ( binary . littleendian . uint32 ( b . read ( 4 ) ) ) } 
func read ( r io . reader ) ( * chd , error ) { b , err : = ioutil . readall ( r ) if err ! = nil { return nil , err } return mmap ( b ) } 
func mmap ( b [ ] byte ) ( * chd , error ) { c : = & chd { } bi : = & slicereader { b : b } rl : = bi . readint ( ) c . r = bi . readuint64array ( rl ) il : = bi . readint ( ) c . indices = bi . readuint16array ( il ) el : = bi . readint ( ) c . keys = make ( [ ] [ ] byte , el ) c . values = make ( [ ] [ ] byte , el ) for i : = uint64 ( 0 ) ; i < el ; i ++ { kl : = bi . readint ( ) vl : = bi . readint ( ) c . keys [ i ] = bi . read ( kl ) c . values [ i ] = bi . read ( vl ) } return c , nil } 
func ( c * chd ) get ( key [ ] byte ) [ ] byte { r0 : = c . r [ 0 ] h : = hasher ( key ) ^ r0 i : = h % uint64 ( len ( c . indices ) ) ri : = c . indices [ i ] if ri >= uint16 ( len ( c . r ) ) { return nil } r : = c . r [ ri ] ti : = ( h ^ r ) % uint64 ( len ( c . keys ) ) k : = c . keys [ ti ] if bytes . compare ( k , key ) ! = 0 { return nil } v : = c . values [ ti ] return v } 
func ( c * chd ) iterate ( ) * iterator { if len ( c . keys ) == 0 { return nil } return & iterator { c : c } } 
func ( c * chd ) write ( w io . writer ) error { write : = func ( nd ... interface { } ) error { for , d : = range nd { if err : = binary . write ( w , binary . littleendian , d ) ; err ! = nil { return err } } return nil } data : = [ ] interface { } { uint32 ( len ( c . r ) ) , c . r , uint32 ( len ( c . indices ) ) , c . indices , uint32 ( len ( c . keys ) ) , } if err : = write ( data ... ) ; err ! = nil { return err } for i : = range c . keys { k , v : = c . keys [ i ] , c . values [ i ] if err : = write ( uint32 ( len ( k ) ) , uint32 ( len ( v ) ) ) ; err ! = nil { return err } if , err : = w . write ( k ) ; err ! = nil { return err } if , err : = w . write ( v ) ; err ! = nil { return err } } return nil } 
func roll ( desc string ) ( rollresult , string , error ) { for , rollhandler : = range rollhandlers { rollhandler . pattern ( ) . longest ( ) if r : = rollhandler . pattern ( ) . findstringsubmatch ( desc ) ; r ! = nil { result , err : = rollhandler . roll ( r ) if err ! = nil { return nil , " " , err } indexes : = rollhandler . pattern ( ) . findstringsubmatchindex ( desc ) reason : = strings . trim ( desc [ indexes [ 0 ] + len ( r [ 0 ] ) : ] , " \ t \n " ) return result , reason , nil } } return nil , " " , errors . new ( " " + desc ) } 
func registerdatasources ( path string ) error { cs : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cs ) ) if c . mapnik register datasources ( cs ) == 0 { e : = c . gostring ( c . mapnik register last error ( ) ) if e ! = " " { return errors . new ( " " + e ) } return errors . new ( " " ) } return nil } 
func registerfonts ( path string ) error { cs : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cs ) ) if c . mapnik register fonts ( cs ) == 0 { e : = c . gostring ( c . mapnik register last error ( ) ) if e ! = " " { return errors . new ( " " + e ) } return errors . new ( " " ) } return nil } 
func new ( ) * map { return & map { m : c . mapnik map ( c . uint ( 800 ) , c . uint ( 600 ) ) , width : 800 , height : 600 , } } 
func newsized ( width , height int ) * map { return & map { m : c . mapnik map ( c . uint ( width ) , c . uint ( height ) ) , width : width , height : height , } } 
func ( m * map ) load ( stylesheet string ) error { cs : = c . cstring ( stylesheet ) defer c . free ( unsafe . pointer ( cs ) ) if c . mapnik map load ( m . m , cs ) ! = 0 { return m . lasterror ( ) } return nil } 
func ( m * map ) resize ( width , height int ) { c . mapnik map resize ( m . m , c . uint ( width ) , c . uint ( height ) ) m . width = width m . height = height } 
func ( m * map ) free ( ) { c . mapnik map free ( m . m ) m . m = nil } 
func ( m * map ) srs ( ) string { return c . gostring ( c . mapnik map get srs ( m . m ) ) } 
func ( m * map ) setsrs ( srs string ) { cs : = c . cstring ( srs ) defer c . free ( unsafe . pointer ( cs ) ) c . mapnik map set srs ( m . m , cs ) } 
func ( m * map ) zoomall ( ) error { if c . mapnik map zoom all ( m . m ) ! = 0 { return m . lasterror ( ) } return nil } 
func ( m * map ) zoomto ( minx , miny , maxx , maxy float64 ) { bbox : = c . mapnik bbox ( c . double ( minx ) , c . double ( miny ) , c . double ( maxx ) , c . double ( maxy ) ) defer c . mapnik bbox free ( bbox ) c . mapnik map zoom to box ( m . m , bbox ) } 
func ( m * map ) selectlayers ( selector layerselector ) bool { m . storelayerstatus ( ) selected : = false n : = c . mapnik map layer count ( m . m ) for i : = 0 ; i < int ( n ) ; i ++ { layername : = c . gostring ( c . mapnik map layer name ( m . m , c . size t ( i ) ) ) switch selector . select ( layername ) { case include : selected = true c . mapnik map layer set active ( m . m , c . size t ( i ) , 1 ) case exclude : c . mapnik map layer set active ( m . m , c . size t ( i ) , 0 ) case default : selected = true } } return selected } 
func ( m * map ) render ( opts renderopts ) ( [ ] byte , error ) { scalefactor : = opts . scalefactor if scalefactor == 0 . 0 { scalefactor = 1 . 0 } i : = c . mapnik map render to image ( m . m , c . double ( opts . scale ) , c . double ( scalefactor ) ) if i == nil { return nil , m . lasterror ( ) } defer c . mapnik image free ( i ) if opts . format == " " { size : = 0 raw : = c . mapnik image to raw ( i , ( * c . size t ) ( unsafe . pointer ( & size ) ) ) return c . gobytes ( unsafe . pointer ( raw ) , c . int ( size ) ) , nil } var format * c . char if opts . format ! = " " { format = c . cstring ( opts . format ) } else { format = c . cstring ( " " ) } b : = c . mapnik image to blob ( i , format ) if b == nil { return nil , errors . new ( " " + c . gostring ( c . mapnik image last error ( i ) ) ) } c . free ( unsafe . pointer ( format ) ) defer c . mapnik image blob free ( b ) return c . gobytes ( unsafe . pointer ( b . ptr ) , c . int ( b . len ) ) , nil } 
func ( m * map ) renderimage ( opts renderopts ) ( * image . nrgba , error ) { scalefactor : = opts . scalefactor if scalefactor == 0 . 0 { scalefactor = 1 . 0 } i : = c . mapnik map render to image ( m . m , c . double ( opts . scale ) , c . double ( scalefactor ) ) if i == nil { return nil , m . lasterror ( ) } defer c . mapnik image free ( i ) size : = 0 raw : = c . mapnik image to raw ( i , ( * c . size t ) ( unsafe . pointer ( & size ) ) ) b : = c . gobytes ( unsafe . pointer ( raw ) , c . int ( size ) ) img : = & image . nrgba { pix : b , stride : int ( m . width * 4 ) , rect : image . rect ( 0 , 0 , int ( m . width ) , int ( m . height ) ) , } return img , nil } 
func ( m * map ) rendertofile ( opts renderopts , path string ) error { scalefactor : = opts . scalefactor if scalefactor == 0 . 0 { scalefactor = 1 . 0 } cs : = c . cstring ( path ) defer c . free ( unsafe . pointer ( cs ) ) var format * c . char if opts . format ! = " " { format = c . cstring ( opts . format ) } else { format = c . cstring ( " " ) } defer c . free ( unsafe . pointer ( format ) ) if c . mapnik map render to file ( m . m , cs , c . double ( opts . scale ) , c . double ( scalefactor ) , format ) ! = 0 { return m . lasterror ( ) } return nil } 
func ( m * map ) setbuffersize ( s int ) { c . mapnik map set buffer size ( m . m , c . int ( s ) ) } 
func search ( st string , mx time . duration ) ( [ ] searchresponse , error ) { conn , err : = listenforsearchresponses ( ) if err ! = nil { return nil , err } defer conn . close ( ) searchbytes , broadcastaddr : = buildsearchrequest ( st , mx ) , err = conn . writeto ( searchbytes , broadcastaddr ) if err ! = nil { return nil , err } return readsearchresponses ( conn , mx ) } 
func ( c * wrappedconn ) write ( b [ ] byte ) ( n int , err error ) { n , err = c . conn . write ( b ) if err ! = nil { c . unusable = true } else { c . start = time . now ( ) } return } 
func newblockingpool ( initcap , maxcap int , livetime time . duration , factory factory ) ( pool , error ) { if initcap < 0 | | maxcap < 1 | | initcap > maxcap { return nil , errors . new ( " " ) } newpool : = & blockingpool { timeout : 3 , conns : make ( chan * wrappedconn , maxcap ) , factory : factory , livetime : livetime , } for i : = 0 ; i < initcap ; i ++ { newpool . conns < - newpool . wrap ( nil ) } return newpool , nil } 
func ( p * blockingpool ) get ( ) ( net . conn , error ) { conns : = p . conns if conns == nil { return nil , errclosed } select { case conn : = < - conns : if time . since ( conn . start ) > p . livetime { if conn . conn ! = nil { conn . conn . close ( ) conn . conn = nil } } if conn . conn == nil { var err error conn . conn , err = p . factory ( ) if err ! = nil { conn . start = time . now ( ) p . put ( conn ) return nil , err } } conn . unusable = false return conn , nil case < - time . after ( time . second * p . timeout ) : return nil , errtimeout } } 
func ( p * blockingpool ) put ( conn * wrappedconn ) error { conns : = p . conns if conns == nil { if conn . conn ! = nil { conn . conn . close ( ) conn . conn = nil } return errclosed } if conn . unusable { if conn . conn ! = nil { conn . conn . close ( ) conn . conn = nil } } conns < - conn return nil } 
func monotostereof32 ( buf * audio . float32buffer ) error { if buf == nil | | buf . format == nil | | buf . format . numchannels ! = 1 { return audio . errinvalidbuffer } stereodata : = make ( [ ] float32 , len ( buf . data ) * 2 ) var j int for i : = 0 ; i < len ( buf . data ) ; i ++ { stereodata [ j ] = buf . data [ i ] j ++ stereodata [ j ] = buf . data [ i ] j ++ } buf . data = stereodata buf . format . numchannels = 2 return nil } 
func monorms ( b * audio . floatbuffer , windowsize int ) error { if b == nil { return audio . errinvalidbuffer } if len ( b . data ) == 0 { return nil } out : = [ ] float64 { } winbuf : = make ( [ ] float64 , windowsize ) windowsizef : = float64 ( windowsize ) processwindow : = func ( idx int ) { total : = 0 . 0 for i : = 0 ; i < len ( winbuf ) ; i ++ { total += winbuf [ idx ] * winbuf [ idx ] } v : = math . sqrt ( ( 1 . 0 / windowsizef ) * total ) out = append ( out , v ) } nbrchans : = 1 if b . format ! = nil { nbrchans = b . format . numchannels } var windowidx int for i : = 0 ; i < len ( b . data ) ; i ++ { v : = b . data [ i ] if nbrchans > 1 { for j : = 1 ; j < nbrchans ; j ++ { i ++ v += b . data [ i ] } v / = float64 ( nbrchans ) } winbuf [ windowidx ] = v windowidx ++ if windowidx == windowsize | | i == ( len ( b . data ) - 1 ) { windowidx = 0 processwindow ( windowidx ) } } if b . format ! = nil { b . format . numchannels = 1 b . format . samplerate / = windowsize } b . data = out return nil } 
func normalizemax ( buf * audio . floatbuffer ) { if buf == nil { return } max : = 0 . 0 for i : = 0 ; i < len ( buf . data ) ; i ++ { if math . abs ( buf . data [ i ] ) > max { max = math . abs ( buf . data [ i ] ) } } if max ! = 0 . 0 { for i : = 0 ; i < len ( buf . data ) ; i ++ { buf . data [ i ] / = max } } } 
func gain ( buf * audio . floatbuffer , multiplier float64 ) error { if buf == nil { return audio . errinvalidbuffer } for i : = 0 ; i < len ( buf . data ) ; i ++ { buf . data [ i ] * = multiplier } return nil } 
func monodownmix ( buf * audio . floatbuffer ) error { if buf == nil | | buf . format == nil { return audio . errinvalidbuffer } nchans : = buf . format . numchannels if nchans < 2 { return nil } nchansf : = float64 ( nchans ) framecount : = buf . numframes ( ) newdata : = make ( [ ] float64 , framecount ) for i : = 0 ; i < framecount ; i ++ { newdata [ i ] = 0 for j : = 0 ; j < nchans ; j ++ { newdata [ i ] += buf . data [ i * nchans + j ] } newdata [ i ] / = nchansf } buf . data = newdata buf . format . numchannels = 1 return nil } 
func quantize ( buf * audio . floatbuffer , bitdepth int ) { if buf == nil { return } max : = math . pow ( 2 , float64 ( bitdepth ) ) - 1 buflen : = len ( buf . data ) for i : = 0 ; i < buflen ; i ++ { buf . data [ i ] = round ( ( buf . data [ i ] + 1 ) * max ) / max - 1 . 0 } } 
func pcmscale ( buf * audio . floatbuffer , bitdepth int ) error { if buf == nil | | buf . format == nil { return audio . errinvalidbuffer } factor : = math . pow ( 2 , 8 * float64 ( bitdepth / 8 ) - 1 ) for i : = 0 ; i < len ( buf . data ) ; i ++ { buf . data [ i ] * = factor } return nil } 
func pcmscalef32 ( buf * audio . float32buffer , bitdepth int ) error { if buf == nil | | buf . format == nil { return audio . errinvalidbuffer } buf . sourcebitdepth = bitdepth factor : = float32 ( math . pow ( 2 , float64 ( bitdepth ) - 1 ) ) - 1 . 0 for i : = 0 ; i < len ( buf . data ) ; i ++ { buf . data [ i ] * = factor } return nil } 
func stereopan ( buf * audio . floatbuffer , pan float64 ) error { if buf == nil | | buf . format == nil | | buf . format . numchannels ! = 2 { return audio . errinvalidbuffer } if pan < 0 | | pan > 1 { return errors . new ( " " ) } if pan == 0 . 5 { return nil } if pan < 0 . 5 { for i : = 0 ; i + 2 <= len ( buf . data ) ; i += 2 { buf . data [ i + 1 ] * = ( pan * 2 ) } } else { for i : = 0 ; i + 2 <= len ( buf . data ) ; i += 2 { buf . data [ i ] * = ( ( 1 - pan ) * 2 ) } } return nil } 
func ( f * follower ) leader ( ) string { f . lock . lock ( ) defer f . lock . unlock ( ) return f . leader } 
func ( c * candidate ) isleader ( ) bool { c . lock . lock ( ) defer c . lock . unlock ( ) return c . leader } 
func newresponse ( clientid , redirecturi , userid , exp , code string ) response { return response { clientid : clientid , redirecturi : redirecturi , userid : userid , exp : exp , code : code } } 
func getrequestid ( ctx context . context ) ( string , error ) { if ctx == nil { return " " , errors . new ( " " ) } reqid , ok : = ctx . value ( contextrequestid ) . ( string ) if ! ok { return " " , errors . new ( " " ) } if len ( reqid ) == 0 { return " " , errors . new ( " " ) } return reqid , nil } 
func ( m * monitorablewriter ) log ( ) { duration : = time . now ( ) . sub ( m . t0 ) if m . code == 0 { m . code = 200 } if m . opts . filter ! = nil && ! m . opts . filter ( m . r , m . code , duration , m . size ) { return } cc : = m . colorcode ( ) size : = " " if m . size > 0 { size = sizestr . tostring ( m . size ) } buff : = bytes . buffer { } m . opts . formattmpl . execute ( & buff , & struct { * colors timestamp , method , path , codecolor string code int duration , size , ip string } { m . opts . colors , m . t0 . format ( m . opts . timeformat ) , m . method , m . path , cc , m . code , fmtduration ( duration ) , size , m . ip , } ) fmt . fprint ( m . opts . writer , buff . string ( ) ) } 
func sendmailssl ( addr string , a smtp . auth , from string , to [ ] string , msg [ ] byte ) error { conn , err : = tls . dial ( " " , addr , & tls . config { insecureskipverify : true } ) if err ! = nil { log . println ( " " , err ) return err } h , , : = net . splithostport ( addr ) c , err : = smtp . newclient ( conn , h ) if err ! = nil { log . println ( " " , err ) return err } defer c . close ( ) if a ! = nil { if ok , : = c . extension ( " " ) ; ok { if err = c . auth ( a ) ; err ! = nil { log . printf ( " " , err ) return err } } } if err = c . mail ( from ) ; err ! = nil { log . printf ( " " , err ) return err } for , addr : = range to { if err = c . rcpt ( addr ) ; err ! = nil { log . printf ( " " , err ) return err } } w , err : = c . data ( ) if err ! = nil { return err } w . write ( msg ) w . close ( ) return c . quit ( ) } 
func ( m * mailservice ) send ( message string , subject string , from string , to string ) ( err error ) { t : = [ ] string { to } msg : = [ ] byte ( " " + from + " \n " + " " + to + " \n " + " " + subject + " \n " + " \n " + message + " \n " ) err = m . smtp . sendmail ( from , t , msg ) return } 
func waitforit ( fullconn , host string , port , timeout int ) error { conn : = buildconn ( host , port , fullconn ) if conn == nil { return errors . new ( " " ) } log . debug ( " " + strconv . itoa ( timeout ) + " " ) if err : = pingtcp ( conn , timeout ) ; err ! = nil { return err } if conn . scheme ! = " " && conn . scheme ! = " " { return nil } if err : = pinghttp ( conn , timeout ) ; err ! = nil { return err } return nil } 
func marshal ( urlset * urlset ) ( sitemapxml [ ] byte , err error ) { if len ( urlset . urls ) > maxurls { err = errexceededmaxurls return } urlset . xmlns = xmlns sitemapxml = [ ] byte ( preamble ) var urlsetxml [ ] byte urlsetxml , err = xml . marshal ( urlset ) if err == nil { sitemapxml = append ( sitemapxml , urlsetxml ... ) } if len ( sitemapxml ) > maxfilesize { err = errexceededmaxfilesize } return } 
func initconfig ( ) { if cfgfile ! = " " { viper . setconfigfile ( cfgfile ) } viper . setconfigname ( " " ) viper . addconfigpath ( " " ) viper . addconfigpath ( " " ) viper . automaticenv ( ) if err : = viper . readinconfig ( ) ; err == nil { fmt . println ( " " , viper . configfileused ( ) ) } } 
func writepluginresultstodatabase ( results map [ string ] interface { } ) { session , err : = r . connect ( r . connectopts { address : fmt . sprintf ( " " , utils . getopt ( " " , " " ) ) , timeout : 5 * time . second , database : " " , } ) if err ! = nil { log . debug ( err ) return } defer session . close ( ) res , err : = r . table ( " " ) . get ( results [ " " ] ) . run ( session ) utils . assert ( err ) defer res . close ( ) if res . isnil ( ) { resp , err : = r . table ( " " ) . insert ( results , r . insertopts { conflict : " " } ) . runwrite ( session ) utils . assert ( err ) log . debug ( resp ) } else { resp , err : = r . table ( " " ) . get ( results [ " " ] ) . update ( map [ string ] interface { } { " " : map [ string ] interface { } { category : map [ string ] interface { } { name : results [ " " ] , } , } , } ) . runwrite ( session ) utils . assert ( err ) log . debug ( resp ) } } 
func newauthcontroller ( um usermanager , cnf web . config ) * authcontroller { authcontroller : = authcontroller { usermanager : um , cnf : cnf } return & authcontroller } 
func ( c * authcontroller ) authenticate ( w http . responsewriter , r * http . request ) { decoder : = json . newdecoder ( r . body ) var user user var data map [ string ] string err : = decoder . decode ( & user ) if err ! = nil { http . error ( w , fmt . sprintf ( " " , err ) , 400 ) return } user , = c . usermanager . get ( user . username , user . password ) if user . username ! = " " { token : = jwt . new ( jwt . getsigningmethod ( " " ) ) claims : = token . claims . ( jwt . mapclaims ) claims [ " " ] = user . username claims [ " " ] = user . email claims [ " " ] = time . now ( ) . add ( time . minute * 10 ) . unix ( ) tokenstring , : = token . signedstring ( [ ] byte ( c . cnf . jwt . key ) ) data = map [ string ] string { " " : tokenstring , } } js , : = json . marshal ( data ) w . write ( js ) } 
func newoauth2controller ( am applicationmanager , cnf web . config ) * oauth2controller { oauth2controller : = oauth2controller { cnf : cnf , applicationmanager : am } return & oauth2controller } 
func marshalindex ( index * index ) ( indexxml [ ] byte , err error ) { if len ( index . sitemaps ) > maxsitemaps { err = errexceededmaxsitemaps return } index . xmlns = xmlns indexxml = [ ] byte ( preamble ) var smixml [ ] byte smixml , err = xml . marshal ( index ) if err == nil { indexxml = append ( indexxml , smixml ... ) } if len ( indexxml ) > maxfilesize { err = errexceededmaxfilesize } return } 
func singlefile ( filename string ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { http . servefile ( w , r , filename ) } ) } 
func newmongo ( filename string , environment string ) ( * mongo , error ) { ctx : = context . background ( ) cnf , err : = getmongo ( filename , environment ) if err ! = nil { return nil , err } var uri string if len ( cnf . username ) > 0 && len ( cnf . password ) > 0 { uri = fmt . sprintf ( , cnf . username , cnf . password , cnf . host , cnf . port , cnf . database , ) } else { uri = fmt . sprintf ( , cnf . host , cnf . port , cnf . database , ) } client , err : = mongo . newclient ( uri ) if err ! = nil { log . printf ( " " , uri ) return nil , err } err = client . connect ( ctx ) if err ! = nil { log . print ( " " ) return nil , err } db : = client . database ( cnf . database ) err = client . ping ( ctx , nil ) if err ! = nil { log . printf ( " " , cnf . host , cnf . port ) return nil , err } return & mongo { client : client , database : db , context : ctx } , nil } 
func ( m * mongo ) disconnect ( ) error { err : = m . client . disconnect ( m . context ) if err ! = nil { log . printf ( " " ) return err } return nil } 
func new ( fields [ ] string ) * table { return & table { fields : fields , rows : make ( [ ] map [ string ] string , 0 ) , fieldsizes : make ( map [ string ] int ) , } } 
func printtable ( fields [ ] string , rows [ ] map [ string ] interface { } ) { table : = new ( fields ) for , r : = range rows { table . addrow ( r ) } table . print ( ) } 
func printhorizontal ( m map [ string ] interface { } ) { table : = new ( [ ] string { " " , " " } ) rows : = maptorows ( m ) for , row : = range rows { table . addrow ( row ) } table . hidehead = true table . print ( ) } 
func printrow ( fields [ ] string , row map [ string ] interface { } ) { table : = new ( fields ) table . addrow ( row ) table . print ( ) } 
func ( t * table ) addrow ( row map [ string ] interface { } ) { newrow : = make ( map [ string ] string ) for , k : = range t . fields { v : = row [ k ] var val string if v == nil { val = " " } else { val = fmt . sprintf ( " " , v ) } newrow [ k ] = val } t . calculatesizes ( newrow ) if len ( newrow ) > 0 { t . rows = append ( t . rows , newrow ) } } 
func ( t * table ) print ( ) { if len ( t . rows ) == 0 && t . footer == nil { return } t . calculatesizes ( t . footer ) if ! t . markdown { t . printdash ( ) } if ! t . hidehead { fmt . println ( t . gethead ( ) ) t . printtabledash ( ) } for , r : = range t . rows { fmt . println ( t . rowstring ( r ) ) if ! t . markdown { t . printdash ( ) } } if t . footer ! = nil { t . printtabledash ( ) fmt . println ( t . rowstring ( t . footer ) ) if ! t . markdown { t . printtabledash ( ) } } } 
func ( t * table ) string ( title string ) string { tablestring : = [ ] string { } if len ( t . rows ) == 0 && t . footer == nil { return " " } tablestring = append ( tablestring , " " + title ) t . calculatesizes ( t . footer ) if ! t . markdown { tablestring = append ( tablestring , t . stringdash ( ) ) } if ! t . hidehead { tablestring = append ( tablestring , t . gethead ( ) ) tablestring = append ( tablestring , t . stringtabledash ( ) ) } for , r : = range t . rows { tablestring = append ( tablestring , t . rowstring ( r ) ) if ! t . markdown { tablestring = append ( tablestring , t . stringdash ( ) ) } } if t . footer ! = nil { tablestring = append ( tablestring , t . stringtabledash ( ) ) tablestring = append ( tablestring , t . rowstring ( t . footer ) ) if ! t . markdown { tablestring = append ( tablestring , t . stringdash ( ) ) } } return strings . join ( tablestring [ : ] , " \n " ) } 
func ( t * table ) gethead ( ) string { s : = " " for , name : = range t . fields { s += t . fieldstring ( name , strings . title ( name ) ) + " " } return s } 
func ( t * table ) rowstring ( row map [ string ] string ) string { s : = " " for , name : = range t . fields { value : = row [ name ] s += t . fieldstring ( name , value ) + " " } return s } 
func ( t * table ) fieldstring ( name , value string ) string { value = fmt . sprintf ( " " , value ) spacesleft : = t . fieldsizes [ name ] - runewidth . stringwidth ( value ) if spacesleft > 0 { for i : = 0 ; i < spacesleft ; i ++ { value += " " } } return value } 
func ( t * table ) stringtabledash ( ) string { if t . markdown { return t . stringmarkdowndash ( ) } return t . stringdash ( ) } 
func ( t * table ) printdash ( ) { s : = " " for i : = 0 ; i < t . linelength ( ) - 2 ; i ++ { s += " " } s += " " fmt . println ( s ) } 
func ( t * table ) stringdash ( ) string { s : = " " for i : = 0 ; i < t . linelength ( ) - 2 ; i ++ { s += " " } s += " " return s } 
func ( t * table ) printmarkdowndash ( ) { r : = make ( map [ string ] string ) for , name : = range t . fields { r [ name ] = strings . repeat ( " " , t . fieldsizes [ name ] - 2 ) } fmt . println ( t . rowstring ( r ) ) } 
func ( t * table ) stringmarkdowndash ( ) string { r : = make ( map [ string ] string ) for , name : = range t . fields { r [ name ] = strings . repeat ( " " , t . fieldsizes [ name ] - 2 ) } return t . rowstring ( r ) } 
func ( t * table ) linelength ( ) ( sum int ) { for , l : = range t . fieldsizes { sum += l + 1 } return sum + 1 } 
func hashpassword ( password [ ] byte , salt [ ] byte ) ( hash [ ] byte , err error ) { hash , err = scrypt . key ( password , salt , n , r , p , keylength ) if err ! = nil { return nil , err } return } 
func encodeoauth2code ( clientid , redirecturi , userid , sharedkey string ) ( code string , err error ) { rand : = randstringbytesmaskimprsrc ( 20 ) exp : = time . now ( ) . add ( time . minute * 10 ) . string ( ) response : = newresponse ( clientid , redirecturi , userid , exp , rand ) jresponse , err : = json . marshal ( response ) if err ! = nil { log . printf ( " " , err ) } j64response : = base64 . stdencoding . encodetostring ( jresponse ) signer , err : = jose . newsigner ( jose . signingkey { algorithm : jose . hs512 , key : [ ] byte ( sharedkey ) } , nil ) if err ! = nil { log . printf ( " " , err ) } object , err : = signer . sign ( [ ] byte ( j64response ) ) if err ! = nil { log . printf ( " " , err ) } code , err = object . compactserialize ( ) return } 
func decodeoauth2code ( code , sharedkey string ) ( response response , err error ) { object , err : = jose . parsesigned ( code ) if err ! = nil { return } output , err : = object . verify ( [ ] byte ( sharedkey ) ) if err ! = nil { return } base64text : = make ( [ ] byte , base64 . stdencoding . decodedlen ( len ( output ) ) ) l , err : = base64 . stdencoding . decode ( base64text , output ) if err ! = nil { return } response = response { } err = json . unmarshal ( base64text [ : l ] , & response ) return } 
func newserver ( filename string , environment string ) ( server * server , err error ) { conf , err : = getconfig ( filename , environment ) logfile , err : = os . openfile ( conf . log . file + logfilename , os . o wronly | os . o create | os . o append , 0666 ) if err ! = nil { log . setoutput ( os . stderr ) log . warningf ( " " , err ) } else { log . setoutput ( logfile ) } level : = log . errorlevel if strings . compare ( conf . log . level , " " ) ! = 0 { level , = log . parselevel ( conf . log . level ) } else { log . infof ( " " , level ) } log . setlevel ( level ) server = & server { config : conf , done : make ( chan bool , 1 ) , error : make ( chan error , 1 ) , server : http . server { handler : newloggingservemux ( conf ) } , quit : make ( chan bool ) , isstarted : false } return } 
func ( s * server ) start ( ) ( err error ) { log . infof ( " " , s . config . port ) var l net . listener go func ( ) { l , err = net . listen ( " " , fmt . sprintf ( " " , s . config . port ) ) if err ! = nil { log . errorf ( " " , err ) s . error < - err return } s . isstarted = true if len ( s . config . ssl . certificate ) > 0 && len ( s . config . ssl . key ) > 0 { err = s . servetls ( l , s . config . ssl . certificate , s . config . ssl . key ) if err ! = nil && err ! = http . errserverclosed { log . errorf ( " " , err ) l . close ( ) s . error < - err s . quit < - true } close ( s . quit ) } else { err = s . serve ( l ) if err ! = nil && err ! = http . errserverclosed { log . errorf ( " " , err ) s . error < - err s . quit < - true } close ( s . quit ) } } ( ) < - s . quit if err = s . shutdown ( context . background ( ) ) ; err ! = nil { log . errorf ( " " , err ) s . error < - err } < - s . quit l = nil log . info ( " " ) s . isstarted = false s . done < - true return } 
func ( s * server ) stop ( ) { if s . isstarted && s . quit ! = nil { log . info ( " " ) s . quit < - true } else { log . info ( " " ) s . error < - errors . new ( " " ) s . done < - false } } 
func newloggingservemux ( conf config ) * loggingservemux { servemux : = http . newservemux ( ) return & loggingservemux { servemux , conf } } 
func ( mux * loggingservemux ) handler ( r * http . request ) ( h http . handler , pattern string ) { return mux . servemux . handler ( r ) } 
func ( mux * loggingservemux ) handle ( pattern string , handler http . handler ) { var log = logrus . new ( ) logfile , err : = os . openfile ( mux . conf . log . file + afilename , os . o wronly | os . o create | os . o append , 0666 ) if err ! = nil { log . out = os . stderr log . warningf ( " " , err ) } else { log . out = logfile } mux . servemux . handle ( pattern , logging ( handler , log ) ) } 
func ( mux * loggingservemux ) handlefunc ( pattern string , handler func ( http . responsewriter , * http . request ) ) { mux . servemux . handle ( pattern , http . handlerfunc ( handler ) ) } 
func ( db * database ) geturl ( ) { if len ( strings . trimspace ( db . index ) ) == 0 { db . index = defaultindex } if len ( strings . trimspace ( db . type ) ) == 0 { db . type = defaulttype } if len ( strings . trimspace ( db . host ) ) == 0 { db . host = defaulthost } if len ( strings . trimspace ( db . port ) ) == 0 { db . port = defaultport } if len ( strings . trimspace ( db . url ) ) == 0 { db . url = defaulturl } if , exists : = os . lookupenv ( " " ) ; exists { log . withfield ( " " , db . url ) . debug ( " " ) db . url = utils . getopt ( " " , fmt . sprintf ( " " , " " , db . port ) ) return } db . url = utils . getopts ( db . url , " " , fmt . sprintf ( " " , db . host , db . port ) ) } 
func ( db * database ) init ( ) error { db . geturl ( ) err : = db . testconnection ( ) if err ! = nil { return errors . wrap ( err , " " ) } client , err : = elastic . newsimpleclient ( elastic . seturl ( db . url ) , elastic . setbasicauth ( utils . getopts ( db . username , " " , " " ) , utils . getopts ( db . password , " " , " " ) , ) , ) if err ! = nil { return errors . wrap ( err , " " ) } exists , err : = client . indexexists ( db . index ) . do ( context . background ( ) ) if err ! = nil { return errors . wrap ( err , " " ) } if ! exists { createindex , err : = client . createindex ( db . index ) . bodystring ( mapping ) . do ( context . background ( ) ) if err ! = nil { return errors . wrapf ( err , " " , db . index ) } if ! createindex . acknowledged { log . error ( " " ) } else { log . debugf ( " " , db . index ) } } else { log . debugf ( " " , db . index ) } return nil } 
func ( db * database ) waitforconnection ( ctx context . context , timeout int ) error { var err error secondswaited : = 0 connctx , cancel : = context . withtimeout ( ctx , time . duration ( timeout ) * time . second ) defer cancel ( ) log . debug ( " " ) for { select { case < - connctx . done ( ) : return errors . wrapf ( err , " " , secondswaited ) default : err = db . testconnection ( ) if err == nil { log . debugf ( " " , secondswaited ) return nil } secondswaited ++ log . debug ( " " ) time . sleep ( 1 * time . second ) } } } 
func camelcase ( src string ) string { bytesrc : = [ ] byte ( src ) chunks : = camelingregex . findall ( bytesrc , - 1 ) for idx , val : = range chunks { if idx > 0 { chunks [ idx ] = bytes . title ( val ) } } return string ( bytes . join ( chunks , nil ) ) } 
func getopt ( name , dfault string ) string { value : = os . getenv ( name ) if value == " " { value = dfault } return value } 
func getopts ( userinput , envvar , dfault string ) string { if len ( strings . trimspace ( userinput ) ) > 0 { return userinput } value : = os . getenv ( envvar ) if value == " " { value = dfault } return value } 
func getsha256 ( name string ) string { dat , err : = ioutil . readfile ( name ) assert ( err ) h256 : = sha256 . new ( ) , err = h256 . write ( dat ) assert ( err ) return fmt . sprintf ( " " , h256 . sum ( nil ) ) } 
func runcommand ( ctx context . context , cmd string , args ... string ) ( string , error ) { var c * exec . cmd if ctx ! = nil { c = exec . commandcontext ( ctx , cmd , args ... ) } else { c = exec . command ( cmd , args ... ) } output , err : = c . output ( ) if err ! = nil { return string ( output ) , err } if ctx ! = nil { if ctx . err ( ) == context . deadlineexceeded { return " " , fmt . errorf ( " " , cmd ) } } return string ( output ) , nil } 
func removeduplicates ( elements [ ] string ) [ ] string { encountered : = map [ string ] bool { } result : = [ ] string { } for v : = range elements { if encountered [ elements [ v ] ] == true { } else { encountered [ elements [ v ] ] = true result = append ( result , elements [ v ] ) } } return result } 
func gethashtype ( hash string ) ( string , error ) { var validmd5 = regexp . mustcompile ( ' ^ [ a - fa - f \ d ] { 32 } $ ' ) var validsha1 = regexp . mustcompile ( ' ^ [ a - fa - f \ d ] { 40 } $ ' ) var validsha256 = regexp . mustcompile ( ' ^ [ a - fa - f \ d ] { 64 } $ ' ) var validsha512 = regexp . mustcompile ( ' ^ [ a - fa - f \ d ] { 128 } $ ' ) switch { case validmd5 . matchstring ( hash ) : return " " , nil case validsha1 . matchstring ( hash ) : return " " , nil case validsha256 . matchstring ( hash ) : return " " , nil case validsha512 . matchstring ( hash ) : return " " , nil default : return " " , errors . new ( " " ) } } 
func askforconfirmation ( ) bool { var response string , err : = fmt . scanln ( & response ) if err ! = nil { log . fatal ( err ) } okayresponses : = [ ] string { " " , " " } nokayresponses : = [ ] string { " " , " " } if stringinslice ( strings . tolower ( response ) , okayresponses ) { return true } if stringinslice ( strings . tolower ( response ) , nokayresponses ) { return false } fmt . println ( " " ) return askforconfirmation ( ) } 
func unzip ( archive , target string ) error { reader , err : = zip . openreader ( archive ) if err ! = nil { return err } defer reader . close ( ) for , file : = range reader . file { filepath : = filepath . join ( target , file . name ) if file . fileinfo ( ) . isdir ( ) { os . mkdirall ( filepath , file . mode ( ) ) continue } filereader , err : = file . open ( ) if err ! = nil { return err } defer filereader . close ( ) targetfile , err : = os . openfile ( filepath , os . o wronly | os . o create | os . o trunc , file . mode ( ) ) if err ! = nil { return err } defer targetfile . close ( ) if , err : = io . copy ( targetfile , filereader ) ; err ! = nil { return err } } return nil } 
func slicecontainsstring ( a string , list [ ] string ) bool { for , b : = range list { if strings . contains ( b , a ) { return true } } return false } 
func newsmtp ( filename string , environment string ) ( s * smtp , err error ) { conf , err : = getsmtp ( filename , environment ) if err ! = nil { return } auth : = smtp . plainauth ( " " , conf . auth . user , conf . auth . password , conf . host ) f : = smtp . sendmail if conf . ssl { f = sendmailssl } s = & smtp { auth : auth , send : f , addr : fmt . sprintf ( " " , conf . host , conf . port ) } return } 
func ( s * smtp ) sendmail ( from string , to [ ] string , msg [ ] byte ) ( err error ) { err = s . send ( s . addr , s . auth , from , to , msg ) return } 
func ( se * smtpenvironment ) unmarshalyaml ( unmarshal func ( interface { } ) error ) error { var aux struct { env map [ string ] struct { config config ' yaml : " smtp " ' } } if err : = unmarshal ( & aux . env ) ; err ! = nil { return err } se . env = make ( map [ string ] config ) for env , conf : = range aux . env { se . env [ env ] = conf . config } return nil } 
func ( se * smtpenvironment ) getenvironment ( environment string ) interface { } { for env , conf : = range se . env { if strings . compare ( environment , env ) == 0 { return conf } } return nil } 
func getsmtp ( source interface { } , environment string ) ( smtp config , err error ) { var smtpenvironment smtpenvironment i , err : = config . get ( source , environment , & smtpenvironment ) smtp = i . ( config ) return } 
func getconfig ( source interface { } , environment string ) ( server config , err error ) { var serverenvironment serverenvironment i , err : = config . get ( source , environment , & serverenvironment ) server = i . ( config ) return } 
func ( m * environment ) unmarshalyaml ( unmarshal func ( interface { } ) error ) error { var aux struct { env map [ string ] struct { config ' yaml : " mongo " ' } } if err : = unmarshal ( & aux . env ) ; err ! = nil { return err } m . env = make ( map [ string ] config ) for env , conf : = range aux . env { m . env [ env ] = conf . config } return nil } 
func ( m * environment ) getenvironment ( environment string ) interface { } { for env , conf : = range m . env { if strings . compare ( environment , env ) == 0 { return conf } } return nil } 
func getmongo ( source interface { } , environment string ) ( mongo config , err error ) { var env environment i , err : = config . get ( source , environment , & env ) mongo = i . ( config ) return } 
func tokenhandler ( next http . handler , cnf web . config ) http . handler { return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { token , err : = request . parsefromrequest ( r , request . authorizationheaderextractor , func ( token * jwt . token ) ( interface { } , error ) { if , ok : = token . method . ( * jwt . signingmethodhmac ) ; ! ok { return nil , fmt . errorf ( " " , token . header [ " " ] ) } return [ ] byte ( cnf . jwt . key ) , nil } ) if err == nil && token . valid { next . servehttp ( w , r ) } else { if r . url . string ( ) == " " { next . servehttp ( w , r ) } else { w . writeheader ( http . statusunauthorized ) } } } ) } 
func connect ( host , senderid , apikey string , debug bool ) ( * conn , error ) { if ! strings . contains ( senderid , gcmdomain ) { senderid += " " + gcmdomain } c , err : = xmpp . newclient ( host , senderid , apikey , debug ) if err ! = nil { return nil , err } if debug { log . printf ( " \n " , c ) } return & conn { host : host , senderid : senderid , debug : debug , xmppconn : c , } , nil } 
func ( c * conn ) receive ( ) ( * inmsg , error ) { stanza , err : = c . xmppconn . recv ( ) if err ! = nil { return nil , err } if c . debug { log . printf ( " \n " , stanza ) } chat , ok : = stanza . ( xmpp . chat ) if ! ok { return nil , nil } if chat . type == " " { return nil , errors . new ( " " ) } var m inmsg if err = json . unmarshal ( [ ] byte ( chat . other [ 0 ] ) , & m ) ; err ! = nil { return nil , errors . new ( " " ) } switch m . messagetype { case " " : return & m , nil case " " : return & m , nil case " " : return & m , nil case " " : return & m , nil case " " : ack : = & outmsg { messagetype : " " , to : m . from , id : m . id } if , err = c . send ( ack ) ; err ! = nil { return nil , fmt . errorf ( " " , err ) } return & m , nil default : } return & m , nil } 
func ( c * conn ) send ( m * outmsg ) ( n int , err error ) { if m . id == " " { if m . id , err = getmsgid ( ) ; err ! = nil { return 0 , err } } mb , err : = json . marshal ( m ) if err ! = nil { return 0 , err } ms : = string ( mb ) res : = fmt . sprintf ( gcmmessagestanza , ms ) return c . xmppconn . sendorg ( res ) } 
func ( d pivnetreleasediffer ) allboshreleasenames ( ) [ ] string { boshreleasenamesmap : = make ( map [ string ] string ) var addreleasenames = func ( br map [ string ] * release . boshrelease ) { for brname : = range br { boshreleasenamesmap [ brname ] = brname } } addreleasenames ( d . release1 . boshrelease ) addreleasenames ( d . release2 . boshrelease ) var releasenames [ ] string for brname : = range boshreleasenamesmap { releasenames = append ( releasenames , brname ) } return releasenames } 
func ( dj * deltajob ) addedproperty ( name string , p * enaml . jobmanifestproperty ) { dj . addedproperties [ name ] = * p } 
func ( dj * deltajob ) removedproperty ( name string , p * enaml . jobmanifestproperty ) { dj . removedproperties [ name ] = * p } 
func ( r * result ) adddeltajob ( dj * deltajob ) { r . deltajob = append ( r . deltajob , * dj ) } 
func ( r * result ) concat ( other * result ) { for , dj : = range other . deltajob { r . deltajob = append ( r . deltajob , dj ) } } 
func ( r * release ) read ( releaselocation string ) ( io . readcloser , error ) { local , err : = r . pull ( releaselocation ) if err ! = nil { return nil , err } rr , err : = os . open ( local ) if err ! = nil { return nil , err } return rr , nil } 
func ( r * release ) pull ( releaselocation string ) ( filename string , err error ) { u , uerr : = url . parse ( releaselocation ) if uerr ! = nil | | ! ( u . scheme == " " | | u . scheme == " " ) { if , ferr : = os . stat ( releaselocation ) ; os . isnotexist ( ferr ) { err = fmt . errorf ( " " , releaselocation ) return } filename = releaselocation } else { filename = r . cachedir + " " + path . base ( releaselocation ) if , err = os . stat ( filename ) ; os . isnotexist ( err ) { fmt . println ( " " ) err = r . download ( releaselocation , filename ) } } return } 
func buildjob ( jobmeta boshjobmeta , dest string ) error { b , err : = json . marshal ( jobmeta ) if err ! = nil { return err } fmt . println ( " " , string ( b ) ) monitfile , specfile , err : = createjobfiles ( dest , jobmeta . name ) if err ! = nil { return err } defer monitfile . close ( ) defer specfile . close ( ) err = writemonitfile ( monitfile , jobmeta . name , jobmeta . pidfile ) if err ! = nil { return err } err = writespecfile ( specfile , jobmeta . name , jobmeta . jobproperties , jobmeta . packages ) return err } 
func loadboshrelease ( releaserepo pull . release , path string ) ( release * boshrelease , err error ) { var rr io . readcloser rr , err = releaserepo . read ( path ) if err ! = nil { return } defer func ( ) { if cerr : = rr . close ( ) ; cerr ! = nil { err = cerr } } ( ) release , err = readboshrelease ( rr ) return } 
func readboshrelease ( rr io . reader ) ( * boshrelease , error ) { release : = & boshrelease { jobmanifests : make ( map [ string ] enaml . jobmanifest ) , } err : = release . readboshrelease ( rr ) return release , err } 
func ( r * boshrelease ) readboshrelease ( rr io . reader ) error { w : = pkg . newtgzwalker ( rr ) w . onmatch ( " " , func ( file pkg . fileentry ) error { return decodeyaml ( file . reader , & r . releasemanifest ) } ) w . onmatch ( " " , func ( file pkg . fileentry ) error { job , jerr : = r . readboshjob ( file . reader ) if jerr == nil { r . jobmanifests [ job . name ] = job } return jerr } ) err : = w . walk ( ) return err } 
func ( r * boshrelease ) readboshjob ( jr io . reader ) ( enaml . jobmanifest , error ) { var job enaml . jobmanifest jw : = pkg . newtgzwalker ( jr ) jw . onmatch ( " " , func ( file pkg . fileentry ) error { return decodeyaml ( file . reader , & job ) } ) err : = jw . walk ( ) return job , err } 
func newclient ( user , pass , host string , port int , sslignore bool ) ( * client , error ) { c : = & client { user : user , pass : pass , host : host , port : port , sslignore : sslignore , http : & http . client { transport : transport ( sslignore ) } , } c . http . checkredirect = func ( req * http . request , via [ ] * http . request ) error { req . url , = url . parse ( req . url . scheme + " " + via [ 0 ] . url . host + req . url . path ) setauth ( c , req ) return nil } return c . setclienttoken ( ) } 
func ( s * client ) pushcloudconfig ( manifest [ ] byte ) error { ccm : = enaml . newcloudconfigmanifest ( manifest ) req , err : = s . newcloudconfigrequest ( * ccm ) if err ! = nil { return err } res , err : = s . http . do ( req ) if err ! = nil { return err } defer res . body . close ( ) if res . statuscode >= 400 { body , err : = ioutil . readall ( res . body ) if err ! = nil { return err } return fmt . errorf ( " " , res . status , string ( body ) ) } return nil } 
func generate ( packagename string , filebytes [ ] byte , outputdir string ) { b : = preprocessjobmanifest ( filebytes ) objects : = make ( map [ string ] map [ string ] objectfield ) var properties [ ] string for , v : = range b . recs { properties = append ( properties , v . orig ) } for i : = 0 ; i < b . max ; i ++ { for , v : = range b . recs { if v . length - 1 >= i { var structname = v . structname ( i , packagename , properties ) var typename = v . typename ( i , properties ) elementname : = v . slice [ i ] attributename : = formatname ( elementname ) if , ok : = objects [ structname ] ; ! ok { objects [ structname ] = make ( map [ string ] objectfield ) } if previouselement , ok : = objects [ structname ] [ attributename ] ; ! ok { lo . g . debug ( " " , attributename , " " , structname , " " , typename ) objects [ structname ] [ attributename ] = objectfield { elementname : attributename , elementtype : typename , elementannotation : createelementannotation ( elementname ) , meta : v . yaml , } } else { if previouselement . elementannotation ! = createelementannotation ( elementname ) { lo . g . warning ( " " , structname , " " , attributename , " " ) previouselement . elementannotation = " " " " objects [ structname ] [ attributename ] = previouselement } } } } } structs : = generatestructs ( objects , packagename ) writestructstodisk ( structs , outputdir ) } 
func createnewrecord ( property string , yaml enaml . jobmanifestproperty ) ( record record ) { elementarray : = strings . split ( property , " " ) record = record { length : len ( elementarray ) , orig : property , slice : elementarray , yaml : yaml , } return } 
func newshowcmd ( releaserepo pull . release , release string ) * showcmd { return & showcmd { releaserepo : releaserepo , release : release , } } 
func ( s * showcmd ) all ( w io . writer ) error { if filepath . ext ( s . release ) == " " { pivnetrelease , err : = release . loadpivnetrelease ( s . releaserepo , s . release ) if err ! = nil { return err } for , br : = range pivnetrelease . boshrelease { s . printboshrelease ( w , br ) } return nil } boshrelease , err : = release . loadboshrelease ( s . releaserepo , s . release ) if err ! = nil { return err } s . printboshrelease ( w , boshrelease ) return nil } 
func ( s * concoursepipeline ) getdefaulttaskimageresource ( ) atc . imageresource { return atc . imageresource { type : s . defaultimagetype , source : atc . source { " " : s . defaultimagerepository , } , } } 
func ( s * concoursepipeline ) addrawjob ( job atc . jobconfig ) { s . jobs = append ( s . jobs , job ) } 
func ( s * concoursepipeline ) addgroup ( name string , jobs ... string ) { s . groups = append ( s . groups , atc . groupconfig { name : name , jobs : jobs , } ) } 
func ( s * concoursepipeline ) setimagedefaults ( platform , imagetype , repo string ) { s . defaultplatform = platform s . defaultimagetype = imagetype s . defaultimagerepository = repo } 
func ( s * concoursepipeline ) getresourcebyname ( name string ) * atc . resourceconfig { for i , v : = range s . resources { if v . name == name { return & s . resources [ i ] } } return nil } 
func ( s * concoursepipeline ) addrawresource ( rawresource atc . resourceconfig ) { s . resources = append ( s . resources , rawresource ) } 
func ( s * concoursepipeline ) addresource ( name string , typename string , source map [ string ] interface { } ) { s . resources = append ( s . resources , atc . resourceconfig { name : name , type : typename , source : source , } ) } 
func ( s * concoursepipeline ) addgithubresource ( name string , source map [ string ] interface { } ) { s . addresource ( name , githubresourcename , source ) } 
func ( s * concoursepipeline ) addboshioresource ( name string , source map [ string ] interface { } ) { s . addresource ( name , boshioresourcename , source ) } 
func ( s * concoursepipeline ) addboshdeploymentresource ( name string , source map [ string ] interface { } ) { s . addresource ( name , boshdeploymentresourcename , source ) } 
func ( s * concoursepipeline ) addgitresource ( name string , source map [ string ] interface { } ) { s . addresource ( name , gitresourcename , source ) } 
func ( d boshreleasediffer ) alljobnames ( ) [ ] string { jobnamesmap : = make ( map [ string ] string ) var addjobnames = func ( br * release . boshrelease ) { if br ! = nil { for jbname : = range br . jobmanifests { jobnamesmap [ jbname ] = jbname } } } addjobnames ( d . release1 ) addjobnames ( d . release2 ) var jobnames [ ] string for jname : = range jobnamesmap { jobnames = append ( jobnames , jname ) } return jobnames } 
func newdeploymentmanifestfromfile ( f * os . file ) * deploymentmanifest { var b [ ] byte fi , : = f . stat ( ) if fi . size ( ) > 0 { b , = ioutil . readall ( f ) } return newdeploymentmanifest ( b ) } 
func newdeploymentmanifest ( b [ ] byte ) * deploymentmanifest { dm : = new ( deploymentmanifest ) yaml . unmarshal ( b , dm ) return dm } 
func ( s * deploymentmanifest ) addremoterelease ( releasename , ver , url , sha1 string ) ( err error ) { s . releases = append ( s . releases , release { name : releasename , url : url , sha1 : sha1 , version : ver , } ) return } 
func ( s * deploymentmanifest ) addremotestemcell ( os , alias , ver , url , sha1 string ) { s . stemcells = append ( s . stemcells , stemcell { os : os , alias : alias , version : ver , url : url , sha1 : sha1 , } ) } 
func ( s * deploymentmanifest ) tag ( key string ) string { if s . tags == nil { return " " } return s . tags [ key ] } 
func ( s * deploymentmanifest ) removetag ( key string ) { if s . tags ! = nil { delete ( s . tags , key ) } } 
func loadpivnetrelease ( releaserepo pull . release , path string ) ( release * pivnetrelease , err error ) { release = & pivnetrelease { } var localpath string localpath , err = releaserepo . pull ( path ) if err ! = nil { return } release = & pivnetrelease { boshrelease : make ( map [ string ] * boshrelease ) , } err = release . readpivnetrelease ( localpath ) return } 
func ( r * pivnetrelease ) boshreleaseorempty ( name string ) * boshrelease { br : = r . boshrelease [ name ] if br == nil { br = emptyboshrelease } return br } 
func ( r * pivnetrelease ) readpivnetrelease ( path string ) error { walker : = pkg . newzipwalker ( path ) walker . onmatch ( " " , func ( file pkg . fileentry ) error { br , berr : = readboshrelease ( file . reader ) if berr ! = nil { return berr } r . boshrelease [ br . releasemanifest . name ] = br return nil } ) return walker . walk ( ) } 
func newcloudconfigmanifest ( b [ ] byte ) * cloudconfigmanifest { cm : = new ( cloudconfigmanifest ) yaml . unmarshal ( b , cm ) return cm } 
func ( s * cloudconfigmanifest ) containsazname ( azname string ) ( result bool ) { result = false for , az : = range s . azs { if az . name == azname { result = true return } } return } 
func ( s * cloudconfigmanifest ) containsvmtype ( vmtypename string ) ( result bool ) { result = false for , vmtype : = range s . vmtypes { if vmtype . name == vmtypename { result = true return } } return } 
func ( s * cloudconfigmanifest ) containsdisktype ( disktypename string ) ( result bool ) { result = false for , disktype : = range s . disktypes { if disktype . name == disktypename { result = true return } } return } 
func decodeyaml ( r io . reader , v interface { } ) error { bytes , err : = ioutil . readall ( r ) if err == nil { yaml . unmarshal ( bytes , v ) } return err } 
func newzipwalker ( zipfile string ) walker { return zipwalker { zippath : zipfile , callbacks : make ( map [ * regexp . regexp ] walkfunc ) , } } 
func newdiffcmd ( releaserepo pull . release , release1 , release2 string ) * diffcmd { return & diffcmd { releaserepo : releaserepo , release1 : release1 , release2 : release2 , } } 
func ( s * diffcmd ) all ( w io . writer ) error { differ , err : = diff . new ( s . releaserepo , s . release1 , s . release2 ) if err ! = nil { return err } d , err : = differ . diff ( ) if err ! = nil { return err } s . printdiffresult ( w , d ) return nil } 
func ( s * diffcmd ) job ( job string , w io . writer ) error { differ , err : = diff . new ( s . releaserepo , s . release1 , s . release2 ) if err ! = nil { return err } d , err : = differ . diffjob ( job ) if err ! = nil { return err } s . printdiffresult ( w , d ) return nil } 
func new ( releaserepo pull . release , r1path , r2path string ) ( differ differ , err error ) { if filepath . ext ( r1path ) ! = filepath . ext ( r2path ) { err = fmt . errorf ( " " + " " ) return } if filepath . ext ( r1path ) == " " { var r1 , r2 * release . pivnetrelease if r1 , err = release . loadpivnetrelease ( releaserepo , r1path ) ; err == nil { if r2 , err = release . loadpivnetrelease ( releaserepo , r2path ) ; err == nil { differ = pivnetreleasediffer { release1 : r1 , release2 : r2 , } } } } else { var r1 , r2 * release . boshrelease if r1 , err = release . loadboshrelease ( releaserepo , r1path ) ; err == nil { if r2 , err = release . loadboshrelease ( releaserepo , r2path ) ; err == nil { differ = boshreleasediffer { release1 : r1 , release2 : r2 , } } } } return } 
func ( v * record ) structname ( i int , packagename string , properties [ ] string ) ( structname string ) { if i > 0 { currentnode : = v . slice [ i - 1 ] structname = formatname ( currentnode ) if i > 1 { parentnames : = v . findallparentsofsamenamedelement ( currentnode , properties ) if len ( parentnames ) > 1 { structname = formatname ( v . slice [ i - 2 ] + " " + currentnode ) } } } else { structname = formatname ( packagename + " " ) } return } 
func ( v * record ) typename ( i int , properties [ ] string ) ( typename string ) { if i + 1 < v . length { currentnode : = v . slice [ i ] typename = " " + formatname ( currentnode ) if i >= 1 { parentnames : = v . findallparentsofsamenamedelement ( currentnode , properties ) if len ( parentnames ) > 1 { typename = " " + formatname ( v . slice [ i - 1 ] + " " + currentnode ) } } } else { typename = " " } return } 
func newtgzwalker ( pkgreader io . reader ) walker { return tgzwalker { pkgreader : pkgreader , callbacks : make ( map [ * regexp . regexp ] walkfunc ) , } } 
func newbackoff ( strategy backoffstrategy , start time . duration , limit time . duration ) * backoff { backoff : = backoff { strategy : strategy , start : start , limit : limit } backoff . reset ( ) return & backoff } 
func ( b * backoff ) reset ( ) { b . count = 0 b . lastduration = 0 b . nextduration = b . getnextduration ( ) } 
func ( b * backoff ) backoff ( ) { time . sleep ( b . nextduration ) b . count ++ b . lastduration = b . nextduration b . nextduration = b . getnextduration ( ) } 
func newexponential ( start time . duration , limit time . duration ) * backoff { return newbackoff ( exponential { } , start , limit ) } 
func newexponentialfulljitter ( start time . duration , limit time . duration ) * backoff { return newbackoff ( exponentialfulljitter { limit : limit } , start , limit ) } 
func newlinear ( start time . duration , limit time . duration ) * backoff { return newbackoff ( linear { } , start , limit ) } 
func ( s * sapin ) getlinesize ( floor , line int ) int { return 1 + line * 2 + floor * 4 + int ( floor / 2 * 2 ) * int ( ( floor + 1 ) / 2 ) } 
func ( s * sapin ) getmaxsize ( ) int { return s . getlinesize ( s . size - 1 , s . size + 3 ) } 
func ( s * sapin ) compute ( ) { if s . output ! = " " { return } maxsize : = s . getmaxsize ( ) for floor : = 0 ; floor < s . size ; floor ++ { for line : = 0 ; line < floor + 4 ; line ++ { linesize : = s . getlinesize ( floor , line ) for i : = ( maxsize - linesize ) / 2 - 1 ; i > 0 ; i -- { s . putchar ( " " ) } for i : = 0 ; i < linesize ; i ++ { s . putchar ( " " ) } s . putchar ( " \n " ) } } for i : = 0 ; i < s . size ; i ++ { linesize : = s . size + ( s . size + 1 ) % 2 for i : = ( maxsize - linesize ) / 2 - 1 ; i > 0 ; i -- { s . putchar ( " " ) } for i : = 0 ; i < linesize ; i ++ { s . putchar ( " " ) } s . putchar ( " \n " ) } } 
func ( o * deleteappsappreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newdeleteappsappok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 404 : result : = newdeleteappsappnotfound ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newdeleteappsappdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( m * newtask ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( o * getappsapproutesreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newgetappsapproutesok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 404 : result : = newgetappsapproutesnotfound ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newgetappsapproutesdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( o * postappsparams ) withtimeout ( timeout time . duration ) * postappsparams { o . settimeout ( timeout ) return o } 
func ( o * postappsparams ) withcontext ( ctx context . context ) * postappsparams { o . setcontext ( ctx ) return o } 
func ( o * postappsparams ) withbody ( body * models . appwrapper ) * postappsparams { o . setbody ( body ) return o } 
func ( o * getappsreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newgetappsok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil default : result : = newgetappsdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( m * taskallof1 ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . validatereason ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * taskallof1 ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( o * getappsappparams ) withtimeout ( timeout time . duration ) * getappsappparams { o . settimeout ( timeout ) return o } 
func ( o * getappsappparams ) withcontext ( ctx context . context ) * getappsappparams { o . setcontext ( ctx ) return o } 
func ( o * getappsappparams ) withapp ( app string ) * getappsappparams { o . setapp ( app ) return o } 
func ( m * app ) validate ( formats strfmt . registry ) error { var res [ ] error if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * app ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( m * routewrapper ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . validateerror ( formats ) ; err ! = nil { res = append ( res , err ) } if err : = m . validateroute ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * routewrapper ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( m * routewrapper ) unmarshalbinary ( b [ ] byte ) error { var res routewrapper if err : = swag . readjson ( b , & res ) ; err ! = nil { return err } * m = res return nil } 
func ( o * getappsparams ) withtimeout ( timeout time . duration ) * getappsparams { o . settimeout ( timeout ) return o } 
func ( o * getappsparams ) withcontext ( ctx context . context ) * getappsparams { o . setcontext ( ctx ) return o } 
func ( o * deleteappsappparams ) withtimeout ( timeout time . duration ) * deleteappsappparams { o . settimeout ( timeout ) return o } 
func ( o * deleteappsappparams ) withcontext ( ctx context . context ) * deleteappsappparams { o . setcontext ( ctx ) return o } 
func ( o * deleteappsappparams ) withapp ( app string ) * deleteappsappparams { o . setapp ( app ) return o } 
func ( o * patchappsapproutesrouteparams ) withtimeout ( timeout time . duration ) * patchappsapproutesrouteparams { o . settimeout ( timeout ) return o } 
func ( o * patchappsapproutesrouteparams ) withcontext ( ctx context . context ) * patchappsapproutesrouteparams { o . setcontext ( ctx ) return o } 
func ( o * patchappsapproutesrouteparams ) withapp ( app string ) * patchappsapproutesrouteparams { o . setapp ( app ) return o } 
func ( o * patchappsapproutesrouteparams ) withbody ( body * models . routewrapper ) * patchappsapproutesrouteparams { o . setbody ( body ) return o } 
func ( o * patchappsapproutesrouteparams ) withroute ( route string ) * patchappsapproutesrouteparams { o . setroute ( route ) return o } 
func ( o * postappsapproutesparams ) withtimeout ( timeout time . duration ) * postappsapproutesparams { o . settimeout ( timeout ) return o } 
func ( o * postappsapproutesparams ) withcontext ( ctx context . context ) * postappsapproutesparams { o . setcontext ( ctx ) return o } 
func ( o * postappsapproutesparams ) withapp ( app string ) * postappsapproutesparams { o . setapp ( app ) return o } 
func ( o * postappsapproutesparams ) withbody ( body * models . routewrapper ) * postappsapproutesparams { o . setbody ( body ) return o } 
func ( o * putappsapproutesrouteparams ) withtimeout ( timeout time . duration ) * putappsapproutesrouteparams { o . settimeout ( timeout ) return o } 
func ( o * putappsapproutesrouteparams ) withcontext ( ctx context . context ) * putappsapproutesrouteparams { o . setcontext ( ctx ) return o } 
func ( o * putappsapproutesrouteparams ) withapp ( app string ) * putappsapproutesrouteparams { o . setapp ( app ) return o } 
func ( o * putappsapproutesrouteparams ) withbody ( body * models . routewrapper ) * putappsapproutesrouteparams { o . setbody ( body ) return o } 
func ( o * putappsapproutesrouteparams ) withroute ( route string ) * putappsapproutesrouteparams { o . setroute ( route ) return o } 
func ( o * putappsappreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newputappsappok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 400 : result : = newputappsappbadrequest ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result case 500 : result : = newputappsappinternalservererror ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newputappsappdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result } } 
func ( o * getappsapproutesparams ) withtimeout ( timeout time . duration ) * getappsapproutesparams { o . settimeout ( timeout ) return o } 
func ( o * getappsapproutesparams ) withcontext ( ctx context . context ) * getappsapproutesparams { o . setcontext ( ctx ) return o } 
func ( o * getappsapproutesparams ) withapp ( app string ) * getappsapproutesparams { o . setapp ( app ) return o } 
func ( m * appwrapper ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . validateapp ( formats ) ; err ! = nil { res = append ( res , err ) } if err : = m . validateerror ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * appwrapper ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( o * deleteappsapproutesroutereader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newdeleteappsapproutesrouteok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 404 : result : = newdeleteappsapproutesroutenotfound ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newdeleteappsapproutesroutedefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( o * patchappsappparams ) withtimeout ( timeout time . duration ) * patchappsappparams { o . settimeout ( timeout ) return o } 
func ( o * patchappsappparams ) withcontext ( ctx context . context ) * patchappsappparams { o . setcontext ( ctx ) return o } 
func ( o * patchappsappparams ) withapp ( app string ) * patchappsappparams { o . setapp ( app ) return o } 
func ( o * patchappsappparams ) withbody ( body * models . appwrapper ) * patchappsappparams { o . setbody ( body ) return o } 
func ( a * client ) gettasks ( params * gettasksparams ) ( * gettasksok , error ) { if params == nil { params = newgettasksparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & gettasksreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * gettasksok ) , nil } 
func ( o * putappsappparams ) withtimeout ( timeout time . duration ) * putappsappparams { o . settimeout ( timeout ) return o } 
func ( o * putappsappparams ) withcontext ( ctx context . context ) * putappsappparams { o . setcontext ( ctx ) return o } 
func ( o * putappsappparams ) withapp ( app string ) * putappsappparams { o . setapp ( app ) return o } 
func ( o * putappsappparams ) withbody ( body * models . appwrapper ) * putappsappparams { o . setbody ( body ) return o } 
func ( o * getappsapproutesroutereader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newgetappsapproutesrouteok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 404 : result : = newgetappsapproutesroutenotfound ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newgetappsapproutesroutedefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( m * appswrapper ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . validateapps ( formats ) ; err ! = nil { res = append ( res , err ) } if err : = m . validateerror ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * appswrapper ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( o * gettasksreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newgettasksok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil default : result : = newgettasksdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( o * putappsapproutesroutereader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 201 : result : = newputappsapproutesroutecreated ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 400 : result : = newputappsapproutesroutebadrequest ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result case 500 : result : = newputappsapproutesrouteinternalservererror ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newputappsapproutesroutedefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result } } 
func ( m * task ) unmarshaljson ( raw [ ] byte ) error { var ao0 newtask if err : = swag . readjson ( raw , & ao0 ) ; err ! = nil { return err } m . newtask = ao0 var ao1 taskallof1 if err : = swag . readjson ( raw , & ao1 ) ; err ! = nil { return err } m . taskallof1 = ao1 return nil } 
func ( m task ) marshaljson ( ) ( [ ] byte , error ) { var parts [ ] [ ] byte ao0 , err : = swag . writejson ( m . newtask ) if err ! = nil { return nil , err } parts = append ( parts , ao0 ) ao1 , err : = swag . writejson ( m . taskallof1 ) if err ! = nil { return nil , err } parts = append ( parts , ao1 ) return swag . concatjson ( parts ... ) , nil } 
func ( m * task ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . newtask . validate ( formats ) ; err ! = nil { res = append ( res , err ) } if err : = m . taskallof1 . validate ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func new ( domain string , dnsresolver dns . dnsresolver ) ( * spf , error ) { return newspf ( domain , dnsresolver , 0 , 0 ) } 
func ( s * spf ) incdnslookupcount ( amt int ) error { s . dnslookupcount = s . dnslookupcount + amt if s . dnslookupcount > dnslookuplimit { return & permerror { fmt . sprintf ( " " , s . domain , dnslookuplimit ) } } return nil } 
func ( s * spf ) incvoidlookupcount ( amt int ) error { s . voidlookupcount = s . voidlookupcount + amt if s . voidlookupcount >= voidlookuplimit { return & permerror { fmt . sprintf ( " " , s . domain , voidlookuplimit ) } } return nil } 
func getranges ( ips [ ] string , ip4 cidr string , ip6 cidr string ) ( [ ] net . ipnet , error ) { net out : = make ( [ ] net . ipnet , 0 ) for , ip : = range ips { cidr : = " " if strings . contains ( ip , " " ) { cidr = ip6 cidr if cidr == " " { cidr = " " } if c , err : = strconv . parseint ( cidr , 10 , 16 ) ; err ! = nil | | c < 0 | | c > 128 { return nil , & permerror { " " + cidr } } } else { cidr = ip4 cidr if cidr == " " { cidr = " " } if c , err : = strconv . parseint ( cidr , 10 , 16 ) ; err ! = nil | | c < 0 | | c > 32 { return nil , & permerror { " " + cidr } } } ip += " " + cidr , ipnet , err : = net . parsecidr ( ip ) if err ! = nil { return nil , err } net out = append ( net out , * ipnet ) } return net out , nil } 
func ( spf * spf ) checkip ( ip str string ) ( string , error ) { ip : = net . parseip ( ip str ) for , ip net : = range spf . fail { if ip net . contains ( ip ) { return " " , nil } } for , ip net : = range spf . softfail { if ip net . contains ( ip ) { return " " , nil } } for , ip net : = range spf . neutral { if ip net . contains ( ip ) { return " " , nil } } for , ip net : = range spf . pass { if ip net . contains ( ip ) { return " " , nil } } for , include : = range spf . includes { check , err : = include . spf . checkip ( ip str ) if err ! = nil { return " " , nil } if check == " " { return qualifiertoresult ( include . qualifier ) , nil } } if spf . all == " " { if spf . redirect ! = nil { return spf . redirect . checkip ( ip str ) } } if spf . all ! = " " { return qualifiertoresult ( spf . all ) , nil } return " " , nil } 
func ( o * patchappsapproutesroutereader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newpatchappsapproutesrouteok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 400 : result : = newpatchappsapproutesroutebadrequest ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result case 404 : result : = newpatchappsapproutesroutenotfound ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newpatchappsapproutesroutedefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( m * errorbody ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( o * postappsreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newpostappsok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 400 : result : = newpostappsbadrequest ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result case 409 : result : = newpostappsconflict ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newpostappsdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( o * getappsappreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newgetappsappok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 404 : result : = newgetappsappnotfound ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newgetappsappdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( o * patchappsappreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newpatchappsappok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 400 : result : = newpatchappsappbadrequest ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result case 404 : result : = newpatchappsappnotfound ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newpatchappsappdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( o * getappsapproutesrouteparams ) withtimeout ( timeout time . duration ) * getappsapproutesrouteparams { o . settimeout ( timeout ) return o } 
func ( o * getappsapproutesrouteparams ) withcontext ( ctx context . context ) * getappsapproutesrouteparams { o . setcontext ( ctx ) return o } 
func ( o * getappsapproutesrouteparams ) withapp ( app string ) * getappsapproutesrouteparams { o . setapp ( app ) return o } 
func ( o * getappsapproutesrouteparams ) withroute ( route string ) * getappsapproutesrouteparams { o . setroute ( route ) return o } 
func ( a * client ) deleteappsapproutesroute ( params * deleteappsapproutesrouteparams ) ( * deleteappsapproutesrouteok , error ) { if params == nil { params = newdeleteappsapproutesrouteparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & deleteappsapproutesroutereader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * deleteappsapproutesrouteok ) , nil } 
func ( a * client ) getappsapproutes ( params * getappsapproutesparams ) ( * getappsapproutesok , error ) { if params == nil { params = newgetappsapproutesparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & getappsapproutesreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * getappsapproutesok ) , nil } 
func ( a * client ) getappsapproutesroute ( params * getappsapproutesrouteparams ) ( * getappsapproutesrouteok , error ) { if params == nil { params = newgetappsapproutesrouteparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & getappsapproutesroutereader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * getappsapproutesrouteok ) , nil } 
func ( a * client ) patchappsapproutesroute ( params * patchappsapproutesrouteparams ) ( * patchappsapproutesrouteok , error ) { if params == nil { params = newpatchappsapproutesrouteparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & patchappsapproutesroutereader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * patchappsapproutesrouteok ) , nil } 
func ( a * client ) postappsapproutes ( params * postappsapproutesparams ) ( * postappsapproutesok , error ) { if params == nil { params = newpostappsapproutesparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & postappsapproutesreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * postappsapproutesok ) , nil } 
func ( m * taskwrapper ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . validatetask ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * taskwrapper ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( m * version ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func new ( transport runtime . clienttransport , formats strfmt . registry ) * functions { cli : = new ( functions ) cli . transport = transport cli . apps = apps . new ( transport , formats ) cli . routes = routes . new ( transport , formats ) cli . tasks = tasks . new ( transport , formats ) cli . version = version . new ( transport , formats ) return cli } 
func ( c * functions ) settransport ( transport runtime . clienttransport ) { c . transport = transport c . apps . settransport ( transport ) c . routes . settransport ( transport ) c . tasks . settransport ( transport ) c . version . settransport ( transport ) } 
func ( o * deleteappsapproutesrouteparams ) withtimeout ( timeout time . duration ) * deleteappsapproutesrouteparams { o . settimeout ( timeout ) return o } 
func ( o * deleteappsapproutesrouteparams ) withcontext ( ctx context . context ) * deleteappsapproutesrouteparams { o . setcontext ( ctx ) return o } 
func ( o * deleteappsapproutesrouteparams ) withapp ( app string ) * deleteappsapproutesrouteparams { o . setapp ( app ) return o } 
func ( o * deleteappsapproutesrouteparams ) withroute ( route string ) * deleteappsapproutesrouteparams { o . setroute ( route ) return o } 
func ( o * postappsapproutesreader ) readresponse ( response runtime . clientresponse , consumer runtime . consumer ) ( interface { } , error ) { switch response . code ( ) { case 200 : result : = newpostappsapproutesok ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return result , nil case 400 : result : = newpostappsapproutesbadrequest ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result case 409 : result : = newpostappsapproutesconflict ( ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } return nil , result default : result : = newpostappsapproutesdefault ( response . code ( ) ) if err : = result . readresponse ( response , consumer , o . formats ) ; err ! = nil { return nil , err } if response . code ( ) / 100 == 2 { return result , nil } return nil , result } } 
func ( d * directive ) getqualifier ( ) string { if len ( d . term ) <= 0 { return " " } if isqualifier ( d . term [ 0 ] ) { return string ( d . term [ 0 ] ) } else { return " " } } 
func ( d * directive ) getmechanism ( ) string { if len ( d . term ) <= 0 { return " " } term : = d . term if isqualifier ( d . term [ 0 ] ) { term = term [ 1 : ] } index : = strings . index ( term , " " ) if index == - 1 { return term } return term [ 0 : index ] } 
func ( o * gettasksparams ) withtimeout ( timeout time . duration ) * gettasksparams { o . settimeout ( timeout ) return o } 
func ( o * gettasksparams ) withcontext ( ctx context . context ) * gettasksparams { o . setcontext ( ctx ) return o } 
func ( m * route ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . validateformat ( formats ) ; err ! = nil { res = append ( res , err ) } if err : = m . validateheaders ( formats ) ; err ! = nil { res = append ( res , err ) } if err : = m . validatetype ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * route ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( m * routeswrapper ) validate ( formats strfmt . registry ) error { var res [ ] error if err : = m . validateerror ( formats ) ; err ! = nil { res = append ( res , err ) } if err : = m . validateroutes ( formats ) ; err ! = nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . compositevalidationerror ( res ... ) } return nil } 
func ( m * routeswrapper ) marshalbinary ( ) ( [ ] byte , error ) { if m == nil { return nil , nil } return swag . writejson ( m ) } 
func ( a * client ) deleteappsapp ( params * deleteappsappparams ) ( * deleteappsappok , error ) { if params == nil { params = newdeleteappsappparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & deleteappsappreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * deleteappsappok ) , nil } 
func ( a * client ) getapps ( params * getappsparams ) ( * getappsok , error ) { if params == nil { params = newgetappsparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & getappsreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * getappsok ) , nil } 
func ( a * client ) getappsapp ( params * getappsappparams ) ( * getappsappok , error ) { if params == nil { params = newgetappsappparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & getappsappreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * getappsappok ) , nil } 
func ( a * client ) patchappsapp ( params * patchappsappparams ) ( * patchappsappok , error ) { if params == nil { params = newpatchappsappparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & patchappsappreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * patchappsappok ) , nil } 
func ( a * client ) postapps ( params * postappsparams ) ( * postappsok , error ) { if params == nil { params = newpostappsparams ( ) } result , err : = a . transport . submit ( & runtime . clientoperation { id : " " , method : " " , pathpattern : " " , producesmediatypes : [ ] string { " " } , consumesmediatypes : [ ] string { " " } , schemes : [ ] string { " " , " " } , params : params , reader : & postappsreader { formats : a . formats } , context : params . context , client : params . httpclient , } ) if err ! = nil { return nil , err } return result . ( * postappsok ) , nil } 
func new ( servicename , workingdir string , binaryupdater * cmdctrl . githubupdater ) ( * server , error ) { if workingdir == " " { workingdir = fmt . sprintf ( " " , defaultbasedir , servicename ) } o : = & server { servicename : servicename , cwd : workingdir , ch : make ( chan bool ) , shutdowncomplete : make ( chan bool ) , waitgroup : & sync . waitgroup { } , stopped : false , } err : = o . obtainconfig ( ) if err ! = nil { return o , err } o . binaryupgrade = binaryupdater return o , err } 
func ( o * server ) setbackend ( backend oortservice ) { o . lock ( ) o . backend = backend o . unlock ( ) } 
func ( o * server ) ring ( ) ring . ring { o . rlock ( ) defer o . runlock ( ) return o . ring } 
func ( o * server ) getlocalid ( ) uint64 { o . rlock ( ) defer o . runlock ( ) return o . localid } 
func ( o * server ) getlistenaddr ( ) string { o . rlock ( ) defer o . runlock ( ) return o . ring . localnode ( ) . address ( 2 ) } 
func ( rs * replgroupstore ) startup ( ctx context . context ) error { rs . ringlock . lock ( ) if rs . ringserverexitchan == nil { rs . ringserverexitchan = make ( chan struct { } ) go rs . ringserverconnector ( rs . ringserverexitchan ) } rs . ringlock . unlock ( ) return nil } 
func ( o * server ) shutdownfinished ( ) { time . sleep ( 10 * time . millisecond ) close ( o . shutdowncomplete ) } 
func ( o * server ) stop ( ) error { o . cmdctrllock . lock ( ) defer o . cmdctrllock . unlock ( ) if o . stopped { return fmt . errorf ( " " ) } close ( o . ch ) o . backend . stoplistenandserve ( ) o . backend . wait ( ) o . backend . stop ( ) o . stopped = true return nil } 
func ( o * server ) exit ( ) error { o . cmdctrllock . lock ( ) defer o . cmdctrllock . unlock ( ) if o . stopped { o . backend . stop ( ) defer o . shutdownfinished ( ) return nil } close ( o . ch ) o . backend . stoplistenandserve ( ) o . backend . wait ( ) o . backend . stop ( ) o . stopped = true defer o . shutdownfinished ( ) return nil } 
func ( o * server ) selfupgrade ( version string , bindiff , checksum [ ] byte ) ( bool , string ) { o . cmdctrllock . lock ( ) defer o . cmdctrllock . unlock ( ) err : = o . binaryupgrade . upgrade ( version ) if err ! = nil { return false , err . error ( ) } return true , " " } 
func ( o * server ) softwareversion ( ) string { o . cmdctrllock . rlock ( ) defer o . cmdctrllock . runlock ( ) return o . binaryupgrade . getcurrentversion ( ) } 
func ( c * client ) rant ( rantid int ) ( rantmodel , [ ] commentmodel , error ) { url : = fmt . sprintf ( rant path , api , rantid , app version ) res , err : = http . get ( url ) if err ! = nil { return rantmodel { } , nil , err } var data rantresponse json . newdecoder ( res . body ) . decode ( & data ) if ! data . success && data . error ! = " " { return rantmodel { } , nil , errors . new ( data . error ) } return data . rant , data . comments , nil } 
func ( c * client ) profile ( username string ) ( usermodel , contentmodel , error ) { userid , err : = getuserid ( username ) if err ! = nil { return usermodel { } , contentmodel { } , err } url : = fmt . sprintf ( user path , api , userid , app version ) res , err : = http . get ( url ) if err ! = nil { return usermodel { } , contentmodel { } , err } var data userresponse json . newdecoder ( res . body ) . decode ( & data ) if ! data . success && data . error ! = " " { return usermodel { } , contentmodel { } , errors . new ( data . error ) } return data . profile , data . profile . content . content , nil } 
func ( c * client ) search ( term string ) ( [ ] rantmodel , error ) { url : = fmt . sprintf ( search path , api , term , app version ) res , err : = http . get ( url ) if err ! = nil { return nil , err } var data searchresponse json . newdecoder ( res . body ) . decode ( & data ) if ! data . success && data . error ! = " " { return nil , errors . new ( data . error ) } return data . rants , nil } 
func ( c * client ) surprise ( ) ( rantmodel , error ) { url : = fmt . sprintf ( surprise path , api , app version ) res , err : = http . get ( url ) if err ! = nil { return rantmodel { } , err } var data rantresponse json . newdecoder ( res . body ) . decode ( & data ) if ! data . success && data . error ! = " " { return rantmodel { } , errors . new ( data . error ) } return data . rant , nil } 
func ( c * client ) weeklyrants ( ) ( [ ] rantmodel , error ) { url : = fmt . sprintf ( weekly path , api , app version ) res , err : = http . get ( url ) if err ! = nil { return nil , err } var data rantsresponse json . newdecoder ( res . body ) . decode ( & data ) if ! data . success && data . error ! = " " { return nil , errors . new ( data . error ) } return data . rants , nil } 
func getuserid ( username string ) ( int , error ) { url : = fmt . sprintf ( user id path , api , username , app version ) res , err : = http . get ( url ) if err ! = nil { return 0 , err } var data getuseridresponse json . newdecoder ( res . body ) . decode ( & data ) if ! data . success && data . error ! = " " { return 0 , errors . new ( data . error ) } return data . userid , nil } 
func ( rs * replvaluestore ) shutdown ( ctx context . context ) error { rs . ringlock . lock ( ) if rs . ringserverexitchan ! = nil { close ( rs . ringserverexitchan ) rs . ringserverexitchan = nil } rs . storeslock . lock ( ) for addr , stc : = range rs . stores { if err : = stc . store . shutdown ( ctx ) ; err ! = nil { rs . logdebug ( " " , addr , err ) } delete ( rs . stores , addr ) select { case < - ctx . done ( ) : rs . storeslock . unlock ( ) return ctx . err ( ) default : } } rs . storeslock . unlock ( ) rs . ringlock . unlock ( ) return nil } 
func fexists ( name string ) bool { if , err : = os . stat ( name ) ; os . isnotexist ( err ) { return false } return true } 
func genserviceid ( service , name , proto string ) ( string , error ) { h , : = os . hostname ( ) d : = strings . splitn ( h , " " , 2 ) if len ( d ) ! = 2 { return " " , fmt . errorf ( " " ) } return fmt . sprintf ( " " , service , name , proto , d [ 1 ] ) , nil } 
func ( m * messagestream ) outbound ( ) { for { select { case < - m . shutdown : log . infof ( " " ) m . conn . close ( ) return case msg : = < - m . outbound : data , : = msg . marshalbinary ( ) if , err : = m . conn . write ( data ) ; err ! = nil { log . warnln ( " " , err ) m . error < - err m . shutdown < - true } log . debugf ( " " , len ( data ) , data ) } } } 
func ( m * messagestream ) parse ( ) { for { b : = < - m . pool . full log . debugf ( " " , b . bytes ( ) ) msg , err : = m . parser . parse ( b . bytes ( ) ) if err ! = nil { log . print ( err ) } m . inbound < - msg b . reset ( ) m . pool . empty < - b } } 
func ( dom * domain ) group ( name string , members [ ] * account ) * group { return & group { domain : dom , name : name , members : members } } 
func ( dom * domain ) groups ( ) ( [ ] * group , error ) { var vl valuelist err : = dom . cgp . request ( listgroups { domain : dom . name } , & vl ) if err ! = nil { return [ ] * group { } , err } vals : = vl . compact ( ) grps : = make ( [ ] * group , len ( vals ) ) for i , v : = range vals { g , err : = dom . getgroup ( v ) if err ! = nil { return grps , err } grps [ i ] = g } return grps , nil } 
func ( dom * domain ) getgroup ( name string ) ( * group , error ) { var d dictionary err : = dom . cgp . request ( getgroup { name : fmt . sprintf ( " " , name , dom . name ) } , & d ) if err ! = nil { return & group { } , err } memstr : = d . tomap ( ) [ " " ] var mems [ ] * account dec : = xml . newdecoder ( bytes . newbufferstring ( memstr ) ) for { var a string err : = dec . decode ( & a ) if err == io . eof { break } if err ! = nil { return dom . group ( name , mems ) , err } if a == " " { continue } mems = append ( mems , dom . account ( a ) ) } return dom . group ( name , mems ) , nil } 
func reticence ( str string , length int ) string { if length > len ( str ) { return str } var i int f : for i = len ( str ) - 1 ; i >= 0 ; i -- { switch str [ i ] { case ' ' , ' , ' , ' ? ' , ' ; ' , ' : ' , ' \ ' ' , ' " ' , ' ! ' : if i <= length { break f } case ' . ' : if i - 2 >= 0 { s : = str [ i - 2 : i ] if s == " " { i = i - 2 if i <= length { break f } } } if i <= length { break f } } } if i - 1 > 0 { switch str [ i - 1 ] { case ' ' , ' , ' , ' ? ' , ' ; ' , ' : ' , ' \ ' ' , ' " ' , ' ! ' : i -- case ' . ' : if i - 2 > 0 && str [ i - 2 : i ] == " " { i - = 3 } } } if i >= 2 { if i + 3 >= len ( str ) { return str } return str [ : i ] + " " } if length >= 2 && length < len ( str ) { if length + 3 >= len ( str ) { return str } return str [ : length ] + " " } return str } 
func checkpassword ( pass string , min , max int ) error { if len ( pass ) < min | | len ( pass ) > max { return e . new ( errinvalidpasslength ) } for , r : = range pass { if ! unicode . isgraphic ( r ) { return e . new ( errinvalidpasschar ) } } return nil } 
func cleanurl ( rawurl string , min , max int ) ( string , error ) { err : = checkurl ( rawurl , min , max ) if err ! = nil { return " " , e . forward ( err ) } u , err : = url . parse ( rawurl ) if err ! = nil { return " " , e . push ( e . new ( errinvurl ) , err ) } if u . scheme == " " { return u . string ( ) , e . new ( errnoscheme ) } return u . string ( ) , nil } 
func newparameter ( name string , value reflect . value ) * parameter { parameter : = parameter { name : name , value : value , } return & parameter } 
func ( p * parameter ) discoverproperties ( tag reflect . structtag ) error { if len ( tag ) > 0 { paramtype : = reflect . typeof ( ( * parameter ) ( nil ) ) prefix : = " " paramvalue : = reflect . valueof ( p ) for idx : = 0 ; idx < paramtype . nummethod ( ) ; idx ++ { method : = paramtype . method ( idx ) if ! strings . hasprefix ( method . name , prefix ) { continue } tagname : = " " + strings . tolower ( method . name [ len ( prefix ) : ] ) if tagval : = tag . get ( tagname ) ; tagval ! = " " { methodvalue : = paramvalue . methodbyname ( method . name ) err : = methodvalue . call ( [ ] reflect . value { reflect . valueof ( tagval ) } ) [ 0 ] . interface ( ) if err ! = nil { return ( err ) . ( error ) } } } } return nil } 
func makeparams ( fieldcount int ) * params { return & params { make ( map [ string ] * parameter ) , make ( [ ] * parameter , 0 , fieldcount ) , } } 
func ( p * params ) parse ( pvalue * reflect . value ) error { vtype : = pvalue . type ( ) . elem ( ) for idx : = 0 ; idx < vtype . numfield ( ) ; idx ++ { field : = vtype . field ( idx ) value : = pvalue . elem ( ) . field ( idx ) if value . kind ( ) == reflect . slice { value . set ( reflect . makeslice ( value . type ( ) , 0 , 0 ) ) } parameter : = newparameter ( field . name , value ) if err : = parameter . discoverproperties ( field . tag ) ; err ! = nil { return err } if err : = p . set ( parameter . name , parameter ) ; err ! = nil { return err } if parameter . alias ! = " " { if err : = p . set ( parameter . alias , parameter ) ; err ! = nil { return err } } p . listing = append ( p . listing , parameter ) } return nil } 
func ( f forwarder ) email ( ) string { return fmt . sprintf ( " " , f . name , f . domain . name ) } 
func ( dom * domain ) forwarder ( name , to string ) * forwarder { return & forwarder { domain : dom , name : name , to : to } } 
func ( dom * domain ) forwarders ( ) ( [ ] * forwarder , error ) { var vl valuelist err : = dom . cgp . request ( listforwarders { param : dom . name } , & vl ) if err ! = nil { return [ ] * forwarder { } , err } vals : = vl . compact ( ) fs : = make ( [ ] * forwarder , len ( vals ) ) for i , v : = range vals { f , err : = dom . getforwarder ( v ) if err ! = nil { return fs , err } fs [ i ] = f } return fs , err } 
func ( dom * domain ) getforwarder ( name string ) ( * forwarder , error ) { var f string err : = dom . cgp . request ( getforwarder { param : fmt . sprintf ( " " , name , dom . name ) } , & f ) if err ! = nil { return & forwarder { } , err } return & forwarder { domain : dom , name : name , to : f } , nil } 
func new ( url , user , pass string ) * cgp { return & cgp { url : url , user : user , pass : pass } } 
func escapecommaseparated ( in ... string ) string { var out string for i , str : = range in { escaped : = strings . replace ( url . queryescape ( str ) , " " , " " , - 1 ) escaped = strings . replace ( escaped , " " " , " " , - 1 ) escaped = strings . replace ( escaped , " " , " " , - 1 ) out += escaped if i < len ( in ) - 1 { out += " " } } return out } 
func ( acc * account ) alias ( name string ) * alias { return & alias { account : acc , name : name } } 
func ( a alias ) email ( ) string { return fmt . sprintf ( " " , a . name , a . account . domain . name ) } 
func ( acc * account ) aliases ( ) ( [ ] * alias , error ) { var vl valuelist err : = acc . domain . cgp . request ( listaliases { param : fmt . sprintf ( " " , acc . name , acc . domain . name ) } , & vl ) if err ! = nil { return [ ] * alias { } , err } vals : = vl . compact ( ) as : = make ( [ ] * alias , len ( vals ) ) for i , v : = range vals { as [ i ] = acc . alias ( v ) } return as , nil } 
func ( a account ) realname ( ) ( string , error ) { var d dictionary err : = a . domain . cgp . request ( getaccountsettings { account : a . email ( ) } , & d ) if err ! = nil { return " " , err } return d . tomap ( ) [ " " ] , nil } 
func ( a account ) email ( ) string { return fmt . sprintf ( " " , a . name , a . domain . name ) } 
func ( dom * domain ) account ( name string ) * account { return & account { domain : dom , name : name } } 
func ( dom * domain ) accounts ( ) ( [ ] * account , error ) { var al accountlist err : = dom . cgp . request ( listaccounts { domain : dom . name } , & al ) if err ! = nil { return [ ] * account { } , err } keys : = al . subkeys as : = make ( [ ] * account , len ( keys ) ) for i , k : = range keys { as [ i ] = dom . account ( k . name ) } return as , nil } 
func ( dom domain ) exists ( ) ( bool , error ) { var d dictionary err : = dom . cgp . request ( getdomainsettings { domain : dom . name } , & d ) if , ok : = err . ( soapnotfounderror ) ; ok { return false , nil } if err ! = nil { return false , err } return true , nil } 
func ( dom domain ) aliases ( ) ( [ ] string , error ) { var vl valuelist err : = dom . cgp . request ( getdomainaliases { domain : dom . name } , & vl ) if err ! = nil { return [ ] string { } , err } return vl . compact ( ) , nil } 
func ( cgp * cgp ) domain ( name string ) * domain { return & domain { cgp : cgp , name : name } } 
func ( cgp * cgp ) domains ( ) ( [ ] * domain , error ) { var vl valuelist err : = cgp . request ( listdomains { } , & vl ) if err ! = nil { return [ ] * domain { } , err } vals : = vl . subvalues ds : = make ( [ ] * domain , len ( vals ) ) for i , d : = range vals { ds [ i ] = cgp . domain ( d ) } return ds , nil } 
func new ( info info , publicmsg ... interface { } ) err { return newerr ( debug . stack ( ) , nil , false , info , publicmsg ) } 
func wrap ( wraperr error , info info , publicmsg ... interface { } ) err { if wraperr == nil { return nil } if info == nil { info = info { } } if errserr , iserr : = iserr ( wraperr ) ; iserr { if errstructerr , iserrserr : = errserr . ( * err ) ; iserrserr { errstructerr . mergein ( info , publicmsg ) return errstructerr } return errserr } return newerr ( debug . stack ( ) , wraperr , false , info , publicmsg ) } 
func usererror ( info info , publicmsg ... interface { } ) err { return newerr ( debug . stack ( ) , nil , true , info , publicmsg ) } 
func format ( info info , format string , argv ... interface { } ) err { return newerr ( debug . stack ( ) , fmt . errorf ( format , argv ... ) , false , info , nil ) } 
func iserr ( err error ) ( err , bool ) { errserr , iserr : = err . ( err ) return errserr , iserr } 
func ( e * err ) mergein ( info info , publicmsgparts [ ] interface { } ) { for key , val : = range info { for e . info [ key ] ! = nil { key = key + " " } e . info [ key ] = val } publicmsgprefix : = concatargs ( publicmsgparts ... ) if publicmsgprefix == " " { } else if e . publicmsg == " " { e . publicmsg = publicmsgprefix } else { e . publicmsg = publicmsgprefix + " " + e . publicmsg } } 
func ( e * err ) wrappederrstr ( ) string { if e == nil { return " " } if e . wrappederr == nil { return " " } return e . wrappederr . error ( ) } 
func concatargs ( args ... interface { } ) string { res : = fmt . sprintln ( args ... ) return res [ 0 : len ( res ) - 1 ] } 
func ( dom * domain ) mailinglist ( name string ) * mailinglist { return & mailinglist { domain : dom , name : name } } 
func ( ml * mailinglist ) subscriber ( email , name string ) * subscriber { return & subscriber { mailinglist : ml , email : email , realname : name } } 
func ( ml * mailinglist ) subscribers ( ) ( [ ] * subscriber , error ) { var res readsubscribersresponse err : = ml . domain . cgp . request ( readsubscribers { name : fmt . sprintf ( " " , ml . name , ml . domain . name ) } , & res ) if err ! = nil { return [ ] * subscriber { } , err } ds : = res . subvalues [ 1 ] . subvalues subs : = make ( [ ] * subscriber , len ( ds ) ) for i , d : = range ds { m : = d . tomap ( ) subs [ i ] = ml . subscriber ( m [ " " ] , m [ " " ] ) } return subs , nil } 
func ( dom * domain ) mailinglists ( ) ( [ ] * mailinglist , error ) { var vl valuelist err : = dom . cgp . request ( listlists { domain : dom . name } , & vl ) if err ! = nil { return [ ] * mailinglist { } , err } vals : = vl . compact ( ) mls : = make ( [ ] * mailinglist , len ( vals ) ) for i , v : = range vals { mls [ i ] = dom . mailinglist ( v ) } return mls , nil } 
func newbytekeyitem ( k [ ] byte ) unsafe . pointer { itm : = bytekeyitem ( k ) return unsafe . pointer ( & itm ) } 
func comparebytes ( this , that unsafe . pointer ) int { thisitem : = ( * bytekeyitem ) ( this ) thatitem : = ( * bytekeyitem ) ( that ) return bytes . compare ( [ ] byte ( * thisitem ) , [ ] byte ( * thatitem ) ) } 
func compareint ( this , that unsafe . pointer ) int { thisitem : = ( * intkeyitem ) ( this ) thatitem : = ( * intkeyitem ) ( that ) return int ( * thisitem - * thatitem ) } 
func malloc ( l int ) unsafe . pointer { if debug { atomic . adduint64 ( & stats . allocs , 1 ) } return c . mm malloc ( c . size t ( l ) ) } 
func free ( p unsafe . pointer ) { if debug { atomic . adduint64 ( & stats . frees , 1 ) } c . mm free ( p ) } 
func stats ( ) string { mu . lock ( ) defer mu . unlock ( ) buf : = c . mm stats ( ) s : = " \n " if debug { s += fmt . sprintf ( " \n " + " \n " , stats . allocs , stats . frees ) } if buf ! = nil { s += c . gostring ( buf ) c . free ( unsafe . pointer ( buf ) ) } return s } 
func freeosmemory ( ) error { errcode : = int ( c . mm free2os ( ) ) if errcode ! = 0 { return fmt . errorf ( " " , errcode ) } return nil } 
func ( n node ) size ( ) int { return int ( nodehdrsize + uintptr ( n . level + 1 ) * noderefsize ) } 
func ( n * node ) dcasnext ( level int , prevptr , newptr * node , previsdeleted , newisdeleted bool ) bool { noderefaddr : = uintptr ( unsafe . pointer ( n ) ) + nodehdrsize + noderefsize * uintptr ( level ) wordaddr : = ( * uint64 ) ( unsafe . pointer ( noderefaddr + uintptr ( 7 ) ) ) prevval : = uint64 ( uintptr ( unsafe . pointer ( prevptr ) ) < < 8 ) newval : = uint64 ( uintptr ( unsafe . pointer ( newptr ) ) < < 8 ) if newisdeleted { newval | = deletedflag } swapped : = atomic . compareandswapuint64 ( wordaddr , prevval , newval ) if swapped { atomic . compareandswappointer ( ( * unsafe . pointer ) ( unsafe . pointer ( noderefaddr + noderefflagsize ) ) , unsafe . pointer ( newptr ) , unsafe . pointer ( newptr ) ) } return swapped } 
func ( s * segment ) add ( itm unsafe . pointer ) { itemlevel : = s . builder . store . newlevel ( s . rand . float32 ) x : = s . builder . store . newnode ( itm , itemlevel ) s . sts . addint64 ( & s . sts . nodeallocs , 1 ) s . sts . addint64 ( & s . sts . levelnodescount [ itemlevel ] , 1 ) s . sts . addint64 ( & s . sts . usedbytes , int64 ( s . builder . store . size ( x ) ) ) for l : = 0 ; l <= itemlevel ; l ++ { if s . tail [ l ] ! = nil { s . tail [ l ] . setnext ( l , x , false ) } else { s . head [ l ] = x } s . tail [ l ] = x } if s . callb ! = nil { s . callb ( x ) } } 
func ( b * builder ) newsegment ( ) * segment { seg : = & segment { tail : make ( [ ] * node , maxlevel + 1 ) , head : make ( [ ] * node , maxlevel + 1 ) , builder : b , rand : rand . new ( rand . newsource ( int64 ( rand . int ( ) ) ) ) , } seg . sts . islocal ( true ) return seg } 
func ( b * builder ) assemble ( segments ... * segment ) * skiplist { tail : = make ( [ ] * node , maxlevel + 1 ) head : = make ( [ ] * node , maxlevel + 1 ) for , seg : = range segments { for l : = 0 ; l <= maxlevel ; l ++ { if tail [ l ] ! = nil && seg . head [ l ] ! = nil { tail [ l ] . setnext ( l , seg . head [ l ] , false ) } else if head [ l ] == nil && seg . head [ l ] ! = nil { head [ l ] = seg . head [ l ] } if seg . tail [ l ] ! = nil { tail [ l ] = seg . tail [ l ] } } } for l : = 0 ; l <= maxlevel ; l ++ { if head [ l ] ! = nil { b . store . head . setnext ( l , head [ l ] , false ) } if tail [ l ] ! = nil { tail [ l ] . setnext ( l , b . store . tail , false ) } } for , seg : = range segments { b . store . stats . merge ( & seg . sts ) } return b . store } 
func comparenodetable ( a , b unsafe . pointer ) int { return int ( uintptr ( a ) ) - int ( uintptr ( b ) ) } 
func new ( hfn hashfn , kfn equalkeyfn ) * nodetable { nt : = & nodetable { fastht : make ( map [ uint32 ] uint64 ) , slowht : make ( map [ uint32 ] [ ] uint64 ) , hash : hfn , keyequal : kfn , } buf : = dbinstances . makebuf ( ) defer dbinstances . freebuf ( buf ) dbinstances . insert ( unsafe . pointer ( nt ) , comparenodetable , buf , & dbinstances . stats ) return nt } 
func ( nt * nodetable ) stats ( ) string { return fmt . sprintf ( " \n \n " + " \n " + " \n " + " \n " , nt . fasthtcount , nt . slowhtcount , nt . conflicts , nt . memoryinuse ( ) ) } 
func ( nt * nodetable ) memoryinuse ( ) int64 { return int64 ( approxitemsize * ( nt . fasthtcount + nt . slowhtcount ) ) } 
func ( nt * nodetable ) get ( key [ ] byte ) unsafe . pointer { res : = nt . find ( key ) if res . status & ntfoundmask == ntfoundmask { if res . status == ntfoundinfast { return decodepointer ( res . fasthtvalue ) } return decodepointer ( res . slowhtvalues [ res . slowhtpos ] ) } return nil } 
func ( nt * nodetable ) update ( key [ ] byte , nptr unsafe . pointer ) ( updated bool , oldptr unsafe . pointer ) { res : = nt . find ( key ) if res . status & ntfoundmask == ntfoundmask { updated = true if res . status == ntfoundinfast { oldptr = decodepointer ( res . fasthtvalue ) nt . fastht [ res . hash ] = encodepointer ( nptr , res . hasconflict ) } else { oldptr = decodepointer ( res . slowhtvalues [ res . slowhtpos ] ) res . slowhtvalues [ res . slowhtpos ] = encodepointer ( nptr , true ) } } else { updated = false newslowvalue : = res . fasththasentry && ! res . hasconflict if res . hasconflict | | newslowvalue { slowhtvalues : = nt . slowht [ res . hash ] slowhtvalues = append ( slowhtvalues , encodepointer ( nptr , false ) ) nt . slowht [ res . hash ] = slowhtvalues if newslowvalue { nt . fastht [ res . hash ] = encodepointer ( decodepointer ( nt . fastht [ res . hash ] ) , true ) nt . conflicts ++ } nt . slowhtcount ++ } else { nt . fastht [ res . hash ] = encodepointer ( nptr , false ) nt . fasthtcount ++ } } return } 
func ( nt * nodetable ) close ( ) { nt . fasthtcount = 0 nt . slowhtcount = 0 nt . conflicts = 0 nt . fastht = make ( map [ uint32 ] uint64 ) nt . slowht = make ( map [ uint32 ] [ ] uint64 ) buf : = dbinstances . makebuf ( ) defer dbinstances . freebuf ( buf ) dbinstances . delete ( unsafe . pointer ( nt ) , comparenodetable , buf , & dbinstances . stats ) } 
func memoryinuse ( ) ( sz int64 ) { buf : = dbinstances . makebuf ( ) defer dbinstances . freebuf ( buf ) iter : = dbinstances . newiterator ( comparenodetable , buf ) for iter . seekfirst ( ) ; iter . valid ( ) ; iter . next ( ) { db : = ( * nodetable ) ( iter . get ( ) ) sz += db . memoryinuse ( ) } return } 
func debugmarkfree ( n * node ) { var block [ ] byte l : = int ( nodetypes [ n . level ] . size ( ) ) sh : = ( * reflect . sliceheader ) ( unsafe . pointer ( & block ) ) sh . data = uintptr ( unsafe . pointer ( n ) ) sh . len = l sh . cap = l copy ( block , freeblockcontent ) } 
func ( it * iterator ) seek ( bs [ ] byte ) { itm : = it . snap . db . newitem ( bs , false ) it . iter . seek ( unsafe . pointer ( itm ) ) it . skipunwanted ( ) } 
func ( it * iterator ) next ( ) { it . iter . next ( ) it . count ++ it . skipunwanted ( ) if it . refreshrate > 0 && it . count > it . refreshrate { it . refresh ( ) it . count = 0 } } 
func ( it * iterator ) refresh ( ) { if it . valid ( ) { itm : = it . snap . db . ptrtoitem ( it . getnode ( ) . item ( ) ) it . iter . close ( ) it . iter = it . snap . db . store . newiterator ( it . snap . db . itercmp , it . buf ) it . iter . seek ( unsafe . pointer ( itm ) ) } } 
func ( it * iterator ) close ( ) { it . snap . close ( ) it . snap . db . store . freebuf ( it . buf ) it . iter . close ( ) } 
func ( m * nitro ) newiterator ( snap * snapshot ) * iterator { if ! snap . open ( ) { return nil } buf : = snap . db . store . makebuf ( ) return & iterator { snap : snap , iter : m . store . newiterator ( m . itercmp , buf ) , buf : buf , } } 
func ( mit * mergeiterator ) seekfirst ( ) { for , it : = range mit . iters { it . seekfirst ( ) if it . valid ( ) { n : = it . getnode ( ) mit . h = append ( mit . h , heapitem { iter : it , n : n } ) } } heap . init ( & mit . h ) mit . next ( ) } 
func ( mit * mergeiterator ) next ( ) { mit . curr = nil if mit . h . len ( ) == 0 { return } o : = heap . pop ( & mit . h ) hi : = o . ( heapitem ) mit . curr = hi . n hi . iter . next ( ) if hi . iter . valid ( ) { hi . n = hi . iter . getnode ( ) heap . push ( & mit . h , hi ) } } 
func ( mit * mergeiterator ) seek ( itm unsafe . pointer ) bool { var found bool for , it : = range mit . iters { if it . seek ( itm ) { found = true } if it . valid ( ) { n : = it . getnode ( ) mit . h = append ( mit . h , heapitem { iter : it , n : n } ) } } heap . init ( & mit . h ) mit . next ( ) return found } 
func ( l * nodelist ) keys ( ) ( keys [ ] [ ] byte ) { node : = l . head for node ! = nil { key : = ( * item ) ( node . item ( ) ) . bytes ( ) keys = append ( keys , key ) node = node . getlink ( ) } return } 
func ( l * nodelist ) remove ( key [ ] byte ) * skiplist . node { var prev * skiplist . node node : = l . head for node ! = nil { nodekey : = ( * item ) ( node . item ( ) ) . bytes ( ) if bytes . equal ( nodekey , key ) { if prev == nil { l . head = node . getlink ( ) return node } prev . setlink ( node . getlink ( ) ) return node } prev = node node = node . getlink ( ) } return nil } 
func ( l * nodelist ) add ( node * skiplist . node ) { node . setlink ( l . head ) l . head = node } 
func newwithconfig ( cfg config ) * skiplist { if runtime . goarch ! = " " { cfg . usememorymgmt = false } s : = & skiplist { config : cfg , barrier : newaccessbarrier ( cfg . usememorymgmt , cfg . barrierdestructor ) , } s . newnode = func ( itm unsafe . pointer , level int ) * node { return allocnode ( itm , level , cfg . malloc ) } if cfg . usememorymgmt { s . freenode = func ( n * node ) { if debug { debugmarkfree ( n ) } cfg . free ( unsafe . pointer ( n ) ) } } else { s . freenode = func ( * node ) { } } head : = allocnode ( minitem , maxlevel , nil ) tail : = allocnode ( maxitem , maxlevel , nil ) for i : = 0 ; i <= maxlevel ; i ++ { head . setnext ( i , tail , false ) } s . head = head s . tail = tail return s } 
func ( s * skiplist ) freenode ( n * node , sts * stats ) { s . freenode ( n ) sts . addint64 ( & sts . nodefrees , 1 ) } 
func ( s * skiplist ) makebuf ( ) * actionbuffer { return & actionbuffer { preds : make ( [ ] * node , maxlevel + 1 ) , succs : make ( [ ] * node , maxlevel + 1 ) , } } 
func ( s * skiplist ) size ( n * node ) int { return s . itemsize ( n . item ( ) ) + n . size ( ) } 
func ( s * skiplist ) newlevel ( randfn func ( ) float32 ) int { var nextlevel int for ; randfn ( ) < p ; nextlevel ++ { } if nextlevel > maxlevel { nextlevel = maxlevel } level : = int ( atomic . loadint32 ( & s . level ) ) if nextlevel > level { if atomic . compareandswapint32 ( & s . level , int32 ( level ) , int32 ( level + 1 ) ) { nextlevel = level + 1 } else { nextlevel = level } } return nextlevel } 
func ( s * skiplist ) insert ( itm unsafe . pointer , cmp comparefn , buf * actionbuffer , sts * stats ) ( success bool ) { , success = s . insert2 ( itm , cmp , nil , buf , rand . float32 , sts ) return } 
func ( s * skiplist ) insert2 ( itm unsafe . pointer , inscmp comparefn , eqcmp comparefn , buf * actionbuffer , randfn func ( ) float32 , sts * stats ) ( * node , bool ) { itemlevel : = s . newlevel ( randfn ) return s . insert3 ( itm , inscmp , eqcmp , buf , itemlevel , false , sts ) } 
func ( s * skiplist ) delete ( itm unsafe . pointer , cmp comparefn , buf * actionbuffer , sts * stats ) bool { token : = s . barrier . acquire ( ) defer s . barrier . release ( token ) found : = s . findpath ( itm , cmp , buf , sts ) ! = nil if ! found { return false } delnode : = buf . succs [ 0 ] return s . deletenode ( delnode , cmp , buf , sts ) } 
func ( s * skiplist ) deletenode ( n * node , cmp comparefn , buf * actionbuffer , sts * stats ) bool { token : = s . barrier . acquire ( ) defer s . barrier . release ( token ) return s . deletenode ( n , cmp , buf , sts ) } 
func ( s * skiplist ) getrangesplititems ( nways int ) [ ] unsafe . pointer { var deleted bool repeat : var itms [ ] unsafe . pointer var finished bool l : = int ( atomic . loadint32 ( & s . level ) ) for ; l >= 0 ; l -- { c : = int ( atomic . loadint64 ( & s . stats . levelnodescount [ l ] ) + 1 ) if c >= nways { persplit : = c / nways node : = s . head for j : = 0 ; node ! = s . tail && ! finished ; j ++ { if j == persplit { j = - 1 itms = append ( itms , node . item ( ) ) finished = len ( itms ) == nways - 1 } node , deleted = node . getnext ( l ) if deleted { goto repeat } } break } } return itms } 
func ( m * nitro ) encodeitem ( itm * item , buf [ ] byte , w io . writer ) error { l : = 2 if len ( buf ) < l { return errnotenoughspace } binary . bigendian . putuint16 ( buf [ 0 : 2 ] , uint16 ( itm . datalen ) ) if , err : = w . write ( buf [ 0 : 2 ] ) ; err ! = nil { return err } if , err : = w . write ( itm . bytes ( ) ) ; err ! = nil { return err } return nil } 
func ( m * nitro ) decodeitem ( buf [ ] byte , r io . reader ) ( * item , error ) { if , err : = io . readfull ( r , buf [ 0 : 2 ] ) ; err ! = nil { return nil , err } l : = binary . bigendian . uint16 ( buf [ 0 : 2 ] ) if l > 0 { itm : = m . allocitem ( int ( l ) , m . usememorymgmt ) data : = itm . bytes ( ) , err : = io . readfull ( r , data ) return itm , err } return nil , nil } 
func ( itm * item ) bytes ( ) ( bs [ ] byte ) { l : = itm . datalen dataoffset : = uintptr ( unsafe . pointer ( itm ) ) + itemheadersize hdr : = ( * reflect . sliceheader ) ( unsafe . pointer ( & bs ) ) hdr . data = dataoffset hdr . len = int ( l ) hdr . cap = hdr . len return } 
func itemsize ( p unsafe . pointer ) int { itm : = ( * item ) ( p ) return int ( itemheadersize + uintptr ( itm . datalen ) ) } 
func kvtobytes ( k , v [ ] byte ) [ ] byte { klen : = len ( k ) buf : = make ( [ ] byte , 2 , len ( k ) + len ( v ) + 2 ) binary . littleendian . putuint16 ( buf [ 0 : 2 ] , uint16 ( klen ) ) buf = append ( buf , k ... ) buf = append ( buf , v ... ) return buf } 
func kvfrombytes ( bs [ ] byte ) ( k , v [ ] byte ) { klen : = int ( binary . littleendian . uint16 ( bs [ 0 : 2 ] ) ) return bs [ 2 : 2 + klen ] , bs [ 2 + klen : ] } 
func comparekv ( a [ ] byte , b [ ] byte ) int { la : = int ( binary . littleendian . uint16 ( a [ 0 : 2 ] ) ) lb : = int ( binary . littleendian . uint16 ( b [ 0 : 2 ] ) ) return bytes . compare ( a [ 2 : 2 + la ] , b [ 2 : 2 + lb ] ) } 
func ( e * eventcontroller ) emit ( b eventbody ) ( int , error ) { var i int event : = event { header : generateheader ( ) , body : b } for , h : = range e . handlers { i ++ go h . handlegomitevent ( event ) } return i , nil } 
func ( e * eventcontroller ) registerhandler ( n string , h handler ) error { e . lazyloadhandler ( ) if e . ishandlerregistered ( n ) { return errors . new ( fmt . sprintf ( " " , n ) ) } e . handlermutex . lock ( ) e . handlers [ n ] = h e . handlermutex . unlock ( ) return nil } 
func ( e * eventcontroller ) unregisterhandler ( n string ) error { e . handlermutex . lock ( ) delete ( e . handlers , n ) e . handlermutex . unlock ( ) return nil } 
func ( e * eventcontroller ) ishandlerregistered ( n string ) bool { , x : = e . handlers [ n ] return x } 
func ( e * eventcontroller ) lazyloadhandler ( ) { if e . handlermutex == nil { e . handlermutex = new ( sync . mutex ) } if e . handlers == nil { e . handlermutex . lock ( ) e . handlers = make ( map [ string ] handler ) e . handlermutex . unlock ( ) } } 
func comparenitro ( this unsafe . pointer , that unsafe . pointer ) int { thisitem : = ( * nitro ) ( this ) thatitem : = ( * nitro ) ( that ) return int ( thisitem . id - thatitem . id ) } 
func defaultconfig ( ) config { var cfg config cfg . setkeycomparator ( defaultkeycmp ) cfg . filetype = rawdbfile cfg . usememorymgmt = false cfg . refreshrate = defaultrefreshrate return cfg } 
func ( w * writer ) put2 ( bs [ ] byte ) ( n * skiplist . node ) { var success bool x : = w . newitem ( bs , w . usememorymgmt ) x . bornsn = w . getcurrsn ( ) n , success = w . store . insert2 ( unsafe . pointer ( x ) , w . inscmp , w . existcmp , w . buf , w . rand . float32 , & w . slsts1 ) if success { w . count ++ } else { w . freeitem ( x ) } return } 
func ( w * writer ) delete ( bs [ ] byte ) ( success bool ) { , success = w . delete2 ( bs ) return } 
func ( w * writer ) delete2 ( bs [ ] byte ) ( n * skiplist . node , success bool ) { if n : = w . getnode ( bs ) ; n ! = nil { return n , w . deletenode ( n ) } return nil , false } 
func ( w * writer ) deletenode ( x * skiplist . node ) ( success bool ) { defer func ( ) { if success { w . count -- } } ( ) x . gclink = nil sn : = w . getcurrsn ( ) gotitem : = ( * item ) ( x . item ( ) ) if gotitem . bornsn == sn { success = w . store . deletenode ( x , w . inscmp , w . buf , & w . slsts1 ) barrier : = w . store . getaccesbarrier ( ) barrier . flushsession ( unsafe . pointer ( x ) ) return } success = atomic . compareandswapuint32 ( & gotitem . deadsn , 0 , sn ) if success { if w . gctail == nil { w . gctail = x w . gchead = w . gctail } else { w . gctail . gclink = x w . gctail = x } } return } 
func ( w * writer ) getnode ( bs [ ] byte ) * skiplist . node { iter : = w . store . newiterator ( w . itercmp , w . buf ) defer iter . close ( ) x : = w . newitem ( bs , false ) x . bornsn = w . getcurrsn ( ) if found : = iter . seekwithcmp ( unsafe . pointer ( x ) , w . inscmp , w . existcmp ) ; found { return iter . getnode ( ) } return nil } 
func ( cfg * config ) setkeycomparator ( cmp keycompare ) { cfg . keycmp = cmp cfg . inscmp = newinsertcompare ( cmp ) cfg . itercmp = newitercompare ( cmp ) cfg . existcmp = newexistcompare ( cmp ) } 
func ( cfg * config ) usememorymgmt ( malloc skiplist . mallocfn , free skiplist . freefn ) { if runtime . goarch == " " { cfg . usememorymgmt = true cfg . mallocfun = malloc cfg . freefun = free } } 
func newwithconfig ( cfg config ) * nitro { m : = & nitro { snapshots : skiplist . new ( ) , gcsnapshots : skiplist . new ( ) , currsn : 1 , config : cfg , gcchan : make ( chan * skiplist . node , gcchanbufsize ) , id : int ( atomic . addint64 ( & dbinstancescount , 1 ) ) , } m . freechan = make ( chan * skiplist . node , gcchanbufsize ) m . store = skiplist . newwithconfig ( m . newstoreconfig ( ) ) m . initsizefuns ( ) buf : = dbinstances . makebuf ( ) defer dbinstances . freebuf ( buf ) dbinstances . insert ( unsafe . pointer ( m ) , comparenitro , buf , & dbinstances . stats ) return m } 
func ( m * nitro ) memoryinuse ( ) int64 { storestats : = m . aggrstorestats ( ) return storestats . memory + m . snapshots . memoryinuse ( ) + m . gcsnapshots . memoryinuse ( ) } 
func ( m * nitro ) close ( ) { for s : = m . snapshots . getstats ( ) ; int ( s . nodecount ) ! = 0 ; s = m . snapshots . getstats ( ) { time . sleep ( time . millisecond ) } m . hasshutdown = true for ! atomic . compareandswapint32 ( & m . isgcrunning , 0 , 1 ) { time . sleep ( time . millisecond ) } close ( m . gcchan ) buf : = dbinstances . makebuf ( ) defer dbinstances . freebuf ( buf ) dbinstances . delete ( unsafe . pointer ( m ) , comparenitro , buf , & dbinstances . stats ) if m . usememorymgmt { buf : = m . snapshots . makebuf ( ) defer m . snapshots . freebuf ( buf ) m . shutdownwg1 . wait ( ) close ( m . freechan ) m . shutdownwg2 . wait ( ) iter : = m . store . newiterator ( m . itercmp , buf ) defer iter . close ( ) var lastnode * skiplist . node iter . seekfirst ( ) if iter . valid ( ) { lastnode = iter . getnode ( ) iter . next ( ) } for lastnode ! = nil { m . freeitem ( ( * item ) ( lastnode . item ( ) ) ) m . store . freenode ( lastnode , & m . store . stats ) lastnode = nil if iter . valid ( ) { lastnode = iter . getnode ( ) iter . next ( ) } } } } 
func ( m * nitro ) newwriter ( ) * writer { w : = m . newwriter ( ) w . next = m . wlist m . wlist = w w . dwrctx . init ( ) m . shutdownwg1 . add ( 1 ) go m . collectionworker ( w ) if m . usememorymgmt { m . shutdownwg2 . add ( 1 ) go m . freeworker ( w ) } return w } 
func snapshotsize ( p unsafe . pointer ) int { s : = ( * snapshot ) ( p ) return int ( unsafe . sizeof ( s . sn ) + unsafe . sizeof ( s . refcount ) + unsafe . sizeof ( s . db ) + unsafe . sizeof ( s . count ) + unsafe . sizeof ( s . gclist ) ) } 
func ( s * snapshot ) encode ( buf [ ] byte , w io . writer ) error { l : = 4 if len ( buf ) < l { return errnotenoughspace } binary . bigendian . putuint32 ( buf [ 0 : 4 ] , s . sn ) if , err : = w . write ( buf [ 0 : 4 ] ) ; err ! = nil { return err } return nil } 
func ( s * snapshot ) decode ( buf [ ] byte , r io . reader ) error { if , err : = io . readfull ( r , buf [ 0 : 4 ] ) ; err ! = nil { return err } s . sn = binary . bigendian . uint32 ( buf [ 0 : 4 ] ) return nil } 
func ( s * snapshot ) open ( ) bool { if atomic . loadint32 ( & s . refcount ) == 0 { return false } atomic . addint32 ( & s . refcount , 1 ) return true } 
func ( s * snapshot ) close ( ) { newrefcount : = atomic . addint32 ( & s . refcount , - 1 ) if newrefcount == 0 { buf : = s . db . snapshots . makebuf ( ) defer s . db . snapshots . freebuf ( buf ) s . db . snapshots . delete ( unsafe . pointer ( s ) , comparesnapshot , buf , & s . db . snapshots . stats ) s . db . gcsnapshots . insert ( unsafe . pointer ( s ) , comparesnapshot , buf , & s . db . gcsnapshots . stats ) s . db . gc ( ) } } 
func comparesnapshot ( this , that unsafe . pointer ) int { thisitem : = ( * snapshot ) ( this ) thatitem : = ( * snapshot ) ( that ) return int ( thisitem . sn ) - int ( thatitem . sn ) } 
func ( m * nitro ) newsnapshot ( ) ( * snapshot , error ) { buf : = m . snapshots . makebuf ( ) defer m . snapshots . freebuf ( buf ) var head , tail * skiplist . node for w : = m . wlist ; w ! = nil ; w = w . next { if tail == nil { head = w . gchead tail = w . gctail } else if w . gchead ! = nil { tail . gclink = w . gchead tail = w . gctail } w . gchead = nil w . gctail = nil m . store . stats . merge ( & w . slsts1 ) atomic . addint64 ( & m . itemscount , w . count ) w . count = 0 } snap : = & snapshot { db : m , sn : m . getcurrsn ( ) , refcount : 1 , count : m . itemscount ( ) } m . snapshots . insert ( unsafe . pointer ( snap ) , comparesnapshot , buf , & m . snapshots . stats ) snap . gclist = head newsn : = atomic . adduint32 ( & m . currsn , 1 ) if newsn == math . maxuint32 { return nil , errmaxsnapshotslimitreached } return snap , nil } 
func ( m * nitro ) collectdead ( ) { buf1 : = m . snapshots . makebuf ( ) buf2 : = m . snapshots . makebuf ( ) defer m . snapshots . freebuf ( buf1 ) defer m . snapshots . freebuf ( buf2 ) iter : = m . gcsnapshots . newiterator ( comparesnapshot , buf1 ) defer iter . close ( ) for iter . seekfirst ( ) ; iter . valid ( ) ; iter . next ( ) { node : = iter . getnode ( ) sn : = ( * snapshot ) ( node . item ( ) ) if sn . sn ! = m . lastgcsn + 1 { return } m . lastgcsn = sn . sn m . gcchan < - sn . gclist m . gcsnapshots . deletenode ( node , comparesnapshot , buf2 , & m . gcsnapshots . stats ) } } 
func ( m * nitro ) gc ( ) { if atomic . compareandswapint32 ( & m . isgcrunning , 0 , 1 ) { m . collectdead ( ) atomic . compareandswapint32 ( & m . isgcrunning , 1 , 0 ) } } 
func ( m * nitro ) getsnapshots ( ) [ ] * snapshot { var snaps [ ] * snapshot buf : = m . snapshots . makebuf ( ) defer m . snapshots . freebuf ( buf ) iter : = m . snapshots . newiterator ( comparesnapshot , buf ) iter . seekfirst ( ) for ; iter . valid ( ) ; iter . next ( ) { snaps = append ( snaps , ( * snapshot ) ( iter . get ( ) ) ) } return snaps } 
func memoryinuse ( ) ( sz int64 ) { buf : = dbinstances . makebuf ( ) defer dbinstances . freebuf ( buf ) iter : = dbinstances . newiterator ( comparenitro , buf ) for iter . seekfirst ( ) ; iter . valid ( ) ; iter . next ( ) { db : = ( * nitro ) ( iter . get ( ) ) sz += db . memoryinuse ( ) } return } 
func comparebs ( this , that unsafe . pointer ) int { thisitm : = ( * barriersession ) ( this ) thatitm : = ( * barriersession ) ( that ) return int ( thisitm . seqno ) - int ( thatitm . seqno ) } 
func ( ab * accessbarrier ) acquire ( ) * barriersession { if ab . active { retry : bs : = ( * barriersession ) ( atomic . loadpointer ( & ab . session ) ) livecount : = atomic . addint32 ( bs . livecount , 1 ) if livecount > barrierflushoffset { ab . release ( bs ) goto retry } return bs } return nil } 
func ( ab * accessbarrier ) release ( bs * barriersession ) { if ab . active { livecount : = atomic . addint32 ( bs . livecount , - 1 ) if livecount == barrierflushoffset { buf : = ab . freeq . makebuf ( ) defer ab . freeq . freebuf ( buf ) if atomic . addint32 ( & bs . closed , 1 ) == 1 { ab . freeq . insert ( unsafe . pointer ( bs ) , comparebs , buf , & ab . freeq . stats ) if atomic . compareandswapint32 ( & ab . isdestructorrunning , 0 , 1 ) { ab . docleanup ( ) atomic . compareandswapint32 ( & ab . isdestructorrunning , 1 , 0 ) } } } } } 
func ( ab * accessbarrier ) flushsession ( ref unsafe . pointer ) { if ab . active { ab . lock ( ) defer ab . unlock ( ) bsptr : = atomic . loadpointer ( & ab . session ) newbsptr : = unsafe . pointer ( newbarriersession ( ) ) atomic . compareandswappointer ( & ab . session , bsptr , newbsptr ) bs : = ( * barriersession ) ( bsptr ) bs . objectref = ref ab . activeseqno ++ bs . seqno = ab . activeseqno atomic . addint32 ( bs . livecount , barrierflushoffset + 1 ) ab . release ( bs ) } } 
func ( n node ) size ( ) int { return int ( unsafe . sizeof ( n ) + uintptr ( n . level + 1 ) * ( unsafe . sizeof ( unsafe . pointer ( nil ) ) + unsafe . sizeof ( noderef { } ) ) ) } 
func ( report * statsreport ) apply ( s * stats ) { var totalnextptrs int var totalnodes int report . readconflicts += s . readconflicts report . insertconflicts += s . insertconflicts for i , c : = range s . levelnodescount { report . nodedistribution [ i ] += c nodesatlevel : = report . nodedistribution [ i ] totalnodes += int ( nodesatlevel ) totalnextptrs += ( i + 1 ) * int ( nodesatlevel ) } report . softdeletes += s . softdeletes report . nodecount = totalnodes report . nextpointerspernode = float64 ( totalnextptrs ) / float64 ( totalnodes ) report . nodeallocs += s . nodeallocs report . nodefrees += s . nodefrees report . memory += s . usedbytes } 
func ( s * stats ) addint64 ( src * int64 , val int64 ) { if s . islocal { * src += val } else { atomic . addint64 ( src , val ) } } 
func ( s * stats ) adduint64 ( src * uint64 , val uint64 ) { if s . islocal { * src += val } else { atomic . adduint64 ( src , val ) } } 
func ( s * stats ) merge ( sts * stats ) { atomic . adduint64 ( & s . insertconflicts , sts . insertconflicts ) sts . insertconflicts = 0 atomic . adduint64 ( & s . readconflicts , sts . readconflicts ) sts . readconflicts = 0 atomic . addint64 ( & s . softdeletes , sts . softdeletes ) sts . softdeletes = 0 atomic . addint64 ( & s . nodeallocs , sts . nodeallocs ) sts . nodeallocs = 0 atomic . addint64 ( & s . nodefrees , sts . nodefrees ) sts . nodefrees = 0 atomic . addint64 ( & s . usedbytes , sts . usedbytes ) sts . usedbytes = 0 for i , val : = range sts . levelnodescount { if val ! = 0 { atomic . addint64 ( & s . levelnodescount [ i ] , val ) sts . levelnodescount [ i ] = 0 } } } 
func ( s * skiplist ) getstats ( ) statsreport { var report statsreport report . apply ( & s . stats ) return report } 
func ( s * skiplist ) newiterator ( cmp comparefn , buf * actionbuffer ) * iterator { return & iterator { cmp : cmp , s : s , buf : buf , bs : s . barrier . acquire ( ) , } } 
func ( it * iterator ) seekfirst ( ) { it . prev = it . s . head it . curr , = it . s . head . getnext ( 0 ) it . valid = true } 
func ( it * iterator ) seekwithcmp ( itm unsafe . pointer , cmp comparefn , eqcmp comparefn ) bool { var found bool if found = it . s . findpath ( itm , cmp , it . buf , & it . s . stats ) ! = nil ; found { it . prev = it . buf . preds [ 0 ] it . curr = it . buf . succs [ 0 ] } else { if found = eqcmp ! = nil && compare ( eqcmp , itm , it . buf . preds [ 0 ] . item ( ) ) == 0 ; found { it . prev = nil it . curr = it . buf . preds [ 0 ] } } return found } 
func ( it * iterator ) seek ( itm unsafe . pointer ) bool { it . valid = true found : = it . s . findpath ( itm , it . cmp , it . buf , & it . s . stats ) ! = nil it . prev = it . buf . preds [ 0 ] it . curr = it . buf . succs [ 0 ] return found } 
func ( it * iterator ) valid ( ) bool { if it . valid && it . curr == it . s . tail { it . valid = false } return it . valid } 
func ( it * iterator ) delete ( ) { it . s . softdelete ( it . curr , & it . s . stats ) it . next ( ) it . deleted = true } 
func ( it * iterator ) next ( ) { if it . deleted { it . deleted = false return } retry : it . valid = true next , deleted : = it . curr . getnext ( 0 ) if deleted { if it . s . helpdelete ( 0 , it . prev , it . curr , next , & it . s . stats ) { it . curr = next } else { atomic . adduint64 ( & it . s . stats . readconflicts , 1 ) found : = it . s . findpath ( it . curr . item ( ) , it . cmp , it . buf , & it . s . stats ) ! = nil last : = it . curr it . prev = it . buf . preds [ 0 ] it . curr = it . buf . succs [ 0 ] if found && last == it . curr { goto retry } } } else { it . prev = it . curr it . curr = next } } 
func isenabled ( ) bool { if appenv , err : = cfenv . current ( ) ; err == nil { if taskservice , err : = appenv . services . withname ( " " ) ; err == nil { if taskservice . credentials [ " " ] . ( string ) == " " { return true } } } lo . g . error ( " " ) return false } 
func init ( ) { s : = new ( skum1smallbuilder ) s . client , = new ( skum1small ) . getinnkeeperclient ( ) skurepo . register ( skuname , s ) } 
func fromurl ( url string ) string { result : = url for , replace : = range replaces { result = strings . replace ( result , replace . a , replace . b , - 1 ) } return result } 
func tourl ( folder string ) string { result : = folder for , replace : = range replaces { result = strings . replace ( result , replace . b , replace . a , - 1 ) } return result } 
func parseprotocolheader ( header uint8 ) ( lenbytes uint8 , version uint8 ) { version = header & protocolversionmask lenbytes = 1 < < ( ( header & protocolsizeenummask ) > > 6 ) return } 
func ( t * tupleheader ) size ( ) int { return versiononetupleheadersize + int ( t . fieldsize ) * int ( t . fieldcount ) } 
func newconfig ( filename string ) * config { c : = new ( config ) c . filename = filename c . config = make ( map [ string ] map [ string ] string ) return c } 
func ( c * config ) read ( ) error { in , err : = os . open ( c . filename ) if err ! = nil { return err } defer in . close ( ) scanner : = bufio . newscanner ( in ) line : = " " section : = " " for scanner . scan ( ) { if scanner . text ( ) == " " { continue } if line == " " { sec , ok : = checksection ( scanner . text ( ) ) if ok { section = sec continue } } if checkcomment ( scanner . text ( ) ) { continue } line += scanner . text ( ) if strings . hassuffix ( line , " \ \ " ) { line = line [ : len ( line ) - 1 ] continue } key , value , ok : = checkline ( line ) if ! ok { return errors . new ( " " + line ) } c . set ( section , key , value ) line = " " } return nil } 
func ( c * config ) get ( section string , key string ) string { value , ok : = c . config [ section ] [ key ] if ! ok { return " " } return value } 
func ( c * config ) set ( section string , key string , value string ) { , ok : = c . config [ section ] if ! ok { c . config [ section ] = make ( map [ string ] string ) } c . config [ section ] [ key ] = value } 
func ( c * config ) add ( section string , key string , value string ) { c . set ( section , key , value ) } 
func ( c * config ) del ( section string , key string ) { , ok : = c . config [ section ] if ok { delete ( c . config [ section ] , key ) if len ( c . config [ section ] ) == 0 { delete ( c . config , section ) } } } 
func ( c * config ) writeto ( filename string ) error { content : = " " for k , v : = range c . config { format : = " \n " if k ! = " " { content += fmt . sprintf ( " \n " , k ) format = " \ t " + format } for key , value : = range v { content += fmt . sprintf ( format , key , value ) } } return ioutil . writefile ( filename , [ ] byte ( content ) , 0644 ) } 
func checksection ( line string ) ( string , bool ) { line = strings . trimspace ( line ) linelen : = len ( line ) if linelen < 2 { return " " , false } if line [ 0 ] == ' [ ' && line [ linelen - 1 ] == ' ] ' { return line [ 1 : linelen - 1 ] , true } return " " , false } 
func checkline ( line string ) ( string , string , bool ) { key : = " " value : = " " sp : = strings . splitn ( line , " " , 2 ) if len ( sp ) ! = 2 { return key , value , false } key = strings . trimspace ( sp [ 0 ] ) value = strings . trimspace ( sp [ 1 ] ) return key , value , true } 
func checkcomment ( line string ) bool { line = strings . trimspace ( line ) for p : = range commentprefix { if strings . hasprefix ( line , commentprefix [ p ] ) { return true } } return false } 
func logger ( l handler . logger ) option { return option { func ( o * options ) { o . logger = l } } } 
func dateformat ( f string ) option { return option { func ( o * options ) { o . dateformat = f } } } 
func access ( h http . handler , opts ... option ) http . handler { o : = options { logger : handler . outlogger ( ) , dateformat : accessdateformat } o . apply ( opts ) return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { start : = time . now ( ) wrapper : = handler . newresponsewrapper ( w ) uri : = r . url . requesturi ( ) remoteaddr : = remoteaddr ( r ) remoteuser : = remoteuser ( r ) method : = r . method referer : = r . header . get ( " " ) useragent : = r . header . get ( " " ) h . servehttp ( wrapper , r ) for k , v : = range wrapper . header ( ) { w . header ( ) [ k ] = v } w . writeheader ( wrapper . code ) w . write ( wrapper . body . bytes ( ) ) now : = time . now ( ) timestamp : = now . format ( o . dateformat ) code : = wrapper . code length : = wrapper . body . len ( ) o . logger . print ( fmt . sprintf ( " " " " " " , remoteaddr , remoteuser , timestamp , now . sub ( start ) , method , uri , code , length , referer , useragent ) ) } ) } 
func getavailableinventory ( taskcollection integrations . collection ) ( inventory map [ string ] skurepo . skubuilder ) { inventory = skurepo . getregistry ( ) onceloadinventorypoller . do ( func ( ) { starttaskpollingforregisteredskus ( taskcollection ) } ) return } 
func logger ( l handler . logger ) tokenopt { return tokenopt { func ( o * options ) { o . logger = l } } } 
func expiration ( e time . duration ) tokenopt { return tokenopt { func ( o * options ) { o . expiration = e } } } 
func claimer ( c func ( claims * jwt . standardclaims ) jwt . claims ) tokenopt { return tokenopt { func ( o * options ) { o . claimer = c } } } 
func issuer ( issuer string ) tokenopt { return tokenopt { func ( o * options ) { o . issuer = issuer } } } 
func user ( user string ) tokenopt { return tokenopt { func ( o * options ) { o . user = user } } } 
func password ( password string ) tokenopt { return tokenopt { func ( o * options ) { o . password = password } } } 
func extractor ( e request . extractor ) tokenopt { return tokenopt { func ( o * options ) { o . extractor = e } } } 
func token ( r * http . request ) string { if token , ok : = r . context ( ) . value ( tokenkey ) . ( string ) ; ok { return token } return " " } 
func claims ( r * http . request ) jwt . claims { if claims , ok : = r . context ( ) . value ( claimskey ) . ( jwt . claims ) ; ok { return claims } return nil } 
func ( t token ) string ( ) string { switch t . type { case tokeneof : return " " case tokenerror : return t . value } if len ( t . value ) > 10 { return fmt . sprintf ( " " , t . value ) } return fmt . sprintf ( " " , t . value ) } 
func newlexer ( name , input string , h handler ) * lexer { return & lexer { name : name , input : input + " \n " , state : lextext , handler : h , } } 
func ( l * lexer ) run ( ) { for state : = lextext ; state ! = nil ; { state = state ( l ) } } 
func ( l * lexer ) emit ( t tokentype ) { if l . pos == l . start { return } tok : = token { t , l . input [ l . start : l . pos ] } l . handler ( tok ) l . start = l . pos } 
func ( l * lexer ) skipwhitespace ( ) { for unicode . is ( unicode . white space , l . next ( ) ) { } l . backup ( ) l . ignore ( ) } 
func ( l * lexer ) next ( ) ( r rune ) { if l . pos >= len ( l . input ) { l . width = 0 return eof } r , l . width = utf8 . decoderuneinstring ( l . remaining ( ) ) l . advance ( l . width ) return } 
func ( l * lexer ) linenum ( ) int { return strings . count ( l . input [ : l . pos ] , " \n " ) } 
func ( l * lexer ) offset ( ) int { lineoffset : = strings . lastindex ( l . input [ : l . pos ] , " \n " ) if lineoffset ! = - 1 { return l . pos - lineoffset } return l . pos } 
func ( l * lexer ) errorf ( format string , args ... interface { } ) statefn { l . handler ( token { tokenerror , fmt . sprintf ( fmt . sprintf ( " " , l . name , l . linenum ( ) , l . offset ( ) ) + format , args ... ) } ) return nil } 
func lexcomment ( l * lexer ) statefn { l . skipwhitespace ( ) l . pos += len ( comment ) if index : = strings . index ( l . remaining ( ) , " \n " ) ; index > 0 { l . pos += index } else { l . pos += len ( l . remaining ( ) ) } l . emit ( tokencomment ) l . skipwhitespace ( ) return lextext } 
func new ( namespace string , name string ) ( t tupletype ) { hash : = synchash . hash ( [ ] byte ( name ) ) ns hash : = synchash . hash ( [ ] byte ( namespace ) ) t = tupletype { namespace , name , ns hash , hash , make ( [ ] [ ] field , 0 ) , make ( map [ string ] int ) } return } 
func ( t * tupletype ) addversion ( fields ... field ) { t . versions = append ( t . versions , fields ) for , field : = range fields { t . fields [ field . name ] = len ( t . fields ) } } 
func ( t * tupletype ) contains ( field string ) bool { , exists : = t . fields [ field ] return exists } 
func ( t * tupletype ) offset ( field string ) ( offset int , exists bool ) { offset , exists = t . fields [ field ] return } 
func ( t * tupletype ) versions ( ) ( vers [ ] version ) { vers = make ( [ ] version , t . numversions ( ) ) for i : = 0 ; i < t . numversions ( ) ; i ++ { vers [ i ] = version { uint8 ( i + 1 ) , t . versions [ i ] } } return } 
func ( s * task ) setprivatemeta ( name string , value interface { } ) { if s . privatemetadata == nil { s . privatemetadata = make ( map [ string ] interface { } ) } s . privatemetadata [ name ] = value } 
func ( s * task ) setpublicmeta ( name string , value interface { } ) { if s . metadata == nil { s . metadata = make ( map [ string ] interface { } ) } s . metadata [ name ] = value } 
func ( s * task ) getredactedversion ( ) redactedtask { s . mutex . rlock ( ) rt : = redactedtask { id : s . id , timestamp : s . timestamp , expires : s . expires , status : s . status , profile : s . profile , callername : s . callername , metadata : s . metadata , } s . mutex . runlock ( ) return rt } 
func ( s * task ) update ( update func ( * task ) interface { } ) interface { } { s . mutex . lock ( ) var ret = update ( s ) s . taskmanager . savetask ( s ) s . mutex . unlock ( ) return ret } 
func ( s * task ) read ( read func ( * task ) interface { } ) interface { } { s . mutex . rlock ( ) var ret = read ( s ) s . mutex . runlock ( ) return ret } 
func ( s * task ) protect ( taskmanager taskmanagerinterface , mutex sync . rwmutex ) { s . taskmanager = taskmanager s . mutex = mutex } 
func ( s task ) equal ( b task ) bool { return ( s . id == b . id && s . timestamp == b . timestamp && s . expires == b . expires && s . status == b . status && s . profile == b . profile && s . callername == b . callername ) } 
func frombytes ( dir , prefix string , data [ ] byte ) ( * tempfile , error ) { var tmp * tempfile = & tempfile { dir : dir , prefix : prefix } var err error tmp . file , err = ioutil . tempfile ( dir , prefix ) if err ! = nil { return nil , err } , err = tmp . write ( data ) if err ! = nil { return nil , err } tmp . seek ( 0 , 0 ) return tmp , nil } 
func create ( dir , prefix string , data [ ] byte ) ( path string , err error ) { var tmp * os . file tmp , err = ioutil . tempfile ( dir , prefix ) if err ! = nil { return " " , err } defer tmp . close ( ) , err = tmp . write ( data ) if err ! = nil { return " " , err } return tmp . name ( ) , nil } 
func ( b * tuplebuilder ) putuint8 ( field string , value uint8 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , uint8field ) ; err ! = nil { return 0 , err } if b . available ( ) < 2 { return 0 , xbinary . erroutofrange } b . buffer [ b . pos ] = byte ( unsignedint8code . opcode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } 
func ( b * tuplebuilder ) putint8 ( field string , value int8 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , int8field ) ; err ! = nil { return 0 , err } if b . available ( ) < 2 { return 0 , xbinary . erroutofrange } b . buffer [ b . pos ] = byte ( int8code . opcode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } 
func ( b * tuplebuilder ) putuint16 ( field string , value uint16 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , uint16field ) ; err ! = nil { return 0 , err } if value < math . maxuint8 { if b . available ( ) < 2 { return 0 , xbinary . erroutofrange } b . buffer [ b . pos ] = byte ( unsignedshort8code . opcode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } wrote , err = xbinary . littleendian . putuint16 ( b . buffer , b . pos + 1 , value ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( unsignedshort16code . opcode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } 
func ( b * tuplebuilder ) putint16 ( field string , value int16 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , int16field ) ; err ! = nil { return 0 , err } if uint16 ( value ) < math . maxuint8 { if b . available ( ) < 2 { return 0 , xbinary . erroutofrange } b . buffer [ b . pos ] = byte ( short8code . opcode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } wrote , err = xbinary . littleendian . putint16 ( b . buffer , b . pos + 1 , value ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( short16code . opcode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } 
func ( b * tuplebuilder ) putuint32 ( field string , value uint32 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , uint32field ) ; err ! = nil { return 0 , err } if value < math . maxuint8 { if b . available ( ) < 2 { return 0 , xbinary . erroutofrange } b . buffer [ b . pos ] = byte ( unsignedint8code . opcode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } else if value < math . maxuint16 { wrote , err = xbinary . littleendian . putuint16 ( b . buffer , b . pos + 1 , uint16 ( value ) ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( unsignedint16code . opcode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } wrote , err = xbinary . littleendian . putuint32 ( b . buffer , b . pos + 1 , value ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( unsignedint32code . opcode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil } 
func ( b * tuplebuilder ) putint32 ( field string , value int32 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , int32field ) ; err ! = nil { return 0 , err } unsigned : = uint32 ( value ) if unsigned < math . maxuint8 { if b . available ( ) < 2 { return 0 , xbinary . erroutofrange } b . buffer [ b . pos ] = byte ( int8code . opcode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } else if unsigned < math . maxuint16 { wrote , err = xbinary . littleendian . putint16 ( b . buffer , b . pos + 1 , int16 ( value ) ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( int16code . opcode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } wrote , err = xbinary . littleendian . putint32 ( b . buffer , b . pos + 1 , value ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( int32code . opcode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil } 
func newpackagelist ( ) packagelist { var lock sync . mutex return & packagelist { make ( map [ string ] package ) , lock } } 
func ( b * tuplebuilder ) putfloat32 ( field string , value float32 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , float32field ) ; err ! = nil { return 0 , err } wrote , err = xbinary . littleendian . putfloat32 ( b . buffer , b . pos + 1 , value ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( floatcode . opcode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil } 
func ( b * tuplebuilder ) putfloat64 ( field string , value float64 ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , float64field ) ; err ! = nil { return 0 , err } wrote , err = xbinary . littleendian . putfloat64 ( b . buffer , b . pos + 1 , value ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( doublecode . opcode ) b . offsets [ field ] = b . pos b . pos += 9 return 9 , nil } 
func classic ( ) * classicmartini { r : = newrouter ( ) m : = new ( ) m . use ( logger ( ) ) m . use ( recovery ( ) ) m . use ( static ( " " ) ) m . use ( contextrender ( " " , renderoptions { extensions : [ ] string { " " , " " , " " } , } ) ) m . mapto ( r , ( * routes ) ( nil ) ) m . action ( r . handle ) return & classicmartini { m , r } } 
func languages ( tags [ ] xlang . tag ) option { return option { func ( o * options ) { o . languages = tags } } } 
func session ( s handler . session ) option { return option { func ( o * options ) { o . session = s } } } 
func urlprefix ( p string ) option { return option { func ( o * options ) { o . urlprefix = p } } } 
func data ( r * http . request ) contextvalue { if v , ok : = r . context ( ) . value ( contextkey ) . ( contextvalue ) ; ok { return v } return contextvalue { } } 
func url ( url , prefix string , data contextvalue ) string { if data . current . isroot ( ) { return url } if prefix == " " { prefix = " " } else if prefix [ len ( prefix ) - 1 ] ! = ' / ' { prefix += " " } if url == " " { url = " " } if url [ 0 ] ! = ' / ' { url = " " + url } return prefix + data . current . string ( ) + url } 
func size ( ) ( w , h int , err error ) { if ! isinit { err = errors . new ( " " ) return } return get size ( ) } 
func getrequestidfromtaskresponse ( taskresponse taskresponse ) ( requestid string , err error ) { var provisionhostinfobytes [ ] byte firstrecordindex : = 0 meta : = taskresponse . metadata provisionhostinfo : = provisionhostinfo { } lo . g . debug ( " " , taskresponse ) lo . g . debug ( " " , meta ) if provisionhostinfobytes , err = json . marshal ( meta [ provisionhostinformationfieldname ] ) ; err == nil { if err = json . unmarshal ( provisionhostinfobytes , & provisionhostinfo ) ; err == nil { if len ( provisionhostinfo . data ) > firstrecordindex { requestid = provisionhostinfo . data [ firstrecordindex ] . requestid } else { lo . g . error ( " " , provisionhostinfo ) } } else { lo . g . error ( " " , err , meta ) lo . g . error ( " " , meta ) } } else { lo . g . error ( " " , err ) } return } 
func loaddirectory ( dir string , parser parser ) ( err error ) { d , err : = os . open ( dir ) if err ! = nil { return } for { if fis , err : = d . readdir ( 128 ) ; err == nil { for , fi : = range fis { switch fi . isdir ( ) { case true : if err : = loaddirectory ( fi . name ( ) , parser ) ; err ! = nil { return err } case false : if ! strings . hassuffix ( fi . name ( ) , " " ) { break } if , err : = loadfile ( filepath . join ( dir , fi . name ( ) ) , parser ) ; err ! = nil { return err } } } } else if err == io . eof { break } else { return err } } return nil } 
func loadfile ( filename string , parser parser ) ( package , error ) { file , err : = os . open ( filename ) if err ! = nil { return package { } , err } defer file . close ( ) bytes , err : = ioutil . readall ( file ) if err ! = nil { return package { } , err } return parser . parse ( file . name ( ) , string ( bytes ) ) } 
func loadpackage ( parser parser , name , text string ) ( package , error ) { return parser . parse ( name , text ) } 
func newdecoder ( reg registry , r io . reader ) decoder { var buf [ ] byte return decoder { reg , defaultmaxsize , bytes . newbuffer ( buf ) , bufio . newreader ( r ) } } 
func newdecodersize ( reg registry , maxsize uint64 , r io . reader ) decoder { var buf [ ] byte return decoder { reg , maxsize , bytes . newbuffer ( buf ) , bufio . newreader ( r ) } } 
func ( f * flagset ) printdefaults ( ) { flags : = make ( map [ interface { } ] flagsbylength ) f . visitall ( func ( f * flag ) { flags [ f . value ] = append ( flags [ f . value ] , f ) } ) var byname flagsbyname for , f : = range flags { sort . sort ( f ) byname = append ( byname , f ) } sort . sort ( byname ) var line bytes . buffer for , fs : = range byname { line . reset ( ) for i , f : = range fs { if i > 0 { line . writestring ( " " ) } line . writestring ( flagwithminus ( f . name ) ) } format : = " \n \n " if , ok : = fs [ 0 ] . value . ( * stringvalue ) ; ok { format = " \n \n " } fmt . fprintf ( f . out ( ) , format , line . bytes ( ) , fs [ 0 ] . defvalue , fs [ 0 ] . usage ) } } 
func ( f * flagset ) parse ( allowintersperse bool , arguments [ ] string ) error { f . parsed = true f . procargs = arguments f . procflag = " " f . args = nil f . allowintersperse = allowintersperse for { name , long , finished , err : = f . parseone ( ) if ! finished { if name ! = " " { finished , err = f . parseflagarg ( name , long ) } } if err ! = nil { switch f . errorhandling { case continueonerror : return err case exitonerror : os . exit ( 2 ) case paniconerror : panic ( err ) } } if ! finished { continue } if err == nil { break } } return nil } 
func panic ( h http . handler , opts ... option ) http . handler { o : = options { logger : handler . errlogger ( ) , dateformat : panicdateformat } o . apply ( opts ) return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { defer func ( ) { if rec : = recover ( ) ; rec ! = nil { stack : = debug . stack ( ) timestamp : = time . now ( ) . format ( o . dateformat ) message : = fmt . sprintf ( " \n \n " , timestamp , rec , stack ) o . logger . print ( message ) w . writeheader ( http . statusinternalservererror ) if ! o . showstack { message = " " } w . write ( [ ] byte ( message ) ) } } ( ) h . servehttp ( w , r ) } ) } 
func makefakesku ( status string ) ( * fakesku , * taskmanager . task , * taskmanager . task ) { spytask : = & taskmanager . task { id : bson . newobjectid ( ) , expires : time . now ( ) . unixnano ( ) , privatemetadata : map [ string ] interface { } { } , } myfakemanager : = & faketaskmanager { returnedtask : spytask , spytasksaved : new ( taskmanager . task ) , } spytask . protect ( myfakemanager , sync . rwmutex { } ) s : = new ( fakesku ) return s , spytask , myfakemanager . spytasksaved } 
func ( s * fakevcdclient ) polltaskurl ( taskurl string ) ( task * vcloudclient . taskelem , err error ) { return s . faketaskelem , s . errpolltaskurl } 
func ( s * fakevcdclient ) deployvapp ( templatename , templatehref , vcdhref string ) ( vapp * vcloudclient . vapp , err error ) { return s . fakevapp , s . errundeployfake } 
func ( s * fakevcdclient ) undeployvapp ( vappid string ) ( task * vcloudclient . taskelem , err error ) { return & s . fakevapp . tasks . task , s . errdeployfake } 
func ( s * fakevcdclient ) auth ( username , password string ) ( err error ) { return s . errauthfake } 
func ( s * fakevcdclient ) querytemplate ( templatename string ) ( vapptemplate * vcloudclient . vapptemplaterecord , err error ) { return s . fakevapptemplaterecord , s . errdeployfake } 
func fakenewcollectiondialer ( c taskmanager . task ) func ( url , dbname , collectionname string ) ( col integrations . collection , err error ) { return func ( url , dbname , collectionname string ) ( col integrations . collection , err error ) { col = & fakecollection { controltask : c , } return } } 
func ( s * mockheritageclient ) createauthrequest ( verb , requesturl , path string , args interface { } ) ( * http . request , error ) { return & http . request { } , nil } 
func ( s * faketaskmanager ) findandstalltaskforcaller ( callername string ) ( t * taskmanager . task , err error ) { return s . returnedtask , s . returnederr } 
func newfakecollection ( updated int ) * fakecollection { fakecol : = new ( fakecollection ) if updated == - 1 { fakecol . fakechangeinfo = nil } else { fakecol . fakechangeinfo = & mgo . changeinfo { updated : updated , } } return fakecol } 
func newencoder ( w io . writer ) encoder { return versiononeencoder { w , make ( [ ] byte , 9 ) , bytes . newbuffer ( make ( [ ] byte , 0 , 4096 ) ) } } 
func getter ( g noncegetter ) option { return option { func ( o * options ) { o . getter = g } } } 
func setter ( s noncesetter ) option { return option { func ( o * options ) { o . setter = s } } } 
func age ( age time . duration ) option { return option { func ( o * options ) { o . age = age } } } 
func nonce ( h http . handler , opts ... option ) http . handler { headerstorage : = nonceheaderstorage { } o : = options { logger : handler . outlogger ( ) , generator : timerandomgenerator , getter : headerstorage , setter : headerstorage , age : 45 * time . second , } o . apply ( opts ) store : = noncestore { } opchan : = make ( chan func ( noncestore ) ) go func ( ) { for op : = range opchan { op ( store ) } } ( ) go func ( ) { for { select { case < - time . after ( 5 * time . minute ) : cleanup ( o . age , opchan ) } } } ( ) setter : = func ( w http . responsewriter , r * http . request ) error { nonce , err : = generateandstore ( o . age , o . generator , opchan ) if err ! = nil { return err } return o . setter . setnonce ( nonce , w , r ) } return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { ctx : = r . context ( ) nonce : = o . getter . getnonce ( r ) if nonce ! = " " { if validateandremovenonce ( nonce , o . age , opchan ) { ctx = context . withvalue ( ctx , noncevaluekey , noncestatus { noncevalid } ) } else { ctx = context . withvalue ( ctx , noncevaluekey , noncestatus { nonceinvalid } ) } } h . servehttp ( w , r . withcontext ( context . withvalue ( ctx , noncesetterkey , setter ) ) ) } ) } 
func noncevaluefromrequest ( r * http . request ) noncestatus { if c : = r . context ( ) . value ( noncevaluekey ) ; c ! = nil { if v , ok : = c . ( noncestatus ) ; ok { return v } } return noncestatus { noncenotrequested } } 
func storenonce ( w http . responsewriter , r * http . request ) ( err error ) { if c : = r . context ( ) . value ( noncesetterkey ) ; c ! = nil { if setter , ok : = c . ( func ( http . responsewriter , * http . request ) error ) ; ok { err = setter ( w , r ) } } return err } 
func ( s * clientdoer ) do ( req * http . request ) ( resp * http . response , err error ) { s . spyrequest = * req return s . response , s . error } 
func newlease ( taskcollection integrations . collection , availableskus map [ string ] skurepo . skubuilder ) * lease { return & lease { taskcollection : taskcollection , taskmanager : taskmanager . newtaskmanager ( taskcollection ) , availableskus : availableskus , task : taskmanager . redactedtask { } , } } 
func ( s * lease ) delete ( logger * log . logger , req * http . request ) ( statuscode int , response interface { } ) { var ( err error ) statuscode = http . statusnotfound s . taskcollection . wake ( ) if err = s . initfromhttprequest ( req ) ; err == nil { logger . println ( " " ) s . restock ( ) statuscode = http . statusaccepted response = s . task } else { response = map [ string ] string { " " : err . error ( ) } } return } 
func ( s * lease ) post ( logger * log . logger , req * http . request ) ( statuscode int , response interface { } ) { var ( err error ) statuscode = http . statusnotfound s . taskcollection . wake ( ) logger . println ( " " ) if err = s . initfromhttprequest ( req ) ; err == nil { logger . println ( " " , s ) s . procurement ( ) statuscode = http . statuscreated response = s . task } else { response = map [ string ] string { " " : err . error ( ) } } return } 
func ( s * lease ) restock ( ) ( skutask * taskmanager . task ) { if skuconstructor , ok : = s . availableskus [ s . sku ] ; ok { leasemap : = structs . map ( s ) sku : = skuconstructor . new ( s . taskmanager , leasemap ) skutask = sku . restock ( ) s . task = skutask . getredactedversion ( ) } else { s . task . status = taskstatusunavailable } return } 
func ( s * lease ) procurement ( ) ( skutask * taskmanager . task ) { if skuconstructor , ok : = s . availableskus [ s . sku ] ; ok { leasemap : = structs . map ( s ) sku : = skuconstructor . new ( s . taskmanager , leasemap ) glogger . println ( " " , sku ) skutask = sku . procurement ( ) tt : = skutask . read ( func ( t * taskmanager . task ) interface { } { tt : = * t return tt } ) glogger . println ( " " , tt ) s . task = skutask . getredactedversion ( ) } else { glogger . println ( " " , s . sku , s . availableskus ) s . task . status = taskstatusunavailable } return } 
func ( t * tuple ) is ( tupletype tupletype ) bool { return t . header . hash == tupletype . hash && t . header . namespacehash == tupletype . namespacehash } 
func ( t * tuple ) offset ( field string ) ( int , error ) { index , exists : = t . header . type . offset ( field ) if ! exists { return 0 , errfielddoesnotexist } if index < 0 | | index >= int ( t . header . fieldcount ) { return 0 , errinvalidfieldindex } return int ( t . header . offsets [ index ] ) , nil } 
func ( t tuple ) writeto ( w io . writer ) ( n int , err error ) { wrote , err : = t . header . writeto ( w ) if err ! = nil { return int ( wrote ) , nil } n , err = w . write ( t . data ) if err ! = nil { return int ( n ) , err } return int ( wrote ) + n , nil } 
func contextrender ( cookiesecret string , options ... renderoptions ) handler { return func ( w http . responsewriter , req * http . request , c context ) { rd : = renderor ( w , req , c , options ... ) if rd . data [ " " ] ! = nil { rd . data [ " " ] = time . since ( rd . data [ " " ] . ( time . time ) ) . nanoseconds ( ) / 1e6 rd . data [ " " ] = nil } ctx : = & cotex { req , map [ string ] string { } , cookiesecret , w , rd } tm : = time . now ( ) . utc ( ) req . parseform ( ) if len ( req . form ) > 0 { for k , v : = range req . form { ctx . form [ k ] = v [ 0 ] } } ctx . setheader ( " " , webtime ( tm ) , true ) ctx . setheader ( " " , " " , true ) c . map ( rd ) c . map ( ctx ) c . next ( ) } } 
func ( ctx * cotex ) writestring ( content string ) { ctx . responsewriter . write ( [ ] byte ( content ) ) } 
func newagent ( t taskmanagerinterface , callername string ) * agent { return & agent { killtaskpoller : make ( chan bool , 1 ) , processcomplete : make ( chan bool , 1 ) , taskpollemitter : make ( chan bool , 1 ) , statusemitter : make ( chan string , 1 ) , taskmanager : t , task : t . newtask ( callername , taskagentlongrunning , agenttaskstatusinitializing ) , } } 
func ( s * agent ) run ( process func ( * agent ) error ) { s . task . update ( func ( t * task ) interface { } { t . taskmanager = s . taskmanager t . status = agenttaskstatusrunning return t } ) s . statusemitter < - agenttaskstatusrunning go s . starttaskpoller ( ) go s . listenforpoll ( ) go func ( agent agent ) { s : = & agent s . processexithanderldecorate ( process ) < - s . processcomplete } ( * s ) } 
func newwaitgroup ( throttle int ) * waitgroup { return & waitgroup { outstanding : 0 , throttle : throttle , completed : make ( chan bool , throttle ) , } } 
func ( w * waitgroup ) add ( ) { w . outstanding ++ if w . outstanding > w . throttle { select { case < - w . completed : w . outstanding -- return } } } 
func ( w * waitgroup ) wait ( ) { if w . outstanding == 0 { return } for w . outstanding > 0 { select { case < - w . completed : w . outstanding -- } } } 
func gzip ( h http . handler , opts ... option ) http . handler { o : = options { logger : handler . outlogger ( ) } o . apply ( opts ) return http . handlerfunc ( func ( w http . responsewriter , r * http . request ) { if ! strings . contains ( r . header . get ( " " ) , " " ) { h . servehttp ( w , r ) return } wrapper : = handler . newresponsewrapper ( w ) h . servehttp ( wrapper , r ) for k , v : = range wrapper . header ( ) { w . header ( ) [ k ] = v } w . header ( ) . set ( " " , " " ) w . header ( ) . set ( " " , " " ) if w . header ( ) . get ( " " ) == " " { w . header ( ) . set ( " " , http . detectcontenttype ( wrapper . body . bytes ( ) ) ) } w . header ( ) . del ( " " ) if wrapper . code ! = http . statusok { w . writeheader ( wrapper . code ) } gz : = gzip . newwriter ( w ) gz . flush ( ) if , err : = gz . write ( wrapper . body . bytes ( ) ) ; err ! = nil { o . logger . print ( " " + err . error ( ) ) http . error ( w , " " , http . statusinternalservererror ) return } gz . close ( ) } ) } 
func new ( uri string , user string , password string ) innkeeperclient { return & ikclient { uri : uri , user : user , password : password , } } 
func ( s * ikclient ) call ( path string , query interface { } , jsonresp interface { } ) ( err error ) { res , err : = goreq . request { insecure : true , uri : s . uri + " " + path , basicauthusername : s . user , basicauthpassword : s . password , querystring : query } . do ( ) if err == nil { if isstatusok ( res . statuscode ) { err = res . body . fromjsonto ( jsonresp ) } else { strerr , : = res . body . tostring ( ) err = errors . new ( strerr ) } } return } 
func ( s * ikclient ) deprovisionhost ( requestid string ) ( resp * getstatusresponse , err error ) { resp = new ( getstatusresponse ) qp : = url . values { } qp . add ( requestidgetparam , requestid ) err = s . call ( routedeprovisionhost , qp , resp ) return } 
func ( s * ikclient ) provisionhost ( sku string , tenantid string ) ( result * innkeeperclient . provisionhostresponse , err error ) { s . spytenantid . store ( tenantid ) result = new ( innkeeperclient . provisionhostresponse ) result . data = make ( [ ] innkeeperclient . requestdata , 1 ) if len ( s . fakestatus ) > s . cnt { result . status = s . fakestatus [ s . cnt ] } if len ( s . fakedata ) > s . cnt { result . data [ 0 ] = s . fakedata [ s . cnt ] } if len ( s . fakemessage ) > s . cnt { result . message = s . fakemessage [ s . cnt ] } s . cnt ++ return } 
func ( s * ikclient ) deprovisionhost ( requestid string ) ( resp * innkeeperclient . getstatusresponse , err error ) { s . spyrequestid = requestid return nil , s . error } 
func renderer ( options ... renderoptions ) handler { opt : = preparerenderoptions ( options ) cs : = preparecharset ( opt . charset ) t : = compile ( opt ) return func ( res http . responsewriter , req * http . request , c context ) { var tc * template . template if env == dev { tc = compile ( opt ) } else { tc , = t . clone ( ) } c . map ( & render { res , req , tc , opt , cs , data } ) } } 
func ( b * tuplebuilder ) puttimestamp ( field string , value time . time ) ( wrote uint64 , err error ) { if err = b . typecheck ( field , timestampfield ) ; err ! = nil { return 0 , err } wrote , err = xbinary . littleendian . putint64 ( b . buffer , b . pos + 1 , value . unixnano ( ) ) if err ! = nil { return 0 , err } b . buffer [ b . pos ] = byte ( timestampcode . opcode ) b . offsets [ field ] = b . pos b . pos += 9 return 9 , nil } 
func newclient ( apikey string , url string , client clientdoer ) * pdclient { return & pdclient { apikey : apikey , client : client , url : url , } } 
func ( s * pdclient ) gettask ( taskid string ) ( task taskresponse , res * http . response , err error ) { req , : = s . createrequest ( " " , fmt . sprintf ( " " , s . url , taskid ) , bytes . newbufferstring ( " ) ) if res , err = s . client . do ( req ) ; err == nil && res . statuscode == http . statusok { resbodybytes , : = ioutil . readall ( res . body ) json . unmarshal ( resbodybytes , & task ) } else { lo . g . error ( " " , err ) lo . g . error ( " " , res ) err = errinvaliddispenserresponse } return } 
func ( s * pdclient ) deletelease ( leaseid , inventoryid , skuid string , metadata map [ string ] interface { } ) ( res * http . response , err error ) { var body io . reader if body , err = s . getrequestbody ( leaseid , inventoryid , skuid , " " , 0 , metadata ) ; err == nil { req , : = s . createrequest ( " " , fmt . sprintf ( " " , s . url ) , body ) if res , err = s . client . do ( req ) ; err ! = nil | | res . statuscode ! = http . statusok { lo . g . error ( " " , err ) lo . g . error ( " " , res ) err = errinvaliddispenserresponse } } else { lo . g . error ( " " , err . error ( ) ) } return } 
func ( s * pdclient ) postlease ( leaseid , inventoryid , skuid , username string , leasedaysduration int64 ) ( leasecreateresponse taskresponse , res * http . response , err error ) { var body io . reader if body , err = s . getrequestbody ( leaseid , inventoryid , skuid , username , leasedaysduration , make ( map [ string ] interface { } , 1 ) ) ; err == nil { req , : = s . createrequest ( " " , fmt . sprintf ( " " , s . url ) , body ) if res , err = s . client . do ( req ) ; err == nil && res . statuscode == http . statuscreated { resbodybytes , : = ioutil . readall ( res . body ) json . unmarshal ( resbodybytes , & leasecreateresponse ) } else { lo . g . error ( " " , err ) lo . g . error ( " " , res ) err = errinvaliddispenserresponse } } else { lo . g . error ( " " , err . error ( ) ) } return } 
func ( s * skum1smallbuilder ) new ( tm skurepo . taskmanager , meta map [ string ] interface { } ) skurepo . sku { var procurementmeta = make ( map [ string ] interface { } ) var useridentifier string if meta ! = nil { if v , ok : = meta [ procurementmetafieldname ] ; ok { procurementmeta = v . ( map [ string ] interface { } ) } if v , ok : = meta [ useridentifiermetafieldname ] ; ok { useridentifier = v . ( string ) } } return & skum1small { client : s . client , procurementmeta : procurementmeta , taskmanager : tm , useridentifier : useridentifier , } } 
func ( s * skum1small ) pollfortasks ( ) { if task , err : = s . taskmanager . findandstalltaskforcaller ( skuname ) ; err == nil { fmt . println ( task ) } return } 
func ( s * skum1small ) procurement ( ) * taskmanager . task { agent : = taskmanager . newagent ( s . taskmanager , skuname ) task : = agent . gettask ( ) agent . run ( func ( ag * taskmanager . agent ) ( err error ) { if clnt , err : = s . getinnkeeperclient ( ) ; err == nil { if phinfo , err : = clnt . provisionhost ( clientskuname , s . useridentifier ) ; err == nil { lo . g . debug ( " " , phinfo ) ag . gettask ( ) . update ( func ( t * taskmanager . task ) interface { } { t . status = taskmanager . agenttaskstatuscomplete t . setpublicmeta ( provisionhostinfometaname , phinfo ) return t } ) go s . startpoller ( phinfo . data [ 0 ] . requestid , task ) } else { return err } } return err } ) return task } 
func ( s * skum1small ) restock ( ) ( tm * taskmanager . task ) { tm = new ( taskmanager . task ) lo . g . debug ( " " , s . procurementmeta ) requestid : = s . procurementmeta [ procurementmetafieldrequestid ] . ( string ) lo . g . debug ( " " , requestid ) if clnt , err : = s . getinnkeeperclient ( ) ; err == nil { var err error var res * innkeeperclient . getstatusresponse if res , err = clnt . deprovisionhost ( requestid ) ; err ! = nil && res . status ! = " " { lo . g . error ( " " , requestid , err , res ) } lo . g . debug ( " " , requestid , err , res ) } return } 
func ( s * skum1small ) initinnkeeperclient ( ) ( clnt innkeeperclient . innkeeperclient , err error ) { if appenv , err : = cfenv . current ( ) ; err == nil { if taskservice , err : = appenv . services . withname ( " " ) ; err == nil { clnt = & innkeeperclient . ikclient { uri : taskservice . credentials [ " " ] . ( string ) , user : taskservice . credentials [ " " ] . ( string ) , password : taskservice . credentials [ " " ] . ( string ) , } } } return } 
func ( s * skum1small ) getinnkeeperclient ( ) ( innkeeperclient . innkeeperclient , error ) { var err error if s . client == nil { if clnt , err : = s . initinnkeeperclient ( ) ; err == nil { s . client = clnt } else { lo . g . error ( " " , err . error ( ) ) } } return s . client , err } 
